<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Geternitier的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-10T10:09:32.878Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Geternitier</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线性代数复习</title>
    <link href="http://example.com/2022/11/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2022/11/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0/</id>
    <published>2022-11-06T07:41:11.229Z</published>
    <updated>2022-11-10T10:09:32.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性代数复习"><a href="#线性代数复习" class="headerlink" title="线性代数复习"></a>线性代数复习</h2><span id="more"></span><h3 id="第一章-行列式"><a href="#第一章-行列式" class="headerlink" title="第一章 行列式"></a>第一章 行列式</h3><ul><li>概念  </li><li>求值<ul><li>1阶：即本身  </li><li>2阶以上：某一行/列中所有元素与其代数余子式的积的和  </li><li>2、3阶可使用对角线法则</li></ul></li><li>性质：</li></ul><ol><li>互为转置的行列式相等</li><li>对调行/列取负</li><li>任意行/列的加法分解可用于行列式分解<ul><li>若某一行(列)为另一行(列)的k倍，行列式值为0</li><li>将某行(列)的k倍加至另一行(列)，行列式值不变</li></ul></li><li>行列式任一行(列)元素与另一行(列)的元素的代数余子式乘积之和为0  </li></ol><ul><li>范德蒙德行列式</li><li>块三角行列式（数学归纳法）</li><li>克莱姆法则：求解n元线性方程组<ul><li>系数行列式D为0，若某个D_i不为0，则无解，否则可能有解也可能无解</li><li>系数行列式不为0,原方程组有唯一解x_i=D_i/D</li><li>齐次方程组有非零解的充要条件为D=0</li></ul></li><li>行列式计算与性质证明</li></ul><hr><h3 id="第二章-矩阵"><a href="#第二章-矩阵" class="headerlink" title="第二章 矩阵"></a>第二章 矩阵</h3><ul><li>概念：</li></ul><ol><li>矩阵、实/复矩阵、零矩阵O  </li><li>向量、行/列向量，实/复向量、零向量𝜃  </li><li>方阵A的行列式：|A|，|A|!=0，称A非异，|A|=0，称A为奇异或退化矩阵</li></ol><ul><li>几种特殊矩阵：</li></ul><ol><li>对角矩阵、单位矩阵E、数值矩阵kE</li><li>上/下三角矩阵（左下/右上为0）</li><li>对称矩阵、反对称矩阵(对称位置为负)</li></ol><ul><li>矩阵运算及其性质：转置、加/减、乘、数乘、幂乘</li></ul><ol><li>矩阵乘法：不具有交换律和消去率、|AB|=|A|·|B|</li><li>转置的运算性质</li></ol><ul><li>可逆矩阵</li></ul><ol><li>逆矩阵与逆变换定义<ul><li>n阶方阵A、B，AB=E，称A、B可逆且互为逆矩阵</li><li>A、B互逆，Ax=y的逆变换为By=x，Ax=C的逆变换为x=BC</li><li>逆矩阵唯一</li></ul></li><li>可逆矩阵的基本性质：可逆矩阵的转置、数乘、逆、积均可逆</li><li>求可逆矩阵：<ul><li>根据定义列方程组</li><li>公式（求伴随矩阵的1/|A|，伴随矩阵：原矩阵每一项求代数余子式并转置）</li><li>算法（A变换成E的初等变换可使E变换成A的逆，将(A E)进行初等变换可得(E A逆)）</li></ul></li><li>矩阵可逆的充要条件：|A|不为0（A满秩）。</li></ol><ul><li>初等变换：对调、数乘、倍加</li></ul><ol><li>初等变换都有逆变换</li><li>初等矩阵：对E进行一次初等变换所得的矩阵<ul><li>对m * n矩阵A进行初等行变换，相当于左乘一个初等m阶矩阵</li><li>对m * n矩阵A进行初等列变换，相当于右乘一个初等n阶矩阵</li></ul></li><li>矩阵的等价<ul><li>称通过有限次行/列初等变换可相互转换的矩阵行/列等价</li><li>称通过有限次初等变换可相互转换的矩阵等价</li></ul></li><li>矩阵的简化<ul><li>行梯形矩阵：零行在下方，从上至下每行首个非零元素前零个数逐行增加</li><li>行简化梯形矩阵：1所在列其余元素均为0的行梯形矩阵</li><li>同理得列梯形矩阵和列简化梯形矩阵定义</li><li>同为行简化、列简化梯形矩阵，称为标准形矩阵</li></ul></li></ol><ul><li>分块矩阵</li></ul><ol><li>定义与运算（加法、数乘、乘法、转置）</li><li>常见的分块方式：按行/列分块</li></ol><ul><li>矩阵的秩</li></ul><ol><li>定义：矩阵A中最大非零子行列式阶数，记为r(A)<ul><li>矩阵任取k行k列按原序构成的k阶行列式称为矩阵的k阶子行列式/子式</li></ul></li><li>性质<ol><li>0 &lt;= r(A) &lt;= min(m,n)</li><li>r(A+B)&lt;=r(A)+r(B)，r(AB)&lt;=min{r(A),r(B)}</li><li>n阶方阵A、B，r(AB)&gt;=r(A)+r(B)-n</li><li>A的转置的秩与A相同</li><li>A满秩是|A|!=0的充要条件，也是A可逆的充要条件</li><li>初等变换不改变矩阵的秩，行梯形矩阵的秩为其非零行数</li><li>满秩矩阵可通过初等行/列变换变换为E  </li></ol></li><li>__矩阵分解__：m*n矩阵A，则存在m阶可逆矩阵P，n阶可逆矩阵Q，标准形矩阵∧，A=P∧Q，其中标准形矩阵的秩等于A的秩。  <ul><li>任一n阶可逆矩阵可表示为有限n个初等矩阵的积</li><li>任一n阶可逆矩阵只经行/列初等变换为单位矩阵</li></ul></li></ol><ul><li>向量组的线性相关与线性无关</li></ul><ol><li>向量线性组合、线性表示与等价向量组、基本向量组的概念</li><li>向量组线性相关、线性无关的概念<ul><li>一个向量线性相关，则其为零向量</li><li>若一向量组的部分向量组线性相关，则其线性相关</li><li>若一向量组线性无关，则其部分向量组线性无关</li></ul></li><li>向量组线性相关的充要条件是，其中至少有一个向量可由其他向量线性表示<ul><li>存在m个不全为0的系数与m个向量各自积的和为0，则该向量组线性相关</li><li>若仅当系数全为0，上式成立，则该向量组线性无关</li></ul></li><li>向量组A线性无关，向量组B线性相关，B比A多一向量，则该向量可由A线性表示，且表达式唯一</li><li>满秩向量组线性无关<ul><li>向量个数大于维数的向量组必线性相关</li><li>n个n维向量的行列式不为0，则线性无关</li></ul></li></ol><ul><li>极大无关组</li></ul><ol><li>原向量组中，线性无关且可表示原向量组中全部向量的部分向量组为极大无关组。<ul><li>原向量组中任一向量可由极大无关组唯一线性表示</li><li>向量组与其任一个极大无关组等价</li><li>两个向量组等价的充要条件是其各自的极大无关组等价</li></ul></li><li>一个向量组的极大无关组含向量数相同，该值即向量组的秩</li><li>同维向量组A、B，若B可线性表示A，则r(B)&gt;=r(A)</li><li>任意矩阵的秩与其行秩、列秩相同</li></ol><hr><h3 id="第三章-线性方程组解的结构"><a href="#第三章-线性方程组解的结构" class="headerlink" title="第三章 线性方程组解的结构"></a>第三章 线性方程组解的结构</h3><ul><li>高斯消元法和矩阵的行变换</li></ul><ol><li>n元m个线性方程组的矩阵/向量表示<ul><li>系数矩阵A，未知向量x，右端向量b，增广矩阵B=(A b)</li><li>具有相同解集的方程组称为同解方程组</li></ul></li><li>使用初等行变换将增广矩阵化为行简化梯形矩阵，同时得到方程组的解，这就是高斯消元法。</li><li>线性方程组的可解性<ul><li>线性方程组有解的充要条件是系数矩阵的秩等于增广矩阵的秩</li><li>r(A)=r(B)=n，方程组有唯一解</li><li>r(A)=r(B)&lt;n，方程组有无穷组解</li></ul></li></ol><ul><li>线性方程组解的性质和结构<blockquote><p>方程组的某一个解称为方程组的特解，所有解的集合称为方程组的通解</p></blockquote></li></ul><ol><li>齐次方程组解的结构<ul><li>若a_1、a_2是齐次方程组的解，则其线性组合也是该方程组的解</li><li>能线性表示出方程组所有解的极大无关组为该方程组的基础解系</li><li>m*n矩阵A，若r(A)=n，则Ax=𝜃只有零解，r(A)&lt;n，则其有非零解</li><li>Ax=𝜃有非零解的充要条件为|A|=0</li><li>行简化梯形矩阵每行左1对应的变量为同解方程组中作为左值的变量称为非自由变量，而其余变量可以自由取值，称为自由变量。</li><li>齐次方程组通解的定理</li><li>r(A)+r(N(A))=n，N(A)为Ax=𝜃的基础解系为列构成的矩阵</li></ul></li><li>非齐次方程组解的结构<ul><li>特解与对应齐次方程组通解的和</li></ul></li></ol><hr><h3 id="第四章-矩阵的特征值和特征向量"><a href="#第四章-矩阵的特征值和特征向量" class="headerlink" title="第四章 矩阵的特征值和特征向量"></a>第四章 矩阵的特征值和特征向量</h3><ul><li>相似矩阵</li></ul><ol><li>同阶矩阵A和B，若存在可逆矩阵P使得B=P^(-1)AP，则称B为A的相似矩阵，P为A到B的相似变换矩阵，记为A～B，称A相似于B。<ul><li>相似作为等价关系，具有自反、对称、传递性</li><li>A～B，则|A|=|B|，进而A与B的可逆性相同</li><li>A～B，且A或B可逆，则A的逆等于B的逆</li><li>A～B，则A与B的同阶幂乘也相似，相同数乘也相似</li><li>A～B，则f(A)～f(B)，f(x)为任意多项式</li></ul></li></ol><hr><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><ul><li>可逆</li><li>行/列简化梯形矩阵</li><li>秩</li><li>线性相关/无关</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;线性代数复习&quot;&gt;&lt;a href=&quot;#线性代数复习&quot; class=&quot;headerlink&quot; title=&quot;线性代数复习&quot;&gt;&lt;/a&gt;线性代数复习&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MIME</title>
    <link href="http://example.com/2022/10/30/MIME/"/>
    <id>http://example.com/2022/10/30/MIME/</id>
    <published>2022-10-30T08:45:32.000Z</published>
    <updated>2022-10-30T09:04:15.071Z</updated>
    
    <content type="html"><![CDATA[<p>媒体类型(Multipurpose Internet Mail Extensions，MIME)是用来表示文档、文件或字节流的性质和格式的一种标准。</p><span id="more"></span><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="通用结构"><a href="#通用结构" class="headerlink" title="通用结构"></a>通用结构</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span>/<span class="hljs-keyword">subtype</span><br></code></pre></td></tr></table></figure><p>由类型和子类型两个字符串中间用’/‘分隔组成，不允许空格存在。type为可以被分为多个子类的独立类别，subtype为细分后的每个类型。<br>MIME对大小写不敏感，但一般使用小写。</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>text</code></td><td align="center">普通文本</td><td align="center"><code>text/plain</code>,<code>text/html</code>,<code>text/css</code>,<code>text/javascript</code></td></tr><tr><td align="center"><code>image</code></td><td align="center">某种图像，包括动态图但补包括视频</td><td align="center"><code>image/gif</code>,<code>image/png</code>,<code>image/jpeg</code></td></tr><tr><td align="center"><code>audio</code></td><td align="center">某种音频文件</td><td align="center"><code>audio/midi</code>,<code>audio/mpeg</code>,<code>audio/wav</code></td></tr><tr><td align="center"><code>video</code></td><td align="center">某种视频文件</td><td align="center"><code>video/webm</code>,<code>video/ogg</code></td></tr><tr><td align="center"><code>application</code></td><td align="center">某种二进制数据</td><td align="center"><code>application/octet-stream</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;媒体类型(Multipurpose Internet Mail Extensions，MIME)是用来表示文档、文件或字节流的性质和格式的一种标准。&lt;/p&gt;</summary>
    
    
    
    <category term="networkProject" scheme="http://example.com/categories/networkProject/"/>
    
    
  </entry>
  
  <entry>
    <title>Java网络编程</title>
    <link href="http://example.com/2022/10/25/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2022/10/25/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2022-10-25T14:03:20.000Z</published>
    <updated>2022-10-30T08:37:06.783Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程是指编写运行在多个通过网络连接的主机的程序。</p><span id="more"></span><blockquote><p>java.net包提供了两种网络协议的支持：TCP和UDP  </p><ul><li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP层是位于IP层之上，应用层之下的中间层。TCP 保障了两个应用程序之间的可靠通信。通常用于互联网协议，称为TCP/IP。  </li><li>UDP（User Datagram Protocol，用户数据报协议）位于 OSI 模型的传输层，是一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。</li></ul></blockquote><h2 id="一、Java-Socket编程"><a href="#一、Java-Socket编程" class="headerlink" title="一、Java Socket编程"></a>一、Java Socket编程</h2><p>在网络编程中，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。<br>Socket套接字是支持TCP/IP协议的网络通信的基本操作单元，它包含了进行网络通信必须的五种信息：</p><ul><li>连接使用的协议  </li><li>本地主机的IP地址  </li><li>本地进程的协议端口  </li><li>远程主机的IP地址  </li><li>远程进程的协议端口  </li></ul><h3 id="1、套接字的连接过程"><a href="#1、套接字的连接过程" class="headerlink" title="1、套接字的连接过程"></a>1、套接字的连接过程</h3><p>服务器监听、客户端请求、连接确认</p><ol><li>服务器套接字处于等待连接的状态，实时监控网络状态</li><li>客户端的套接字提出连接请求以连接服务端套接字。为此，客户端套接字需要服务器套接字的地址和端口号</li><li>服务器套接字监听到并响应客户端套接字，建立一个新的线程，将服务端套接字的描述发给客户端。</li></ol><h3 id="2、Socket的基本工作过程："><a href="#2、Socket的基本工作过程：" class="headerlink" title="2、Socket的基本工作过程："></a>2、Socket的基本工作过程：</h3><ol><li>创建Socket</li><li>创建连接Socket的IO流</li><li>按一定协议对Socket进行读写操作</li><li>关闭Socket</li></ol><h3 id="3、Java-Socket：简单的服务端与客户端程序"><a href="#3、Java-Socket：简单的服务端与客户端程序" class="headerlink" title="3、Java Socket：简单的服务端与客户端程序"></a>3、Java Socket：简单的服务端与客户端程序</h3><h4 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">sock</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(sock.getInputStream());<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);<br>            String message;<br>            message = bufferedReader.readLine();<br>            System.out.println(message);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Server</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();<br>        server.execute();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(socket.getOutputStream());<br>            <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream());<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);<br>            System.out.println(<span class="hljs-string">&quot;Connection succeeded.&quot;</span>);<br>            writer.println(<span class="hljs-string">&quot;Happy Birthday!&quot;</span>);<br>            writer.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>();<br>        client.execute();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、IO-模型"><a href="#二、IO-模型" class="headerlink" title="二、IO 模型"></a>二、IO 模型</h2><h3 id="1、同步和异步"><a href="#1、同步和异步" class="headerlink" title="1、同步和异步"></a>1、同步和异步</h3><ul><li>同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回</li><li>异步：异步就是发起一个调用后，立即得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他请求。  </li></ul><p>被调用者通常依靠事件、回调等机制来通知调用者其返回结果。<br>两者的最大区别在于，异步的情况下，调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。</p><h3 id="2、阻塞和非阻塞"><a href="#2、阻塞和非阻塞" class="headerlink" title="2、阻塞和非阻塞"></a>2、阻塞和非阻塞</h3><ul><li>阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li><li>非阻塞：非阻塞就是发起一个请求，调用者不用已知等着结果返回，可以从事其他任务。</li></ul><p>Java Socket在调用accept、read等方法时，会发生阻塞</p><h3 id="3、Java支持的三种IO模型"><a href="#3、Java支持的三种IO模型" class="headerlink" title="3、Java支持的三种IO模型"></a>3、Java支持的三种IO模型</h3><ul><li>BIO（Blocking IO，同步阻塞IO）：一个线程处理一个连接</li><li>NIO（Non-blocking IO，同步非阻塞IO）：一个线程处理多个连接</li><li>AIO（Asynchronous IO，异步非阻塞IO）：通道异步</li></ul><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>在Server中建立ServerSocket对象，绑定端口，等待连接，若连接成功就新建一个进程去处理连接。</p><p>BIO的缺点：资源的浪费，每个客户端的连接都需要占用一个进程。</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>相关类处于java.nio包中。<br><img src="/img/networkProject/NIO%E5%9B%BE%E8%A7%A3.jpeg" alt="NIO 图解" title="NIO 图解"><br>NIO的三大核心部分：Selector(选择器)、Channel(通道)、Buffer(缓冲区)    </p><ul><li><p>Buffer：数据从Channel读入Buffer，又从Buffer写入Channel<br>在Java中，Buffer是一个抽象类，具有ByteBuffer、CharBuffer等子类，采用相似方法管理不同数据类型。<br>具有的基本属性：  </p><ul><li>容量：Buffer作为一个内存块所具有的一定大小，不能为负且创建后不可更改。</li><li>限制：Buffer中可以操作数据的大小，不能为负且小于等于其容量。写入模式下，限制等于buffer的容量，读取模式下，限制等于写入的数据量。</li><li>位置：下一个要读取或写入的数据的索引，不能为负且不能大于限制。</li><li>标记：通过mark方法指定Buffer中一个特定的位置，之后可以调用reset方法恢复到这个位置。</li></ul><p>Java Buffer存取数据的两个基本办法：</p><ul><li>put() 在Buffer的当前位置写入内容</li><li>get() 获取Buffer数据</li></ul></li><li><p>Channel：IO源与目标打开的连接，不能直接访问数据，只能与Buffer进行交互。<br>在Java中，Channel是一个接口，具有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等实现</p><p>Java Channel读写数据的基本办法：</p><ul><li>read()</li><li>write()</li></ul></li><li><p>Selector<br>Selector会不断轮询注册在上的所有channel，并发现处于就绪状态的channel。<br>使用步骤：</p></li></ul><ol><li>使用静态工厂办法open()获取选择器：<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span> = <span class="hljs-keyword">Selector</span>.open()<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li><li>获取可选择通道。该通道必须实现SelectableChannel接口并为非阻塞模式。</li><li>将通道注册到选择器，并告知监控的事件：<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">SelectableChannel.register(<span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span>, int ops)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li><li>调用Selector.select()，该方法将就绪事件放在SelectedKey集合中，并返回就绪事件数，这是个阻塞方法，直到至少有一个就绪事件，或其它县城调用当前Selector对象的wakeup()方法，或当前线程中断时返回。<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-keyword">while</span>(selector.<span class="hljs-built_in">select</span>() &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">Set</span>&lt;SelectionKey&gt; <span class="hljs-built_in">keys</span> = selector.selectedKeys();<br>&#125;<br></code></pre></td></tr></table></figure>给select()赋予一个long类型的参数可以限制其阻塞时间；selectNode()不阻塞，无就绪事件则返回0。  </li><li>处理就绪事件</li></ol><p>Channel和Buffer的基本操作</p><ol><li>分别建立连接文件和Socket的Channel</li><li>建立所需类型（Byte，等等）的Buffer，分配内存</li><li>从Channel中将数据读入Buffer/使用Channel从Buffer中读取数据</li><li>关闭Channel</li></ol><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络编程是指编写运行在多个通过网络连接的主机的程序。&lt;/p&gt;</summary>
    
    
    
    <category term="networkProject" scheme="http://example.com/categories/networkProject/"/>
    
    
  </entry>
  
  <entry>
    <title>Geternitier的博客</title>
    <link href="http://example.com/2022/10/20/%E5%A4%A9%E9%A9%AC%E6%AD%8C/"/>
    <id>http://example.com/2022/10/20/%E5%A4%A9%E9%A9%AC%E6%AD%8C/</id>
    <published>2022-10-20T15:43:39.838Z</published>
    <updated>2022-10-25T10:19:39.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="天马歌"><a href="#天马歌" class="headerlink" title="天马歌"></a>天马歌</h3><span id="more"></span><p>唐·李白</p><p>天马来出月支窟，背为虎文龙翼骨。<br>嘶青云，振绿发， 兰筋权奇走灭没。<br>腾昆仑，历西极，四足无一蹶。<br>鸡鸣刷燕晡秣越，神行电迈蹑慌惚。<br>天马呼，飞龙趋， 目明长庚臆双凫。<br>尾如流星首渴乌，口喷红光汗沟朱。<br>曾陪时龙蹑天衢，羁金络月照皇都。<br>逸气棱棱凌九区，白璧如山谁敢沽。<br>回头笑紫燕，但觉尔辈愚。<br>天马奔， 恋君轩，駷跃惊矫浮云翻。<br>万里足踯躅，遥瞻阊阖门。<br>不逢寒风子，谁采逸景孙。<br>白云在青天，丘陵远崔嵬。<br>盐车上峻坂，倒行逆施畏日晚。<br>伯乐翦拂中道遗，少尽其力老弃之。<br>愿逢田子方，恻然为我悲。<br>虽有玉山禾，不能疗苦饥。<br>严霜五月凋桂枝，伏枥衔冤摧两眉。<br>请君赎献穆天子，犹堪弄影舞瑶池。  </p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;天马歌&quot;&gt;&lt;a href=&quot;#天马歌&quot; class=&quot;headerlink&quot; title=&quot;天马歌&quot;&gt;&lt;/a&gt;天马歌&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
