<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Geternitier的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-27T08:42:17.823Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Geternitier</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件质量管理_概述</title>
    <link href="http://example.com/2024/06/21/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/1.%20%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2024/06/21/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/1.%20%E6%A6%82%E8%BF%B0/</id>
    <published>2024-06-21T04:00:00.000Z</published>
    <updated>2024-06-27T08:42:17.823Z</updated>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="概述">1. 概述</h1><h2 id="软件危机">1.0 软件危机</h2><p>软件在改变（定义？颠覆？）我们的世界。</p><p>软件自身的变化：规模、比例。</p><h3 id="软件四大本质困难和挑战">软件四大本质困难和挑战</h3><p>复杂性、不可见性、可变性、一致性</p><ul><li>除了不可见性，其他三个本质难题因项目而异</li><li>四大本质难题相互促进</li><li>本质难题变化带动软件方法（过程）演变</li></ul><h3 id="软件危机-1">软件危机</h3><p>软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。</p><h3 id="软件工程">软件工程</h3><p>一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。</p><p>软件工程的两大视角</p><ul><li>管理视角——能否复制成功？</li><li>技术视角——是否可以将问题解决得更好？</li></ul><h2 id="软件项目与过程管理">1.1 软件项目与过程管理</h2><p>管理的三大关键要素：</p><ul><li>目标</li><li>状态</li><li>纠偏</li></ul><h3 id="软件项目管理">1.1.1 软件项目管理</h3><p>应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。</p><ul><li>三大目标：成本、质量、工期</li><li>估算、计划、跟踪、风险管理、范围管理、人员管理、沟通管理，等等</li></ul><p>核心问题：复制成功</p><h4 id="软件过程">软件过程</h4><p>为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合</p><ul><li>这组实践间往往有一定先后顺序，作为整体来实现事先定义的一个或者多个目标。</li></ul><h4 id="广义软件过程">广义软件过程</h4><p>理论基石：软件产品和服务的质量，很大程度上取决于生产维护该软件或者服务的过程的质量。</p><p>广义软件过程包括技术、人员以及狭义过程。</p><ul><li>也称软件开发方法、软件开发过程。</li><li>极限编程方法、SCRUM方法、Gate方法</li><li>敏捷软件过程／方法、轻量型过程／方法以及重型过程／方法等</li></ul><h4 id="生命周期模型">生命周期模型</h4><p>对软件过程的一种人为的划分。</p><ul><li>生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分。</li><li>生命周期模型往往不包括技术实践。</li><li>瀑布模型、迭代式模型、增量模型、螺旋模型、原型法等等</li></ul><h3 id="软件过程管理">1.1.2 软件过程管理</h3><p>管理对象：软件过程</p><p>目的：让软件过程在开发效率、质量等方面有着更好性能绩效</p><ul><li>软件项目管理：产品生产管理（SCRUM、Kanban）</li><li>软件过程管理：流水线的设计、建设、维护、优化（CMMI、SPICE）</li></ul><h4 id="软件过程改进">软件过程改进</h4><ul><li>管理参考模型：CMM/CMMI、SPICE</li><li>改进参考元模型：PDCA、IDEAL</li></ul><h2 id="软件发展三大阶段">1.2 软件发展三大阶段</h2><ol type="1"><li>软硬件一体化阶段（50年代~70年代）</li></ol><ul><li>软件完全依附于硬件</li><li>软件作坊</li></ul><ol start="2" type="1"><li>软件成为独立的产品（70年代~90年代）</li><li>网络化和服务化（90年代中期迄今）</li></ol><h3 id="软硬件一体化">1.2.1 软硬件一体化</h3><h4 id="软件完全依附于硬件">软件完全依附于硬件</h4><p>软件应用典型特征：</p><ul><li><p>软件支持硬件完成计算任务</p></li><li><p>功能单一</p></li><li><p>复杂度有限</p></li><li><p>几乎不需要需求变更</p></li></ul><p>软件开发典型特征</p><ul><li>硬件太贵</li><li>团队以硬件工程师和数学家为主</li></ul><p>实践：Measure twice, cut once</p><h4 id="软件作坊">软件作坊</h4><p>软件应用典型特征</p><ul><li>功能简单</li><li>规模小</li></ul><p>软件开发典型特征</p><ul><li>很多非专业领域的人员涌入软件开发领域</li><li>高级程序语言出现</li><li>质疑权威文化盛行</li></ul><p>实践：Code and fix</p><h3 id="软件成为独立产品">1.2.2 软件成为独立产品</h3><p>软件应用特征</p><ul><li>摆脱了硬件束缚</li><li>功能强大</li><li>规模和复杂度剧增</li><li>个人电脑出现，普通人成为软件用户<ul><li>需求多变</li><li>兼容性要求</li></ul></li><li>来自市场的压力</li></ul><p>实践：</p><ul><li>形式化方法</li><li>结构化程序设计、瀑布模型</li><li>CMM/CMMI</li></ul><h3 id="网格化和服务化">1.2.3 网格化和服务化</h3><p>软件应用特征</p><ul><li>功能更复杂，规模更大</li><li>用户数量急剧增加（这会带来什么问题？）</li><li>快速演化和需求不确定</li><li>分发方式的变化（SaaS）</li></ul><p>典型软件过程和实践</p><ul><li><p>迭代式</p></li><li><p>敏捷宣言</p><ul><li>个体和互动胜过流程和工具</li><li>可以工作的软件胜过详尽的文档</li><li>客户合作胜过合同谈判</li><li>响应变化胜过遵循计划</li></ul></li><li><p>XP、SCRUM、Kanban</p></li><li><p>开源软件开发方法</p></li></ul><h3 id="软件发展现状">1.2.4 软件发展现状</h3><p>软件应用典型特征</p><ul><li><p>进一步服务化和网络化（移动是主流）</p></li><li><p>用户需求多样性进一步凸显</p></li><li><p>软件产品和服务的地位变化</p></li><li><p>错综复杂的部署环境</p></li><li><p>近乎苛刻的用户期望</p><ul><li>多：功能丰富，个性化</li><li>快：快速使用，及时更新，快速解决问题</li><li>好：稳定，可靠，安全，可信</li><li>省：用户的获得成本低，最好免费</li></ul></li></ul><p>软件开发典型特征</p><ul><li>空前强大的开发和部署环境——XaaS<ul><li>IaaS</li><li>PaaS</li><li>SaaS, FaaS</li></ul></li><li>盛行共享和开源</li><li>潜在支撑获得了长足进步（AI，Bigdata， Cloud，etc.）</li></ul><p>典型DevOps实践和方法</p><ul><li>方法论基础：敏捷软件开发、精益思想以及Kanban方法。</li><li>以领域驱动设计为指导的微服务架构方式</li><li>大量虚拟化技术的使用</li><li>一切皆服务的理念指导</li><li>构建了强大的工具链，支持高水平自动化</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;高堂明镜悲白发，朝如青丝暮成雪。&lt;/p&gt;</summary>
    
    
    
    <category term="软件质量管理" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>软件系统设计_软件架构复习</title>
    <link href="http://example.com/2024/06/14/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2024/06/14/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%A4%8D%E4%B9%A0/</id>
    <published>2024-06-14T04:00:00.000Z</published>
    <updated>2024-06-23T16:49:06.534Z</updated>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="软件架构复习">软件架构复习</h1><h2 id="总览">0. 总览</h2><ol type="1"><li>软件架构</li><li>质量属性</li><li>架构模式</li><li>架构设计</li><li>架构文档化</li><li>架构评价</li><li>微服务</li></ol><h2 id="软件架构">1. 软件架构</h2><h3 id="什么是软件架构">1.1 什么是软件架构？</h3><p>程序或计算系统的结构，由软件元素、这些元素外部可⻅的属性、这些元素的关系组成。</p><h3 id="软件架构师做什么">1.2 软件架构师做什么？</h3><p>联络：客户、技术团队和业务需求分析师</p><p>软件工程</p><p>技术知识</p><p>风险管理。</p><h3 id="架构来自哪里">1.3 架构来自哪里？</h3><p>NFRs、ASRs、质量要求、涉众、组织、技术环境、业务目标</p><h3 id="架构41视图">1.4 架构4+1视图</h3><p>逻辑视图：描述架构中重要的元素及其之间的关系</p><p>进程视图：描述架构的并发和通信元素</p><p>物理视图：描述主要过程和元素是如何被映射到应⽤程序硬件</p><p>开发视图：捕获软件组件的内部组织</p><p>架构⽤例：捕获架构的需求；与多个特定视图关联</p><h3 id="架构活动和过程">1.5 架构活动和过程</h3><h4 id="架构活动">架构活动</h4><ul><li><p>创造系统的商业案例</p></li><li><p>理解需求</p></li><li><p>创造和选择架构</p></li><li><p>与包括开发者在内的涉众沟通架构</p></li><li><p>分析或评估架构</p><ul><li><p>总的⽅法</p></li><li><p>质量特定技术</p></li></ul></li><li><p>实现架构</p></li><li><p>确保架构符合要求</p></li></ul><h4 id="架构过程">架构过程</h4><ol type="1"><li>确定ASRs</li><li>架构设计</li><li>文档化</li><li>架构评估</li></ol><h3 id="软件架构知识领域">1.6 软件架构知识领域</h3><p>软件设计基本概念</p><ul><li><p>总体设计概念</p></li><li><p>上下⽂：软件开发⽣命周期——需求、设计、构建和测试</p></li><li><p>设计过程（⻆⾊、活动、⼯作产品）</p></li><li><p>软件设计的可⽤⼯具</p></li></ul><p>关键技术问题：并⾏性、事件控制和处理、分布式、异常处理、交互式系统、持久化</p><p>软件结构和架构</p><ul><li><p>架构结构和视点</p></li><li><p>架构样式和模式（宏观架构）</p></li><li><p>设计模式（微观架构）</p></li></ul><p>软件设计⽅法</p><ul><li><p>架构⽅法（如属性驱动设计）</p></li><li><p>设计⽅法（如动态系统开发⽅法）</p></li></ul><p>软件设计质量分析和评估</p><ul><li><p>质量属性</p></li><li><p>质量分析和评估⽅法、技术、⼯具</p><ul><li><p>设计审查（如 SEI 的架构权衡分析⽅法）</p></li><li><p>静态分析和动态分析</p></li><li><p>模拟和原型</p></li></ul></li><li><p>度量</p><ul><li><p>指标：架构层次</p></li><li><p>与技术有关的度量</p></li></ul></li></ul><p>设计建模和表示</p><ul><li><p>架构和设计标记（架构描述语⾔ ADL Architecture DescriptionLanguages）</p></li><li><p>统⼀建模语⾔（UML）</p></li><li><p>设计⽂档（视图和超越视图）</p></li><li><p>其他：视能⼒、关注点和领域⽽定</p></li></ul><h2 id="质量属性">2. 质量属性</h2><h3 id="软件需求">2.1 软件需求</h3><h4 id="功能需求">功能需求</h4><p>系统必须完成的、为涉众提供价值的内容。</p><ul><li>功能的实现可能⽤了很多的结构，但功能是与结构⽆关的。</li></ul><h4 id="质量需求nfrs">质量需求（NFRs）</h4><p>整个系统的期望特征，在功能需求之上。</p><ul><li>如果质量属性很重要，软件架构将约束功能的分配到不同的结构。</li></ul><h4 id="约束">约束</h4><p>0 ⾃由度、预定义的设计决定</p><ul><li>接受设计决定、协调其他受影响的设计决定，如此来满⾜约束</li></ul><h3 id="质量属性-1">2.2 质量属性</h3><p>内部/外部属性</p><h4 id="建模质量属性场景">建模质量属性场景</h4><p>源、刺激、制品、环境、响应、度量</p><h4 id="举例">举例</h4><p>可用性、互操作性、可修改性、性能、安全性、可测试性、其他</p><h4 id="质量属性战术">质量属性战术</h4><p>战术是影响质量属性响应控制的设计决定。</p><ul><li>战术的集合被称为架构策略。</li></ul><h4 id="架构设计决策检查列表">架构设计决策检查列表</h4><h3 id="架构重要需求">2.3 架构重要需求</h3><p>在架构上有深刻影响的需求。</p><p>如何收集、确认ASRs：</p><ol type="1"><li>从需求文档收集</li><li>采访涉众</li><li>理解业务目标</li><li>质量属性效用树</li></ol><h2 id="架构模式">3. 架构模式</h2><h3 id="架构模式-1">3.1 架构模式</h3><p>⼀系列在实践中能反复地看到的设计决定。</p><ul><li>上下文：经常出现的、普遍的、引起问题的情形</li><li>问题：适当地概括的，在给定上下⽂中出现</li><li>解决方案：成功的、适当抽象的架构解决⽅案</li></ul><h3 id="模块模式">3.2 模块模式</h3><p>分层模式（微内核模式）</p><h3 id="组件-连接件模式">3.3 组件-连接件模式</h3><p>代理人模式、MVC模式、管道、过滤器模式、C/S模式、P2P模式、SO模式、发布-订阅模式、数据共享模式</p><h3 id="分配模式">3.4 分配模式</h3><p>Map-Reduce模式、Multi-Tier模式</p><h3 id="模式与战术">3.5 模式与战术</h3><ol type="1"><li><p>战术⽐模式简单：使⽤单⼀的结构或机制来处理单⼀的架构要求</p></li><li><p>模式通常将多个设计决定合并到⼀个包</p></li><li><p>模式和战术⼀起构成了软件架构师的主要⼯具</p></li><li><p>战术是设计的建造⽅块，⽤来创建架构模式</p></li><li><p>⼤多数模式由⼏个不同的战术组成</p><ul><li><p>所有战术为了⼀个共同⽬的</p></li><li><p>经常被选择来保证不同的质量属性</p></li></ul></li></ol><h2 id="架构设计">4. 架构设计</h2><h3 id="通用设计策略">4.1 通用设计策略</h3><p>抽象、分解、迭代、重用</p><h3 id="设计决策分类">4.2 设计决策分类</h3><p>职责、协调、数据、资源、元素映射、技术</p><h3 id="属性驱动设计add">4.3 属性驱动设计（ADD）</h3><p>输⼊：需求</p><p>输出：软件元素、⻆⾊、职责、属性、关系</p><p>步骤：</p><ol type="1"><li>确认需求</li><li>选择并分解元素</li><li>识别ASR</li><li>选择满足ASR的设计<ul><li>确认关注点</li><li>列出可选项（模式/战术）</li><li>选择模式/战术</li><li>决定模式/战术和ASR间关系</li><li>捕捉初步架构视图</li><li>解决不一致</li></ul></li><li>实例化元素，分配职责</li><li>定义元素接口</li><li>验证、细化需求</li><li>重复2-7直到所有架构重要需求被满足</li></ol><h2 id="架构文档化">5. 架构文档化</h2><h3 id="视图">5.1 视图</h3><h4 id="样式模式和视图">样式、模式和视图</h4><p>架构样式：元素和关系类型的专⻔化，以及如何使⽤它们的⼀组约束。</p><p>架构模式：软件系统中的基础结构组织⽅法的表达。</p><ul><li>架构模式关注问题和上下午，样式侧重方法。</li></ul><p>样式的三个分类：</p><ul><li>一组样式单元：模块样式</li><li>一组有运行时行为和交互的元素：组件-连接件样式</li><li>与环境中的非软件结构关联：分配样式</li></ul><p>架构视图：⼀组系统元素及其关系的表示。</p><ul><li>视图让我们将系统实体划分成感兴趣和易于管理的系统表示。</li><li>不同的视图⽀持不同的⽬标和⽤户，凸显出不同系统元素和关系</li><li>不同视图在不同程度上展现不同的质量属性</li></ul><h4 id="结构性视图">结构性视图</h4><h5 id="模块视图">模块视图</h5><p>模块是提供⼀套连贯的职责的实现单元。</p><p>包含：</p><ul><li>分解视图 Decomposition view</li><li>使⽤视图 Uses view</li><li>概括视图 Generalization view</li><li>分层视图 Layered view</li><li>⽅⾯视图 Aspects view</li><li>数据模型视图 Data model view</li></ul><p>元素：模块，提供⼀套连贯职责的实现单元</p><p>关系：</p><ul><li><p>“⼀部分”：部分⼦模块和整体聚合模块之间的部分、整体关系</p></li><li><p>“依赖于”：两个模块之间的依赖关系。特定的模块视图详细说明了依赖关系的含义</p></li><li><p>“是”：更具体的⼦模块和更⼀般的⽗模块之间的泛化、专⻔化关系</p></li></ul><p>约束：不同模块视图可能会施加特定的拓扑约束，例如限制模块之间的可⻅性。</p><p>⽤途</p><ul><li><p>代码构建蓝图</p></li><li><p>变更影响分析</p></li><li><p>规划增量开发</p></li><li><p>需求追踪分析</p></li></ul><h5 id="组件-连接件视图">组件-连接件视图</h5><p>显示运行时组件。</p><ul><li><p>例如进程、对象、客户机、服务器和数据存储</p></li><li><p>“连接”指明了哪些连接器连接到哪些组件。</p></li></ul><p>包含：</p><ul><li>管道-过滤器视图 Pipe-and-filter view</li><li>客户机-服务端视图 Client-server view</li><li>点对点视图 Peer-to-peer view</li><li>⾯向服务架构视图 Service-oriented view</li><li>发布-订阅视图 Publish-subscribe view</li><li>共享数据视图 Shared-data view</li><li>多层视图 Multi-tier view</li></ul><p>元素：</p><ul><li><p>组件。主要处理单元和数据存储。组件有⼀组端⼝，通过这些端⼝与其他组件进⾏交互（通过连接器）</p></li><li><p>连接器。组件间交互的途径。连接器有⼀组⻆⾊（接⼝），指示组件如何在交互中使⽤连接器</p></li></ul><p>约束：</p><ul><li><p>组件只能连接到连接器，⽽不是直连其他组件</p></li><li><p>连接器只能连接到组件，⽽不是直连其他连接器</p></li><li><p>连接只能在相容的端⼝和⻆⾊上建⽴</p></li><li><p>接⼝委托只能在两个相容端⼝或⻆⾊上定义</p></li><li><p>连接器不能孤⽴出现，必须连接到组件</p></li></ul><p>⽤途</p><ul><li><p>演示系统如何⼯作</p></li><li><p>通过指定运⾏时元素的结构和⾏为来指导开发</p></li><li><p>帮助解释运⾏时系统质量属性，如性能和可⽤性</p></li></ul><h5 id="分配视图">分配视图</h5><p>描述了软件单元到软件开发或执⾏环境元素的映射。</p><p>包含：</p><ul><li>部署视图 Deployment view</li><li>安装视图 Install view</li><li>⼯作安排视图 Work assignment view</li><li>其他分配视图 Other allocation view</li></ul><p>元素</p><ul><li><p>软件元素。软件元素具有环境所需的属性</p></li><li><p>环境元素。环境元素具有提供给软件的属性</p></li></ul><p>关系：被分配。软件元素被分配到环境元素，属性取决于特定视图。</p><p>⽤途：</p><ul><li><p>⽤于对性能、可⽤性、安全性 security 和安全性 safety进⾏解释</p></li><li><p>⽤于解释分布式开发和将⼯作分配给团队</p></li><li><p>⽤于解释软件版本的并⾏访问</p></li><li><p>⽤于解释系统安装的形式和机制</p></li></ul><h4 id="质量视图">质量视图</h4><p>包含</p><ul><li><p>安全视图 Security view</p></li><li><p>性能视图 Performance view</p></li><li><p>可靠性视图 Reliability view</p></li><li><p>通信视图 Communication view</p></li><li><p>异常视图 Exception view（错误处理视图 error- handlingview）</p></li></ul><h3 id="视图文档化">5.2 视图文档化</h3><h3 id="选择视图">选择视图</h3><h4 id="选择视图-1">选择视图</h4><ol type="1"><li><p>构建涉众-视图表</p></li><li><p>组合视图</p><ol type="1"><li>确定上表中的边缘视图</li><li>通过将⼀个视图的元素与另⼀个视图中的元素相关联，将每个边缘视图与另⼀个更具⽀持性的视图相结合</li></ol></li><li><p>确定优先级和阶段</p><ul><li><p>分解视图</p></li><li><p>⼋⼆开原则</p></li><li><p>按顺序完成所有视图</p></li></ul></li></ol><h4 id="涉众文档">涉众文档</h4><p>左列是涉众的类别，右列是对应涉众如何使⽤这个⽂档。</p><h4 id="涉众-视图表">涉众-视图表</h4><p>左边是涉众，右边每⼀列都是⼀个视图，值分别表示：</p><ul><li>d 详细信息</li><li>s ⼀些细节</li><li>o ⼤概信息</li><li>x ⽆所谓。</li></ul><h3 id="超越视图">5.3 超越视图</h3><p>文档信息、架构信息、视图间映射。</p><h2 id="架构评价">6. 架构评价</h2><h3 id="架构分析评价方法">6.1 架构分析+评价方法</h3><p>软件架构分析⽅法 SAAM，Software Architecture Analysis Method</p><p>架构层级可修改性分析 ALMA，Architecture Level ModifiabilityAnalysis</p><p>软件架构性能评估 PASA，Performance Assessment of SoftwareArchitecture</p><p>架构权衡分析⽅法 ATAM，Architecture Trade-off Analysis Method</p><h3 id="atam">6.2 ATAM</h3><p>架构权衡分析⽅法，Architecture Tradeoff Analysis Method</p><ol start="0" type="1"><li><p>合作与准备</p><p>参与者：团队领导和主要项目决策者</p><p>输入：架构文档</p><p>输出：评价计划</p></li><li><p>评估1</p><p>参与者：评估团队和项目决策者</p><p>输出：架构展示、业务驱动因素、质量属性需求优先级列表、效用树、风险、敏感点和权衡点</p><ol type="1"><li>展示 ATAM</li><li>展示业务驱动因素</li><li>展示架构</li><li>识别架构⽅法</li><li>⽣成效⽤树</li><li>分析架构⽅法</li></ol></li><li><p>评估2</p><p>参与者：评估团队、项目决策者、架构涉众</p><p>输出：涉众社区的优先级场景列表、风险主题和受威胁的业务驱动因素</p><ol type="1"><li>展示 ATAM 和结果</li><li>头脑⻛暴和定优先级</li><li>分析架构⽅法</li><li>展示结果</li></ol></li><li><p>后续⾏动</p><p>参与者：评估团队和主要涉众</p><p>输出：最终评估报告</p></li></ol><h4 id="atam输出">ATAM输出</h4><ul><li>架构的简短展示</li><li>业务⽬标的表达</li><li>由质量属性场景表达的定优先级的质量属性需求</li><li>效⽤树</li><li>⼀组⻛险和⾮⻛险</li><li>⼀组⻛险主题</li><li>从架构决定到质量需求的映射</li><li>⼀组确定的敏感点和权衡点</li><li>最终评估报告</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;天生我材必有用，千金散尽还复来。&lt;/p&gt;</summary>
    
    
    
    <category term="软件系统设计" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>软件系统设计_详细设计复习</title>
    <link href="http://example.com/2024/06/13/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2024/06/13/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/</id>
    <published>2024-06-13T04:00:00.000Z</published>
    <updated>2024-06-23T08:50:39.269Z</updated>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="详细设计复习">详细设计复习</h1><h2 id="软件模式">1. 软件模式</h2><p>软件开发的总体指导思路或参照样板。</p><ul><li>软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等。</li><li>在软件生存期的每一个阶段都存在着一些被认同的模式。</li></ul><h3 id="组成">组成</h3><ul><li>问题描述</li><li>前提条件(环境或约束条件)</li><li>解法</li><li>效果。</li></ul><h3 id="大三律">大三律</h3><p>只有经过三个以上不同类型(或不同领域)系统的校验，一个解决方案才能从候选模式升格为模式。</p><h2 id="设计模式">2.设计模式</h2><p>被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><h3 id="基本要素">基本要素</h3><ul><li>模式名称 (Pattern name)</li><li>问题 (Problem)</li><li>解决方案 (Solution)</li><li>效果 (Consequences)</li></ul><h3 id="分类">分类</h3><p>根据其目的分为</p><ul><li>创建型（Creational）：创建对象</li><li>结构型（Structural）：处理类或对象的组合</li><li>行为型（Bahavioral）：描述对类或对象怎样交互和分配职责</li></ul><p>根据范围，即模式主要用于处理类/对象之间关系分为</p><ul><li>类模式：处理类和子类的关系，这些关系在编译时确定，是静态的</li><li>对象模式：处理对象间关系，这些关系在运行时变化，是动态的</li></ul><h3 id="考察内容">考察内容</h3><table><thead><tr class="header"><th>范围/目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr class="odd"><td>类模式</td><td>工厂方法模式</td><td>（类）适配器模式</td><td>模板方法模式</td></tr><tr class="even"><td>对象模式</td><td>抽象工厂模式<br />原型模式</td><td>（对象）适配器模式<br />组合模式<br />装饰模式<br />外观模式</td><td>命令模式<br />中介者模式<br />观察者模式<br />状态模式<br />策略模式</td></tr></tbody></table><h3 id="设计模式与类库框架">设计模式与类库框架</h3><ol type="1"><li><p>设计模式比库的层次更高。设计模式告诉我们如何构建类和对象以解决特定问题。</p></li><li><p>框架和库不是设计模式；它们提供了具体的实现，我们将这些实现链接到我们的代码中。</p></li></ol><h2 id="设计原则">3. 设计原则</h2><p>对于面向对象的软件系统设计来说，在支持可维护性的同时，需要提高系统的可复用性。</p><ul><li>软件的复用可以提高软件的开发效率和软件质量，节约开发成本。</li><li>恰当的复用还可以改善系统的可维护性。</li></ul><p>目标：开闭原则</p><p>指导：最小知识原则</p><p>基础：单一职责原则、可变性封装原则</p><p>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</p><ol type="1"><li><p>开闭原则：一个软件实体应当对扩展开放，对修改关闭。</p></li><li><p>单一职责原则：一个类只负责一个功能领域中的相应职责。</p></li><li><p>里氏代换原则：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</p></li><li><p>依赖倒转原则：</p><p>抽象不应该依赖于细节，细节应该依赖于抽象</p><p>针对接口编程，不要针对实现编程。</p></li><li><p>接口隔离原则：客户端不应该依赖那些它不需要的接口。</p><ul><li>将一些大的接口细化成一些小的接口供客户端使用。</li></ul></li><li><p>合成复用原则：复用时尽量使用对象组合，而不使用继承。</p></li><li><p>迪米特法则：一个软件实体应当尽可能少的与其他实体发生相互作用。</p></li></ol><h2 id="表驱动法">4. 表驱动法</h2><h3 id="目标">目标</h3><p>将复杂逻辑从代码中⽴出来，以便于单独维护。</p><h3 id="原理">原理</h3><p>从表⾥⾯查找信息⽽不使⽤逻辑语句。</p><h3 id="查询">查询</h3><h4 id="直接访问">直接访问</h4><p>通过索引值（如下标）直接从表中找到对应的条⽬。</p><h4 id="索引访问">索引访问</h4><p>当⽆法直接从表中查询需要的条⽬时，就需要借助其他⽅法先获取表键值</p><ul><li>⽅法：先⽤⼀个基本类型的数据从索引表中查出⼀个键值，然后再⽤这⼀键值查出主数据。</li></ul><h4 id="阶梯访问">阶梯访问</h4><p>基本思想：通过确定每项命中的阶梯层次确定其归类。</p><ul><li>⽐索引访问⽅法节省空间，当阶梯多了⽐较次数就多。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;天生我材必有用，千金散尽还复来。&lt;/p&gt;</summary>
    
    
    
    <category term="软件系统设计" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>软件系统设计_设计模式</title>
    <link href="http://example.com/2024/06/12/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2024/06/12/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-06-12T04:00:00.000Z</published>
    <updated>2024-06-23T08:37:10.042Z</updated>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="设计模式">设计模式</h1><p>被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><h2 id="概念">0. 概念</h2><h3 id="基本要素">基本要素</h3><ul><li>模式名称 (Pattern name)</li><li>问题 (Problem)</li><li>解决方案 (Solution)</li><li>效果 (Consequences)</li></ul><h3 id="分类">分类</h3><p>根据其目的分为</p><ul><li>创建型（Creational）：创建对象</li><li>结构型（Structural）：处理类或对象的组合</li><li>行为型（Bahavioral）：描述对类或对象怎样交互和分配职责</li></ul><p>根据范围，即模式主要用于处理类/对象之间关系分为</p><ul><li>类模式：处理类和子类的关系，这些关系在编译时确定，是静态的</li><li>对象模式：处理对象间关系，这些关系在运行时变化，是动态的</li></ul><h3 id="设计模式与类库框架">设计模式与类库框架</h3><ol type="1"><li><p>设计模式比库的层次更高。设计模式告诉我们如何构建类和对象以解决特定问题。</p></li><li><p>框架和库不是设计模式；它们提供了具体的实现，我们将这些实现链接到我们的代码中。</p></li></ol><h3 id="考察内容">考察内容</h3><table><thead><tr class="header"><th>范围/目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr class="odd"><td>类模式</td><td>工厂方法模式</td><td>（类）适配器模式</td><td>模板方法模式</td></tr><tr class="even"><td>对象模式</td><td>抽象工厂模式<br />原型模式</td><td>（对象）适配器模式<br />组合模式<br />装饰模式<br />外观模式</td><td>命令模式<br />中介者模式<br />观察者模式<br />状态模式<br />策略模式</td></tr></tbody></table><h2 id="工厂模式">1. 工厂模式</h2><h3 id="简单工厂模式">简单工厂模式</h3><p>专门定义一个类来负责创建其他类的实例，根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><ul><li><p>又称静态工厂模式。</p></li><li><p>将对象的创建和对象本身业务处理分离可以降低系统的耦合度。</p></li></ul><h3 id="工厂方法模式">工厂方法模式</h3><p>简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这违背了开闭原则。</p><h4 id="概念-1">概念</h4><p>工厂方法模式（Factory Method Pattern）又称为工厂模式。</p><ul><li>也叫虚拟构造器（Virtual Constructor）模式、多态工厂（PolymorphicFactory）模式。</li></ul><ol type="1"><li>工厂父类负责定义创建产品对象的公共接口</li><li>工厂子类则负责生成具体的产品对象</li></ol><p>通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><ul><li>允许系统在不修改工厂角色的情况下引进新产品。</li></ul><h4 id="优缺点">优缺点</h4><p>优点：</p><ol type="1"><li>用户只需要关心所需产品对应的工厂，无须关心创建细节、具体产品类名。</li><li>工厂可以自主确定创建何种对象、如何创建对象。</li><li>在系统中加入新产品时，只要添加具体工厂和具体产品。</li></ol><p>缺点：</p><ol type="1"><li>添加新产品时系统中类的个数成对增加，提高了系统复杂度。</li><li>系统中加入抽象层，提高了系统理解难度和实现难度。</li></ol><h4 id="适用环境">适用环境</h4><ol type="1"><li>一个类不知道它所需要的对象的类。</li><li>一个类通过其子类来指定创建哪个对象。</li><li>客户端不需要关心是哪一个工厂子类，需要时动态指定。<ul><li>可将具体工厂类名存储在数据库或配置文件中。</li></ul></li></ol><h4 id="配置文件实例化具体工厂">配置文件实例化具体工厂</h4><p>将具体类的类名写入配置文件中，再通过Java的反射机制，读取XML格式的配置文件，根据存储在XML文件中的类名字符串生成对象。</p><h3 id="抽象工厂模式">抽象工厂模式</h3><p>有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p><ul><li>产品等级结构：产品的继承结构</li><li>产品族：由同一个工厂生产的 ，位于不同产品等级结构中的一组产品</li></ul><h4 id="问题">问题</h4><p>系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品。</p><h4 id="概念-2">概念</h4><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p><ul><li><p>又称为Kit模式。</p></li><li><p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p></li><li><p>工厂方法模式针对一个产品等级结构，而抽象工厂模式需要面对多个。</p></li></ul><h4 id="优缺点-1">优缺点</h4><p>优点：</p><ol type="1"><li>隔离了具体类的生成，只需改变具体工厂的实例，就在某种程度上改变整个软件系统的行为。</li><li>实现高内聚低耦合的设计目的。</li><li>保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的具体工厂和产品族修改已有系统，符合开闭原则。</li></ol><p>缺点：</p><p>添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品。</p><ul><li>即：增加新的工厂和产品族容易，增加新的产品等级结构麻烦。</li></ul><h4 id="和工厂方法模式区别">和工厂方法模式区别</h4><p>工厂模式创建同一个产品的不同类型，抽象工厂模式创建不同类的产品。</p><ul><li>产品种类单一，适合用工厂模式。</li><li>有多个种类，各种类型时，适合抽象工厂模式。</li></ul><h4 id="适用环境-1">适用环境</h4><p>对所有的工厂模式：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节。</p><ol type="1"><li>系统中有多于一个的产品族，属于同一个产品族的产品将在一起使用。</li><li>所有的产品以同样的接口出 现，从而使客户端不依赖于具体实现。</li></ol><h3 id="模式扩展">模式扩展</h3><h4 id="开闭原则的倾斜性">开闭原则的倾斜性</h4><ol type="1"><li><p>增加产品族：对于增加新的产品族，工厂模式很好的支持了开闭原则，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</p></li><li><p>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持开闭原则。</p></li></ol><h4 id="工厂模式的退化">工厂模式的退化</h4><ol type="1"><li>只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式。</li><li>工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li></ol><h2 id="原型模式">2. 原型模式</h2><h3 id="概念-3">概念</h3><p>用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><ul><li><p>基本工作原理：</p><p>将一个原型对象传给要发动创建的对象，该对象请求原型对象拷贝原型自身来实现创建。</p></li><li><p>包含角色：抽象原型类、具体原型类、客户类</p></li><li><p>类包含一些成员对象，在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为深克隆和浅克隆。</p></li><li><p>clone()满足：</p><ol type="1"><li>对任何的对象x，都有x.clone() !=x，即克隆对象与原对象不是同一个对象。</li><li>对任何的对象x，都有x.clone().getClass()==x.getClass()，克隆对象与原对象类型一样。</li><li>如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</li></ol></li></ul><h3 id="优缺点-2">优缺点</h3><p>优点：</p><ol type="1"><li>简化对象的创建过程，通过已有实例提高新实例的创建效率。</li><li>动态增加或减少产品类。</li><li>可以使用深克隆保存对象的状态。</li></ol><p>缺点：</p><ol type="1"><li>需要为每一个类配备一个克隆方法。</li><li>实现深克隆的代码较为复杂。</li></ol><h3 id="适用环境-2">适用环境</h3><ol type="1"><li>创建新对象成本较大。</li><li>系统要保存对象的状态。</li><li>避免使用分层次的工厂类来创建分层次的对象。</li></ol><h3 id="模式扩展-1">模式扩展</h3><p>相似对象复制：通过原型模式获得相同对象后再对其属性进行修改，从而获取所需对象。</p><h2 id="适配器模式">3. 适配器模式</h2><h3 id="概念-4">概念</h3><p>将一个接口转换成客户希望的另一个接口。</p><ul><li>也称包装器（Wrapper）。</li><li>既可以作为类结构型模式，也可以作为对象结构型模式。</li><li>包含角色：目标抽象类、适配器类、适配者类、客户类</li></ul><h3 id="优缺点-3">优缺点</h3><p>适配器模式优点：</p><ol type="1"><li>将目标类和适配者类解耦。<ul><li>通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li></ul></li><li>增加了类的透明性和复用性。</li><li>灵活性和扩展性好。<ul><li>通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合开闭原则。</li></ul></li></ol><p>类适配器：</p><p>优点：适配器类是适配者类的子类，可以置换一些适配者的方法，灵活性强。</p><p>缺点：在很多编程语言中适配器类不能同时适配多个适配者类。</p><p>对象适配器：</p><p>优点：同一个适配器可以把适配者类和它的子类都适配到目标接口。</p><p>缺点：不容易置换适配者类的方法。</p><h3 id="适用环境-3">适用环境</h3><ol type="1"><li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ol><h3 id="模式扩展-2">模式扩展</h3><h4 id="默认适配器模式">默认适配器模式</h4><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式。</p><h4 id="双向适配器">双向适配器</h4><p>如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器。</p><h2 id="组合模式">4. 组合模式</h2><h3 id="概念-5">概念</h3><p>组合多个对象形成树形结构以表示“整体-部分”的结构层次。</p><ul><li><p>对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。</p></li><li><p>又称“整体-部分”（Part-Whole）模式</p></li><li><p>包含角色：抽象构件、叶子构件、容器构件、客户类</p></li><li><p>关键：</p><p>定义一个抽象构件类，既可以代表叶子，又可以代表容器，递归组合成树形结构。</p><p>而客户端针对该抽象构件类进行编程。</p></li></ul><h3 id="优缺点-4">优缺点</h3><p>优点：</p><ol type="1"><li>清楚地定义分层次的复杂对象。</li><li>客户端可以一致的使用组合结构或其中单个对象。</li><li>定义了包含叶子对象和容器对象的类层次结构，递归组合成树形结构。</li><li>更容易在组合体内加入对象构件。</li></ol><p>缺点：</p><ol type="1"><li>设计更加抽象困难。</li><li>很难对容器中的构件类型进行限制。</li></ol><h3 id="适用环境-4">适用环境</h3><ol type="1"><li>需要表示一个对象整体或部分层次。</li><li>客户端可以针对抽象构件编程，无须关心对象层次结构的细节。</li><li>对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们。</li></ol><h2 id="装饰模式">5. 装饰模式</h2><h3 id="概念-6">概念</h3><p>动态地给一个对象增加一些额外的职责。</p><ul><li><p>又称包装器（Wrapper），和适配器别名相同，但使用场合不同。</p></li><li><p>包含角色：抽象构件、具体构件、抽象装饰类、具体装饰类</p></li><li><p>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性。</p><ul><li>继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。</li><li>关联关系使系统具有较好的松耦合性， 因此使得系统更加容易维护。</li><li>关联关系的缺点是比继承关系要创建更多的对象。</li></ul></li></ul><h3 id="优缺点-5">优缺点</h3><p>优点：</p><ol type="1"><li>提供比继承更多的灵活性。</li><li>通过一种动态的方式来扩展一个对象的功能。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。</li><li>具体构件类与具体装饰类可以独立变化。</li></ol><p>缺点：</p><ol type="1"><li>产生很多小对象。</li><li>装饰模式比继承更加易于出错，排错也很困难。<ul><li>对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul></li></ol><h3 id="适用环境-5">适用环境</h3><ol type="1"><li>以动态、透明的方式给单个对象添加职责。</li><li>动态地给一个对象增加、撤销功能。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。<ul><li>系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长</li><li>类定义不能继承（final类）。</li></ul></li></ol><h3 id="模式扩展-3">模式扩展</h3><h4 id="装饰模式简化">装饰模式简化</h4><ol type="1"><li>一个装饰类的接口必须与被装饰类的接口保持相同。</li><li>不要把太多的逻辑和状态放在具体构件类中。</li><li>如果只有一个具体构件类而没有抽象构件类，抽象装饰类可以作为具体构件类的直接子类。</li></ol><h4 id="透明装饰模式和半透明装饰模式">透明装饰模式和半透明装饰模式</h4><ul><li>透明装饰模式：完全针对抽象编程，不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型。</li><li>半透明装饰模式：允许声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li></ul><h2 id="外观模式">6. 外观模式</h2><h3 id="概念-7">概念</h3><p>外部与一个子系统的通信通过统一的外观对象进行，为子系统中的一组接口提供一致的界面。</p><ul><li><p>Facade Pattern</p></li><li><p>包含角色：外观、子系统</p></li><li><p>在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性。</p></li><li><p>通过引入一个新的外观类降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p></li></ul><h3 id="优缺点-6">优缺点</h3><p>优点：</p><ol type="1"><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。</li><li>实现了子系统与客户之间的松耦合关系。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ol><p>缺点：</p><ol type="1"><li>不能很好地限制客户使用子系统类。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了开闭原则。</li></ol><h3 id="适用环境-6">适用环境</h3><ol type="1"><li>为一个复杂子系统提供一个简单接口。</li><li>客户程序与多个子系统之间存在很大的依赖性。</li><li>使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ol><h3 id="模式扩展-4">模式扩展</h3><ol type="1"><li>在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互。</li><li>不要试图通过外观类为子系统增加新行为。</li><li>抽象外观类。</li></ol><h2 id="模板方法模式">7. 模板方法模式</h2><h3 id="概念-8">概念</h3><p>定义一个操作中算法的骨架，而将一些步骤延迟到子类中。</p><ul><li><p>使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></li><li><p>包含角色：抽象类、具体子类</p></li><li><p>只有类之间的继承关系，没有对象关联关系</p></li><li><p>模板方法：</p><p>定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。</p></li></ul><h3 id="优缺点-7">优缺点</h3><p>优点：</p><ol type="1"><li>在一个类中抽象地定义算法，而由它的子类实现细节的处理。</li><li>是代码复用的一项基本技术。</li><li>导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合开闭原则。</li></ol><p>缺点：</p><p>导致类的个数增加。</p><h3 id="适用环境-7">适用环境</h3><ol type="1"><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类。</li><li>对一些复杂的算法进行分割。</li><li>控制子类的扩展。</li></ol><h3 id="模式扩展-5">模式扩展</h3><h4 id="好莱坞原则">好莱坞原则</h4><p>子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，父类控制对子类的调用。</p><h4 id="钩子方法的使用">钩子方法的使用</h4><p>使得子类可以控制父类的行为。</p><ol type="1"><li><p>最简单的钩子方法就是空方法，也可以在钩子方法中定义一个默认的实现，如果子类不覆盖钩子方法，则执行父类的默认实现代码。</p></li><li><p>比较复杂一点的钩子方法可以对其他方法进行约束，这种钩子方法通常返回一个boolean类型，即返回true或false，用来判断是否执行某一个基本方法。</p></li></ol><h2 id="命令模式">8. 命令模式</h2><p>动机：对发送者和接收者完全解耦，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p><h3 id="概念-9">概念</h3><p>将请求封装为对象，从而使我们可用不同的请求对客户进行参数化。</p><ul><li><p>对请求排队或者记录请求日志，以及支持可撤销的操作。</p></li><li><p>包含如下角色：抽象命令类、具体命令类、调用者、接收者、客户类</p></li><li><p>本质：对命令进行封装，将发出命令的责任和执行命令的责任分割开。</p></li><li><p>允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口。</p></li><li><p>关键：引入了抽象命令接口，发送者针对抽象命令接口编程。</p></li></ul><h3 id="优缺点-8">优缺点</h3><p>优点：</p><ol type="1"><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的Undo和Redo。</li></ol><p>缺点：</p><p>可能会导致某些系统有过多的具体命令类。</p><h3 id="适用环境-8">适用环境</h3><ol type="1"><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销操作和恢复操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令。</li></ol><h2 id="中介者模式">9. 中介者模式</h2><p>动机：</p><p>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式。</p><h3 id="概念-10">概念</h3><p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><ul><li><p>Mediator Pattern</p></li><li><p>又称调停者模式</p></li><li><p>包含如下角色：抽象中介者、具体中介者、抽象同事类、具体同事类</p></li><li><p>职责：中转与协调</p></li></ul><h3 id="优缺点-9">优缺点</h3><p>优点：</p><ol type="1"><li>简化对象之间交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ol><p>缺点：</p><p>具体中介者类非常复杂，使得系统难以维护。</p><h3 id="适用环境-9">适用环境</h3><ol type="1"><li><p>系统中对象间存在复杂引用关系。</p></li><li><p>一个对象由于引用了其他很多对象并且直接和这些对象通信而难以复用。</p></li><li><p>通过一个中间类来封装多个类中的行为。</p></li></ol><h2 id="观察者模式">10. 观察者模式</h2><p>动机：</p><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系。</p><h3 id="概念-11">概念</h3><p>定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</p><ul><li><p>又称发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p></li><li><p>让主题和观察者之间松耦合。</p></li></ul><h3 id="优缺点-10">优缺点</h3><p>优点：</p><ol type="1"><li>实现表示层和数据逻辑层的分离。<ul><li>定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li></ul></li><li>在观察目标和观察者之间建立一个抽象的耦合。</li><li>支持广播通信。</li><li>符合开闭原则的要求。</li></ol><p>缺点：</p><ol type="1"><li>如果观察者太多，将所有的观察者都通知到会花费很多时间。</li><li>观察者和观察目标之间的循环依赖会导致系统崩溃。</li><li>没有相应的机制让观察者知道所观察的目标对象如何发生变化。</li></ol><h3 id="适用环境-10">适用环境</h3><ol type="1"><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li></ol><h2 id="状态模式">11. 状态模式</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的（stateful）对象。</p><h3 id="概念-12">概念</h3><p>一个对象在其内部状态改变时改变它的行为。</p><ul><li><p>包含角色：环境类、抽象状态类、具体状态类。</p></li><li><p>关键：引入抽象状态类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</p></li><li><p>环境类与抽象状态类：</p><ul><li><p>环境类：拥有状态的对象</p></li><li><p>环境类有时候可以充当状态管理器(StateManager)的角色，可以在环境类中对状态进行切换操作。</p></li><li><p>状态类的产生是由于环境类存在多个状态，并且</p><ul><li>这些状态经常需要切换， 在不同的状态下对象的行为不同</li></ul><p>因此将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为。</p></li></ul></li></ul><h3 id="优缺点-11">优缺点</h3><p>优点：</p><ol type="1"><li>封装了转换规则。</li><li>枚举可能的状态，可以方便地增加新的状态。</li><li>状态转换逻辑与状态对象合成一体。</li><li>让多个环境对象共享一个状态对象。</li></ol><p>缺点：</p><ol type="1"><li>增加系统类和对象的个数</li><li>使用不当将导致程序结构和代码的混乱。</li><li>对开闭原则的支持并不太好<ul><li>增加新的状态类需要修改那些负责状态转换的源代码。</li></ul></li></ol><h3 id="适用环境-11">适用环境</h3><ol type="1"><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句。</li></ol><h3 id="模式扩展-6">模式扩展</h3><ol type="1"><li>共享状态</li><li>简单状态模式（状态不变）</li><li>可切换状态的状态模式</li></ol><h2 id="策略模式">12. 策略模式</h2><h3 id="概念-13">概念</h3><p>一组各自封装的算法族，可以相互替换。策略让算法可以独立于使用它的用户而变化。</p><h3 id="适用环境-12">适用环境</h3><ol type="1"><li>当许多相关类仅在其行为上有所不同时。</li><li>算法的不同变体。</li><li>算法使用用户不应知道的数据。</li><li>一个类定义了许多行为，而这些行为在它的操作中表现为多个条件语句。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;天生我材必有用，千金散尽还复来。&lt;/p&gt;</summary>
    
    
    
    <category term="软件系统设计" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>软件系统设计_面向对象设计原则</title>
    <link href="http://example.com/2024/06/11/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2024/06/11/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2024-06-11T04:00:00.000Z</published>
    <updated>2024-06-23T08:37:17.503Z</updated>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="面向对象设计原则">面向对象设计原则</h1><p>需求：系统需要满足的目标</p><p>规约：系统的外部可观察到的行为</p><p>架构：</p><ul><li><p>系统一级的主要组成部分</p></li><li><p>各部分的交互方法</p></li><li><p>使用的技术</p></li></ul><p>设计：</p><ul><li>如何完成任务</li><li>需要写的代码<ul><li>可维护、可复用</li></ul></li></ul><p>面向对象软件设计：将实现的约束条件应用到面向对象分析所产生的概念模型的过程。</p><ul><li><p>用方法和属性来描述用于构成系统的类</p></li><li><p>添加不明显属于领域的类，比如接口</p></li><li><p>描述类是如何构成组件的</p></li></ul><p>难点：将一个系统分解成对象</p><h2 id="面向对象设计原则概述">0. 面向对象设计原则概述</h2><p>目标：提高软件的可维护性和可复用性</p><p>Robert C.Martin认为一个软件设计可维护性较低通常的4个原因：</p><ul><li><p>过于僵硬（Rigidity）</p></li><li><p>过于脆弱（Fragility）</p></li><li><p>复用率低（Immobility）</p></li><li><p>黏度过高（Viscosity）</p></li></ul><p>Peter Coad认为，一个好的系统设计具备的三个性质:</p><ul><li>可扩展性（Extensibility）</li><li>灵活性（Flexibility）</li><li>可插入性（Pluggability）</li></ul><p>软件的复用拥有众多优点，如可以提高软件的开发效率，提高软件质量，节约开发成本。</p><p>恰当的复用还可以改善系统的可维护性。</p><p>面向对象设计复用的目标在于实现支持可维护性的复用。</p><p>在面向对象的设计里面，可维护性复用都是以面向对象设计原则为基础的，这些设计原则首先都是复用的原则，遵循这些设计原则可以有效地提高系统的复用性，同时提高系统的可维护性。</p><p>面向对象设计原则也是对系统进行合理重构的指南针，重构是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。</p><p>常用的7个面向对象设计原则：</p><ul><li>单一职责原则</li><li>开闭原则</li><li>里氏代换原则</li><li>依赖倒转原则</li><li>接口隔离原则</li><li>合成复用原则</li><li>迪米特法则</li></ul><p>这些原则并不是孤立存在的，它们相互依赖，相互补充。</p><h2 id="单一职责原则">1. 单一职责原则</h2><p>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类里。</p><ul><li>对一个类而言，应该仅有一个引起它变化的原因。</li></ul><p>一个类承担的职责越多，它被复用的可能性越小。让一个类承担过多的职责相当于将这些职责耦合，当其中一个职责变化时，可能会影响其他职责的运作。</p><p>数据职责（属性）和行为职责（方法）。</p><h2 id="开闭原则">2. 开闭原则</h2><p>一个软件实体应当对扩展开放，对修改关闭。</p><ul><li><p>在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。</p></li><li><p>软件实体可以指一个软件模块，一个由多个类组成的局部结构或一个独立的类。</p></li></ul><p>抽象化是开闭原则的关键。</p><p>对可变性封装原则：找到系统的可变因素并将其封装起来。</p><h2 id="里氏代换原则">3. 里氏代换原则</h2><p>如果对每一个类型为<span class="math inline">\(S\)</span>的对象<spanclass="math inline">\(o_1\)</span>，都有类型为<spanclass="math inline">\(T\)</span>的对象<spanclass="math inline">\(o_2\)</span>，使得以<spanclass="math inline">\(T\)</span>定义的所有程序<spanclass="math inline">\(P\)</span>在所有的对象<spanclass="math inline">\(o_2\)</span>都代换成<spanclass="math inline">\(o_1\)</span>时，程序<spanclass="math inline">\(P\)</span>的行为没有变化，那么类型<spanclass="math inline">\(S\)</span>是类型<spanclass="math inline">\(T\)</span>的子类型。</p><ul><li>所有引用基类的地方必须能透明地使用其子类的对象。</li></ul><p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h2 id="依赖倒转原则">4. 依赖倒转原则</h2><p>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><ul><li><p>要针对接口编程，不要针对实现编程。</p></li><li><p>代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。</p></li></ul><p>如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。</p><p>依赖倒转原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件中。</p><p>类之间的耦合：</p><ul><li>零耦合关系</li><li>具体耦合关系</li><li>抽象耦合关系</li></ul><p>依赖倒转原则要求客户端依赖于抽象耦合，以抽象方式耦合是依赖倒转原则的关键。</p><h2 id="接口隔离原则">5. 接口隔离原则</h2><p>客户端不应该依赖那些它不需要的接口。</p><ul><li>一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。</li></ul><p>使用多个专门的接口，而不使用单一的总接口。每一个接口应该承担一种相对独立的角色。</p><p>使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</p><ul><li>只提供用户需要的行为，而隐藏用户不需要的行为。</li></ul><h2 id="合成复用原则">6. 合成复用原则</h2><p>尽量使用对象组合，而不是继承来达到复用的目的。</p><p>合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。</p><h2 id="迪米特法则">7. 迪米特法则</h2><p>也称最小知识原则。几种典型定义：</p><ol type="1"><li><p>不和“陌生人”说话。</p></li><li><p>只与你的直接朋友通信。</p></li><li><p>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p></li></ol><ul><li>一个软件实体应当尽可能少的与其他实体发生相互作用。</li></ul><p>对于一个对象，其朋友包括以下几类:</p><ul><li>当前对象本身</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ul><p>狭义迪米特法则：</p><p>如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p>广义的迪米特法则：</p><p>指对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制。</p><p>迪米特法则的主要用途在于控制信息的过载：</p><ol type="1"><li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及;</li><li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限;</li><li>在类的设计上，只要有可能，一个类型应当设计成不变类;</li><li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ol><h2 id="小结">8. 小结</h2><ol start="0" type="1"><li><p>对于面向对象的软件系统设计来说，在支持可维护性的同时，需要提高系统的可复用性。</p></li><li><p>软件的复用可以提高软件的开发效率，提高软件质量，节约开发成本，恰当的复用还可以改善系统的可维护性。</p></li><li><p>单一职责原则要求在软件系统中，一个类只负责一个功能领域中的相应职责。</p></li><li><p>开闭原则要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</p></li><li><p>里氏代换原则可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</p></li><li><p>依赖倒转原则要求抽象不应该依赖于细节，细节应该依赖于抽象;要针对接口编程，不要针对实现编程。</p></li><li><p>接口隔离原则要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</p></li><li><p>合成复用原则要求复用时尽量使用对象组合，而不使用继承。</p></li><li><p>迪米特法则要求一个软件实体应当尽可能少的与其他实体发生相互作用。</p></li></ol><p>目标：开闭原则</p><p>指导：最小知识原则</p><p>基础：单一职责原则、可变性封装原则</p><p>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;天生我材必有用，千金散尽还复来。&lt;/p&gt;</summary>
    
    
    
    <category term="软件系统设计" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程_4_内核驱动</title>
    <link href="http://example.com/2024/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E7%AB%A0%20%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"/>
    <id>http://example.com/2024/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E7%AB%A0%20%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/</id>
    <published>2024-05-04T04:00:00.000Z</published>
    <updated>2024-06-21T07:24:02.689Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第4章-内核驱动">第4章 内核驱动</h1><h2 id="什么是内核">0. 什么是内核？</h2><p>操作系统是一系列程序的集合，其中最重要的部分构成了内核。</p><p>单内核/微内核</p><ul><li>单内核是一个很大的进程，内部可以分为若干模块，运行时是一个独立的二进制文件，模块间通讯通过直接调用函数实现</li><li>微内核中大部分内核作为独立的进程在特权下运行，通过消息传递进行通讯</li></ul><p>Linux内核的能力</p><ul><li>内存管理，文件系统，进程管理，多线程支持，抢占式，多处理支持</li></ul><p>Linux内核区别于其他UNIX商业内核的优点</p><ul><li>单内核，模块支持</li><li>免费/开源</li><li>支持多种CPU，硬件支持能力非常强大</li><li>Linux开发者都是非常出色的程序员</li><li>通过学习Linux内核的源码可以了解现代操作系统的实现原理</li></ul><h3 id="配置内核">配置内核</h3><p>下载源码、解压、make clean、<strong>make menuconfig</strong></p><figure><img src="/image/Linux系统编程/menu.png" alt="menu" /><figcaption aria-hidden="true">menu</figcaption></figure><p>编译内核：</p><ul><li>make</li><li>make zImage、make bzImage：生成压缩内核镜像</li><li>make modules：编译模块</li></ul><p>make install：将编译好的内核copy到/boot</p><h2 id="驱动">1. 驱动</h2><p>许多常见驱动的源代码集成在内核源码里，也有第三方开发的驱动，可以单独编译成模块.ko。编译需要内核头文件的支持。</p><p>驱动运行在内核态。</p><h3 id="加载模块">加载模块</h3><p>底层命令：</p><p>insmod：<code>insmod [options] module_file</code></p><ul><li><code>-f</code>: 强制加载模块，即使模块已被其他进程使用。</li><li><code>-o</code>: 指定模块的参数。</li><li><code>-v</code>: 显示详细信息。</li></ul><p>rmmod：<code>rmmod [options] module_name</code></p><ul><li><code>-f</code>: 强制卸载模块，即使模块已被其他进程使用。</li><li><code>-s</code>: 模块卸载后，不更新/proc/modules文件。</li><li><code>-w</code>: 在卸载模块之前，等待其关闭所有文件描述符。</li></ul><p>高层命令：</p><p>modprobe：<code>modprobe [options] module_name</code></p><ul><li><code>-a</code>: 自动加载所有依赖的模块。</li><li><code>-c</code>: 从 /etc/modprobe.conf 中读取配置。</li><li><code>-d</code>: 检测模块依赖，但不加载它们。</li><li><code>-e</code>: 禁止使用某些内核特性（如 SMP）。</li><li><code>-k</code>: 保留内核符号表。</li><li><code>-l</code>: 列出可以加载的模块，而不实际加载它们。</li><li><code>-n</code>: 禁止自动插入已指定名字的模块。</li><li><code>-p</code>: 使用预设的模块参数。</li><li><code>-r</code>: 删除模块及其依赖的模块。</li><li><code>-s</code>: 使模块静默加载，不输出信息。</li><li><code>-v</code>: 输出更多的信息。</li></ul><p>模块依赖</p><p>自动按需加载/卸载</p><p>moddep：列出指定内核模块所依赖的其他模块</p><p>lsmod：列出当前内核加载的所有模块及其各种信息</p><p>modinfo：显示关于内核模块的详细信息</p><h3 id="模块编写">模块编写</h3><p>不能使用c库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/moduleparam.h&gt;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> test;<br><span class="hljs-built_in">module_param</span>(test, <span class="hljs-type">int</span>, <span class="hljs-number">0644</span>);<span class="hljs-comment">//module_param(变量名称，类型, 访问许可掩码)</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">hello_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(KERN_INFO “Hello world test=%d \n” , test);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">hello_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;Goodbye world\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-built_in">MODULE_DESCRIPTION</span>(<span class="hljs-string">&quot;Test&quot;</span>);<br><span class="hljs-built_in">MODULE_AUTHOR</span>(<span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-built_in">module_init</span>(hello_init);<br><span class="hljs-built_in">module_exit</span>(hello_exit);<br></code></pre></td></tr></table></figure><h4 id="导出符号">导出符号</h4><p>如果一个模块需要向其他模块导出符号（方法或全局变量），需要使用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">EXPORT_SYMBOL(<span class="hljs-params">name</span>)</span>;<br><span class="hljs-constructor">EXPORT_SYMBOL_GPL(<span class="hljs-params">name</span>)</span>;<br></code></pre></td></tr></table></figure><p>符号必须在模块文件的全局部分导出。</p><p>/proc/kallsyms 可以显示所有导出的符号。</p><h3 id="字符设备">字符设备</h3><h4 id="设备号">设备号</h4><p>一个字符设备或者块设备都有一个主设备号和次设备号。</p><ul><li>主设备号和次设备号统称为设备号。<ul><li>主设备号用来表示一个特定的驱动程序。</li><li>次设备号用来表示使用该驱动程序的各设备。</li></ul></li></ul><h4 id="cdev">cdev</h4><p>linux内核中使用cdev结构体来描述字符设备。该结构体是所有字符设备的抽象，其包含了大量字符设备所共有的特性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> cdev *my_cdev = cdev<span class="hljs-constructor">_alloc()</span>;<br>my_cdev-&gt;ops = &amp;my_fops;<br>void cdev<span class="hljs-constructor">_init(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">cdev</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file_operations</span> <span class="hljs-operator">*</span><span class="hljs-params">fops</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="初始化加载过程">初始化加载过程</h4><ol type="1"><li>申请设备号</li><li>定义文件操作结构体 file_operations</li><li>创建并初始化定义结构体 cdev</li><li>将cdev注册到系统，并和对应的设备号绑定</li><li>在/dev文件系统中用mknod创建设备文件，并将该文件绑定到设备号上</li></ol><p>申请释放设备号：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">first</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>;<br><span class="hljs-built_in">int</span> alloc<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">firstminor</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>;<br>void unregister<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">first</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span>;<br></code></pre></td></tr></table></figure><p>设备注册与释放</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> cdev<span class="hljs-constructor">_add(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">dev_t</span> <span class="hljs-params">num</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span>;<br>void cdev<span class="hljs-constructor">_del(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程_3_编程</title>
    <link href="http://example.com/2024/05/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0%20Linux%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/05/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0%20Linux%E7%BC%96%E7%A8%8B/</id>
    <published>2024-05-03T04:00:00.000Z</published>
    <updated>2024-06-21T07:23:49.037Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第3章-linux编程">第3章 Linux编程</h1><h2 id="编程前的准备">0. 编程前的准备</h2><h3 id="编译命令">0.1 编译命令</h3><p>gcc -c（编译）</p><p>gcc（链接 或者 编译 + 链接）</p><p>g++（C++对应的命令，其实就是换了前端）</p><p>gcc [options] [filename]</p><p>基础可选项:</p><ul><li>-E: 只对源程序进行预处理(调用cpp预处理器)</li><li>-S: 只对源程序进行预处理、编译</li><li>-c: 执行预处理、编译、汇编而不链接</li><li>-o output_file: 指定输出文件名</li><li>-g: 产生调试工具必需的符号信息</li><li>-O/On: 在程序编译、链接过程中进行优化处理</li><li>-Wall: 显示所有的警告信息</li><li>-Idir: 指定额外的头文件搜索路径</li><li>-Ldir: 指定额外的库文件搜索路径</li><li>-lname: 链接时搜索指定的库文件</li><li>-DMACRO[=DEFN]: 定义MACRO宏</li></ul><h3 id="make">0.2 make</h3><p>make [-f Makefile] [option] [target]</p><p>makefile描述模块间的依赖关系，make命令根据makefile对程序进行管理和维护；make判断被维护文件的时序关系。</p><h4 id="make执行顺序">make执行顺序</h4><ol type="1"><li>make会在当前目录下找名字叫“Makefile” 或“makefile” 的文件。</li><li>查找文件中的第一个目标文件（target），举例中的hello</li><li>如果hello文件不存在，或是hello所依赖的文件修改时间要比hello新，就会执行后面所定义的命令来生成hello文件。</li><li>如果hello所依赖的.o文件不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（类似一个堆栈的过程）</li><li>make根据.o文件的规则生成 .o 文件，然后再用 .o文件生成hello文件。</li></ol><h4 id="makefile规则结构">Makefile规则结构</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">target <span class="hljs-string">...</span> : prerequisites <span class="hljs-string">...</span><br><span class="hljs-keyword">command</span>```<br></code></pre></td></tr></table></figure><ul><li>target是一个目标文件，可以是Object File，也可以是执行文件</li><li>prerequisites是要生成target所需要的文件或是目标</li><li>command是make需要执行的命令。（可以是任意的Shell命令）</li></ul><p>例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hello : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span><br>gcc -o hello <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span><br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs<span class="hljs-selector-class">.h</span><br>cc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br><span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.c</span> defs<span class="hljs-selector-class">.h</span> command<span class="hljs-selector-class">.h</span><br>cc -c <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.c</span><br>clean :<br>rm edit <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span>.o<br></code></pre></td></tr></table></figure><p>伪目标：clean</p><p>取名不能和文件名重名，可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”。</p><ul><li><p>一般没有依赖的文件，但也可以为伪目标指定所依赖的文件。</p></li><li><p>伪目标同样可以作为“默认目标”，只要将其放在第一个。</p></li></ul><h4 id="预定义变量">预定义变量</h4><ul><li>$&lt; 第一个依赖文件的名称</li><li>$?所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚</li><li>$+所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件</li><li>$^ 所有的依赖文件，以空格分开，不包含重复的依赖文件</li><li>$* 不包括扩展名的目标文件名称</li><li>$@ 目标的完整名称</li><li>$% 如果目标是归档成员，则该变量表示目标的归档成员名称</li></ul><h4 id="多目标扩展">多目标扩展</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">targets</span> <span class="hljs-attr">...</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">target-pattern</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">prereq-patterns</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">commands</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = foo.o bar.o<br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br><span class="hljs-variable">$(objects)</span>: %.o: %.c<br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><ul><li>目标从$object中获取</li><li>“%.o”表明要所有以“.o”结尾的目标，即“foo.obar.o”，就是变量$object集合的模式</li><li>依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是依赖的目标就是“foo.c bar.c”</li></ul><h4 id="函数">函数</h4><p>调用语法：</p><ul><li><p><code>$(&lt;function&gt; &lt;arguments&gt;)</code></p></li><li><p><code>$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</code></p></li><li><p>字符串处理函数</p><ul><li><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></li><li><code>$(strip &lt;string&gt;)</code></li></ul></li><li><p>文件名操作函数</p><ul><li><code>$(dir &lt;names...&gt;)</code></li><li><code>$(basename &lt;names...&gt;)</code></li></ul></li><li><p>foreach函数：<code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></p></li><li><p>if函数：<code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code></p></li><li><p>call函数：<code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code></p></li></ul><h2 id="文件系统">1. 文件系统</h2><p>文件：可以被读写的对象。</p><ul><li>文件的属性包含访问权限、文件类型。</li></ul><p>文件系统：文件及其属性的集合。</p><h3 id="文件类型和结构">1.1 文件类型和结构</h3><p>文件类型：</p><ul><li>-：常规文件</li><li>d：目录</li><li>l：链接</li><li>c：字符设备文件</li><li>b：块设备文件</li><li>p：管道</li><li>s：套接字</li></ul><p>文件结构：字节流</p><h3 id="vfsvirtual-file-system-switch">1.2 VFS：Virtual File SystemSwitch</h3><p>用户程序系统调用的统一接口，连接Ext2、FAT等多种不同的文件系统。</p><p>虚拟、只存在于内存。</p><p>组件：</p><ul><li>超级块：文件系统的元数据，它包含了文件系统的全局信息，如块大小、inode和数据块的数量、分配策略等。</li><li>i-node：文件的元数据，如文件的大小、创建时间、最后访问时间、最后修改时间、文件权限等，但不包括文件名和文件数据本身。</li><li>文件：打开的文件，包含了读写文件的当前位置、文件的状态等。</li><li>dentry：文件系统中的一个目录入口，即一个路径名与一个i-node的映射。</li></ul><h3 id="硬链接和符号链接">1.3 硬链接和符号链接</h3><p>硬链接：</p><ul><li>不同的文件名对应同一个inode</li><li>不能跨越文件系统</li><li>对应系统调用link</li></ul><p>符号链接</p><ul><li>存储被链接文件的文件名(而不是inode)实现链接</li><li>可跨越文件系统</li><li>对应系统调用symlink</li></ul><h3 id="系统调用和库函数">1.4 系统调用和库函数</h3><p>都是C函数。</p><p>系统调用：Linux内核的对外接口；用户程序和内核之间唯一的接口。</p><p>库函数：依赖于系统调用，提供较复杂功能。</p><h4 id="基础io系统调用">基础I/O系统调用</h4><ul><li>文件描述符：非负整数<ul><li>STDIN_FILENO (0)、STDOUT_FILENO (1)、STDERR_FILENO (2)</li></ul></li><li>基础I/O函数<ul><li>open/creat、close、read、write、lseek</li><li>dup/dup2</li><li>fcntl</li><li>ioctl</li></ul></li></ul><h5 id="opencreat">open/creat</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br>(Return: a <span class="hljs-keyword">new</span> file descriptor <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>flags：文件访问模式。</p><ul><li>O_RDONLY：只读</li><li>O_WRONLY：只写</li><li>O_RDWR：读写</li><li>O_APPEND：追加</li><li>O_TRUNC：如果文件存在，截断到0字节</li><li>O_CREAT：文件不存在则创建</li><li>O_EXCL：与 <code>O_CREAT</code>标志结合使用。如果文件已存在则报错。</li></ul><p>mode：八进制数，文件权限。</p><figure><img src="/image/Linux系统编程/权限.png" alt="权限" /><figcaption aria-hidden="true">权限</figcaption></figure><p>umask：一个环境变量，决定了文件创建时的权限掩码。</p><ul><li>mode &amp; ~umask，得到最终创建的文件权限。</li></ul><h5 id="close">close</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h5 id="readwrite">read/write</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br>(返回值: 读到的字节数，若已到文件尾为<span class="hljs-number">0</span>，若出错为<span class="hljs-number">-1</span>)<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br>(返回值: 若成功为已写的字节数，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h5 id="lseek">lseek</h5><p>改变文件读写位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br>(Return: the resulting offset location <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>whence（出发点）：</p><ul><li>SEEK_SET</li><li>SEEK_CUR</li><li>SEEK_END</li></ul><h5 id="dupdup2">dup/dup2</h5><p>复制文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span></span>;<br>(Return: the <span class="hljs-keyword">new</span> file descriptor <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h5 id="fcntl">fcntl</h5><p>管理文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">long</span> arg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> flock *lock)</span></span>;<br>(返回值: 若成功则依赖于cmd，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><p>cmd：</p><ul><li>F_DUPFD：复制文件描述符</li><li>F_GETFD/F_SETFD：获取设置文件描述符控制标志</li><li>F_GETFL/F_SETFL：获取设置文件描述符状态标志</li><li>F_GETOWN/F_SETOWN：获取设置I/O可用性标志</li><li>F_GETLK/F_SETLK/F_SETLKW：获取设置文件锁</li></ul><h5 id="ioctl">ioctl</h5><p>控制设备。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> request, ...)</span></span>;<br></code></pre></td></tr></table></figure><p>重定向用到了哪些系统调用？</p><h4 id="标准io库">标准I/O库</h4><p>主要考察缓冲。</p><p>文件流</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs julia">FILE* fp;<br>// <span class="hljs-literal">stdin</span> <span class="hljs-literal">stdout</span> <span class="hljs-literal">stderr</span><br></code></pre></td></tr></table></figure><p>三种缓冲：</p><ul><li>块缓冲</li><li>线性缓冲</li><li>无缓冲</li></ul><p>setbuf、setvbuf</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setvbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> mode, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>mode：_IOFBF（满缓冲）、_IOLBF（行缓冲）、_IONBF（无缓冲）</p><p>流式I/O函数：</p><ul><li><p>open/close</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fclose</span><span class="hljs-params">(FILE *stream)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>mode：r w a r+(读写) w+(读写，无则新建，有则清空)a+(读与追加，无则新建)</p></li><li><p>read/write</p><ul><li><p>每次一个字符的I/O</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getc</span>(<span class="hljs-params">FILE *fp</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fgetc</span>(<span class="hljs-params">FILE *fp</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getchar</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span>;<br>（Result: Reads the next character <span class="hljs-keyword">from</span> a stream <span class="hljs-keyword">and</span> returns it <span class="hljs-keyword">as</span> an unsigned <span class="hljs-built_in">char</span> cast to an <span class="hljs-built_in">int</span>, <span class="hljs-keyword">or</span> EOF <span class="hljs-keyword">on</span> end of file <span class="hljs-keyword">or</span> error.）<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">ungetc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> c, FILE *stream</span>)</span>; <span class="hljs-comment">// 将字符插回流中</span><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> putc(<span class="hljs-built_in">int</span> c, <span class="hljs-keyword">FILE</span> *fp);<br><span class="hljs-built_in">int</span> fputc(<span class="hljs-built_in">int</span> c, <span class="hljs-keyword">FILE</span> *fp);<br><span class="hljs-built_in">int</span> putchar(<span class="hljs-built_in">int</span> c);<br>(<span class="hljs-keyword">Return</span>: the <span class="hljs-keyword">character</span> <span class="hljs-keyword">if</span> success; -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure></li><li><p>每次一行的I/O</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span>; <span class="hljs-comment">//not recommended.</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>直接I/O(二进制I/O)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span></span>;<br>(Return: the number of a items successfully read <span class="hljs-keyword">or</span> written.)<br></code></pre></td></tr></table></figure></li><li><p>格式化I/O</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">scanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sscanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>reposition</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">ftell</span><span class="hljs-params">(FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rewind</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fgetpos</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">fpos_t</span> *pos)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fsetpos</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">fpos_t</span> *pos)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>flush</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fflush</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>流与文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fileno</span><span class="hljs-params">(FILE *fp)</span></span>;<br><span class="hljs-function">FILE *<span class="hljs-title">fdopen</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>临时文件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">char *<span class="hljs-built_in">tmpnam</span>(char *s);<br>(返回值: 指向唯一路径名的指针)<br>FILE *<span class="hljs-built_in">tmpfile</span>(void);<br>(返回值: 若成功为文件指针，若出错为NULL)<br></code></pre></td></tr></table></figure></li></ul><h4 id="高级系统调用">高级系统调用</h4><p>stat、fstat：返回文件状态信息，存储在buf中</p><p>lstat：获取符号链接本身的状态信息，存储在buf中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> filedes, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> &#123;<br><span class="hljs-type">mode_t</span> st_mode; <span class="hljs-comment">/*file type &amp; mode*/</span><br><span class="hljs-type">ino_t</span> st_ino; <span class="hljs-comment">/*inode number (serial number)*/</span><br><span class="hljs-type">dev_t</span> st_rdev; <span class="hljs-comment">/*device number (file system)*/</span><br><span class="hljs-type">nlink_t</span> st_nlink; <span class="hljs-comment">/*link count*/</span><br><span class="hljs-type">uid_t</span> st_uid; <span class="hljs-comment">/*user ID of owner*/</span><br><span class="hljs-type">gid_t</span> st_gid; <span class="hljs-comment">/*group ID of owner*/</span><br><span class="hljs-type">off_t</span> st_size; <span class="hljs-comment">/*size of file, in bytes*/</span><br><span class="hljs-type">time_t</span> st_atime; <span class="hljs-comment">/*time of last access*/</span><br><span class="hljs-type">time_t</span> st_mtime; <span class="hljs-comment">/*time of last modification*/</span><br><span class="hljs-type">time_t</span> st_ctime; <span class="hljs-comment">/*time of last file status change*/</span><br><span class="hljs-type">long</span> st_blksize; <span class="hljs-comment">/*Optimal block size for I/O*/</span><br><span class="hljs-type">long</span> st_blocks; <span class="hljs-comment">/*number 512-byte blocks allocated*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>测试文件类型：sys/stat.h</p><ul><li>S_ISREG()</li><li>S_ISDIR()</li><li>S_ISCHAR()</li><li>S_ISBLK()</li><li>S_ISFIFO()</li><li>S_ISLNK()</li><li>S_ISSOCK()</li></ul><p>文件权限</p><ul><li><p>rwx</p></li><li><p>SUID：需要有效uid</p></li><li><p>SGID：需要有效gid</p></li><li><p>Sticky bit：只有owner</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchmod</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">mode_t</span> mode)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchown</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lchown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">mode_t</span> <span class="hljs-title">umask</span><span class="hljs-params">(<span class="hljs-type">mode_t</span> mask)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">symlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">readlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> bufsiz)</span></span>;<br>(Return: the count of characters placed in the buffer <span class="hljs-keyword">if</span> success;<span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>目录</p><ul><li>mkdir/rmdir</li><li>chdir/fchdir, getcwd</li><li>读取目录：DIR数据结构<ul><li>opendir/closedir</li><li>readdir</li><li>telldir</li><li>seekdir</li></ul></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rmdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchdir</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dir)</span></span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *<span class="hljs-built_in">readdir</span>(DIR *dir);<br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">telldir</span><span class="hljs-params">(DIR *dir)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seekdir</span><span class="hljs-params">(DIR *dir, <span class="hljs-type">off_t</span> offset)</span></span>;<br></code></pre></td></tr></table></figure><p>文件锁 important</p><ul><li><p>记录锁</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fcntl</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> fd, <span class="hljs-built_in">int</span> cmd, <span class="hljs-keyword">struct</span> flock *<span class="hljs-keyword">lock</span></span>)</span>;<br>(返回值: 若成功则依赖于cmd，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure></li><li><p>劝告锁</p><ul><li>检查，加锁有应用程序自己控制</li></ul></li><li><p>强制锁</p><ul><li>检查，加锁由内核控制</li><li>影响[open() read() write()]等</li></ul></li><li><p>共享锁</p></li><li><p>排他锁</p></li><li><p>共享模式强制锁</p></li><li><p>租借锁</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">flock</span>&#123;<br>...<br><span class="hljs-type">short</span> l_type; <span class="hljs-comment">/* Type of lock: F_RDLCK, F_WRLCK, F_UNLCK */</span><br><span class="hljs-type">short</span> l_whence; <span class="hljs-comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR,</span><br><span class="hljs-comment">SEEK_END */</span><br><span class="hljs-type">off_t</span> l_start; <span class="hljs-comment">/* Starting offset for lock */</span><br><span class="hljs-type">off_t</span> l_len; <span class="hljs-comment">/* Number of bytes to lock */</span><br><span class="hljs-type">pid_t</span> l_pid; <span class="hljs-comment">/* PID of process blocking our lock (F_GETLK only) */</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>cmd</p><ul><li>F_GETLK：获得文件的封锁信息</li><li>F_SETLK：对文件的某个区域封锁或解除封锁</li><li>F_SETLKW：功能同F_SETLK，wait方式。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/file.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lockf</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">off_t</span> len)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="多核编程">2. 多核编程</h2><h3 id="exec">exec</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>execl</code>、<code>execlp</code>和<code>execle</code>：可变参数为逐个列举。<code>execl</code>和<code>execle</code>带有环境变量，而<code>execlp</code>不带环境变量。实际上会调用对应的v系列函数。</p></li><li><p><code>execv</code>、<code>execvp</code>和<code>execve</code>：可变参数为NULL结尾的指针数组。<code>execv</code>和<code>execvp</code>不带环境变量，而<code>execve</code>可以传递环境变量。前两者最终会调用execve函数。</p></li></ul><h3 id="fork">fork</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)<br>&#123;子进程执行的代码段；&#125;<br><span class="hljs-keyword">else</span><br>&#123;父进程执行的代码段；&#125;<br></code></pre></td></tr></table></figure><h3 id="wait-waitpid">wait &amp; waitpid</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *status)</span></span>;<br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *status, <span class="hljs-type">int</span> options)</span></span>;<br></code></pre></td></tr></table></figure><p>wait：调用wait函数的进程会被挂起，等待任意一个子进程结束，如果该子进程结束了，此函数会回收子进程的资源。</p><ul><li>如果成功，wait会返回被收集的子进程的进程ID；</li><li>如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。</li></ul><p>waitpid：回收指定进程号的子进程，可以设置是否阻塞。</p><ul><li><p>pid=0，等待任意子进程。</p></li><li><p>pid=-1，回收所有子进程。</p></li><li><p>pid&lt;-1，其绝对值为某个进程组的组id，回收该进程组的所有进程。</p></li><li><p>status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。</p></li><li><p>options：WNOHANG，非阻塞。</p></li></ul><ol type="1"><li><p>当正常返回的时候，waitpid返回收集到的子进程的进程ID；</p></li><li><p>如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0；　　</p></li><li><p>如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在；</p><p>当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD。</p></li></ol><h3 id="signal">Signal</h3><p>信号处理</p><ul><li><p>忽略信号</p></li><li><p>不能忽略的信号： SIGKILL, SIGSTOP、一些硬件异常信号</p></li><li><p>执行系统默认动作</p></li><li><p>捕捉信号</p></li></ul><p>signal函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span></span>;<br>(Returned Value: the previous handler <span class="hljs-keyword">if</span> success, SIG_ERR <span class="hljs-keyword">if</span> error)<br></code></pre></td></tr></table></figure><p>handler为用户定义的函数。</p><h4 id="kill和raise">kill和raise</h4><p>kill向进程发送信号，raise向当前进程发送信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span></span>;<br>(Returned Value: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success, <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>;<br>(Returned Value: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success, <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h4 id="alarm和pause">alarm和pause</h4><p>alarm：一定时间后发送SIGALRM信号。</p><p>pause：挂起等待信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pause</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>组合两者可以让进程等待一段时间后执行。</p><h4 id="可靠信号机制">可靠信号机制</h4><h3 id="可重入函数">可重入函数</h3><p>可以被中断的函数。</p><p>不可重入函数：</p><ul><li>系统资源</li><li>全局变量</li><li>使用静态数据结构</li><li>malloc、free</li><li>标准IO函数</li></ul><h3 id="posix-thread">POSIX Thread</h3><p>编译：gcc thread.c –o thread –lpthread</p><h4 id="创建和终止">创建和终止</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_t</span> *thread,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_attr_t</span> *attr,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> *arg)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="等待和分离">等待和分离</h4><p>Joinable Thread：可连接线程</p><ul><li>可以被其他线程等待（join）的线程。</li></ul><p>Detached Thread：分离线程</p><ul><li>启动后独立运行的线程。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;pthread.h&gt;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_join(<span class="hljs-params">pthread_t</span> <span class="hljs-params">th</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">thread_return</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_detach(<span class="hljs-params">pthread_t</span> <span class="hljs-params">th</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="线程同步">线程同步</h4><h5 id="信号量">信号量</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_init(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-params">pshared</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">value</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_wait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_post(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_destroy(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_trywait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_getvalue(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">sval</span>)</span>;<br></code></pre></td></tr></table></figure><p>生产者-消费者问题：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/wait.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;fcntl.h&gt;</span><br><span class="hljs-comment">#include &lt;semaphore.h&gt;</span><br><br><span class="hljs-comment">#define BUFFER_SIZE 10</span><br><span class="hljs-comment">#define PRODUCER_COUNT 3</span><br><span class="hljs-comment">#define CONSUMER_COUNT 2</span><br><br>sem_t empty, full, mutex;<br>int buffer[BUFFER_SIZE];<br>int <span class="hljs-keyword">in</span> = <span class="hljs-number">0</span>;<br>int out = <span class="hljs-number">0</span>;<br><br>void produce(int index) &#123;<br>    sem_wait(&amp;empty);<br>    sem_wait(&amp;mutex);<br><br>    printf(<span class="hljs-string">&quot;生产者%d生产了一个产品\n&quot;</span>, index);<br>    buffer[<span class="hljs-keyword">in</span>] = index;<br>    <span class="hljs-keyword">in</span> = (<span class="hljs-keyword">in</span> + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br><br>    sem_post(&amp;mutex);<br>    sem_post(&amp;full);<br>&#125;<br><br>void consume(int index) &#123;<br>    sem_wait(&amp;full);<br>    sem_wait(&amp;mutex);<br><br>    printf(<span class="hljs-string">&quot;消费者%d消费了一个产品\n&quot;</span>, index);<br>    buffer[out] = -<span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 或者可以用某种方式标记为已消费<br>    out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br><br>    sem_post(&amp;mutex);<br>    sem_post(&amp;empty);<br>&#125;<br><br>int main() &#123;<br>    <span class="hljs-regexp">//</span> 初始化信号量<br>    <span class="hljs-keyword">if</span> (sem_init(&amp;empty, <span class="hljs-number">1</span>, BUFFER_SIZE) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sem_init(&amp;full, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sem_init(&amp;mutex, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    pid_t pid;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; PRODUCER_COUNT; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 子进程，生产者<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                produce(i);<br>                sleep(rand() % <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 随机睡眠以模拟不同生产者生产速度<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; CONSUMER_COUNT; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 子进程，消费者<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                consume(i);<br>                sleep(rand() % <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 随机睡眠以模拟不同消费者消费速度<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 等待所有生产者和消费者结束<br>    <span class="hljs-keyword">while</span> (wait(NULL) &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-regexp">//</span> 销毁信号量<br>    sem_destroy(&amp;empty);<br>    sem_destroy(&amp;full);<br>    sem_destroy(&amp;mutex);<br><br>    <span class="hljs-keyword">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="互斥量">互斥量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex, <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *mutexattr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><br><span class="hljs-type">int</span> buffer[BUFFER_SIZE];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> out = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 互斥量初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex, empty, full;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        <span class="hljs-keyword">while</span> (in == BUFFER_SIZE) &#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>); <span class="hljs-comment">// 生产者等待</span><br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        &#125;<br><br>        <span class="hljs-comment">// 生产产品</span><br>        buffer[in] = *(<span class="hljs-type">int</span>*)arg;<br>        in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产了产品 %d\n&quot;</span>, *(<span class="hljs-type">int</span>*)arg);<br><br>        <span class="hljs-comment">// 通知消费者有新产品</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        full++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有产品</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        <span class="hljs-keyword">while</span> (out == in) &#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>); <span class="hljs-comment">// 消费者等待</span><br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        &#125;<br><br>        <span class="hljs-comment">// 消费产品</span><br>        <span class="hljs-type">int</span> product = buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费了产品 %d\n&quot;</span>, product);<br><br>        <span class="hljs-comment">// 通知生产者有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        empty++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; mutex init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;empty, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; empty init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;full, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; full init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_t</span> pid, cid;<br>    <span class="hljs-type">int</span> producer_arg = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> consumer_arg = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建生产者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, producer, &amp;producer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建消费者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;cid, <span class="hljs-literal">NULL</span>, consumer, &amp;consumer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(cid, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 销毁互斥量</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;empty);<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;full);<br></code></pre></td></tr></table></figure><h5 id="条件变量">条件变量</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_init(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>, <span class="hljs-params">pthread_condattr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond_attr</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_destory(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_wait(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>, <span class="hljs-params">pthread_mutex_t</span> <span class="hljs-params">mutex</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_signal(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-params">cond</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_broadcast(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-params">cond</span>)</span>;<br></code></pre></td></tr></table></figure><p>条件变量使用：与互斥量结合</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><br><span class="hljs-type">int</span> buffer[BUFFER_SIZE];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> out = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 互斥量初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-comment">// 条件变量初始化</span><br><span class="hljs-type">pthread_cond_t</span> empty, full;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">while</span> (in == BUFFER_SIZE) &#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;empty, &amp;mutex);<br>        &#125;<br><br>        <span class="hljs-comment">// 生产产品</span><br>        buffer[in] = *(<span class="hljs-type">int</span>*)arg;<br>        in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产了产品 %d\n&quot;</span>, *(<span class="hljs-type">int</span>*)arg);<br><br>        <span class="hljs-comment">// 通知消费者有新产品</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;full);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有产品</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">while</span> (out == in) &#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;full, &amp;mutex);<br>        &#125;<br><br>        <span class="hljs-comment">// 消费产品</span><br>        <span class="hljs-type">int</span> product = buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费了产品 %d\n&quot;</span>, product);<br><br>        <span class="hljs-comment">// 通知生产者有空余位置</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;empty);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; mutex init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化条件变量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_cond_init</span>(&amp;empty, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; empty init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_cond_init</span>(&amp;full, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; full init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_t</span> pid, cid;<br>    <span class="hljs-type">int</span> producer_arg = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> consumer_arg = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建生产者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, producer, &amp;producer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建消费者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;cid, <span class="hljs-literal">NULL</span>, consumer, &amp;consumer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(cid, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 销毁互斥量</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;empty);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;full);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程取消">线程取消</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cancel(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcancelstate(<span class="hljs-params">int</span> <span class="hljs-params">state</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldstate</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcanceltype(<span class="hljs-params">int</span> <span class="hljs-params">type</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldtype</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="线程局部存储-tls">线程局部存储 TLS</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_key_create(<span class="hljs-params">pthread_key_t</span> <span class="hljs-operator">*</span><span class="hljs-params">key</span>, <span class="hljs-params">void</span> (<span class="hljs-operator">*</span><span class="hljs-params">destructor</span>)</span>(void*));<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_key_delete(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>)</span>;<br>void *pthread<span class="hljs-constructor">_getspecific(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setspecific(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>, <span class="hljs-params">const</span> <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">value</span>)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程_2_Shell</title>
    <link href="http://example.com/2024/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E7%AB%A0%20Shell%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E7%AB%A0%20Shell%E7%BC%96%E7%A8%8B/</id>
    <published>2024-05-02T04:00:00.000Z</published>
    <updated>2024-06-21T07:23:33.201Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第2章-shell编程">第2章 Shell编程</h1><p>Shell：指令解释器和编程环境。</p><p>用户和操作系统之间的接口，作为核外程序存在。</p><p>Shell的双重角色：</p><ul><li>命令解释程序<ul><li>Linux的开机启动过程；进程树</li><li>Shell的工作步骤</li><li>打印提示符；得到命令行；解析命令；查找文件；准备参数；执行命令</li></ul></li><li>独立的程序设计语言解释器</li></ul><p>Shell列举：ash、bsh、bash、sh、csh、zsh</p><h2 id="脚本文件">脚本文件</h2><p>注释：#</p><p>退出码：</p><ul><li>0：正常返回</li><li>1~128：错误码</li><li>129+：信号量</li></ul><h3 id="执行脚本文件">执行脚本文件</h3><ol type="1"><li><p>$ sh script_file</p></li><li><p>chmod +x script_file</p><p>./script_file</p></li><li><p>source script_file或 . script_file</p></li></ol><h3 id="用户环境">用户环境</h3><ol type="1"><li>.bash_profile，.bash_logout，.bashrc<ul><li>.bash_profile：用户登录时被读取，其中命令被bash执行</li><li>.bashrc：启动一个新的shell时被读取并执行</li><li>.bash_logout：登录退出时读取执行</li></ul></li><li>Alias：alias/unalias</li><li>环境变量<ul><li>export/env/set</li></ul></li></ol><h3 id="变量">变量</h3><ul><li>用户变量</li><li>环境变量</li><li>参数变量和内部变量</li></ul><h4 id="用户变量">用户变量</h4><p>用户在shell脚本里定义的变量。</p><ul><li><p>变量的赋值与使用：var=value echo $var</p></li><li><p>read命令：read var（读取用户输入并赋值给var）</p><ul><li>-p：在提示符后添加文本</li><li>-s：不显示用户输入</li><li>-r：用户输入不能修改</li><li>-n[字符数]：指定读取字符数，例如-n1</li></ul></li><li><p>引号</p><ul><li>单引号内的所有字符保持本身字符的意思，不被bash解释</li><li>除了$、``（不是单引号）、，双引号内的所有字符将保持字符本身含义，不被bash解释</li></ul></li></ul><h4 id="环境变量">环境变量</h4><p>Shell环境提供的变量，通常使用大写字母做名称。</p><table><thead><tr class="header"><th>环境变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$HOME</td><td>当前用户登录目录</td></tr><tr class="even"><td>$PATH</td><td>以冒号分隔的用来搜索命令的目录清单</td></tr><tr class="odd"><td><span class="math inline">\(PS1 |命令行提示符，通常是”\)</span>”字符</td><td></td></tr><tr class="even"><td>$PS2</td><td>辅助提示符，用来提示后续输入，通常是”&gt;”字符</td></tr><tr class="odd"><td>$IFS</td><td>输入区分隔符。当shell读取输入数据时会把一组字符看成是单词之间的分隔符，通常是空格、制表符、换行符等。</td></tr></tbody></table><h4 id="参数变量和内部变量">参数变量和内部变量</h4><p>调用脚本程序时如果带有参数，对应的参数和额外产生的一些变量。</p><table><thead><tr class="header"><th>环境变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$#</td><td>传递到脚本程序的参数个数</td></tr><tr class="even"><td>$0</td><td>脚本程序的名字</td></tr><tr class="odd"><td>$1</td><td>脚本程序的参数</td></tr><tr class="even"><td>$*</td><td>一个全体参数组成的清单，它是一个独立的变量，各个参数之间用环境变量IFS中的第一个字符分隔开</td></tr><tr class="odd"><td><span class="math inline">\(@ |“\)</span>*”的一种变体，它不使用IFS环境变量。</td><td></td></tr></tbody></table><h3 id="条件测试">条件测试</h3><p>test expression 或 [ expression ]</p><ul><li>字符串比较</li><li>算术比较</li><li>文件相关测试</li><li>逻辑操作</li></ul><table><thead><tr class="header"><th>字符串比较</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>str1 = str2</td><td>相同则为真</td></tr><tr class="even"><td>str1!=str2</td><td>不同则为真</td></tr><tr class="odd"><td>-z str</td><td>字符串为空则结果为真</td></tr><tr class="even"><td>-n str</td><td>字符串不为空则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>算术比较</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>expr1 –eq expr2</td><td>两个表达式相等则结果为真</td></tr><tr class="even"><td>expr1 –ne expr2</td><td>两个表达式不等则结果为真</td></tr><tr class="odd"><td>expr1 –gt expr2</td><td>expr1 大于 expr2 则结果为真</td></tr><tr class="even"><td>expr1 –ge expr2</td><td>expr1 大于或等于 expr2 则结果为真</td></tr><tr class="odd"><td>expr1 –lt expr2</td><td>expr1 小于 expr2 则结果为真</td></tr><tr class="even"><td>expr1 –le expr2</td><td>expr1 小于或等于 expr2 则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>文件条件测试</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>-e file</td><td>文件存在则结果为真</td></tr><tr class="even"><td>-d file</td><td>文件是一个子目录则结果为真</td></tr><tr class="odd"><td>-f file</td><td>文件是一个普通文件则结果为真</td></tr><tr class="even"><td>-s file</td><td>文件的长度不为零则结果为真</td></tr><tr class="odd"><td>-r file</td><td>文件可读则结果为真</td></tr><tr class="even"><td>-w file</td><td>文件可写则结果为真</td></tr><tr class="odd"><td>-x file</td><td>文件可执行则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>逻辑操作</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>! expr</td><td>逻辑表达式求反</td></tr><tr class="even"><td>expr1 –a expr2</td><td>两个逻辑表达式“And”（“与”）</td></tr><tr class="odd"><td>expr1 –o expr2</td><td>两个逻辑表达式“Or”（“或”）</td></tr></tbody></table><h3 id="条件语句">条件语句</h3><h4 id="if语句">if语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ expression ]<br><span class="hljs-keyword">then</span><br>statements<br><span class="hljs-keyword">elif</span> [ expression ]<br><span class="hljs-keyword">then</span><br>statements<br><span class="hljs-keyword">elif</span> …<br><span class="hljs-keyword">else</span><br>statements<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h4 id="case语句">case语句</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">case</span> str <span class="hljs-built_in">in</span><br>str1 | <span class="hljs-type">str2</span>) statements;;<br>str3 | <span class="hljs-type">str4</span>) statements;;<br>*) statements;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="重复语句">重复语句</h3><h4 id="for语句">for语句</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">in</span> list<br><span class="hljs-keyword">do</span><br>statements<br>done<br></code></pre></td></tr></table></figure><h4 id="while语句">while语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span><br>statements<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="until语句">until语句</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">until</span> condition<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">statements</span><br>done<br></code></pre></td></tr></table></figure><h4 id="select语句">select语句</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">select</span> item in itemlist<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">statements</span><br>done<br></code></pre></td></tr></table></figure><p>生成菜单列表</p><h3 id="命令表">命令表</h3><p>命令的组合。</p><ul><li><p>分号串联：command1 ; command2 ; …</p></li><li><p>条件组合，AND和OR：</p><p><code>statement1 &amp;&amp; statement2 &amp;&amp; …</code>和<code>statement1 || statement2 || …</code></p></li></ul><h3 id="语句块">语句块</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&#123;<br>stateme<span class="hljs-symbol">nt1</span><br>stateme<span class="hljs-symbol">nt2</span><br>…<br>&#125;<br>&#123; stateme<span class="hljs-symbol">nt1</span>; stateme<span class="hljs-symbol">nt2</span> ; … ; &#125;<br></code></pre></td></tr></table></figure><h3 id="函数">函数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">func</span><span class="hljs-params">()</span></span><br>&#123;<br>statements<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量：local关键字</p><p>函数调用：func para1 para2 ...</p><p>返回值：return</p><h3 id="杂项命令">杂项命令</h3><ul><li>break：从for/while/until循环退出</li><li>continue：跳到下一个循环继续执行</li><li>exit n：以退出码”n”退出脚本运行</li><li>return：函数返回</li><li>export：将变量导出到shell，使之成为shell的环境变量</li><li>set：为shell设置参数变量</li><li>unset：从环境中删除变量或函数</li><li>trap：指定在收到操作系统信号后执行的动作</li><li>“:”(冒号命令)：空命令</li><li>“.”(句点命令)或source在当前shell中执行命令</li></ul><h3 id="捕获命令输出">捕获命令输出</h3><p><code>$(command)</code>和<code>`(command)`</code></p><h3 id="算术扩展">算术扩展</h3><p><code>$((...))</code></p><h3 id="参数扩展">参数扩展</h3><p>批处理 1_tmp, 2_tmp, …</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>i=1<br><span class="hljs-keyword">while</span> [ “<span class="hljs-variable">$i</span>” –ne 10 ]; <span class="hljs-keyword">do</span><br><span class="hljs-built_in">touch</span> “<span class="hljs-variable">$&#123;i&#125;</span>_tmp”<br>i=$((<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure><p>更复杂形式：</p><figure><img src="/image/Linux系统编程/参数.png" alt="参数扩展" /><figcaption aria-hidden="true">参数扩展</figcaption></figure><h3 id="即时文档">即时文档</h3><p>在shell脚本中向一条命令传送输入数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">cat</span> &gt;&gt; file.txt &lt;&lt; !CATINPUT!<br>Hello, this is a here document.<br>!CATINPUT!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程_1_基础</title>
    <link href="http://example.com/2024/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E7%AB%A0%20Linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E7%AB%A0%20Linux%E5%9F%BA%E7%A1%80/</id>
    <published>2024-05-01T04:00:00.000Z</published>
    <updated>2024-06-21T07:23:15.117Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第1章-linux系统基础">第1章 Linux系统基础</h1><h2 id="linux概念与使用">1. Linux概念与使用</h2><p>基于GNU通用公共协议的类Unix操作系统。</p><ul><li>开源、流行、支持大多数平台</li></ul><h3 id="gnulinux系统">GNU/Linux系统</h3><p>GNU软件/库+Linux内核</p><p>版本：Ubuntu、Debian、Mint、Red Hat、Fodore、SuSe</p><h3 id="boot-loader">Boot loader</h3><p>Boot loader加载并启动Linux内核。</p><p>常见的Boot loader：</p><ul><li>LILO：Linux Loader</li><li>GRUB：Grand Unified Boot Loader<ul><li>配置文件：<code>/boot/grub/grub.conf</code>（旧版）</li><li>不需要和LILO一样进行配置激活（自动识别加载系统内核和initrd文件）</li><li>使用grub-install安装在MBR中</li></ul></li></ul><p>GRUB引导过程：</p><ol type="1"><li>MBR上的引导程序，负责加载GRUB的第二阶段</li><li>完整的内核加载在/boot/grub目录下</li></ol><p>要能读懂GRUB配置文件</p><p>基本结构：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">default</span>=<span class="hljs-number">0</span>  # 默认启动第一个系统<br><span class="hljs-attribute">timeout</span>=<span class="hljs-number">5</span>  # 等待超时时间<span class="hljs-number">5</span>秒<br><span class="hljs-attribute">splashimage</span>=(hd0,<span class="hljs-number">0</span>)/grub/splash.xpm.gz  # 背景图片<br><span class="hljs-attribute">hiddenmenu</span>  # 隐藏菜单，若要显式，在启动时按下ESC<br><span class="hljs-attribute">title</span> Red Hat Enterprise Linux AS (<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5)  # 定义操作系统的说明信息<br>    <span class="hljs-attribute">root</span> (hd0,<span class="hljs-number">0</span>) <br>    <span class="hljs-attribute">kernel</span> /vmlinuz-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5 ro root＝/dev/sda2 rhgb quiet<br>    <span class="hljs-attribute">initrd</span> /initrd-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5.img<br></code></pre></td></tr></table></figure><p>GRUB2：<code>/boot/grub/grub.cfg</code></p><h3 id="虚拟终端">虚拟终端</h3><p>控制台模拟了一个或多个虚拟终端。</p><p>每个虚拟终端是独立的控制台，不同用户可以使用不同的虚拟终端。</p><p>切换方式：Ctrl+Alt+Fn / Alt+Fn</p><h2 id="linux基础命令">2. Linux基础命令</h2><p>命令行：$ 和 #（root）</p><p>$ command option(s) argument(s)</p><p>主要命令都需要掌握。</p><h3 id="基础命令">0. 基础命令</h3><ul><li>passwd：修改密码</li><li>mkpasswd：生成随机密码</li><li>date, cal：打印日期/日历</li><li>who, finger：查看系统上在线的用户信息</li><li>clear：清空屏幕</li><li>echo：打印信息</li><li>write, wall, talk：与其他用户信息通信。<ul><li><code>write username</code>：提示输入消息内容，然后将消息发送给<code>username</code>。</li><li><code>wall</code>：即write all，发送给所有用户</li><li><code>talk username</code>：连接目标用户，启动聊天会话</li></ul></li></ul><h3 id="目录命令">1. 目录命令</h3><ul><li><p>pwd：打印工作目录</p></li><li><p>cd</p></li><li><p>mkdir</p></li><li><p>rmdir</p></li><li><p>ls：列出目录中的内容</p><ul><li><p>-l：以长格式显示文件和目录的信息。</p><p>包括文件或目录的权限模式、所有者、群组、大小和最后修改日期。</p></li><li><p>-a：显示所有文件，包括以.开头的隐藏文件。</p></li><li><p>-R：递归列出所有子目录中的内容。</p></li></ul></li><li><p>mknod：创建字符设备或块设备<code>mknod [options] [name] [type] [major minor]</code></p><ul><li><code>[options]</code>：可选的标志，如 <code>-m</code>用来设置文件的权限模式。</li><li><code>[major minor]</code>：设备的节点号。主节点号和次节点号用于识别设备类型。对于字符设备，主节点号通常表示设备类，而次节点号表示特定的设备。</li></ul></li></ul><h3 id="文件命令">2. 文件命令</h3><ul><li><p>touch：创建新文件、更新文件修改时间</p></li><li><p>cp</p></li><li><p>mv：移动并重命名文件</p></li><li><p>ln：链接文件</p><ul><li>硬链接：<code>ln source_file link_name</code></li><li>符号链接：<code>ln -s /full/path/to/source source_directory/link_name</code></li></ul></li><li><p>rm</p></li><li><p>cat</p></li><li><p>chown：改变文件或目录的所有者。<code>chown [options] [user:group] [file...]</code></p><ul><li><p><code>[options]</code>：</p><p><code>-R</code> 用于递归改变所有子目录和文件的所有者；</p><p><code>-h</code>：对于符号链接，改变链接本身的所有者，而不是链接指向的文件。</p></li><li><p><code>[user:group]</code>：指定新的所有者和组。用户名可以单独指定，或者与组名一起指定。如果只指定用户名，则默认组为用户所属的默认组。</p></li><li><p><code>[file...]</code>：要改变所有者的文件或目录列表。</p></li></ul></li><li><p>chgrp：改变文件或目录的组所有权。<code>chgrp [options] [group] [file...]</code></p></li><li><p>more/less：分页查看文件内容</p><ul><li>more：逐页显示文件，空格下一页，<code>b</code>上一页，<code>q</code>退出</li><li>less：滚动显示文件，功能更多。<ul><li>按 <code>/</code> ，输入搜索词搜索文件内容，按 <code>n</code>查找下一个匹配项，按 <code>p</code> 查找上一个匹配项。</li></ul></li></ul></li></ul><h4 id="文件权限">文件权限</h4><p>三个访问等级：</p><ul><li>用户</li><li>群组</li><li>其他</li></ul><p>三个权限：</p><ul><li>读 r</li><li>写 w</li><li>执行 x</li></ul><p>ls -l会展示文件权限</p><p>默认文件权限</p><p>file：-rw-r--r--</p><p>Directory：drwxr-xr-x</p><p>第一个字符表示文件类型，后续9个字符分别为u、g、o的rwx。</p><p>文件类型：</p><ul><li>-：常规文件</li><li>d：目录</li><li>l：链接</li><li>c：字符设备文件</li><li>b：块设备文件</li><li>p：管道</li><li>s：套接字</li></ul><p>修改权限：<code>chmod who operator what filename</code></p><ul><li>who:<ul><li>u：文件所有者</li><li>g：群组</li><li>o：系统其他用户</li><li>a：all</li></ul></li><li>operator:<ul><li>+：添加权限</li><li>-：删除权限</li><li>=: 设置明确权限</li></ul></li><li>what: rwx</li></ul><p>将u、g、o各自的rwx权限看为一个二进制数，可以用数字为它们赋予权限。</p><ul><li><p>r=4,w=2,x=1</p></li><li><p>chmod 765 file：u=rwx,g=rw,o=rx</p></li></ul><h4 id="文件编辑">文件编辑</h4><p>vi、emacs、gedit</p><h3 id="进程">3. 进程</h3><p>进程是一个正在执行的程序实例。由执行程序、它的当前值、状态信息以及通过操作系统管理此进程执行情况的资源组成。</p><ul><li><p>ps：报告进程状态</p></li><li><p>pstree：展示进程树</p></li><li><p>jobs, fg, bg, ctrl-z：任务控制</p><ul><li><p>jobs：查看当前 shell环境中所有在后台运行的任务列表，会给出每个任务的唯一编号。</p></li><li><p>fg %1：将一个后台任务调至前台执行，用%指定任务编号。</p></li><li><p>bg %1：将一个在后台暂停的任务继续运行在后台。</p></li><li><p>Ctrl+Z：将当前前台执行的任务挂起到后台。</p></li></ul></li><li><p>kill：杀死进程<code>kill [PID]</code>、发送信号给进程<code>kill [signal] [PID]</code></p></li><li><p>nohup：无视挂起信号运行指令</p></li><li><p>nice, renice：调整进程优先级</p><p>nice介于-20～19，影响调度优先级，nice越低优先级越高</p><ul><li><p>nice：启动一个新进程，并为其设置一个nice值。</p></li><li><p>renice：改变正在运行的进程的nice值。</p></li></ul></li><li><p>top：展示占用CPU最高的进程列表</p></li></ul><h3 id="寻找帮助">4. 寻找帮助</h3><p>man、info、--help</p><h3 id="重定向">5. 重定向</h3><p>标准输入、标准输出、标准错误</p><ul><li>对应的文件描述符：0, 1, 2</li></ul><p><code>&lt;、&gt;</code>：覆盖文件</p><p><code>&gt;&gt;</code>：追加到末尾</p><p><code>2&gt;</code>：将标准错误输出到文件，而标准输出仍然会输出到命令行</p><p><code>&gt;&amp;</code>：将标准输出和错误都输出到文件</p><p><code>2&gt;&amp;1</code>：将标准错误输出重定向到标准输出，与上个选项的区别是会打印到命令行</p><h3 id="管道">6. 管道</h3><p>一个进程的输出作为另一个进程的输入。</p><p><code>命令1|命令2</code>：命令1的输出会直接传递给命令2作为输入。</p><h3 id="高级命令">7. 高级命令</h3><ul><li><p>find：查找文件。<code>find [options] [path...] [-exec [command] &#123;&#125; +]</code></p><ul><li><code>[options]</code>：find命令的行为选项，如<code>-name</code>、<code>-type</code>、<code>-mtime</code> 等。<ul><li><code>-print</code>：打印找到的文件名。</li><li><code>-delete</code>：删除找到的文件。</li></ul></li><li><code>[path...]</code>：要搜索的目录路径。如果省略，默认在当前目录搜索。</li></ul></li><li><p>sed：通过模式匹配对文本进行处理。</p></li><li><p>grep：在文本文件中搜索指定的文本字符串。<code>grep [options] [pattern] [file...]</code></p><ul><li>选项：<ul><li><code>-i</code>：忽略大小写。</li><li><code>-v</code>：反转匹配，只显示不匹配的行。</li><li><code>-c</code>：计数，只输出匹配行的数量。</li><li><code>-n</code>：显示匹配行及其行号。</li><li><code>-l</code>：只输出包含匹配字符串的文件名。</li><li><code>-L</code>：只输出不包含匹配字符串的文件名。</li><li><code>-r</code> 或 <code>-R</code>：递归搜索目录中的所有文件。</li><li><code>-E</code>：使用扩展正则表达式。</li><li><code>-o</code>：只输出匹配到的部分，而不是整行内容。</li></ul></li></ul></li></ul><p>基本正则表达式：</p><ul><li><code>.</code>：匹配任意单个字符。<ul><li>例子：<code>grep '.$' file.txt</code> 将匹配 file.txt中以任意字符结尾的行。</li></ul></li><li><code>*</code>：匹配前一个字符出现零次或多次。<ul><li>例子：<code>grep 'o*' file.txt</code> 将匹配 file.txt中包含零个或多个 “o” 的行。</li></ul></li><li><code>^</code>：匹配行的开始。<ul><li>例子：<code>grep '^A' file.txt</code> 将匹配 file.txt 中以 “A”开头的行。</li></ul></li><li><code>$</code>：匹配行的结束。<ul><li>例子：<code>grep 'B$' file.txt</code> 将匹配 file.txt 中以 “B”结尾的行。</li></ul></li><li><code>[abc]</code>：匹配方括号内的任意一个字符。<ul><li>例子：<code>grep '[abc]' file.txt</code> 将匹配 file.txt 中包含“a”、“b” 或 “c” 的行。</li></ul></li><li><code>[^abc]</code>：匹配不在方括号内的任意一个字符。<ul><li>例子：<code>grep '[^abc]' file.txt</code> 将匹配 file.txt 中不包含“a”、“b” 或 “c” 的行。</li></ul></li><li><code>\</code>：转义字符，用于匹配特殊字符。<ul><li>例子：<code>grep '\\.' file.txt</code> 将匹配 file.txt中包含一个反斜杠后跟一个点（<code>.</code>）的行。</li></ul></li><li><code>()</code>：标记子表达式的开始和结束。<ul><li>例子：<code>grep '(abc|def)' file.txt</code> 将匹配 file.txt 中包含“abc” 或 “def” 的行。</li></ul></li><li><code>|</code>：逻辑或操作符。<ul><li>例子：<code>grep 'A|B' file.txt</code> 将匹配 file.txt 中包含 “A” 或“B” 的行。</li></ul></li><li><code>\&lt;</code>：匹配单词的开始（前面必须有一个单词边界）。<ul><li>例子：<code>grep '\&lt;word' file.txt</code> 将匹配 file.txt 中以“word” 开头的行，其中 “word” 是一个单词。</li></ul></li><li><code>\&gt;</code>：匹配单词的结束（后面必须有一个单词边界）。<ul><li>例子：<code>grep '\&gt;word' file.txt</code> 将匹配 file.txt 中以“word” 结尾的行，其中 “word” 是一个单词。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_5_云数据中心</title>
    <link href="http://example.com/2024/04/05/%E4%BA%91%E8%AE%A1%E7%AE%97/5-%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/"/>
    <id>http://example.com/2024/04/05/%E4%BA%91%E8%AE%A1%E7%AE%97/5-%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/</id>
    <published>2024-04-05T04:00:00.000Z</published>
    <updated>2024-06-21T07:11:10.378Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云数据中心">5-云数据中心</h1><h2 id="基本设计">1. 基本设计</h2><p>外部：不间断的电源、足够带宽的网络</p><p>内部：散热（保证设备安全）</p><h2 id="云数据中心特征">2. 云数据中心特征</h2><h3 id="特征">2.0 特征</h3><ol type="1"><li><p>高设备利用率</p><ul><li><p>通过虚拟化整合云平台系统与数据中心硬件资源，减少物理服务器数量</p></li><li><p>优化资源利用率、简化管理，降低成本、快速响应业务需求的变化等</p></li><li><p>较大的数据中心有更低的单位运营成本：网络、存储、管理</p></li></ul></li><li><p>绿色节能</p><ul><li><p>能源</p></li><li><p>功耗：服务器、空调</p></li></ul></li><li><p>自动化管理</p><ul><li><p>人力成本是大多数管理数据中心站点最大成本因素</p></li><li><p>无人值守，远程管理</p></li><li><p>门禁、通风、温度、湿度、电力均可远程调度与控制</p></li></ul></li><li><p>高可用性</p><ul><li><p>各个部分的冗余、容错、容灾设计</p></li><li><p>扩展和升级时，保持正常运行</p></li></ul></li></ol><h3 id="绿色节能技术">2.1 绿色节能技术</h3><h4 id="耗电原因">耗电原因</h4><ul><li>技术因素<ul><li>云计算中心规模不断扩大，硬件设备数量激增，导致总体耗电量大幅上升。</li><li>为了保证高可用性和稳定性，通常采用功耗相对较高的高性能处理器、内存和存储设备。</li><li>虚拟化技术的广泛应用也带来了额外的能耗。</li></ul></li><li>商业因素<ul><li>客户需求不断增长<spanclass="math inline">\(\rightarrow\)</span>数据中心建设、扩容。</li><li>激烈的市场竞争<spanclass="math inline">\(\rightarrow\)</span>不断优化更新技术。</li></ul></li></ul><h4 id="采取措施">采取措施</h4><ol type="1"><li><p>优化技术</p><ul><li>使用更高能效设备、服务器架构和更智能的资源调度策略。</li></ul></li><li><p>节约能源</p><ul><li><p>在数据中心设计和运营中充分考虑节能因素。</p><p>例如，采用更为合理的布局和散热系统设计，减少冷却能耗；</p><p>合理安排数据中心工作时间，充分利用自然冷却等方式降低能耗。</p></li></ul></li><li><p>提升硬件使用率</p><ul><li><p>例如，推广容器化技术，实现应用打包和快速部署；</p><p>采用无服务器架构，减少闲置服务器数量等。</p></li></ul></li><li><p>可再生能源</p></li><li><p>绿色云生态系统</p><ul><li>与硬件厂商、政府部门等共同合作，构建一个绿色云生态系统。通过政策引导、技术创新和市场机制等手段，推动整个行业的绿色发展。</li></ul></li></ol><h4 id="具体节能技术">具体节能技术</h4><ul><li>配电系统：高压直流配电、市电直供配电</li><li>空调系统节能：高温回风、精确制冷、自然冷空调</li><li>集装箱数据中心节能技术<ul><li>服务器设备、网络设备、空调设备、供电设备等高密度地装入固定尺寸的集装箱中</li><li>高密度、模块化、按需快速部署、移动便捷</li></ul></li><li>管理系统节能策略和算法：供电管理</li><li>新能源应用</li></ul><h3 id="自动化管理">2.2 自动化管理</h3><p>目标：使得在规模较大的情况下，实现较少人员对数据中心的高度智能管理。</p><p>工作范围：按需分配/收回资源；自动配电、冷却、消防等。</p><p>具体内容：资源的自动化调度和对业务的灵活响应。</p><ul><li>既需要单业务自治，也需要对业务和资源进行全局控制和协调。</li></ul><h4 id="特征和内容">特征和内容</h4><ol type="1"><li><p>全面可视化：多层级运行时视图，全面掌握数据中心资产、配置和各层次依赖关系的现状</p></li><li><p>自动的控制执行：全面自动化流程</p></li><li><p>多层次的无缝集成：流畅地自动执行在不同层次和组成部分之间地各种处理流程，快速的协调数据中心内外的所有变更，实现端到端的流程管理</p></li><li><p>综合与实时的报告：提供全面综合和透视依赖关系的报告提高管理水平</p></li><li><p>全生命周期支持：自动化整个“计划—实施—检查—更正”的IT流程生命周期</p></li></ol><p>实现的三个阶段：</p><ol type="1"><li><p>IT服务操作：监控和管理IT基础设施的广义集合</p><ul><li><p>目标：生成有效的全局IT支撑架构，提高IT服务质量，对活动和过程进行协调和执行</p></li><li><p>活动和过程：事故管理、事件监控和管理、问题管理</p></li></ul></li><li><p>IT服务管理：制定设施间的交互和协作处理，确保IT服务符合标准规范</p><ul><li><p>定义：根据客户需求的层次确保IT服务质量的一系列过程</p></li><li><p>主题：服务管理、服务层管理、IT资产管理、财务管理</p></li></ul></li><li><p>数据中心自动化：维护IT环境，定制、检查和执行服务层协议</p></li></ol><p>采用数据中心自动化工具必须具备如下条件</p><ul><li>管理系统</li><li>定义过程</li><li>认知非自动化过程的成本</li><li>内部流程资源</li></ul><h3 id="容灾备份">2.3 容灾备份</h3><table><thead><tr class="header"><th><strong>对比维度</strong></th><th><strong>备份</strong></th><th><strong>容灾</strong></th></tr></thead><tbody><tr class="odd"><td>使用目的</td><td>避免数据丢失，一般通过快照、备份等技术构建数据的数据备份副本，故障时可以通过数据的历史副本恢复用户数据。</td><td>避免业务中断，一般是通过复制技术（应用层复制、主机I/O层复制、存储层复制）在异地构建业务的备用主机和数据，主站点故障时备用站点可以接管业务。</td></tr><tr class="even"><td>使用场景</td><td>针对病毒入侵、人为误删除、软硬件故障等场景，可将数据恢复到任意备份点。</td><td>针对软硬件故障以及海啸、火灾、地震等重大自然灾害，运行故障切换，尽快恢复业务。源端可用区恢复正常时，可轻松利用故障恢复能力重新切换回到源端可用区。</td></tr><tr class="odd"><td>成本</td><td>通常是生产系统的1~2%。</td><td>通常是生产系统的20%~100%（根据不同的RPO/RTO要求而定），高级别的双活容灾，要求备用站点也要部署一套和主站点相同的业务系统，基础设施成本需要翻倍计算。</td></tr></tbody></table><p>容灾备份：</p><p>异地建立、维护备份存储系统，利用地理分离保证系统和数据对灾难性事件的抵御能力。</p><ul><li>容灾系统的抵抗程度：数据级容灾和应用级容灾。</li></ul><h4 id="关键技术">关键技术</h4><p>技术核心：复制数据</p><ul><li><p>镜像：将符合指定规则的报文复制到目的端口</p></li><li><p>快照：拷贝指定数据集合，用于数据备份恢复、提供额外访问通道。</p></li><li><p>基于IP的SAN的远程数据容灾备份技术：主数据中心复制到备份数据中心。</p></li><li><p>数据库复制。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_4_网络</title>
    <link href="http://example.com/2024/04/04/%E4%BA%91%E8%AE%A1%E7%AE%97/4-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2024/04/04/%E4%BA%91%E8%AE%A1%E7%AE%97/4-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C/</id>
    <published>2024-04-04T04:00:00.000Z</published>
    <updated>2024-06-21T07:10:51.728Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算网络">4-云计算网络</h1><h2 id="基本架构">1. 基本架构</h2><p>云数据中心需要基础网络将所有设备组织在本地网络里面——基础网络架构。</p><p>传统树结构：建造方便简单，但不便于拓展与升级</p><ul><li>任意一个核心交换机故障导致上千台服务器失效</li></ul><p>架构需求：低成本、高可扩展性、低配置开销、健壮性、节能</p><h3 id="改进树结构">1.1 改进树结构</h3><h4 id="fattree">FatTree</h4><ol type="1"><li>K叉树，K个Pod(集装器)，每个Pod有K个交换机，其中K/2个为接入交换机，K/2个为汇聚交换机。</li><li>Pod中每个交换机有K个接口。<ul><li>接入交换机的K/2个接口接主机，K/2个接口接汇聚交换机；</li><li>汇聚交换机的K/2个接口接接入交换机，K/2个接核心交换机。</li></ul></li><li>有<spanclass="math inline">\((K/2)^2\)</span>个核心交换机，每个交换机K个端口接K个汇聚交换机。</li><li>一个Pod内的所有交换机相互连接：完全二分图。</li><li>一个Pod内的每个汇聚交换机与一部分核心交换机连接，但是一个Pod和每一个核心交换机都有连接。</li></ol><p>两级路由表，允许两级前缀查询：Pod间流量尽可能均匀分布于核心交换机</p><p>任意两个不同Pod主机之间存在K条路径</p><ul><li>将流量在这些路径间分散</li><li>任意给定Pod的低层和高层交换机对位于本Pod的任意子网都有终结性表项</li><li>在全负载最坏的情况下实现约87%的聚合带宽</li></ul><p>与传统层次结构相比，FatTree有如下特点：</p><ul><li>消除了树形结构上层链路对吞吐量的限制</li><li>为内部节点间通信提供多条并行链路</li><li>与现有数据中心网络使用的以太网结构和IP 配置的服务器兼容</li><li>但是布线复杂了；扩展时需要重构；受到端口数限制等。</li></ul><p>FatTree的扩展性受限于核心交换机端口数量，目前比较常用的是48端口10G核心交换机，在3层树结构中能够支持27648台主机。</p><h4 id="vl2">VL2</h4><p>若干服务器连接到机架(接入)交换机；</p><p>每台接入交换机与两台汇聚交换机连接；</p><p>每台汇聚交换机与所有核心交换机连接。</p><p>特点：</p><ul><li>扁平寻址，允许服务实例被放置到网络覆盖的任何地方</li><li>负载均衡将流量统一分配到网络路径</li><li>终端系统的地址解析拓展到巨大的服务器池</li></ul><p>核心思想：使用FatTree同样的拓扑结构建立扁平的第二层网络。</p><p>机制：</p><ul><li>IP地址仅仅作为名字使用，没有拓扑含义；将服务器的名字与其位置分开。</li><li>使用可扩展、可靠的目录系统来维持名字和位置间的映射。</li><li>当服务器发送分组时，服务器上的VL2代理开启目录系统以得到实际的目的位置，然后将分组发送到目的地。</li></ul><p>优势：VL2是目前最易用于对现有数据中心网络改造的结构；应用程序使用服务地址通信而底层网络使用位置信息地址进行转发，使得虚拟机能够在网络中任意迁移而不影响服务质量。</p><p>缺点：VL2依赖于中心化的基础设施来实现2层语义和资源整合，面临单点失效和扩展性问题。</p><h3 id="递归层次结构">1.2 递归层次结构</h3><p>每一个高层的网络拓扑，由多个低层的递归单元按照递归规律相互连接构成，同时也是更高层级网络的一个递归单元。</p><ul><li>增加服务器数量<spanclass="math inline">\(\rightarrow\)</span>提高总的递归层次<ul><li>添加服务器更加灵活，可增加的数量增大</li><li>对交换机性能要求低</li></ul></li></ul><p>递归层次结构：DCell、Ficonn、BCube、MDCube</p><h4 id="ficonn">FiConn</h4><p>服务器使用两个网卡端口：主用端口连接低层网络，备用端口连接高层网络</p><p>递归定义的结构</p><ul><li>第0层为基本构建单元，n个服务器连接一个具有n个端口的交换机</li><li>每个低层<strong>FiConn</strong>中备用端口空闲的一半服务器与其他相同层次的FiConn网络中备用端口空闲的服务器连接</li><li>k层服务器、k层端口、k层链路</li></ul><h4 id="bcube">BCube</h4><p>主要使用交换机构建层次化网络</p><p>第0层：n服务器连接1交换机</p><p>第1层：n个0层连接n个交换机</p><p>……</p><p>第k层：n个k-1层连接nk交换机</p><p>交换机n个端口，服务器k+1个端口。</p><h3 id="光交换网络">1.3 光交换网络</h3><p>使用光纤交换机调整网络拓扑。</p><h2 id="软件定义网络">2. 软件定义网络</h2><h3 id="openflow">2.1 OpenFlow</h3><p>使用集中控制器控制OpenFlow Switch的Flow Table。</p><p>Controller 会为特定的工作负载计算最佳路径，从而对 Switch的数据转发定义路径。</p><p>核心理论：控制转发分离架构、可编程性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_3_虚拟化</title>
    <link href="http://example.com/2024/04/03/%E4%BA%91%E8%AE%A1%E7%AE%97/3-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2024/04/03/%E4%BA%91%E8%AE%A1%E7%AE%97/3-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/</id>
    <published>2024-04-03T04:00:00.000Z</published>
    <updated>2024-06-21T07:10:30.083Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="虚拟化技术">3-虚拟化技术</h1><p>问题：云计算涉及到哪些虚拟化技术？需要对哪些资源做虚拟化？对应的虚拟化技术和产品是什么？</p><h2 id="什么是虚拟化">0. 什么是虚拟化</h2><p>虚拟化是云计算的核心技术。</p><p>本质：通过虚拟化层逻辑化原先的物理设备，实现软硬件解耦。</p><p>核心思想：</p><ul><li><p>利用软件或固件管理程序构成虚拟化层，把物理资源映射为虚拟资源。</p></li><li><p>在虚拟资源上可以安装和部署多个虚拟机，实现多用户共享物理资源。</p></li></ul><h2 id="服务器虚拟化">1. 服务器虚拟化</h2><p>硬件级、操作系统级、程序库API、应用程序</p><p>代表产品：</p><p>裸机虚拟化（VMware vSphere）、操作系统级虚拟化（VMwareWorkstation、Docker）</p><h3 id="硬件级虚拟化">1.1 硬件级虚拟化</h3><p>使用作为虚拟化层的软件管理客户操作系统，使其独立于主机操作系统，同时运行在同硬件上。</p><ul><li>Hypervisor、Virtual Machine Monitor（VMM）</li></ul><p>要求：高效、隔离、复制</p><p>类别：裸机虚拟化、寄居虚拟化</p><h4 id="优势">优势</h4><ol type="1"><li>封装性：虚拟机快照、克隆、挂起和恢复非常便捷</li><li>多实例：降低计算机资源损耗</li><li>隔离</li><li>硬件无关性</li><li>特权功能</li></ol><h4 id="可虚拟化架构">可虚拟化架构</h4><p>使用特权级分隔应用软件和系统软件的架构。</p><p>原因：提高虚拟机控制软件直接访问硬件的效率、低特权级的虚拟机之间更易实现资源隔离。</p><h4 id="虚拟化硬件对象">虚拟化硬件对象</h4><p>CPU、内存、I/O设备</p><h5 id="cpu虚拟化">CPU虚拟化</h5><ul><li>任意时刻一个物理CPU只能运行一个虚拟CPU</li><li>每个客户操作系统可以使用一个或多个虚拟CPU</li><li>各个操作系统之间虚拟CPU运行相互隔离，互不影响</li></ul><p>调度：VMM决定哪个虚拟CPU在哪个物理CPU上运行，保证隔离、公平和性能</p><p>执行：虚拟CPU保证虚拟机的指令正确运行。</p><ul><li>实现技术：模拟执行、监控执行</li></ul><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：解释、扫描、翻译</li><li>基于硬件辅助的虚拟化：硬件针对虚拟化作出支持</li><li>修改操作系统的类虚拟化：修改客户机操作系统，配合VMM进行虚拟化</li></ol><h5 id="内存虚拟化">内存虚拟化</h5><p>把物理内存统一管理，包装成多个虚拟的物理内存提供给虚拟机使用。</p><p>每个虚拟机拥有各自独立的内存空间。</p><p>VMM的工作：</p><ol type="1"><li>维护客户机物理地址和宿主机器的机器地址之间的映射</li><li>截获虚拟机对客户机物理地址的访问，并根据所记录的映射关系，转换成机器地址</li></ol><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：影子页表，直接把客户机虚拟地址翻译为物理地址</li><li>基于硬件辅助的虚拟化：硬件辅助地址转换</li><li>修改操作系统的类虚拟化：客户机直接使用VMM的机器地址到物理地址的翻译表</li></ol><h5 id="io虚拟化">I/O虚拟化</h5><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：VMM进行设备模拟并处理所有设备请求与响应</li><li>基于硬件辅助的虚拟化：DMA地址重映射</li><li>修改操作系统的类虚拟化：修改客户机操作系统，客户机直接与物理设备交互</li></ol><h3 id="操作系统级虚拟化">1.2 操作系统级虚拟化</h3><p>在主机操作系统中插入一个虚拟化层。</p><p>在同一个操作系统内核内，运行多个虚拟机；虚拟机可以访问内核。</p><p>虚拟机/容器</p><p>容器的优缺点：</p><ul><li>启动/停止开销最小，资源需求低，可扩展性强</li><li>可同步虚拟机与宿主操作系统环境状态的变化</li><li>允许虚拟机中进程访问尽可能多的主机资源</li><li>同一个容器中的操作系统级虚拟机必须使用相同的客户操作系统</li><li>资源隔离性较差</li></ul><h2 id="云数据中心虚拟化">2. 云数据中心虚拟化</h2><p>为什么要虚拟化？</p><ul><li>一台物理设备一个用户 vs.一台物理设备多个用户：提升资源共享与复用的效率，降低成本</li><li>固定大小与位置的存储空间 vs.灵活扩展和空间分布的空间：提升可扩展性，提升存储资源使用效率</li><li>为了实现服务器、存储虚拟化，要求网络也要能够方便、灵活地调整：随着虚拟机的迁移一起迁移</li></ul><h3 id="服务器虚拟化-1">服务器虚拟化</h3><p>将一个或多个物理服务器虚拟成多个逻辑上的服务器。</p><p>虚拟机、容器。</p><h3 id="存储虚拟化">存储虚拟化</h3><p>把分布的异构存储设备统一为一个或几个大的存储池。</p><p>存储虚拟化将系统中分散且异构的存储资源整合起来，形成一个统一连续编址的逻辑存储空间。</p><h3 id="网络虚拟化">网络虚拟化</h3><p>在底层物理网络和网络用户之间增加一个抽象层。</p><p>云数据中心对网络的需求</p><ul><li>提高数据传输效率：应对数据同步、备份、虚拟机迁移等的大流量</li><li>提高管理效率：采用统一的交换网络减少布线、维护和扩容的成本</li></ul><p>网络虚拟化技术：</p><ul><li><p>核心层网络虚拟化</p></li><li><p>虚拟机网络虚拟化</p></li><li><p>接入层网络虚拟化</p></li></ul><h2 id="虚拟机迁移">3. 虚拟机迁移</h2><h3 id="需求">需求</h3><ol type="1"><li><p>负载平衡需要</p></li><li><p>物理服务器定期升级的需要</p></li></ol><p>关注重点：实时迁移</p><ul><li>保持虚拟机运行的同时，将其从一个计算机迁移到另一个计算机，并在目的计算机恢复运行</li></ul><h3 id="迁移内容">迁移内容</h3><ul><li>内存迁移：最困难</li><li>网络迁移：迁移网络设备、协议状态和配置</li><li>存储设备迁移：使用NAS作为存储设备共享数据</li></ul><p>分类：</p><ul><li>物理机到虚拟机 P2V</li><li>虚拟机到虚拟机 V2V</li><li>虚拟机到物理机 V2P</li></ul><h3 id="内存迁移方案">内存迁移方案</h3><table><thead><tr class="header"><th>迁移方案</th><th>具体描述</th><th>优势与劣势</th></tr></thead><tbody><tr class="odd"><td>Stop and Copy</td><td>A停机，将对应内存全部复制到B，启动B</td><td>方法简单，总迁移时间最短，但停机时间无法接受</td></tr><tr class="even"><td>Stop and Copy和Pull阶段结合</td><td>A停机，将部分内存复制到B，启动B，B运行中遇到缺失内存，再到A内存中复制</td><td>停机时间很短，总迁移时间很长。Pull阶段复制造成的性能下降，用户体验差</td></tr><tr class="odd"><td>Push和Stop and Copy阶段结合</td><td>A不停机，保持对外服务，将变化的内存迭代地复制到B，直到最后剩余很少要复制的再停止A，复制最后变动到B，启动B</td><td>平衡了停机时间和总迁移时间之间的矛盾。需要有一种算法能够测定工作集，以避免反复重传。可能会占用大量的网络带宽，对其他服务造成影响</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_2_架构</title>
    <link href="http://example.com/2024/04/02/%E4%BA%91%E8%AE%A1%E7%AE%97/2-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2024/04/02/%E4%BA%91%E8%AE%A1%E7%AE%97/2-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/</id>
    <published>2024-04-02T04:00:00.000Z</published>
    <updated>2024-06-21T07:26:02.071Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算架构">2-云计算架构</h1><h2 id="计算架构的演化">1. 计算架构的演化</h2><h3 id="发展历程">1.1 发展历程</h3><ol type="1"><li>中央集权架构：所有计算、计算资源、业务逻辑都集中于一台主机</li><li>客户机/服务机架构（C/S架构）<ul><li>客户端：承载少量计算任务和所有IO任务</li><li>服务器：承载主要计算任务</li><li>优点：充分利用客户端计算能力；关注点分离，简化软件复杂度、编程模式</li><li>缺点：持久链接，系统伸缩能力受限；客户端开发维护成本高；平台相关，升级换代麻烦</li></ul></li><li>中间层架构：将业务逻辑和数据服务分别放在两个服务器上（还是C/S架构）<ul><li>客户机到中间件为无状态的非持久链接：提升架构弹性</li></ul></li><li>浏览器/服务器架构（B/S架构）<ul><li>对客户机、中间层架构的扩展——客户端开发、维护成本降低，升级改动小</li><li>客户端：负载进一步缩减，仅显示和运行基于浏览器的脚本程序</li><li>服务器：Web服务器层屏蔽各中间件的差异，提供通用的用户访问界面</li><li>扩展性高：对客户机性能无要求</li><li>对网络性能要求高</li></ul></li><li>C/S和B/S混合架构<ul><li>没有一种架构能够适用于所有场景</li><li>有些服务需要持久的链接（内部用户）</li><li>有些仅通过非持久链接即可（外部用户）</li></ul></li><li>面向服务的架构（SOA）</li><li>微服务架构：在SOA思想上对系统业务做彻底的组件化、服务化。</li></ol><h3 id="面向服务的架构soa">1.2 面向服务的架构（SOA）</h3><p>通过定义良好的接口，联系应用程序的不同服务的组件模型。</p><p>接口：中立定义，独立于硬件平台、操作系统和编程语言。</p><ul><li><p>服务交互方式统一、通用。</p></li><li><p>服务只做本职工作，暴露接口。</p></li><li><p>通过统一的界面协调多个服务：控制复杂性，更容易管理。</p></li></ul><p>SOA的目标：系统更有弹性，更灵活、更快地响应不断改变的企业业务需求，解决软件重用问题。</p><p>具体通过：</p><ul><li>简单的服务间接口</li><li>粗粒度：调用者和服务层只需一次交互</li><li>松耦合：服务间相对独立无依赖</li><li>位置透明</li><li>协议无关</li></ul><p>SOA架构角色：</p><ul><li>服务请求者</li><li>服务提供者</li><li>服务注册中心</li></ul><p>操作：</p><ul><li>发布</li><li>查询</li><li>绑定和调用</li></ul><h2 id="云计算架构二维视角">2. 云计算架构二维视角</h2><p>基础架构 + 应用程序（后端+前端）</p><h3 id="基础架构">2.1 基础架构</h3><p>虚拟化层</p><ul><li><p>将硬件转换为统一的IT资源（可灵活拆分、统一计量、统一管理、软件定义的）</p></li><li><p>可以在不同的抽象层实现：应用层、操作系统层、体系结构层、硬件层等</p></li></ul><p>Web服务层</p><ul><li><p>将云资源提供给客户的一种最方便的方式，解决大部分客户无法直接使用虚拟机的问题；</p></li><li><p>支持面广、对客户端要求低，只需要浏览器就可以访问。</p></li></ul><p>服务总线层</p><ul><li>中间件层，封装计算服务、数据存储、消息传递</li><li>分离用户与虚拟化层、连接用户与Web服务层。</li></ul><p>客户机用户界面</p><ul><li><p>Web门户，将各种服务混搭集成在一个页面。</p></li><li><p>基于Ajax，Javascript，趋势是使用功能完善的组件</p><ul><li>如JavaBeans/Applets，Silvedight/.NET等</li><li>可下载和安装在客户机上</li></ul></li></ul><p>###　2.2 云应用程序结构</p><p>传统操作系统上的应用程序：进程、线程、服务、shell（应用程序的控制接口）</p><ul><li>进程就是最终产品，每一个进程可运行多个指令序列（线程），一个线程对应一种服务。</li></ul><p>云环境中的应用程序：应用程序、应用实例、服务、云命令行界面（控制端）</p><ul><li><p>应用程序由多个同时运行的实例支撑</p></li><li><p>不同的应用实例运行在不同的服务器上，每一个应用实例提供一种或多种服务</p></li><li><p>服务间相互独立</p></li></ul><h2 id="云计算逻辑架构">3. 云计算逻辑架构</h2><h3 id="云体">3.1 云体</h3><p>云计算的物质基础，使用的资源集合，构成云计算的软硬件环境。</p><ul><li><p>例如网络、服务器、存储器、交换机等。</p><p>广义的云体包括数据中心机器辅助设施如电力、空调、机架、冷却等系统。</p></li></ul><p>目前，云体就是数据中心。</p><p>云计算的横向架构。</p><p>传统系统环境：进程/线程/内存管理 + 文件系统 + 进程间通信/网络。</p><p>云运行时环境：计算资源+持久存储+通信</p><h4 id="云数据中心">云数据中心</h4><p>数据集中存储、计算、交换的中心。</p><p>传统数据中心的问题</p><ul><li>机器过多、利用率过低</li><li>应用迁移太困难</li><li>存储需求增长太快</li></ul><p>云数据中心：重视虚拟化，以提高资源利用率</p><p>软件定义数据中心：</p><ul><li>软件定义计算：计算节点虚拟化。</li><li>软件定义存储：分离管理接口与数据读写。管理接口统一，数据读写可以兼容各种方式。</li><li>软件定义网络：数据平面（数据转发）和控制平面（转发表的设置等）分离；集中控制，分布式转发。</li></ul><h3 id="云栈">3.2 云栈</h3><p>又称云平台，是在云上建造的运行环境。</p><ul><li><p>支持应用程序的发布、运行、监控、调度、伸缩，</p><p>并为应用程序提供辅助服务机制，如访问控制、权限管理等。</p></li></ul><h4 id="云栈的三层模式">云栈的三层模式</h4><ol type="1"><li>基础设施即服务层：硬件+虚拟化</li><li>平台即服务层：应用程序的运行环境</li><li>软件即服务层：Web应用服务</li></ol><h4 id="云计算技术架构">云计算技术架构</h4><p>SOA构建层+管理中间件层+资源池层+物理资源层</p><p>管理中间件层和资源池层是云计算技术的最关键部分。</p><h4 id="iaas实现机制">IaaS实现机制</h4><ol type="1"><li>配置工具：在分配的节点上准备任务运行环境。</li><li>系统管理模块：管理和分配所有可用的资源，其核心是负载均衡。</li><li>服务目录：用户可以访问的服务清单。</li><li>用户交互接口：Web用户访问接口。</li><li>监视统计模块：监视节点运行状态，统计节点使用情况。</li></ol><h3 id="云计算">3.3 云计算</h3><p>利用云体和云平台所进行的计算或处理。</p><p>无论在哪个层面开展，只要符合“按量计费、资源可伸缩”就是云计算。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_1_概念</title>
    <link href="http://example.com/2024/04/01/%E4%BA%91%E8%AE%A1%E7%AE%97/1-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2024/04/01/%E4%BA%91%E8%AE%A1%E7%AE%97/1-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E5%BF%B5/</id>
    <published>2024-04-01T04:00:00.000Z</published>
    <updated>2024-06-21T07:25:56.523Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算概念">1-云计算概念</h1><p>大规模分布式计算模式，通过一系列技术实现按需交付。</p><h2 id="计算模式的发展历程">1. 计算模式的发展历程</h2><p>主机系统与集中计算<spanclass="math inline">\(\rightarrow\)</span>集群计算<spanclass="math inline">\(\rightarrow\)</span>个人计算机与桌面计算<spanclass="math inline">\(\rightarrow\)</span>分布式计算<spanclass="math inline">\(\rightarrow\)</span>网格计算<spanclass="math inline">\(\rightarrow\)</span>​云计算</p><ul><li><strong>效用计算</strong>：将IT资源包装成可以度量的服务提供给用户。</li><li><strong>服务计算</strong>（软件即服务SaaS）：将应用程序作为服务提供。</li></ul><p>云计算：效用计算+服务计算</p><h3 id="对计算的追求">对计算的追求</h3><p>自动化、高性能、易使用</p><h3 id="云计算持续优化的动力">云计算持续优化的动力</h3><ol type="1"><li>节能</li><li>降低成本</li><li>提升资产安全</li><li>提升信息系统容灾备份能力</li></ol><h2 id="云计算的特征与分类">2. 云计算的特征与分类</h2><h3 id="特征">2.1 特征</h3><ul><li><p>物理特征：大规模</p></li><li><p>技术特征：虚拟化</p></li><li><p>商业特征：按需服务</p></li><li><p>使用特征：通用、高可伸缩</p></li><li><p>目标：高可靠</p></li></ul><h3 id="云部署模型">2.2 云部署模型</h3><p>公有云：由第三方云提供者拥有的可公共访问的云环境</p><p>私有云：由一家组织单独拥有，利用云计算技术来访问组织内部的IT资源</p><p>混合云：由两种或者更多不同云部署模型组成的云环境</p><h3 id="云服务模型">2.3 云服务模型</h3><ul><li>软件作为服务：Software as a Service，SaaS</li><li>平台作为服务：PaaS</li><li>基础设施作为服务：IaaS</li></ul><h4 id="iaas">IaaS</h4><p>通过虚拟机方式对外提供计算、存储和网络能力</p><ul><li>虚拟机安装操作系统，享有公网IP，使用公网访问虚拟机</li><li>额外租用存储设备挂载到虚拟机</li><li>多个虚拟机之间通过公用网络、私有网络进行通信</li></ul><p>类似租用独立的计算机，用户自行解决多台机器之间的协同问题</p><p>优势</p><ul><li>允许用户动态申请和释放资源</li><li>按使用量计费</li><li>更高的资源使用效率（节能环保）</li></ul><h4 id="paas">PaaS</h4><p>提供用户应用程序的开发和运行环境，包括应用编程接口和运行平台等，支持应用从创建到运行整个生命周期需要的各种软硬件资源和工具。</p><ul><li>经过封装的IT能力，或逻辑资源：数据库、文件系统和应用运行环境</li><li>主要面向软件开发者（包括应用服务上）</li></ul><p>PaaS自身负责资源的动态扩展和容错管理，用户无需考虑节点间的配合问题。</p><p>用户自主权降低，需按照给定的编程环境和编程模型构建应用。</p><h4 id="saas">SaaS</h4><p>通过标准的Web浏览器或软件客户端访问云上的应用。</p><h3 id="相关技术">2.4 相关技术</h3><p>虚拟化技术、容器技术、数据加密、分布式计算与分布式存储等。</p><h4 id="分布式计算">分布式计算</h4><p>多个通过网络互联的计算机相互之间传递数据，实现信息共享，协作共同完成处理任务。</p><p>优势：</p><ul><li>资源共享</li><li>多设备负载均衡</li><li>将程序放在最适合的计算机上运行</li></ul><h2 id="云计算三元认知">3. 云计算三元认知</h2><h3 id="商业模式">3.1 商业模式</h3><p>一种全新的商业模式、服务类型。</p><ul><li>在软件服务基础上提供平台和基础设施服务</li><li>具体实现：云平台，包括计算范式和实现方式</li></ul><h3 id="计算范式">3.2 计算范式</h3><p>理论实现，针对商业模式的架构设计。</p><ul><li>云体逻辑结构：具体落地的云平台逻辑结构。<ul><li>物理结构：云数据中心</li><li>计算+存储+通信</li></ul></li><li>云栈逻辑结构：面向服务的云平台逻辑结构。<ul><li>物理结构：管理系统的结构</li><li>基础设施即服务，平台即服务，软件即服务</li></ul></li></ul><h3 id="实现方式">3.3 实现方式</h3><p>数据中心+云平台管理系统</p><ul><li>软件定义数据中心：软件定义计算，软件定义存储，软件定义网络，软件定义安全。</li></ul><h2 id="云计算的开源方法论">4. 云计算的开源方法论</h2><h3 id="什么是开源">4.1 什么是开源</h3><p>开源是一种方法论、一种构造大规模复杂软件的协作方式。</p><p>开源软件：</p><p>一种版权持有人为任何人和任何目的提供学习、修改和分发权力，并公布源代码的计算机软件。</p><ol type="1"><li><p>许可证不应限制任何个人或团体将包含该开源软件的广义作品进行销售或赠予</p></li><li><p>开源软件的程序必须包含源代码，必须允许发布源代码及以后的程序</p></li><li><p>开源软件许可证必须允许修改和派生作品，并允许使用原有软件的许可条款发布他们</p></li></ol><p>开源不一定自由，开源不一定免费；自由不一定免费；免费不一定开源，不一定自由。</p><h3 id="开源的价值与意义">4.2 开源的价值与意义</h3><ol type="1"><li>开源促进国家信息技术创新，带动经济发展</li><li>软件厂商依托开源提升研发能力</li><li>用户使用开源技术改变信息化路线</li><li>企业自主开源，引领技术发展路径</li></ol><h2 id="云计算技术的挑战与未来">5. 云计算技术的挑战与未来</h2><h3 id="难点">5.1 难点</h3><ol type="1"><li><p>数据中心安全控制</p></li><li><p>构建高度同构化的虚拟资源</p></li><li><p>高可用性的实现——资源管理</p></li><li><p>容错的实现——任务管理</p><p>当集群中的服务出现故障时，服务器集群上的程序执行不会被中端或挂起。</p></li><li><p>节能（负载均衡）——任务管理</p><p>任务调度；虚拟机调度。</p></li><li><p>云安全与隐私保护——安全管理</p><p>基础设施安全，平台安全，软件安全；数据完整性和隐私保护等。</p></li></ol><p><span class="math inline">\(集群可用性=\frac{MTTF(两个相邻故障之间的系统平均正常运行时间)}{MTTF+MTTR(发生故障后修复及还原工作状态的平均时间)}\)</span></p><h3 id="风险与挑战">5.2 风险与挑战</h3><ol type="1"><li><p>增加了安全漏洞</p><ul><li>远程使用IT资源需要云用户将信任边界扩展到外部的云，建立这样的安全架构同时又不引入安全漏洞是非常困难的</li><li>重叠的信任边界和不断增加的数据曝光为恶意的云用户提供了更多的攻击IT资源、窃取或破坏企业数据的机会</li></ul></li><li><p>降低了运营管理控制能力</p><ul><li>云用户对云资源的管理控制低于对企业内部IT资源的管理控制<ul><li>云提供者可能不遵守它发布的云服务保证</li><li>云用户和云提供者之间较长的地理距离可能需要更多的网络跳数，会带来延迟波动和带宽受限</li></ul></li></ul></li><li><p>云提供者之间有限的可移植性</p><ul><li>由于缺乏行业标准，不同的云提供者提供的服务存在较大差异</li></ul></li><li><p>法规和法律问题</p><ul><li><p>第三方云提供者通常选择造价较低、方便的地理位置建立数据中心，而云用户通常不会意识到所使用IT资源和自身数据所存放的位置</p></li><li><p>某些云用户可能会遇到严重的法律问题</p><p>例如：英国法律规定，英国公民的个人数据只能留在英国境内</p></li><li><p>潜在的数据获得和公开</p><p>例如：某些国家的法律规定，某些类型的数据必须向某些政府机构或数据主体公开</p></li></ul></li></ol><h3 id="缺陷与未来">5.3 缺陷与未来</h3><ul><li>从平台角度看——没有统一的标准</li><li>从计算角度看——针对松耦合的数据处理</li><li>从数据角度看——管理和分析商业数据</li><li>从资源集成角度看——必须集中到云中</li><li>从信息安全角度看——暴露、丢失的风险</li></ul><p>这也恰是网格的优势。</p><p>未来：云格计算</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_07_演化学习</title>
    <link href="http://example.com/2023/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07_%E6%BC%94%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07_%E6%BC%94%E5%8C%96%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-12-05T13:00:00.000Z</published>
    <updated>2024-06-21T07:33:09.021Z</updated>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="演化学习">演化学习</h1><h2 id="动机">1. 动机</h2><p>人工神经网络：从生物神经系统中得到灵感</p><p>涌现学习模型：模仿生物的声明演化形式</p><p>遗传算法：学习是问题候选假设在进化中的一种竞争，较好的候选假设在自然选择中不断演化。</p><p>进化论：（个体）适应+（自然）选择+（种群）进化</p><h2 id="遗传算法">2. 遗传算法</h2><p>genetic algorithms</p><p>通过对当前最好的假设模型重组来产生后续假设模型。</p><ul><li>生成并测试的柱状搜索</li><li>假设的各个部分相互作用，每一部分对总体的影响难以建模</li></ul><p>算法的一般形式：</p><ol type="1"><li><span class="math inline">\(t:=0\)</span>，初始化种群<spanclass="math inline">\(P(t)\)</span></li><li>循环至终止条件<ul><li>评估<span class="math inline">\(P(t)\)</span>每个染色体的适应度</li><li>根据适应度函数选择部分染色体</li><li>根据所选择的染色体产生后代</li><li>根据<spanclass="math inline">\(P(t)\)</span>中染色体的适应度，选择被替换的染色体，以后代替换</li><li><span class="math inline">\(t:=t+1\)</span></li></ul></li></ol><p>四个问题：</p><ul><li><p>染色体<spanclass="math inline">\(\rightarrow\)</span>模式，每个<属性-值>对用二进制的一位表示：1、0、#（表示1and0）</p><ul><li>模式：0、1、#组成的任意串</li></ul></li><li><p>适应度函数</p></li><li><p>染色体选择：基于适应度函数，与适应度成比例选择</p></li><li><p>后代产生</p><ul><li><p>选择父母：</p><ul><li><p>锦标赛选择：</p><p>每次有放回地取出一定数量个体，选择其中最好个体进入子代种群，重复至新种群与原种群规模相同</p></li><li><p>截断选择：</p><p>适应度前f个染色体进入下一代种群，复制染色体填充种群规模到原种群规模</p></li></ul></li></ul></li></ul><p>遗传算子：对从当前群体中选择的染色体进行重组以产生后代</p><ul><li><p>两个染色体单点/多点交叉替换形成两个新的候选个体</p></li><li><p>变异，随机选择候选个体，以小概率<spanclass="math inline">\(p=1/L\)</span>（L为染色体长度）选位取反</p><ul><li>避免局部收敛，保证种群多样性</li></ul></li></ul><p>后代种群的演化</p><ul><li><p>简易方案：后代染色体直接替代父代染色体</p><ul><li>易丢失优解</li></ul></li><li><p>精英法：每代保留上代最优染色体，丢弃最差个体</p><ul><li>往往与选择算子混用</li></ul></li><li><p>锦标赛法：父母染色体与后代染色体竞争，胜者放入下一代种群</p></li><li><p>小生境法：</p><p>每代个体划分为若干类，每个类中选择若干适应度较大的个体作为一个类的优秀代表组成一个群；</p><p>种群中，以及不同种群之间杂交、变异产生新一代个体群。</p><ul><li>预选择机制：只用高适应度子代替换父代</li><li>排挤机制：预定义原型。所产生的子代要保持和原型的模式不一致，模式相似的个体被替换</li><li>共享机制：计算适应度和模式的关联关系，共享这种模式</li></ul></li></ul><p>优点：</p><ul><li>无需理解问题内部相关性和因果性</li><li>以一个随机的群体开始，以适应度作为某种启发式</li><li>保证整个种群的演化</li></ul><p>问题：</p><ul><li>表示：编码不规范以及编码存在表示的不准确性</li><li>约束：单一遗传算法编码不能全面地将优化问题的约束表示出来</li><li>效率：效率比传统方法低，容易出现过早收敛</li><li>理论保证：对遗传算法的精度、可行性、计算复杂性等方面还没有有效的定量分析方法</li></ul><p>模式定理：高适应度的短模式会在演化的过程中增加占比。</p><h2 id="其他">3. 其他</h2><p>自然计算：模仿自然界特点，具有自适应、自组织、自学习能力的模型和算法</p><ul><li>遗传算法、蚁群算法、粒子群算法、免疫算法</li><li>往往用来解决非凸优化问题</li></ul><p>蚁群优化：模拟蚂蚁觅食，更新信息素</p><p>粒子群优化：模拟鸟群觅食，更新移动位置</p><p>学习分类器系统</p><p>课件没有文字介绍</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;两岸猿声啼不住，轻舟已过万重山。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_06_神经元</title>
    <link href="http://example.com/2023/11/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06_%E7%A5%9E%E7%BB%8F%E5%85%83/"/>
    <id>http://example.com/2023/11/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06_%E7%A5%9E%E7%BB%8F%E5%85%83/</id>
    <published>2023-11-14T13:00:00.000Z</published>
    <updated>2024-06-21T07:32:12.649Z</updated>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="神经元">神经元</h1><h2 id="脑和神经元">1. 脑和神经元</h2><h3 id="生物学基础">生物学基础</h3><ol type="1"><li><p>神经元内化学物质调节内部电位。</p></li><li><p>跨膜电位达到一个阈值时，则激活或放电。</p></li><li><p>（固定）时间和强度的脉冲传递给轴突</p></li><li><p>轴突像树枝状，连接到突触</p></li></ol><p>人脑有<spanclass="math inline">\(10^{11}\)</span>个神经元，每个神经元处理速度<spanclass="math inline">\(10^{-3}s\)</span>。</p><p>赫布理论：连接强度调整量与输入输出的乘积成正比。</p><ul><li>又称为长程增强机制或神经可塑。</li></ul><h3 id="mp神经元">MP神经元</h3><p>输入<span class="math inline">\(X=[x_1,x_2,...]\)</span></p><p>权值<span class="math inline">\(W=[w_1,w_2,...]\)</span></p><p>激活函数<spanclass="math inline">\(f(net)=f(\Sigma(w_i*x_i))\)</span></p><p>偏置单元<span class="math inline">\(x_0\)</span>，对应权值<spanclass="math inline">\(w_0\)</span></p><ul><li>输入<span class="math inline">\(X\)</span>，输出<spanclass="math inline">\(f(net)\)</span></li></ul><p>局限性：</p><ul><li>输入方面：线性求和</li><li>输出方面：单一输出值</li><li>更新机制：时钟同步更新</li><li>权值的物理意义：兴奋性连接与抑制性连接；不存在由正到负/由负到正的连接</li></ul><p>激活函数</p><ul><li>单位阶跃函数：<span class="math inline">\(f(x):= \begin{cases}1,\quad x\ge 0 \\[2ex] 0, \quad x\lt0 \end{cases}\)</span><ul><li>不连续，对变化敏感，在x=0处不可微</li><li>一般适合单层感知机</li></ul></li><li>Sigmoid函数：<spanclass="math inline">\(f(x):=\frac{1}{1+e^{-x}}\)</span><ul><li>连续、光滑、严格单调，范围在(0,1)，S形非线性</li><li>导数始终小于1且不以0为对称轴</li><li>饱和类激活函数</li></ul></li><li>ReLU：<span class="math inline">\(f(x):=max(0,x)\)</span></li><li>Leaky ReLU：<span class="math inline">\(f(x):=\begin{cases}x,\quadx\ge0\\ax,\quad x\lt 0 \end{cases}\)</span><ul><li>若a遵循均匀分布随机采样，则为Randomized Leaky ReLU</li></ul></li></ul><p>ReLU都是非饱和类激活函数。</p><h2 id="感知机学习">2. 感知机学习</h2><p>最简单形式的前馈式人工神经网络。</p><p>二元线性分类器，使用特征向量作为输入，把矩阵上的输入x映射到输出值f(x)上（二元值）。</p><p>感知机学习算法</p><ol type="1"><li>权值初始化</li><li>输入样本对</li><li>计算输出</li><li>根据学习规则调整权重</li><li>继续输入下一对样本，循环至对所有样本的实际输出与期望输出相等</li></ol><p>学习规则：<span class="math inline">\(\Delta w_i=c(d-sign(\Sigmaw_i·x_i))x_i\)</span></p><ul><li>c是常数，表示学习率</li><li>d是期望的输出，值为1或-1</li><li>sign是感知机的输出，值为1或-1</li></ul><h2 id="线性可分性">3.线性可分性</h2><p>决策边界：</p><p>即不同决策的输入间的边界。</p><ul><li>鉴别函数</li><li>神经元激活阈值</li></ul><p>多分类决策边界：每个输出神经元定义一条决策边界。</p><p>感知机收敛理论：给定一个线性可分数据集，感知机将在有限次迭代中收敛到一个决策边界。</p><ul><li><p>设<spanclass="math inline">\(\gamma\)</span>是分离超平面与最接近的数据点之间的距离，则迭代次数的界是<spanclass="math inline">\(1/\gamma^2\)</span>。</p></li><li><p>感知机学习可以收敛的前提是训练样例必须线性可分，否则只能收敛到近似目标概念。</p></li></ul><p>感知机学习缺点：单层神经网络，不能解决非线性可分问题。</p><ul><li>异或</li></ul><p>感知机表达能力：n维实例空间的超平面决策。</p><ul><li>候选假设空间：所有可能的权向量的集合</li></ul><p>二层神经网络可以表达所有布尔函数</p><ul><li>广义布尔函数m-of-n：n个输入值至少有m个为真，则输出为真</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;两岸猿声啼不住，轻舟已过万重山。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_05_支持向量机</title>
    <link href="http://example.com/2023/11/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05_%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>http://example.com/2023/11/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05_%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</id>
    <published>2023-11-07T13:00:00.000Z</published>
    <updated>2024-06-21T07:31:17.212Z</updated>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="支持向量机">支持向量机</h1><p>20231031</p><p>18:30-21:20</p><p>20231107</p><p>18:30-21:20</p><p>从统计学的观点来看，机器学习的目的是得到映射：<spanclass="math inline">\(X\rightarrow Y\)</span></p><ul><li>类的先验概率：<span class="math inline">\(p(y=i)\)</span></li><li>样本的先验概率：<span class="math inline">\(p(x)\)</span></li><li>类的条件概率：<span class="math inline">\(p(x|y=i)\)</span></li><li>后验概率：<span class="math inline">\(p(y=i|x)\)</span></li></ul><p>统计机器学习方法从概率框架的角度粗略分类：</p><ul><li>生成式模型：估计<span class="math inline">\(p(x|y=i)\)</span>和<spanclass="math inline">\(p(y=i)\)</span>，用贝叶斯定理求<spanclass="math inline">\(p(y=i|x)\)</span></li><li>判别式模型：直接估计<span class="math inline">\(p(y=i|x)\)</span><ul><li>判别函数：不假设概率模型，直接求一个把各类分开的边界</li></ul></li></ul><h2 id="感知机">感知机</h2><h3 id="二分类">二分类</h3><p>二分类问题可以看作是在特征空间上对类别进行划分的任务。</p><p>线性超平面、线性可分</p><ul><li><p><spanclass="math inline">\(w^Tx+b=0\)</span>：划分超平面的线性方程</p><p><spanclass="math inline">\(w\)</span>为法向量，决定了超平面的方向；<spanclass="math inline">\(b\)</span>为位移量，决定了超平面和原点之间的距离</p><p><span class="math inline">\(f(x)=sign(w^Tx+b)\)</span></p></li></ul><h2 id="线性支持向量机">线性支持向量机</h2><h3 id="间隔与支持向量">间隔与支持向量</h3><p>一个点到分界超平面的垂直距离称为这个点对应的间隔（margin）：<spanclass="math inline">\(\frac{|f(x)|}{||w||}=\frac{|w^Tx+b|}{||w||}\)</span>。</p><p>具有最小间隔的点称为支持向量（supported vectors）。</p><p>支持向量机（supported vectormachine，SVM）最大化（所有训练样本的）最小间隔。</p><h3 id="分类与评价">分类与评价</h3><p><span class="math inline">\(f(\vec x)\gt0\)</span>则为正类，<spanclass="math inline">\(f(\vec x)\lt0\)</span>则为负类。</p><p><span class="math inline">\(y_i=\{-1,1\}\)</span>，<spanclass="math inline">\(y_if(\vec x_i)\gt0\)</span>为正确，<spanclass="math inline">\(y_if(\vec x_i)\lt0\)</span>为错误。</p><ul><li>假设能完全分开，且<spanclass="math inline">\(|y_i|=1\)</span>，那么<spanclass="math inline">\(y_if(\vec x_i)=|f(x_i)|\)</span></li></ul><h2 id="非线性支持向量机">非线性支持向量机</h2><p>将样本从原始空间映射到一个更高维的特征空间，使样本在这个特征空间内线性可分。</p><p>非线性核：RBF/高斯核、多项式核</p><h2 id="多类支持向量机">多类支持向量机</h2><p>1vs rest/1v1</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;两岸猿声啼不住，轻舟已过万重山。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_04_集成学习</title>
    <link href="http://example.com/2023/10/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/10/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-10-24T14:00:00.000Z</published>
    <updated>2024-06-21T07:29:11.712Z</updated>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="集成学习">集成学习</h1><h2 id="集成学习原理">集成学习原理</h2><h3 id="特点分类">特点（分类）</h3><p>多个分类器集成在一起，以提高分类准确率；</p><p>由训练数据构建基分类器，然后根据预测结果投票。</p><ul><li><p>集成学习本身不是一种分类器，而是一种分类器结合方法。</p></li><li><p>通常集成分类器性能会好于单个分类器。</p></li></ul><h4 id="例多数投票法结合">例：多数投票法结合</h4><p>每个二分类器的分类精度为p，则集成T个分类器的分类精度为<spanclass="math inline">\(\Sigma_{k=\frac{T}{2}+1}^T(_k^T)p^k(1-p)^{T-k}\)</span></p><ul><li>当<span class="math inline">\(p\gt0.5\)</span>且<spanclass="math inline">\(T\rightarrow\infty\)</span>时，上式<spanclass="math inline">\(\rightarrow 1\)</span></li></ul><h3 id="bias-variance-tradeoff问题">Bias-Variance tradeoff问题</h3><p>Bias：学习结果的期望和真实规律的差距</p><p><span class="math inline">\(Bias=E[\hat f(x)]-f(x)\)</span></p><p>Variance：学习结果自身的不稳定性</p><p><span class="math inline">\(Variance=E[(\hat f(x)-E[\hatf(x)])^2]\)</span></p><p>Total Error：以均方误差为例</p><p><spanclass="math inline">\(Err(x)=Bias^2+Variance+Random\,Error\)</span></p><h4 id="核心问题">核心问题</h4><p>序列集成（基学习器）法</p><ul><li>利用基学习器之间的依赖关系依次生成</li><li>减少偏差bias</li></ul><p>并行集成（基学习器）法</p><ul><li>利用基学习器之间的独立关系并行生成</li><li>减少方差variance</li></ul><p>问题：如何训练和结合每个学习器</p><h3 id="结合策略">结合策略</h3><p>平均法（回归问题）</p><ul><li>简单平均</li><li>加权平均</li></ul><p>投票法（分类问题）</p><ul><li>绝对多数</li><li>相对多数</li><li>加权投票</li></ul><p>学习法（Stacking）</p><h3 id="多样性策略学习基学习器">多样性策略（学习基学习器）</h3><p>数据层面</p><ul><li>输入样本的扰动，构建基学习器</li><li>输出样本的扰动，构建基学习器</li></ul><p>属性层面</p><ul><li>随机选择部分属性，构建基学习器</li></ul><p>参数层面</p><ul><li>算法模型参数的扰动，构建基学习器</li></ul><h2 id="bagging和随机森林">Bagging和随机森林</h2><h3 id="bagging">Bagging</h3><p>Bagging（Boosting aggregating）基本原理：</p><p>有放回采样方法。统计上的目的是得到统计量分布以及置信区间。</p><h4 id="bagging-算法流程">Bagging 算法流程</h4><p>输入：训练集S，基学习算法I，整数T（训练轮数/自助Bootstrap数）</p><p><span class="math inline">\(for\;i = 1\;to\;T\)</span> <spanclass="math inline">\(\{\)</span> <spanclass="math inline">\(S&#39;=从S中自助采样（有放回的独立采样）\)</span><span class="math inline">\(C_i=I(S&#39;)\)</span> <spanclass="math inline">\(\}\)</span></p><p><span class="math inline">\(C^*(x)=argmax_{y\inY}\Sigma_{i=1}^T(C_i(x)=y)\)</span></p><p>输出：分类器<span class="math inline">\(C^*\)</span></p><p>优点：</p><p>并行式集成学习，降低分类器方差，改善泛化。</p><ul><li>其性能依赖于基分类器的稳定性，若基分类器稳定，则其误差主要由基分类器bias决定</li><li>由于采样概率相同，bagging方法不侧重于任何特定实例</li><li>可以并行化处理，提高效率</li></ul><p>缺点：</p><ul><li>当基学习器具有高bias，集成之后也会具有较高bias</li><li>集成之后的模型会损失可解释性</li><li>依赖数据集，计算可能会比较昂贵</li></ul><p>代表性算法：随机森林（Random Forest，RF）</p><h3 id="随机森林">随机森林</h3><ol type="1"><li>训练用例的个数为N，特征数目为M，输入特征数目m以确定决策树上个结点的决策结果。<ul><li>m应远小于M。</li></ul></li><li>从N个训练样例中以有放回抽样的方式取样N次，形成一个训练集（即bagging取样），并用未抽到的用例作预测，评估其误差。</li><li>对于每一个结点，随机选择m个特征（通常为M的均方根<spanclass="math inline">\(log_2M\)</span>），根据这m个特征，计算其最佳的分裂方式。</li><li>每棵树都会完整成长而不会剪枝，这有可能在建完一棵正常树状分类器后会被采用。</li><li>以上过程做充分多次以产生足够多的随机树。</li></ol><p>特点：</p><ul><li>差异性：每棵树是不同的；每棵树使用的特征是不同的的</li><li>缓解维度灾难：每棵树没有使用全部特征，特征空间被减小了</li><li>可并行化：每棵树使用不同数据、不同特征，可以有效采用并行化技术</li><li>训练-测试划分：训练和测试的划分不是必须的，因为构建每棵决策树时，总有30%的数据没有采样</li><li>稳定性：通过多数投票或者平均，结果较为稳定</li></ul><h2 id="boosting">Boosting</h2><h3 id="概率近似正确pac学习理论">概率近似正确（PAC）学习理论</h3><p>强可学习：在PAC框架中，一个概念，如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这个概念是强可学习的。</p><p>弱可学习：在PAC框架中，一个概念，如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测略好，那么就称这个概念是弱可学习的。</p><p>PAC学习理论：</p><ul><li>强学习器和弱学习器是等价的</li><li>一个概念是强学习的充分必要条件是这个概念是弱可学习的</li><li>可以通过提升方法（Boosting）将弱学习器转为强学习器</li></ul><h3 id="boosting-1">Boosting</h3><p>代表性算法：Adaptive Boost（AdaBoost）</p><p>从弱学习算法出发，通过改变训练数据的概率（权值）分布，反复学习，得到一系列弱分类器，然后进行组合，构成一个强分类器。</p><p>策略：</p><ul><li>权值分布：提高那些被前一轮弱分类器错误分类样本的权值，降低那些被正确分类样本的权值。</li><li>弱分类器组合：采用加权多数表决策略；增加分类误差率小的弱分类器权重，减小分类误差率大的弱分类器权重。</li></ul><h3 id="adaboost">AdaBoost</h3><p>以分类问题为例：分类器的误差率和权重系数</p><p>AdaBoost采用加权表决。</p><p>AdaBoost算法的另一个解释：</p><ul><li><p>AdaBoost的模型为加法模型</p></li><li><p>AdaBoost的损失函数为指数函数：<spanclass="math inline">\(L(y,f(x))=exp[-yf(x)]\)</span></p></li><li><p>AdaBoost的学习算法为前向分步算法</p></li><li><p>AdaBoost的算法是一个二分类学习算法</p></li><li><p>AdaBoost的最终分类器：<spanclass="math inline">\(f(x)=\Sigma_{k=1}^K\alpha_kG_k(x_i)\)</span></p></li></ul><h4 id="加法模型">加法模型</h4><p><spanclass="math inline">\(f(x)=\Sigma_{m=1}^M\beta_mb(x;\gamma_m)\)</span></p><p>基函数（共M个）：<spanclass="math inline">\(b(x;\gamma_m)\)</span></p><p>基函数参数：<span class="math inline">\(\gamma_m\)</span></p><p>基函数系数：<span class="math inline">\(\beta_m\)</span></p><p>目标函数：<spanclass="math inline">\(min_{(\beta_m,\gamma_m)}\Sigma_{i=1}^NL(y_i,\Sigma_{m=1}^M\beta_mb(x_i;\gamma_m))\)</span></p><h4 id="前向分步算法">前向分步算法</h4><p>学习目标函数为加法模型，如果能够从前到后，每一步只学习一个基函数及其系数，逐步逼近要优化的总目标函数，就可以简化优化的复杂度。</p><p>输入：</p><ul><li>训练数据集<spanclass="math inline">\(T=\{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}\)</span>；</li><li>损失函数<span class="math inline">\(L(Y,f(x))\)</span>；</li><li>基函数集<span class="math inline">\(\{b(x;\gamma)\}\)</span></li></ul><p>输出：加法模型<span class="math inline">\(f(x)\)</span></p><ol type="1"><li>初始化<span class="math inline">\(f_0(x)=0\)</span></li><li>对<span class="math inline">\(m=1,2,...,M\)</span><ol type="1"><li>极小化损失函数得到<spanclass="math inline">\(\beta_m,\gamma_m\)</span>：<spanclass="math inline">\((\beta_m,\gamma_m)=argmin_{\beta,\gamma}\Sigma_{i=1}^NL(y_i,f_{m-1}(x_i)+\betab(x_i;\gamma))\)</span></li><li>更新：<spanclass="math inline">\(f_m(x)=f_{m-1}(x)+\beta_mb(x;\gamma_m)\)</span></li></ol></li><li>得到加法模型：<spanclass="math inline">\(f(x)=f_M(x)=\Sigma_{m=1}^M\beta_mb(x;\gamma_m)\)</span></li></ol><h3 id="提升树">提升树</h3><p>提升（Boosting）方法主要采用加法模型，即基函数的线性组合，与前向分步算法。</p><p>以决策树为基函数的提升方法称为提升树（boosting tree）。</p><ul><li><spanclass="math inline">\(f_M(x)=\Sigma_{m=1}^Mh_m(x)\)</span>，其中<spanclass="math inline">\(h_m(x)\)</span>表示决策树，<spanclass="math inline">\(M\)</span>为决策树个数</li></ul><h4 id="提升树算法流程">提升树算法流程</h4><p>回归问题</p><ol type="1"><li>初始化<span class="math inline">\(f_0(x)=0\)</span></li><li>对<span class="math inline">\(m=1,2,...,M\)</span><ol type="1"><li>计算<spanclass="math inline">\(argmin\Sigma_{i=1}^NL(y_i,f_{m-1}(x_i)+h_m(x_i))\)</span></li><li>得到<span class="math inline">\(h_m(x)\)</span></li><li>更新<spanclass="math inline">\(f_m(x)=f_{m-1}(x)+h_m(x)\)</span></li></ol></li><li>得到回归问题提升树：<spanclass="math inline">\(f_M(x)=\Sigma_{m=1}^Mh_m(x)\)</span></li></ol><p>当采用平方误差损失函数：<spanclass="math inline">\(L(y,f_{m-1}(x)+h_m(x))=(y-f_{m-1}(x)-h_m(x))^2=(r-h_m(x))^2\)</span></p><p>其中残差<span class="math inline">\(r=y-f_{m-1}(x)\)</span>。</p><p>可以拟合残差<spanclass="math inline">\(r_{m_i}\)</span>学习一个回归树，得到<spanclass="math inline">\(h_m(x)\)</span>。</p><p>推广到一般损失：第m轮第i个样本的负梯度作为残差的近似值：<spanclass="math inline">\(-[\frac{\partial L(y,f(x_i))}{\partialf(x_i)}]_{f=f_{m-1}}\)</span></p><h3 id="gbdt">GBDT</h3><p>Gradient Boosting Decision Tree，梯度提升树</p><h4 id="算法流程">算法流程</h4><ol type="1"><li>初始化弱分类器</li><li>循环<ol type="1"><li>对每个样本计算负梯度</li><li>构建新的样本集合</li><li>根据对树的约束，构建CART树</li><li>计算叶子区域最佳拟合值</li><li>更新得到强学习器</li></ol></li><li>得到最终强学习器</li></ol><p>回归问题</p><ol type="1"><li>初始化<spanclass="math inline">\(f_0(x)=argmin_\gamma\Sigma_{i=1}^NL(y_i,\gamma)\)</span></li><li>对<span class="math inline">\(m=1,2,...,M\)</span><ol type="1"><li>计算残差<span class="math inline">\(r_{mi}=-[\frac{\partialL(y,f(x_i))}{\partial f(x_i)}]_{f=f_{m-1}},i=1,2,...,N\)</span></li><li>残差<spanclass="math inline">\(rmi\)</span>拟合一个回归树，得到第m棵树的叶结点区域<spanclass="math inline">\(R_{mj},j=1,2,...,J\)</span></li><li>对<span class="math inline">\(j=1,2,...,J\)</span>计算<spanclass="math inline">\(Y_{mj}=argmin_c\Sigma_{x_i\inR_{mj}}L(y_i,f_{m-1}(x_i)+\gamma)\)</span></li><li>更新<spanclass="math inline">\(f_m(x)=f_{m-1}(x)+\Sigma_{j=1}^J\gamma_{mj}I(x\inR_{mj})\)</span></li></ol></li><li>得到回归问题提升树：<spanclass="math inline">\(f_M(x)=\Sigma_{m=1}^M\Sigma_{j=1}^J\gamma_{mj}I(x\inR_{mj})\)</span></li></ol><h3 id="xgboost">XGBoost</h3><p>Extreme Gradient Boosting</p><ul><li><p>GBDT的一种高效实现</p></li><li><p>目标函数通过二阶泰勒展开式做近似</p></li><li><p>定义了树的复杂度，并应用到目标函数中</p></li><li><p>分裂结点处通过结构打分和分割损失动态生长</p></li><li><p>分裂结点的候选集合通过一种分布式Quantile Sketch得到</p></li><li><p>可以处理稀疏、缺失数据</p></li><li><p>可以通过特征的列采样防止过拟合</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;两岸猿声啼不住，轻舟已过万重山。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_03_树学习</title>
    <link href="http://example.com/2023/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_%E6%A0%91%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-10-10T14:00:00.000Z</published>
    <updated>2023-11-02T12:04:30.865Z</updated>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="树学习">树学习</h1><p>20230926</p><p>18:30-21:30</p><p>20231010</p><p>18:30-21:30</p><h2 id="符号学习">符号学习</h2><p>推理的角度：</p><ul><li>演绎推理：<span class="math inline">\(P\rightarrowQ\)</span>，P为真则Q为真</li><li>反绎推理：<span class="math inline">\(P\rightarrowQ\)</span>，Q为真则P为真</li><li>归纳推理：P为真，Q未必为真</li></ul><p>符号（概念）学习是一类归纳推理。</p><h3 id="概念学习">概念学习</h3><p>给定样例集合，以及每个样例是否属于某个概念，自动地推断出该概念的一般定义。</p><h4 id="概念学习任务">概念学习任务</h4><ul><li>实例集合X</li><li>目标概念c：定义在实例集X上的布尔函数<spanclass="math inline">\(c:X\rightarrow\{0,1\}\)</span></li><li>训练样例：正例<spanclass="math inline">\((c(x)=1)\)</span>，反例<spanclass="math inline">\((c(x)=0)\)</span></li><li>假设集H：每个假设h表示X上定义的布尔函数<spanclass="math inline">\(h:X\rightarrow\{0,1\}\)</span></li></ul><p>概念学习：寻找一个假设h，使对于X中的所有x，<spanclass="math inline">\(h(x)=c(x)\)</span></p><p>归纳学习假设：任一假设如果在足够大的训练样例集合中能很好地逼近目标概念函数，它也能在未见实例中很好地逼近目标概念。</p><h4 id="作为搜索的概念学习">作为搜索的概念学习</h4><p>当假设的表示确定后，也就确定了概念学习算法所有假设的空间。</p><p>搜索的目标是为了寻找最好的拟合训练样例的假设。</p><p>搜索的操作：</p><ul><li>用逻辑变量替换常量</li><li>合取表达式去掉部分条件</li><li>对表达式增加析取项</li><li>用属性的超类来替换属性</li></ul><h4 id="假设的一般到特殊序">假设的一般到特殊序</h4><ul><li><p>更泛化</p><p><span class="math inline">\(令h_j和h_k是定义在X上的布尔函数，h_j\ge_gh_k即h_j更泛化于h_k\)</span></p><p><span class="math inline">\(当且仅当(\forall x\inX)[(h_k(x)=1)\rightarrow (h_j(x)=1)]\)</span></p></li><li><p>严格泛化：记为<spanclass="math inline">\(h_j\gt_gh_k\)</span></p></li><li><p>更特化：记为<spanclass="math inline">\(h_j\ge_sh_k\)</span></p></li></ul><h3 id="寻找极大特殊假设find-s">寻找极大特殊假设，Find-S</h3><ol type="1"><li><p>将h初始化为H中最特殊的假设</p></li><li><p>对每个正例x：</p><p>对h的每个属性约束，如果x满足，不处理；</p><p>否则将该约束替换为x满足的另一个最一般的约束</p></li><li><p>输出假设h</p></li></ol><p>对以属性合取式表示的假设空间，输出与正例一致的最特殊的假设。</p><h3id="列表消除算法list-then-eliminate">列表消除算法，List-Then-Eliminate</h3><ol type="1"><li>变型空间Version Space：假设空间H中所有假设的列表</li><li>对每个样例<spanclass="math inline">\(&lt;x,c(x)&gt;\)</span>，从变型空间中移除<spanclass="math inline">\(h(x)\neq c(x)\)</span>的假设h</li><li>输出变型空间中的假设列表</li></ol><p>要列出所有假设，在实际中往往不可能。</p><h2 id="变型空间">变型空间</h2><p>一致：一个假设h与训练样例集合D一致，当且仅当<spanclass="math inline">\(Consistent(h,D)\equiv(\forall&lt;x,c(x)&gt;\inD)\quad h(x)=c(x)\)</span>。</p><p>变型空间（Version Space）：</p><p>关于假设空间H和训练样例集合D的变型空间，是H中与训练样例D一致的所有假设构成的子集。<spanclass="math inline">\(VS_{H,D}\equiv\{h\inH|Consistent(h,D)\}\)</span></p><ul><li><p>极大泛化：H中和D一致的极大一般成员的集合</p><p><span class="math inline">\(G\equiv\{g\inH|Consistent(g,D)\and(\neg\exist g&#39;\in H[(g&#39;\gt_g g)\andConsistent(g&#39;,D)])\}\)</span></p></li><li><p>极大特化：H中和D一致的极大特殊成员的集合</p><p><span class="math inline">\(S\equiv\{s\inH|Consistent(s,D)\and(\neg\exist s&#39;\in H[(s\gt_s s&#39;)\andConsistent(s&#39;,D)])\}\)</span></p></li></ul><h3 id="表示定理">表示定理</h3><p>令X为任意的实例集合，H为X上定义的布尔函数集合。令<spanclass="math inline">\(c:X\rightarrow[0,1]\)</span>为X上定义的任一目标概念，并令D为任意训练样例的集合<spanclass="math inline">\(\{&lt;x,c(x)&gt;\}\)</span>。对所有的X，H，c，D以及良好定义的S和G：<spanclass="math inline">\(VS_{H,D}\equiv\{h\in H|(\exist s\in S)(\exist g\inG)[g\gt_g h\gt_s s]\}\)</span></p><ul><li>其中G为极大泛化集合，S为极大特化集合。</li></ul><h3 id="正例和反例的作用">正例和反例的作用</h3><p>正例用于S泛化，搜索S集合；反例用于G特化，缩小G集合。</p><p>反例对于超泛化具有抑制作用。</p><h3 id="候选消除算法">候选消除算法</h3><p>将G集合初始化为H中最一般的假设：<spanclass="math inline">\(G_0=\{&lt;?,...,?&gt;\}\)</span></p><p>将S集合初始化为H中最特殊的假设：<spanclass="math inline">\(S_0=\{&lt;\empty,...,\empty&gt;\}\)</span></p><p>对每个训练样例d，</p><ul><li><p>如果d是正例：</p><ul><li><p>从G中移去所有与d不一致的假设</p></li><li><p>对S中每一个与d不一致的假设s：</p><ul><li><p>从S中移除s</p></li><li><p>把s的所有极小泛化假设h加入到S中</p><p>h满足与D一致，而且G中某个成员比h更一般</p></li><li><p>从S中移去所有比S中另一假设更一般的假设</p></li></ul></li></ul></li><li><p>如果d是反例：</p><ul><li><p>从S中移去所有和d不一致的假设</p></li><li><p>对G中每一个与d不一致的假设g：</p><ul><li><p>从G中移除g</p></li><li><p>把g的所有极小特化假设h加入到G中</p><p>h满足与D一致，而且S中某个成员比h更特殊</p></li><li><p>从G中移去所有比G中另一假设更特殊的假设</p></li></ul></li></ul></li></ul><h3 id="归纳偏置">归纳偏置</h3><p>归纳推理的根本问题：</p><ul><li>目标概念假设不在假设空间怎么办？</li><li>能设计包含所有假设的空间吗？</li><li>假设空间大小对未见实例的泛化能力有什么影响？</li><li>假设空间大小对所需训练样例数量有什么影响？</li></ul><p>假设空间往往是合取的有偏表示，而真实空间是析取的无偏表示。</p><p>无偏学习的无用性：</p><p>无偏学习需要X中所有实例进行训练，无法进行泛化，变型空间和候选消除算法失效。</p><p>因此，归纳学习必须给定某种形式的预先假定，即归纳偏置。</p><ul><li><p>核心：学习器从训练样例中泛化并推断新实例分类过程中所采用的策略</p></li><li><p>精确定义：</p><ul><li><p>给定任意训练数据<spanclass="math inline">\(D_c=\{x,c(x)\}\)</span>，目标概念c，学习算法L</p></li><li><p>推断新实例性<span class="math inline">\(x_i\)</span></p></li><li><p>归纳推理过程为：</p><p><span class="math inline">\((D_c\and x_i)\rightarrowL(x_i,D_c)\)</span></p><p><span class="math inline">\((B\and D_c\and x_i)\vdashL(x_i,D_c)\)</span></p></li></ul><p>学习器的归纳偏置为附加的前提集合B，通过B，则归纳推理可由演绎推理派生</p></li></ul><h4 id="有偏性">有偏性</h4><ul><li>无归纳偏置</li><li><span class="math inline">\(c\in H\)</span></li><li><span class="math inline">\(c\inH\)</span>且任何实例，除非可由其他先验推出，否则为反例</li></ul><p>有偏性越强，则学习器的归纳能力越强。</p><p>有偏程度不同的三种归纳学习算法：</p><ul><li>机械式学习器</li><li>候选消除算法</li><li>Find-S</li></ul><h2 id="决策树学习">决策树学习</h2><ul><li><p>实例：“属性-值”对表示，应用最广的归纳推理算法之一</p></li><li><p>目标函数具有离散的输出值</p></li><li><p>很好的健壮性（样例可以包含错误，也可以处理缺少属性值的实例）</p></li><li><p>能够学习析取表达式</p></li></ul><p>决策树学习算法：</p><ul><li>ID3、Assistant、C4.5</li><li>搜索一个完整表示的假设空间，表示为多个if-then规则</li></ul><p>归纳偏置：优先选择较小的树</p><h3 id="算法框架">算法框架</h3><p>问题设置：</p><ul><li>可能的实例集X</li><li>未知的目标函数<span class="math inline">\(f:X\rightarrowY\)</span></li><li>假设函数集<span class="math inline">\(H=\{h|h:X\rightarrowY\}\)</span></li></ul><p>输入：未知目标函数f的训练样例<spanclass="math inline">\(\{&lt;x_i,y_i&gt;\}\)</span></p><p>输出：最佳近似f的假设<span class="math inline">\(h\in H\)</span></p><p>算法框架：</p><ol type="1"><li>处理基本情况</li><li>寻找最好的分类属性A</li><li>用A建立一个节点划分样例</li><li>递归处理每一个划分作为其子节点/子树</li></ol><h3 id="假设空间搜索">假设空间搜索</h3><p>搜索的假设空间就是可能的决策树的集合。</p><p>从一个假设空间中搜索一个正确拟合训练样例的假设。</p><p>从简单到复杂的爬山算法遍历假设空间。从空的树开始，然后逐步考虑更加复杂的假设。引导爬山搜索的评估函数是信息增益度量。</p><h3 id="如何选择最佳属性">如何选择最佳属性</h3><p>衡量给定的属性区分训练样例的能力：信息增益</p><p>信息的度量：熵，刻画了样例集合的纯度。</p><ul><li><p>目标属性为布尔值的样例集S的熵：</p><p><spanclass="math inline">\(Entropy(S)=-p_+log_2p_+-p_-log_2p_-\)</span></p><p>其中，<span class="math inline">\(p_+\)</span>为正例的概率，<spanclass="math inline">\(p_-\)</span>为反例的概率。</p></li><li><p>熵的一般定义：</p><p><spanclass="math inline">\(Entropy(S)=\Sigma_{i=1}^c(-p_ilog_2p_i)\)</span></p></li></ul><p>信息增益：使用属性分割样例，导致期望熵降低</p><p><span class="math inline">\(Gain(S,A)=Entropy(S)-\Sigma_{v\inValues(A)}\frac{|S_v|}{S}Entropy(S_v)\)</span></p><ul><li><p>其中<spanclass="math inline">\(Values(A)\)</span>是属性A所有可能值的集合</p></li><li><p><spanclass="math inline">\(S_v\)</span>是S中属性A的值为v的子集，即<spanclass="math inline">\(S_v=\{s\in S|A(s)=v\}\)</span></p></li><li><p>第二项是用A分类S后熵的期望值</p></li></ul><h3 id="用于学习布尔函数的id3算法">用于学习布尔函数的ID3算法</h3><p><span class="math inline">\(ID3(Examples,Attributes)\)</span></p><ol type="1"><li><p>创建树的Root结点</p></li><li><p>如果Examples的目标属性均为正，则返回label=+的单结点树Root</p></li><li><p>如果Examples的目标属性均为反，那么返回label=-的单结点树Root</p></li><li><p>如果Attributes为空，那么返回单结点树Root，label设置为Examples中最普遍的目标属性值</p></li><li><p>否则</p><ul><li><p><span class="math inline">\(A\leftarrowAttributes中分类Examples能力最好的属性\)</span></p></li><li><p><span class="math inline">\(Root的决策属性\leftarrowA\)</span></p></li><li><p><span class="math inline">\(对于A的每个可能值v_i\)</span></p><ul><li><p><spanclass="math inline">\(令Examples_{v_i}为Examples中满足A属性值为v_i的子集\)</span></p></li><li><p><span class="math inline">\(如果Examples_{v_i}为空\)</span></p><ul><li><p><spanclass="math inline">\(在这个分支下加一个叶子结点，\)</span></p><p><spanclass="math inline">\(结点的label设置为Examples中最普遍的目标属性值\)</span></p></li></ul></li><li><p><spanclass="math inline">\(否则，在这个分支下加一个子树ID3(Examples_{v_i},Attributes-\{A\})\)</span></p></li></ul></li></ul></li><li><p>结束，返回树Root</p></li></ol><h4 id="id3算法特点">ID3算法特点</h4><p>假设空间：包含所有的决策树</p><p>遍历过程：仅维持单一的当前假设</p><ul><li>变型空间候选消除算法维持满足训练样例的所有假设</li></ul><p>不进行回溯，局部最优</p><p>基于统计，对错误样例不敏感，不适用于增量处理。</p><p>改进算法：C4.5等。</p><h3 id="决策树学习中的归纳偏置">决策树学习中的归纳偏置</h3><p><span class="math display">\[ 搜索策略决定了归纳偏置\begin{cases}近似：优先选择较短的树\\ 有限选择信息增益高的属性更接近根结点的树\end{cases}\]</span></p><h3 id="奥卡姆剃刀原理">奥卡姆剃刀原理</h3><p>如果对于同一现象有两种不同的假说，应该采取比较简单的那一种。</p><ul><li>不是简单的选择最简化的假设，而是推理所依据的是使可证伪的假设的数目更少。</li></ul><h2 id="其他树算法">其他树算法</h2><h3 id="c4.5算法">C4.5算法</h3><p>属性选择指标：</p><p>信息增益率：信息增益/该属性的熵</p><ul><li>信息增益准则对可取值数目较多的属性有所偏好</li><li>避免对取值数目较少的属性有所偏好，采用以下启发式：<ul><li>先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的</li></ul></li></ul><h3 id="cart算法">CART算法</h3><h4 id="属性选择指标分类">属性选择指标（分类）</h4><p>信息增益和增益率准则均需要计算对数。</p><p>基尼指数：模型的纯度，越小纯度越高。</p><ul><li><p>K个分类：<spanclass="math inline">\(Gini(p)=\Sigma_{k=1}^K(1-p_k)p_k=1-\Sigma_{k=1}^Kp_k^2\)</span></p></li><li><p>数据集D：<spanclass="math inline">\(Gini(D)=1-\Sigma_{k=1}^K(\frac{C_k}{D})^2\)</span></p></li><li><p>属性A对数据集的划分：<spanclass="math inline">\(Gini(D,A)=\frac{|D_1|}{D}Gini(D_1)+\frac{|D_2|}{D}Gini(D_2)\)</span></p></li><li><p>基尼指数和熵是正相关的，均可用来表示一个集合的混乱程度，并作为叶子结点的损失</p></li></ul><h4 id="属性选择指标回归">属性选择指标（回归）</h4><p>采用方差和度量。</p><p>度量目标是对于划分特征A，对应划分点s两边的数据集<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>，求出使<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>各自集合的均方差最小，同时<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>的均方差之和最小。</p><p><span class="math inline">\(min_{A,s}[min_{c_1}\Sigma_{x_i\inD_1(A,s)}(y_i-c_i)^2+min_{c_2}\Sigma_{x_i\inD_2(A,s)}(y_i-c_2)^2]\)</span></p><p>回归树输出不是类别，采用叶子结点的均值或者中位数来预测输出结果。</p><h4 id="连续值处理">连续值处理</h4><p>连续特征离散化：</p><ul><li>C4.5基于信息增益率离散化，CART基于基尼系数离散化</li><li>m个样本的连续特征A有m个，从小到大排列<spanclass="math inline">\(a_1,...,a_m\)</span>，则CART取相邻两样本值的平均数做划分点，一共取m-1个，其中第i个划分点<spanclass="math inline">\(T_i\)</span>表示为：<spanclass="math inline">\(T_i= (a_i+a_{i+1})/2\)</span>。<ol type="1"><li>分别计算以这m-1个点作为二元分类点时的基尼系数。</li><li>选择基尼系数最小的点为该连续特征的二元离散分类点。</li><li>如取到的基尼系数最小的点为<spanclass="math inline">\(a_t\)</span>，则小于<spanclass="math inline">\(a_t\)</span>的值为类别1；大于<spanclass="math inline">\(a_t\)</span>的值为类别2，这样就做到了连续特征的离散化。</li></ol></li></ul><h4 id="离散值处理">离散值处理</h4><p>CART分类树算法：对离散值的处理，采用不停地二分离散特征。</p><ul><li><p>多叉树：在ID3、C4.5，特征A被选中，如果它有3个取值<spanclass="math inline">\(A_1,A_2,A_3\)</span>，则建立三叉子树</p></li><li><p>二叉树：</p><ul><li>CART将特征A分成<span class="math inline">\(\{A_1\}\)</span>和<spanclass="math inline">\(\{A_2,A_3\}\)</span>、<spanclass="math inline">\(\{A_2\}\)</span>和<spanclass="math inline">\(\{A_1,A_3\}\)</span>、<spanclass="math inline">\(\{A_3\}\)</span>和<spanclass="math inline">\(\{A_1,A_2\}\)</span>三种情况，找到基尼系数最小的组合，比如<spanclass="math inline">\(\{A_2\}\)</span>和<spanclass="math inline">\(\{A_1,A_3\}\)</span>，然后建立二叉树节点。</li><li>由于并没有把特征A的取值完全分开，后面还有机会对子节点继续选择特征A划分<spanclass="math inline">\(A_1\)</span>和<spanclass="math inline">\(A_3\)</span>。</li></ul></li></ul><h4 id="剪枝处理">剪枝处理</h4><p>后剪枝：从完全生长的决策树的底端剪去一些子树，使决策树变小，从而增强泛化能力。</p><ul><li>首先从生成算法产生的决策树<spanclass="math inline">\(T_0\)</span>底端开始不断剪枝，直到<spanclass="math inline">\(T_0\)</span>的根节点，形成一个子序列<spanclass="math inline">\(T_0,...,T_n\)</span></li><li>然后通过交叉验证在独立的验证集上对子树序列进行测试，从中选择最优子树。</li></ul><p>最小化子树的损失函数：<spanclass="math inline">\(C_a(T)=C(T)+a|T|\)</span></p><ul><li>T为任意子树，C(T)为对数据的预测误差（如基尼系数），|T|为子树叶结点个数。超参<spanclass="math inline">\(a\ge0\)</span>，权衡训练数据的拟合程度与模型的复杂度。</li><li>a比较大，则最优子树<span class="math inline">\(T_a\)</span>偏小</li><li>a比较小，则最优子树<span class="math inline">\(T_a\)</span>偏大</li><li>a=0，则最优子树等于未剪枝的<spanclass="math inline">\(T_0\)</span></li><li>a趋近于∞，则最优子树为根结点树</li></ul><h2 id="树学习算法优缺点">树学习算法优缺点</h2><h3 id="优点">优点</h3><ul><li><p>简单直观，可解释性强。</p></li><li><p>基本不需要预处理，也不需要提前归一化和处理缺失值。既可以处理离散值也可以处理连续值。不过很多算法只是专注于离散值或者连续值。</p></li><li><p>可以处理多维度输出的分类问题。</p></li><li><p>使用决策树预测的代价为<spanclass="math inline">\(O(log_2m)\)</span>，m为样本数。</p></li><li><p>可以交叉验证的剪枝来选择模型，从而提高泛化能力。</p></li><li><p>对于异常点的容错能力好，健壮性高。</p></li></ul><h3 id="缺点">缺点</h3><ul><li><p>树算法非常容易过拟合，导致泛化能力不强（设置节点最少样本树、限制树深度）</p></li><li><p>样本的一点变动会导致树结构的剧烈改变（集成学习）</p></li><li><p>寻找最优决策树是NP难题，通过启发式方法容易陷入局部最优（集成学习）</p></li><li><p>比较复杂的关系，决策树很难学习（使用其他学习方法）</p></li><li><p>如果某些特征的样本比例过大，生成决策树比较容易偏向于这些特征（调节样本权重）</p></li></ul><h3 id="延伸">延伸</h3><ul><li><p>BAIR博客地址：https://bair.berkeley.edu/blog/2020/04/23/decisions/</p></li><li><p>论文地址：https://arxiv.org/abs/2004.00221</p></li><li><p>开源项目地址：https://github.com/alvinwan/neu</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;两岸猿声啼不住，轻舟已过万重山。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_02_无监督学习</title>
    <link href="http://example.com/2023/09/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/09/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-09-17T14:00:00.000Z</published>
    <updated>2023-11-02T12:02:56.540Z</updated>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="无监督学习">无监督学习</h1><p>20230912</p><p>20:10-21:10</p><p>20230917</p><p>18:30-21:10</p><p>聚类算法 Clustering Algorithm</p><p>聚类的“好坏”不存在绝对标准。</p><h2 id="大纲">大纲</h2><ul><li>相关概念</li><li>距离度量</li><li>聚类准则</li><li>聚类方法</li><li>聚类评价</li></ul><h2 id="相关概念">相关概念</h2><p>聚类：数据对象的集合</p><ul><li>在同一个类里，数据对象是相似的</li><li>不同类的数据对象是不相似的</li></ul><p>聚类算法：根据给定的相似性评判标准，将一个数据集合划分为几个聚类。</p><ul><li><p>数学形式化：</p><p>样本集合：<span class="math inline">\(D=\{x_1,x_2,...,x_m\},x_i\inR^d\)</span></p><p>聚类成k个簇：<span class="math inline">\(\{C_l|l=1,2,...,k\}\)</span></p></li><li><p>好的聚类算法：聚类内部高相似，聚类之间低相似。</p></li></ul><p>聚类的依据：将整个数据集中每个样本的特征向量看成是分布在特征空间中的一些点，点与点之间的距离即可作为相似性度量依据。</p><p>聚类方法目的：寻找数据中潜在的自然分组结构、感兴趣的关系。</p><p>聚类方法的有效性和数据分布形式有很大关系。</p><h2 id="距离度量">距离度量</h2><p>目的：度量同类样本间的相似性或不同样本间的差异性</p><h3 id="度量函数和度量空间">度量函数和度量空间</h3><h3 id="常用度量函数">常用度量函数</h3><p>闵可夫斯基距离</p><h2 id="聚类准则">聚类准则</h2><h3 id="类的定义">类的定义</h3><h3 id="试探方法">试探方法</h3><p>凭直观感觉或方法，针对实际问题定义一种距离度量的阈值，然后按最近邻规则制定某些样本属于一个聚类类别。</p><h3 id="聚类准则函数方法">聚类准则函数方法</h3><h2 id="聚类方法">聚类方法</h2><ul><li>基于试探的聚类搜索算法</li><li>系统聚类法</li><li>动态聚类法</li></ul><h3 id="基于试探的聚类搜索算法">基于试探的聚类搜索算法</h3><h4 id="按最近邻规则的简单试探法">按最近邻规则的简单试探法</h4><p>选用不同的阈值和起始点来试探。</p><p>依赖于以下因素：</p><ul><li>第一个聚类中心的位置</li><li>待分类样本的排序次序</li><li>距离阈值T的大小</li><li>样本分布的几何性质</li></ul><h4 id="最大最小距离算法">最大最小距离算法</h4><p>基本思想：以试探类间欧式距离为最大作为预选出聚类中心的条件。</p><ol type="1"><li>任选一个样本作为第一个聚类中心</li><li>选距离其最远的样本为第二个聚类中心</li><li>逐个计算各样本与两个聚类中心间距离，并选取其中较小值</li><li>在所有较小值中选出最大距离，若该最大值达到一定阈值，则选取相应样本点为迪桑聚类中心</li><li>重复3、4步，若无新聚类中心，进入下一步</li><li>不同样本按最近距离分到最近的聚类中心</li><li>最后，在每一类中计算各样本均值以得到更具代表性的聚类中心。</li></ol><h3 id="系统聚类法">系统聚类法</h3><p>基本思想：</p><p>将数据样本按距离准则逐步分类，类别有多到少，直到获得合适的分类要求为止。</p><h4 id="距离准则函数">距离准则函数</h4><ul><li>最短距离（两个集合所有距离最小值）</li><li>最长距离（两个集合所有距离最大值）</li><li>类平均距离（两个集合所有距离平均值）</li></ul><h3 id="动态聚类法">动态聚类法</h3><p>基本思想：</p><p>首先选择若干个样本点作为聚类中心，再按某种聚类准则使样本点向各中心聚集，从而得到初始聚类；然后判断初始分类是否合理，若不合理，则修改聚类，如此反复，直至合理。</p><p>代表算法：K-means算法和ISODATA算法（迭代自组织数据分析算法）</p><h4 id="k-means算法">K-means算法</h4><ol type="1"><li>选择一个聚类数量k</li><li>初始化聚类中心<ul><li>随机选择k个样本点，设置这些样本点为中心</li></ul></li><li>对每个样本点，计算样本点到k个聚类中心的距离，将样本点分距离它最近的聚类中心所属的聚类</li><li>重新计算聚类中心，聚类中心为属于这一聚类的所有样本的均值</li><li>如果没有发生样本所属的聚类改变的情况则退出，否则，返回第三步重复</li></ol><p>K-means算法的结果影响因素：</p><ul><li>所选聚类数目</li><li>聚类中心的初始分布</li><li>样本分布的几何性质</li></ul><p>在实际应用中，需要试探不同的K值和选择不同的聚类中心的起始值。</p><p>如果数据样本可以形成若干个相距较远的孤立区域分布，一般都能得到较好的收敛效果。</p><ul><li>K-means算法比较适合于分类数目已知的情况。</li></ul><h5 id="k-means">K-means++</h5><p>基本思想：K个初始聚类中心相互之间应该分得越开越好</p><ol type="1"><li>从数据集中随机选取一个样本作为初始聚类中心</li><li>首先计算每个样本与当前已有聚类中心之间的最短距离（即与最近的一个聚类中心的距离），用D(x)表示；接着计算每个样本被选为下一个聚类中心的概率<spanclass="math inline">\(\frac{D(x)^2}{\Sigma_{x\inX}D(x)^2}\)</span>，最后，按轮盘法选择下一个聚类中心</li><li>重复第2步选择出共K个聚类中心</li><li>K-means中第3步至第5步</li></ol><h4 id="迭代自组织数据分析算法-isodata">迭代自组织数据分析算法ISODATA</h4><p>基本步骤与思路：</p><ol type="1"><li>选择某些初始值，可选不同的参数，也可在迭代过程中人为修改，以将N个样本按指标分配到各个聚类中心去</li><li>计算各类中诸样本的距离指标函数</li><li>按给定的要求，将前一次获得的聚类集合进行分裂和合并处理，从而获得新的聚类中心</li><li>重新进行迭代运算，计算各项指标，判断聚类结果是否符合要求。经过多次迭代后，若结果收敛，则运算结束。</li></ol><p>具体过程（运行中能够根据各个类别的实际情况进行分裂和合并来调整聚类中心数）：</p><ol type="1"><li>从数据集中随机选取<spanclass="math inline">\(K_0\)</span>个样本作为聚类中心<spanclass="math inline">\(C=\{c_1,...,c_{K_0}\}\)</span></li><li>针对数据集中每个样本<spanclass="math inline">\(x_i\)</span>，计算它到<spanclass="math inline">\(K_0\)</span>个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中</li><li>判断上述每个类中的元素数目是否小于<spanclass="math inline">\(N_{min}\)</span>。如果小于<spanclass="math inline">\(N_{min}\)</span>则需要丢弃该类，令<spanclass="math inline">\(K=K-1\)</span>，并将该类中的样本重新分配给剩下类中距离最小的类</li><li>针对每个类别<spanclass="math inline">\(c_i\)</span>，重新计算它的聚类中心$c_i=_{xc_i}x</li><li>如果当前<spanclass="math inline">\(K\le\frac{K_0}{2}\)</span>，说明当前类别太少，前往分裂</li><li>如果当前<span class="math inline">\(K\ge2K_0\)</span>，说明当前类别太多，前往合并</li><li>如果达到最大迭代次数则终止，否则返回第2步继续执行</li></ol><p>合并</p><ol type="1"><li><p>计算当前所有类别聚类中心两两之间的距离，用矩阵D表示，其中<spanclass="math inline">\(D(i,i)=0\)</span></p></li><li><p>对于<span class="math inline">\(D(i,j)\lt d_{min}(i\neqj)\)</span>的两个类别需要进行合并操作，变成一个新的类，该类的聚类中心位置为<spanclass="math inline">\(m_{new}=\frac{1}{n_i+n_j}(n_im_i+n_jm_j)\)</span></p><p>上述<span class="math inline">\(n_i\)</span>和<spanclass="math inline">\(n_j\)</span>表示这两个类别中样本的个数，新的聚类中心可以看作对这两个类别进行加权求和。如果其中一个类所包含的样本个数较多，所合成的新类就会更加偏向它。</p></li></ol><ul><li><spanclass="math inline">\(d_{min}\)</span>：两个类别对应聚类中心之间所允许最小距<spanclass="math inline">\(d_{min}\)</span>，是否进行合并的阈值</li></ul><p>分裂</p><ol type="1"><li><p>计算每个类别下所有样本在每个维度下的方差</p></li><li><p>针对每个类别的所有方差挑选出最大的方差<spanclass="math inline">\(\sigma_{max}\)</span></p></li><li><p>如果某个类别的<span class="math inline">\(\sigma_{max}\gtSigma\)</span>并且该类别所包含的样本数量<spanclass="math inline">\(n_i\ge2n_{min}\)</span>，则可以进行分裂操作4，否则退出</p></li><li><p>将满足步骤3中的类分裂成两个子类别并令<spanclass="math inline">\(K=K+1\)</span></p><p><spanclass="math inline">\(m_i^{(+)}=m_i+\sigma_{max},m_i^{-}=m_i-\sigma_{max}\)</span></p></li></ol><ul><li>最大方差Sigma</li></ul><h4 id="两个算法的比较">两个算法的比较</h4><ul><li>K-means算法通常适合于类别数目已知的聚类，而ISODATA算法则更加灵活</li><li>从算法角度看，两者相似，聚类中心都是通过样本均值的迭代计算决定</li><li>ISODATA算法加入了一些试探步骤，并且可以结合人机交互的结构，使其能利用中间结果所取得的经验更好地进行分类</li><li>ISODATA原理直观，但需要更多参数，并且某些参数很难确定，因此ISODATA算法实际过程中并没有很受欢迎</li></ul><h2 id="聚类评价">聚类评价</h2><p>几个评价指标：</p><ul><li>聚类中心之间的距离</li><li>聚类域中的样本数目</li><li>聚类域内样本的距离方差</li></ul><p>聚类目前还没有一种通用的准则，往往需要根据实际应用来选择合适的方法。</p><h3 id="常用评价指标标签未知">常用评价指标（标签未知）</h3><h4 id="紧密度compactnesscp">紧密度（Compactness，CP）</h4><p><spanclass="math inline">\(\overline{CP}=\frac{1}{K}\Sigma_{k=1}^K\overline{CP_k}\)</span></p><p>缺点：没有考虑类间聚类效果。</p><h4 id="间隔度separationsp">间隔度（Separation，SP）</h4><p><spanclass="math inline">\(\overline{SP}=\frac{2}{k^2-k}\Sigma_{i=1}^k\Sigma_{j=i+1}^k||w_i-w_j||_2\)</span></p><p><span class="math inline">\(w_i\)</span>表示第i簇的中心，<spanclass="math inline">\(w_j\)</span>表示第j簇的中心，<spanclass="math inline">\(\overline{SP}\)</span>值越大类间越分散。</p><p>缺点：没有考虑类内聚类效果</p><h4 id="davies-bouldin-indexdbi分类适确性指标">Davies-BouldinIndex(DBI)，分类适确性指标</h4><p><span class="math inline">\(DB=\frac{1}{k}\Sigma_{i=1}^kmax_{j\neqi}(\frac{\overline{C_i}+\overline{C_j}}{||w_i-w_j||_2})\)</span></p><p><spanclass="math inline">\(\overline{C_i}\)</span>表示第i簇的紧密度，<spanclass="math inline">\(w_i\)</span>表示第i簇的中心。</p><p>DB越小，表示类内越紧凑，类间越分散，</p><p>缺点：使用欧式距离，对于环状分布聚类评价很差</p><h4 id="dunn-validity-indexdvi邓恩指数">Dunn ValidityIndex(DVI)，邓恩指数</h4><p>缺点：对离散点的聚类评价高，对环状分布评价效果差</p><h3 id="常用评价指标标签已知">常用评价指标（标签已知）</h3><ul><li>Cluster Accuracy，CA，聚类准确率</li><li>Rand Index，RI，兰德指数</li><li>Adjusted Rand Index，ARI，调整兰德指数</li><li>Mutual Information，MI，互信息</li><li>Normalized Mutual Information，NMI，归一化互信息</li></ul><h2 id="前沿进展">前沿进展</h2><p>监督深度学习：</p><ol type="1"><li>收集大量具有差异性的样本</li><li>对数据进行清洗和精细标注</li><li>采用多块显卡长时间训练</li></ol><p>监督深度学习的困境：</p><ul><li>数据体量大</li><li>数据标注时间长</li><li>数据标注代价高</li></ul><p>现实中，获取原始未标注数据较容易，而典型的监督学习技术不能利用这些数据；</p><p>监督信号有时候会使得深度模型有偏。</p><h3 id="自监督学习">自监督学习</h3><p>无监督学习的一种形式，其中数据没有提供（人类标注的）监督信息。</p><ul><li>通常需要定义一个前置任务让网络学习我们关心的事情。</li><li>对于大部分前置任务，我们需要保留一部分数据，让网络学会预测。</li><li>从前置任务学习到的特征会被用到不同的下游任务（通常包含标注）</li></ul><p>自监督预训练：</p><ul><li>无标注数据</li><li>前置任务预训练</li></ul><p>下游任务迁移：</p><ul><li>有标签数据</li><li>训练测试数据集可不同</li><li>多种下游任务测试</li></ul><h4 id="自监督学习分类">自监督学习分类</h4><ul><li>前置任务学习</li><li>对比学习</li><li>非对比学习</li></ul><h4 id="前置任务学习">前置任务学习</h4><ul><li><p>生成式方法——图像着色</p></li><li><p>生成式方法——图像修复</p></li><li><p>判别式方法——图像拼图</p></li></ul><h4 id="对比学习">对比学习</h4><h4 id="非对比学习">非对比学习</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;两岸猿声啼不住，轻舟已过万重山。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
</feed>
