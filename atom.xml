<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Geternitier的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-06-20T01:53:09.218Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Geternitier</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/06/19/SEII%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2023/06/19/SEII%E5%A4%8D%E4%B9%A0/</id>
    <published>2023-06-19T12:08:57.095Z</published>
    <updated>2023-06-20T01:53:09.218Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">title</span>: SEII-期末复习<br><span class="hljs-attribute">date</span>: <span class="hljs-number">2023</span>-<span class="hljs-number">6</span>-<span class="hljs-number">19</span> <span class="hljs-number">12</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><h1 id="seii复习">SEII复习</h1><span id="more"></span><ul><li>软件需求工程</li><li>软件设计</li><li>软件构造</li><li>软件测试</li><li>软件交付</li><li>软件维护</li></ul><h2 id="包的原则">包的原则</h2><ul><li>重用发布等价原则（REP）</li><li>共同封闭原则（CCP）</li><li>共同重用原则（CRP）</li><li>无环依赖原则（ARP）</li><li>稳定依赖原则（SDP）</li><li>稳定抽象原则（SAP）</li></ul><h2 id="人机交互">人机交互</h2><h3 id="人机交互设计原则">人机交互设计原则</h3><ul><li><p>简洁</p></li><li><p>一致性</p></li><li><p>低出错</p></li><li><p>易记性</p></li><li><p>可视化</p></li><li><p>导航</p></li><li><p>反馈</p></li><li><p>差异性</p></li></ul><h2 id="耦合和内聚">耦合和内聚</h2><h3 id="耦合">耦合</h3><p>从高到低，越低越好，1、2、3不可接受</p><ol type="1"><li>内容耦合：一个模块直接修改另一个模块的内容</li><li>公共耦合：全局变量、文件、设备</li><li>重复耦合：重复代码</li><li>控制耦合：一个模块给其他模块传递控制信息</li><li>印记耦合：共享数据结构却只使用一部分</li><li>数据耦合：模块间传参只传需要的数据，最理想</li></ol><h3 id="内聚">内聚</h3><p>从高到低，越低越差，6、7不能接受</p><ol type="1"><li>信息内聚：模块进行许多操作，各自有各自的入又点，每个操作代码相对独立，而且所有操作都在相同的数据结构上进行</li><li>功能内聚：只执行一个操作或达到一个目的</li><li>通信内聚：对相同数据执行不同操作</li><li>过程内聚：含有不同步骤操作</li><li>时间内聚：具有时间相关性的相关操作</li><li>逻辑内聚：逻辑上相似但没有直接关联操作</li><li>偶然内聚：多个毫不相干的操作</li></ol><h2 id="设计原则">设计原则</h2><ol type="1"><li>全局变量有害</li><li>代码清晰可修改</li><li>避免重复</li><li>面向接口编程</li><li>迪米特法则：不能出现a.b.method()</li><li>接口隔离原则（接口最小化原则）</li><li>里氏替换原则：所有派生类都须可以替代其基类</li><li>组合代替继承</li><li>单一职责原则</li><li>最小化类和成员的可访问性</li><li>开放/封闭原则（OCP）：模块可扩展，不应修改（无switch、if/else）</li><li>依赖倒置原则（DIP）：高级模块不应依赖于低级，两者均应依赖抽象</li></ol><h2 id="设计模式">设计模式</h2><ul><li>策略模式</li><li>迭代器模式</li><li>抽象工厂模式</li><li>单件模式</li></ul><h2 id="代码设计">代码设计</h2><ul><li>单元测试用例的设计</li><li>契约式设计</li><li>防御式编程</li><li>表驱动</li></ul><h2 id="软件开发过程模型">软件开发过程模型</h2><ul><li>生命周期模型</li><li>构建-修复模型</li><li>瀑布模型</li><li>增量迭代模型</li><li>演化模型</li><li>原型模型</li><li>螺旋模型</li></ul>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs apache&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;title&lt;/span&gt;: SEII-期末复习&lt;br&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;date&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2023&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;seii复习&quot;&gt;SEII复习&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>毛概-期末复习</title>
    <link href="http://example.com/2023/06/15/%E6%AF%9B%E6%A6%82%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2023/06/15/%E6%AF%9B%E6%A6%82%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</id>
    <published>2023-06-15T04:00:00.000Z</published>
    <updated>2023-06-19T05:22:39.263Z</updated>
    
    <content type="html"><![CDATA[<h1id="毛泽东思想和中国特色社会主义理论体系概论-期末复习">毛泽东思想和中国特色社会主义理论体系概论期末复习</h1><span id="more"></span><p>任课教师：武海宝</p><h3 id="科学社会主义">科学社会主义</h3><ul><li>科学社会主义确认金融资本是现代社会各种病症的根源。</li><li>共产主义不是对财产的否定，而是对社会财产的私人垄断的否定。</li></ul><p>伦理社会主义：</p><p>伦理社会主义是在自然经济时代发展起来的，它强调人与人之间的和谐，与宗教、大同理想、家族文化等各种形态相结合，以一种改良的身份去批评资本主义，但它无法改变资本主义的基本逻辑</p><h2 id="新民主主义革命">新民主主义革命</h2><h3 id="中国社会主义革命道路探索">中国社会主义革命道路探索</h3><h4 id="中国的两步走">中国的两步走</h4><p>中国革命必须分为两个步骤。第一步，改变这个殖民地、半殖民地、半封建的社会形态，使之变成一个独立的民主主义的社会，第二部，使这个革命向前发展，建立一个社会主义的社会。——毛泽东《新民主主义论》</p><h4 id="三湾改编">三湾改编</h4><p>1927年9月至10月，毛泽东在江西省永新县三湾村领导了三湾改编。</p><p>毛泽东创造性地确立了支部建在连上、官兵平等等一系列治军方略。三湾改编是中国共产党建设新型人民军队最早的一次成功探索和实践。</p><p>意义：</p><ul><li>从政治上和组织上保证了党对军队的绝对领导，是我党建设新型人民军队最早的一次成功探索和实践，标志着毛泽东建设人民军队思想的开始形成</li><li>初步解决了如何把以农民和旧军人为主要成分的革命军队建设成为一支无产阶级新型人民军队的问题，奠定了政治强军的基础</li><li>实现民主主义，对团结广大士兵群众、瓦解敌军起到巨大作用</li></ul><h4 id="新民主主义革命的基本纲领">新民主主义革命的基本纲领</h4><ul><li>没收封建地主阶级的土地归农民所有；没收官僚资本主义的垄断资本归国家所有；保护民族工商业</li><li>建立无产阶级领导下的一切反帝反封建的人民联合专政的民主共和国，这就是新民主主义的共和国</li><li>实行人民大众的反帝反封建的文化，即民族的、科学的、大众的文化</li></ul><h4 id="新旧民主主义革命的异同">新旧民主主义革命的异同</h4><ul><li>相同点：<ul><li>社会性质：都发生在半殖民地半封建社会</li><li>革命任务：都是反对外国资本主义侵略和本国封建统治</li><li>革命性质：都属于资产阶级民主革命的范畴</li></ul></li><li>不同点：<ul><li>领导力量：旧民主主义革命的领导是资产阶级，新民主主义革命的领导是无产阶级</li><li>指导思想：旧民主主义革命是资产阶级的平等、自由思想和民族观念，新民主主义革命是马克思主义</li><li>革命前途：旧民主主义革命是建立资产阶级民主共和国，新民主主义革命在完成民主革命任务后，还要进入社会主义社会</li><li>革命发展和群众发动的深度、广度：旧民主主义革命的纲领不彻底，群众发动不充分，土地问题不能彻底解决；新民主主义革命提出了彻底的革命纲领，广泛发动群众，解决了民主革命的中心问题，即土地问题</li><li>结果不同：旧民主主义革命有胜利的一面，但最终果实被窃取，革命任务没有完成，社会性质没有改变，在这一意义讲是最终遭到了失败；新民主主义革命的胜利成为了社会主义的必要准备，社会主义是新民主主义革命的必然结果</li><li>旧民主主义革命属于世界资产阶级革命的一部分，新民主主义革命属于无产阶级世界革命的一部分</li></ul></li></ul><h3 id="新民主主义社会">新民主主义社会</h3><ul><li>政治上，新民主主义的国家实行工人阶级领导的、工农联盟为基础的、团结各民主阶级和国内各民族的人民民主专政。</li><li>经济上：</li></ul><table><thead><tr class="header"><th>成分</th><th>来源</th><th>性质</th><th>地位</th></tr></thead><tbody><tr class="odd"><td>国营经济</td><td>没收官僚资本</td><td>社会主义</td><td>领导地位</td></tr><tr class="even"><td>合作社经济</td><td>个体向社会主义集体经济过渡</td><td>半社会主义</td><td></td></tr><tr class="odd"><td>个体经济</td><td>个体农业、手工业</td><td>个体经济</td><td>绝对优势</td></tr><tr class="even"><td>私人资本主义经济</td><td>民族资本主义</td><td>资本主义</td><td></td></tr><tr class="odd"><td>国家资本主义经济</td><td>私人资本主义经济向社会主义国营经济过渡</td><td>半社会主义</td><td></td></tr></tbody></table><p>新民主主义社会，是指在新民主主义革命胜利的基础上，建立起来的既不是资产阶级共和国也不是无产阶级共和国的的各个革命阶级联合专政的共和国，是落后国家进行革命的特有社会形态。</p><ul><li>性质：过渡性社会形态，隶属于社会主义体系</li><li>特点：既有社会主义因素，也有资本主义因素</li><li>从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期</li><li>过渡时期的时间，中央领导估计大约需要10年、15年或者更久</li></ul><h4 id="过渡时期总路线">过渡时期总路线</h4><p>从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造。</p><h4id="中国社会主义改造道路三大改造">中国社会主义改造道路：三大改造</h4><ul><li>农业合作化，将小农经济改造为农业集体主义经济</li><li>手工业社会主义改造，通过合作化道路，把个体手工业转变为社会主义劳动群众集体所有制经济</li><li>资本主义工商业社会主义改造，通过国家资本主义的形式，采取和平赎买的政策，将民族资本主义经济改造成社会主义公有制企业，而且将所有制改造与人的改造相结合，努力使剥削者成为自食其力的劳动者</li></ul><p>社会主义改造时期，把实现国家的工业化作为党在过渡时期总路线的主体，受苏联的影响，一度过多强调重工业和基础设施的发展，促使党思考如何走中国工业化道路的问题。</p><h4 id="中国工业化道路的目标和方针">中国工业化道路的目标和方针</h4><ul><li>总方针：以农业为基础，以工业为主导，以农、轻、重为序发展国民经济</li><li>农业为重工业提供积累资金和原料，同时提供市场</li><li>目标：逐步建立独立的比较完整的基础工业体系和国防工业体系</li></ul><h3 id="中国无产阶级的主要优点">中国无产阶级的主要优点</h3><ol type="1"><li>革命性强。深受帝国主义、封建主义、资本主义的三重压迫，具有强烈的反抗意识</li><li>和广大农民有着天然联系，容易和农民结成亲密的联盟</li><li>集中在沿海、沿江大中城市，便于组织</li></ol><p>新民主主义革命的动力：农民</p><h2 id="改革开放">改革开放</h2><h3 id="家庭联产承包责任制和土地流转">家庭联产承包责任制和土地流转</h3><p>家庭联产承包责任制和统分结合的双层经营体制：</p><p>所有权、承包权和经营权三权分置，经营权流转的格局。农业用地在土地承包期限内，可以通过转包、转让、入股、合作、租赁、互换等方式出让经营权。</p><h3id="中国社会主义农业改革和发展的两个飞跃">中国社会主义农业改革和发展的两个飞跃</h3><p>两个飞跃是邓小平晚年关于我国农业改革和发展的重要思考</p><ol type="1"><li>废除人民公社，实行家庭联产承保责任制</li><li>适应科学生产、生产社会化的需要，再度发展集体经济</li></ol><h3id="中国特色社会主义市场经济制度的体制优势">中国特色社会主义市场经济制度的体制优势</h3><ul><li>从落后国家率先取得胜利的社会主义，还不能一下子排除掉资本。中国从新民主主义社会到改革开放，基本探索出一个相对稳定的制度形式，也就是公有制主导下的市场经济</li><li>以公有制为主体的社会主义市场经济制度既能充分利用市场、充分利用一般职能资本的积极作用来推动社会发展，又能避免金融资本的剥削性、寄生性、投机性积累及其所导致的一系列问题，创造了一条不同于西方的现代化道路</li></ul><h2 id="社会主义">社会主义</h2><h3 id="社会主义的本质">社会主义的本质</h3><ul><li>解放和发展生产力——基本经济制度的内在属性</li><li>消灭剥削，消除两极分化——基本经济制度的内在张力</li><li>最终达到共同富裕</li></ul><h3 id="三个代表">三个代表</h3><p>三个代表是建党理论。</p><p>中国共产党始终代表</p><ul><li>中国先进生产力的发展要求</li><li>中国先进文化的前进方向</li><li>中国最广大人民的根本利益</li></ul><h3 id="科学发展观">科学发展观</h3><ul><li>第一要义是发展</li><li>核心是以人为本</li><li>基本要求是全面协调可持续发展</li><li>根本方法是统筹兼顾</li></ul><h3 id="十个坚持">十个坚持</h3><ul><li>坚持党的领导</li><li>坚持人民至上</li><li>坚持理论创新</li><li>坚持独立自主</li><li>坚持中国道路</li><li>坚持胸怀天下</li><li>坚持开拓创新</li><li>坚持敢于斗争</li><li>坚持统一战线</li><li>坚持自我革命</li></ul><h2 id="使命型政党">使命型政党</h2><h3 id="理论渊源">理论渊源</h3><p>⻢克思：过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的，为绝大多数人谋利益的独立的运动。在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。</p><h3 id="人民利益的统一性完整性">人民利益的统一性、完整性</h3><ul><li>区别公意和众意：<ul><li>卢梭在《社会契约论》中说：“公意和众意之间经常有着很大的差别。公意总是着眼于公共利益，而众意则着眼于私利，它只是个体意志的总和。”</li></ul></li></ul><h3 id="中国共产党是使命型政党">中国共产党是使命型政党</h3><ul><li>把国家从金融资本、金融寡头的工具变成社会利益的集中代表，这是社会主义国家的国体概念。作为社会联合所有制的代理人来执行职能的国家，这是一种和新自由主义消极国家不一样的积极国家，这种积极国家又要依赖一个先锋队、依赖一个使命型政党。</li><li>这种政党不同于⻄方那样一种选举型政党。选举型政党容易分裂人⺠的意志，而人⺠意志的分裂有利于金融寡头对经济、政治的支配。</li><li>共产党作为先锋队的组织，作为人⺠意志的集中表现，作为一个没有自己特殊私利的政党，共产党的合法性依据先进的纲领、依据人⺠⺠主、依据自我革命。社会主义政权的一系列的组织形式不同于⻄方三权分立的政治制度。</li></ul><h4id="使命型政党和西方选举型政党的区别">使命型政党和西方选举型政党的区别</h4><ul><li>基于全心全意为人民服务的马克思主义政党；建立在人性恶和权力恶的双重不信任文化基础上的政党</li><li>作为整体的部分而服务于本体的政党；割裂于整体而利用本体牟利的政党</li></ul><h2 id="我国的政治制度">我国的政治制度</h2><h4 id="人民民主专政国体">人民民主专政——国体</h4><p>中国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家。</p><p>人民民主专政是中国的国家根本性质</p><p>只有人民民主专政才能终结国外列强操控的军阀割据。</p><p>军阀割据的社会根源：</p><ul><li>中国社会的半封建性，中国具有分散性的封建地主经济的必然产物</li><li>中国社会的半殖民性，帝国主义分而治之的侵略政策必然导致军阀割据</li></ul><h4 id="人民代表大会制度政体">人民代表大会制度——政体</h4><ul><li>人民通过人民代表大会有效行使国家权力</li><li>全国人民代表大会是最高国家权力机关，地方人民代表大会是地方国家权力机关</li><li>各级国家行政机关、监察机关、审判机关、检察机关都由人民代表大会产生，对人大负责，受人大监督。人民代表大会有立法权、监督权、决定权、任免权</li><li>人大代表来自人民，横向上，来自各地区、各民族、各方面、各阶层；纵向上，全国、省、市、县、乡五级都有人民代表大会，具有广泛代表性</li></ul><h4id="中国共产党领导的多党合作和政治协商制度">中国共产党领导的多党合作和政治协商制度</h4><p>中国共产党是执政党，八个民主党派是接受中国共产党领导、同中国共产党亲密合作的参政党。</p><ul><li>在中国，没有反对党，也没有在野党。中国既不是一党专政，也不是多党竞争、轮流执政，而是“共产党领导、多党派合作，共产党执政、多党派参政”。</li></ul><h4 id="民主实践选举民主">民主实践：选举民主</h4><ul><li><p>人⺠通过选举、投票行使权利，选出代表自己意愿的人来掌握并行使权力，是中国⺠主的一种主要形式，是人⺠实现当家作主的主要体现。</p></li><li><p>中国的选举是广泛的，有国家机构选举、村(居)委会选举、企事业单位职工代表大会选举等，涵盖了国家政治生活和社会生活的各个方面。</p></li><li><p>中国的选举是平等的，人⺠的选举权和被选举权得到充分保障，一人一票、票票等值</p></li><li><p>中国的选举是真实的，不受金钱操控，选⺠按照自己的意愿选出自己信任的人。</p></li><li><p>国家机构选举：从全国人大到乡级人大，五级人⺠代表大会代表均由⺠主选举产生，每届任期5年。选⺠直接选举产生县乡两级人大代表，县级以上人大代表由下一级人大选举产生。各级国家机关领导人员均由同级人大选举产生或者决定任命。</p></li><li><p>基层选举：村(居)⺠委员会选举和企事业单位职工代表大会选举。村(居)⺠依法定期选举产生村(居)⺠委员会成员。在企事业单位中，职工代表大会是职工当家作主、行使⺠主管理权力的机构。</p></li></ul><h4 id="民主实践协商民主">民主实践：协商民主</h4><ul><li><p>人⺠在通过选举、投票行使权利的同时，在重大决策前和决策过程中进行充分协商，尽可能就共同性问题取得一致意⻅。协商⺠主是中国⺠主独特的、独有的、独到的⺠主形式。</p></li><li><p>协商⺠主形式:提案、会议、座谈、论证、听证、评估、咨询、网络、⺠意调查等多种途径和方式，在决策之前和决策实施之中开展广泛协商。</p></li></ul><p>缺乏协商民主：英国脱欧</p><p>票决至上：一人一票是民主的一种形式，但绝非其唯一和全部</p><h4 id="政党和民主">政党和民主</h4><ul><li>中国共产党的领导，是中国发展全过程人⺠⺠主的根本保证。</li><li>把中国14亿多人⺠的意愿表达好、实现好，必须有坚强有力的统一领导。</li><li>中国共产党始终坚持以人⺠为中心、坚持人⺠主体地位，真正为人⺠执政、靠人⺠执政；充分发挥总揽全局、协调各方的领导核心作用。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1
id=&quot;毛泽东思想和中国特色社会主义理论体系概论-期末复习&quot;&gt;毛泽东思想和中国特色社会主义理论体系概论
期末复习&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据管理基础-第十一章_并发控制</title>
    <link href="http://example.com/2023/06/11/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2023/06/11/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</id>
    <published>2023-06-11T14:00:00.000Z</published>
    <updated>2023-06-13T12:47:38.268Z</updated>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第十一章-并发控制">第十一章 并发控制</h1><p>事务可以一个一个地串行执行，即每一刻都只有一个事务运行。</p><ul><li>在单处理器系统中，事务的并行执行实际上是这些并行事务的并行操作轮流交叉运行。</li><li>在多处理器系统中，可以实现真正多个事务的并行运行，称为同时并发方式。</li></ul><p>本章讨论的数据库并发控制以单处理器系统为基础。</p><h2 id="并发控制概述">11.1 并发控制概述</h2><p>事务是并发控制的基本单位。</p><p>数据库管理系统需要对并发操作进行正确调度，以保证事务的隔离性和一致性。</p><h3 id="并发操作带来的数据不一致性">并发操作带来的数据不一致性</h3><ul><li>丢失修改<ul><li>两个事务同时读入同一数据进行修改，导致其中一者的修改被丢失</li></ul></li><li>不可重复读<ul><li>一个事务读取数据后，另一个事务更新了数据，使得前一个事务再读取数据异常</li></ul></li><li>读“脏”数据（dirty read）<ul><li>一个事务修改数据，另一个事务读取了数据后，前一个事务被撤销</li></ul></li></ul><p>并发控制机制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务干扰，从而避免造成数据的不一致性。</p><p>并发控制的主要技术：</p><ul><li>封锁</li><li>时间戳</li><li>乐观控制法</li><li>多版本并发控制</li></ul><h2 id="封锁">11.2 封锁</h2><p>封锁是实现并发控制的一种非常重要的技术。封锁就是事务在操作某个数据对象前，先向系统发出请求对其加锁，避免其他事务干扰。</p><h3 id="基本的封锁类型">基本的封锁类型</h3><ul><li>排他锁（exclusive locks，又称X锁、写锁）<ul><li>事务T对数据对象A加上X锁后，只允许T读取和修改A，其他任何事务都不能对A加任何锁，直到T释放锁。</li><li>保证其他事务在T释放锁前不能再读取和修改A。</li></ul></li><li>共享锁（share locks，又称S锁、读锁）<ul><li>事务T对数据对象A加上S锁后，事务T可以读A但不能修改A，而其他事务也只能对A加S锁。</li><li>保证其他事务在T释放锁前不能修改A。</li></ul></li></ul><h3 id="封锁协议">封锁协议</h3><p>封锁协议是运用X锁和S锁的一些规则。</p><p>三级封锁协议的主要区别在于什么操作需要申请封锁，以及何时释放锁。</p><ul><li>封锁协议级别越高，一致性程度越高。</li></ul><h4 id="一级封锁协议">一级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放。</p><ul><li>不能保证可重复读和不读“脏”数据</li></ul><h4 id="二级封锁协议">二级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放；</p><p>事务T在读取数据R之前必须对其加S锁，读完即可释放S锁。</p><ul><li>不能保证可重复读</li></ul><h4 id="三级封锁协议">三级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放；</p><p>事务T在读取数据R之前必须对其加S锁，直到事务结束才释放。</p><h3 id="活锁和死锁">11.2.3 活锁和死锁</h3><h4 id="活锁">活锁</h4><p>事务由于一直被其他事务封锁而永远等待，这就是活锁。</p><p>避免活锁的简单办法是采用先来先服务的策略。</p><h4 id="死锁">死锁</h4><p>两个事务各自封锁了部分资源，又等待对方封锁的资源，这就形成了死锁。</p><p>解决死锁问题的方法：采取一定措施预防死锁；定期诊断系统中有无死锁，有则解除之。</p><h5 id="死锁的预防">死锁的预防</h5><ul><li>一次封锁法<ul><li>每个事务必须一次将所有要使用的数据全部加锁，否则就不能执行</li><li>可以有效防止死锁</li><li>缺点：<ul><li>一次加锁全部数据，扩大封锁范围，降低系统并发度</li><li>数据库数据不断变化，原本不要求封锁的数据可能也会变成封锁对象，很难事先确定每个事务要封锁的全部数据对象。为此只能进一步扩大封锁范围，降低并发度</li></ul></li></ul></li><li>顺序封锁法<ul><li>预先对数据对象规定一个封锁顺序</li><li>可以有效防止死锁</li><li>缺点：<ul><li>数据库系统中要封锁的数据对象太多，维护资源封锁顺序非常困难</li><li>事务的封锁请求可以随着事务的执行动态决定，很难事先确定，按顺序封锁</li></ul></li></ul></li></ul><h5 id="死锁的诊断和解除">死锁的诊断和解除</h5><p>一般使用超时法或事务等待图法。</p><ul><li>超时法<ul><li>一个事务的等待时间超过规定的时限，就认为发生了死锁</li><li>实现简单</li><li>缺点：<ul><li>容易误判死锁</li><li>时间若设置太长，死锁发生后不能及时发现</li></ul></li></ul></li><li>等待图法<ul><li>使用有向图表示的事务等待图动态地反映事务的等待情况。</li></ul></li></ul><p>解除死锁的方法：选择一个处理死锁代价最小的事务进行撤销，之后再加以恢复。</p><h2 id="并发调度的可串行性">11.3 并发调度的可串行性</h2><p>多个事务的并发调度是正确的，当且仅当其结果与按某一次序串行地执行这些事务的结果相同，这种调度策略称为可串行化调度。</p><p>可串行性是并发事务正确调度的准则。一个可串行化的并发调度才是正确的调度。</p><h3 id="可串行化调度的充分条件">可串行化调度的充分条件</h3><h4 id="冲突可串行化">冲突可串行化</h4><p>冲突操作是指不同的事务对同一个数据的读写操作和写写操作。</p><p>不同事务的冲突操作和同一事务的两个操作是不能交换的。</p><p>一个调度在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度。如果这另一个调度是串行的，则称原调度是冲突可串行化的调度。</p><ul><li><p>一个冲突可串行化的调度一定是可串行化的调度。</p><p>即，冲突可串行化是可串行化的充分条件。</p></li></ul><h4 id="两段锁协议">两段锁协议</h4><p>两段锁协议（简称2PL）是当前数据库管理系统普遍采用以实现并发调度可串行性的方法。</p><ul><li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁，称为扩展阶段</li><li>在释放一个封锁后，事务不再申请和获得其他封锁，称为收缩阶段</li></ul><p>事务遵守两段锁协议是可串行化调度的充分条件。</p><h2 id="封锁的粒度">11.4 封锁的粒度</h2><p>封锁对象的大小称为封锁粒度（granularity）。</p><ul><li><p>封锁粒度和系统的并发度和并发控制的开销密切相关。</p></li><li><p>一个系统同时支持多种封锁粒度供不同的事务选择是比较理想的，称为多粒度封锁。</p></li></ul><h3 id="多粒度封锁">多粒度封锁</h3><p>多粒度树：根结点是整个数据库，表示最大的数据粒度，叶结点表示最小的数据粒度。</p><p><strong>多粒度封锁协议</strong>允许多粒度树中的每一个结点被独立地加锁。</p><ul><li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样的锁<ul><li>显式封锁：应事务要求直接加到数据对象上的锁</li><li>隐式封锁：未被独立加锁，因为其上级结点加锁而被加锁</li></ul></li><li>对某个对象加锁，先要检查自身是否有显式封锁与之冲突，再要检查所有上级结点是否赋于它隐式封锁，最后还要检查其下级结点是否有冲突的显式封锁，这样效率太低<ul><li>引入意向锁</li></ul></li></ul><h3 id="意向锁">意向锁</h3><p>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；即任一结点加锁时，须对它的上层结点加意向锁。</p><p>三种常见意向锁：</p><ul><li>意向共享锁（Intent Share Lock，IS锁）<ul><li>对一个结点加S锁，先对其上级结点加IS锁</li></ul></li><li>意向排他锁（Intent Exclusive Lock，IX锁）<ul><li>对一个结点加X锁，先对其上层结点加IX锁</li></ul></li><li>共享意向排他锁（Share Intent Exclusive Lock，SIX锁）<ul><li>一个数据对象先被加了S锁，后被加了IX锁</li></ul></li></ul><p>锁的强度偏序：X—SIX—S/IX—IS</p><ul><li><p>以强锁代替弱锁是安全的，反之则不然</p></li><li><p>申请时自上而下检查，释放时自下而上</p></li></ul><h2 id="其他并发控制机制">11.5 其他并发控制机制</h2><p>时间戳方法、乐观控制法和多版本并发控制等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我自横刀向天笑，去留肝胆两昆仑。&lt;/p&gt;</summary>
    
    
    
    <category term="数据管理基础" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据管理基础-第十章_数据库恢复技术</title>
    <link href="http://example.com/2023/06/10/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2023/06/10/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/</id>
    <published>2023-06-10T13:00:00.000Z</published>
    <updated>2023-06-13T11:41:01.016Z</updated>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第十章-数据库恢复技术">第十章 数据库恢复技术</h1><h2 id="事物的基本概念">10.1 事物的基本概念</h2><h3 id="事物">事物</h3><p>事物是用户定义的一个数据库操作序列，是一个不可分割的工作单位。</p><p>在SQL中，定义事务的语句一般有三条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>事务以<code>BEGIN TRANSACTION</code>开始，以<code>COMMIT</code>或<code>ROLLBACK</code>结束。</p><ul><li><code>COMMIT</code>表示提交</li><li><code>ROLLBACK</code>表示回滚，系统将该事务已经完成的操作全部撤销</li></ul><p>事务是恢复和并发控制的基本单位。</p><h3 id="事务的acid特性">事务的ACID特性</h3><ul><li>原子性（Atomicity）<ul><li>事务是数据库的逻辑工作单位，包括的操作要么都做，要么不做</li></ul></li><li>一致性（Consistency）<ul><li>事务执行的结果必须是数据库从一个一致性状态到另一个一致性状态</li></ul></li><li>隔离性（Isolation）<ul><li>一个事务的执行不能被其他事务干扰</li></ul></li><li>持续性（Durability）<ul><li>也称永久性，一个事务一旦提交，它对数据库中数据的改变就是永久的</li></ul></li></ul><p>保证事务ACID特性是事务管理的重要任务，可能破坏ACID的因素有：</p><ul><li>多个事务并行运行时，不同事务的操作交叉执行</li><li>事务在运行过程中被强行停止</li></ul><h2 id="数据库恢复概述">10.2 数据库恢复概述</h2><p>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态的功能。</p><ul><li>恢复子系统是数据库管理系统的一个重要组成部分</li></ul><h3 id="故障的种类">10.2.1 故障的种类</h3><ul><li>事务内部的故障<ul><li>非预期的，不能由应用程序处理的故障</li><li>恢复程序需要强行回滚该事务，这类恢复操作称为事务撤销（UNDO）</li></ul></li><li>系统故障<ul><li>又称软故障，指造成系统停止运转的任何事件，使得系统要重新启动</li><li>恢复子系统除需要撤销所有未完成的事务，还需要重做（REDO）所有已提交事务</li></ul></li><li>介质故障<ul><li>又称硬故障，指外存故障，如磁盘损坏、磁头碰撞等</li></ul></li><li>计算机病毒</li></ul><p>各类故障对数据库的影响有两种可能性：数据库本身被破坏；数据可能不正确。</p><p>恢复的基本原理：冗余</p><ul><li>数据库任何一部分被破坏或不正确的数据可以根据存储在系统别处的冗余数据来重建</li></ul><h3 id="恢复的实现技术">10.2.2 恢复的实现技术</h3><p>建立冗余数据最常用的技术是数据转储和登记日志文件。通常一个数据库系统会同时使用这两种方法。</p><h4 id="数据转储">数据转储</h4><p>数据转储是数据库恢复中采用的基本技术。数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存。这些备用的数据称为<strong>后备副本</strong>或后援副本。</p><ul><li>重装后备副本只能将数据库恢复到转储时的状态，故必须重新运行转储后的所有更新</li><li>转储十分耗费时间和资源，不能频繁进行</li></ul><p>转储可分为静态转储和动态转储：</p><ul><li>静态转储是在系统中无运行事务时进行的转储操作。<ul><li>简单，保证数据库的一致性，但会降低数据库的可用性</li></ul></li><li>动态转储是指转储期间允许对数据库进行存取或修改<ul><li>必须登记转储期间各事务对数据库的修改活动，建立日志文件</li></ul></li></ul><p>转储又可分为海量转储和增量转储：</p><ul><li>海量转储，一次转储全部数据库</li><li>增量转储，每次只转储上次转储后更新过的数据</li></ul><h4 id="日志文件">日志文件</h4><p>日志文件是用来记录事务对数据库的更新操作的文件，主要有两种格式：</p><ul><li>以记录为单位的日志文件</li><li>以数据块为单位的日志文件</li></ul><p>以记录为单位的日志文件需要登记的内容：</p><ul><li>各个事务的开始、结束标记</li><li>各个事务的所有更新操作</li></ul><p>这里每个事务的开始、结束标记和每个更新操作均作为日志文件的一个日志记录，包括：</p><ul><li>事务标识（表明是哪个事务）</li><li>操作的类型（更新、插入和删除）</li><li>操作对象</li><li>更新前数据的旧值（对于插入操作为空）</li><li>更新后数据的新值（对于删除操作为空）</li></ul><p>以数据块为单位的日志文件需要登记事务标识和被更新的数据块，将更新前和更新后的整个块放入日志文件中。</p><h5 id="日志文件的作用">日志文件的作用</h5><ul><li>事务故障恢复和系统故障恢复必须用日志文件</li><li>在动态转储方式中必须建立日志文件，结合后备副本和日志文件恢复数据库</li><li>在静态转储方式中也可以建立日志文件帮助恢复，不必重新运行已完成的事务</li></ul><h5 id="登记日志文件">登记日志文件</h5><p>为保证数据库可恢复，登记日志文件必须遵循两条原则：</p><ul><li>登记的次序严格按并发事务处理的时间顺序。</li><li>必须先写日志文件，后写数据库</li></ul><h3 id="恢复策略">10.2.3 恢复策略</h3><h4 id="事务故障的恢复">1. 事务故障的恢复</h4><p>事务故障是指事务在运行至正常终点前被终止，这时恢复子系统应利用日志文件做撤销：</p><ol type="1"><li>反向扫描日志文件，查找该事务的更新操作</li><li>对该事务的更新操作进行逆操作</li><li>继续扫描处理直到该事务的开始标记</li></ol><h4 id="系统故障的恢复">2. 系统故障的恢复</h4><p>系统故障的恢复是由系统在重新启动时自动完成的。</p><ol type="1"><li>正向扫描日志文件，找出故障发生前已经提交的事务，将其事务标记记入重做队列，同时找出故障发生时尚未完成的事务，记入撤销队列</li><li>对撤销队列中的各个事务进行撤销</li><li>对重做队列中的各个事务进行重做</li></ol><h4 id="介质故障的恢复">3. 介质故障的恢复</h4><p>恢复方法时重装数据库，重做已完成的事务。</p><ol type="1"><li>装入最新的数据库后备副本</li><li>装入相应的日志文件副本，重做已完成的事务</li></ol><h3 id="具有检查点的恢复技术">10.2.4 具有检查点的恢复技术</h3><p>在日志中增加一类新的记录——检查点记录，增加一个重新开始文件，让恢复子系统在登录日志期间动态维护日志。</p><p>检查点记录的内容：</p><ul><li>建立检查点时刻所有在执行的事务清单</li><li>这些进程是最近一个日志记录的地址</li></ul><p>动态维护日志的方法是：周期性地执行建立检查点、保存数据库状态的操作</p><ol type="1"><li>将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上。</li><li>在日志文件中写入一个检查点记录。</li><li>将当前数据缓冲区的所有数据记录写入磁盘的数据库中。</li><li>把检查点记录在日志文件中的地址写入一个重新开始文件</li></ol><p>使用检查点方法可以改善恢复效率。</p><p>系统使用检查点方法进行恢复的步骤：</p><ol type="1"><li><p>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。</p></li><li><p>由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。这里建立两个事务队列:</p><ul><li>UNDO-LIST：需要执行UNDO操作的事务集合；</li><li>REDO- LIST：需要执行REDO操作的事务集合。</li></ul></li><li><p>从检查点开始正向扫描日志文件。</p><ul><li>如有新开始的事务，把事务暂时放入UNDO-LIST队列；</li><li>如有提交的事务，把事务从UNDO-LIST队列移到REDO-LIST队列；</li></ul><p>直到日志文件结束。</p></li><li><p>对UNDO-LIST中的每个事务执行UNDO操作，对REDO-LIST中的每个事务执行REDO 操作。</p></li></ol><h3 id="数据库镜像">10.2.5 数据库镜像</h3><p>数据库镜像，即数据库管理系统根据数据管理员要求，自动把整个数据库或其中关键数据复制到另一个磁盘上。每当主数据库更新，数据库管理系统自动把更新后的数据复制过去，由数据库管理系统自动保证镜像数据和主数据库的一致性。</p><p>实际应用中，用户往往只选择对关键数据和日志文件进行镜像。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我自横刀向天笑，去留肝胆两昆仑。&lt;/p&gt;</summary>
    
    
    
    <category term="数据管理基础" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据管理基础-第八章_数据库编程</title>
    <link href="http://example.com/2023/06/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AB%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2023/06/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AB%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</id>
    <published>2023-06-08T11:00:00.000Z</published>
    <updated>2023-06-14T01:23:06.758Z</updated>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第八章-数据库编程">第八章 数据库编程</h1><p>SQL编程技术可以有效克服SQL语言实现复杂应用方面的不足，提高应用系统和数据库管理系统间的互操作性。</p><p>在应用系统中使用SQL编程来访问和管理数据库中数据的方式主要有：嵌入式SQL、过程化SQL、存储过程和自定义函数、开放数据库互连、OLEDB、JDBC（Java数据库连接）等。</p><h2 id="嵌入式sql">8.1 嵌入式SQL</h2><p>将SQL语句嵌入程序设计语言中，一般采取预编译方法实现。</p><h3 id="嵌入式sql语句和主语言之间的通信">8.1.1嵌入式SQL语句和主语言之间的通信</h3><p>数据库工作单元与源程序工作单元之间的通信主要包括</p><ul><li>向主语言传递SQL语句的执行状态信息，使主语言能够据此信息控制程序流程，主要用SQL通信区（SQLCommunication Area，SQLCA）实现</li><li>主语言向SQL语句提供参数，主要用主变量实现</li><li>将SQL语句查询数据库的结果交由主语言处理，主要用主变量和游标实现</li></ul><h4 id="sql通信区">SQL通信区</h4><p>SQL语句执行后，系统反馈给应用的信息将被送到SQL通信区中。</p><ul><li>SQL通信区中变量SQLCODE用以存储每次执行SQL后返回的代码</li><li>应用每次执行完一条SQL语句后都应该测试SQLCODE的值</li></ul><h4 id="主变量">主变量</h4><p>SQL中使用的主语言程序变量简称为<strong>主变量</strong>。</p><ul><li>分为输入主变量和输出主变量<ul><li>输入主变量由应用程序赋值，SQL语句引用</li><li>输出主变量由SQL语句赋值，返回给应用程序</li></ul></li><li>一个主变量可以附带一个任选的指示变量<ul><li>指示变量是用以指示主变量的值或条件的整型变量</li></ul></li></ul><h4 id="游标">游标</h4><p>SQL面向集合，一条SQL语句可以产生或处理多条记录；主语言面向记录，一次只能处理一条记录，因此只用主变量不能完全满足SQL和主语言的协同。</p><p>游标是系统为用户开设的一个数据缓冲区，存放SQL的执行结果，每个游标区都有其名字。</p><ul><li>用户通过游标逐一获取记录并赋给主变量，交由主语言处理</li></ul><p>不用游标的SQL语句：</p><p>说明性语句、数据定义语句、数据控制语句、查询结果为单记录的选择语句、非CURRENT形式的增删改语句</p><p>使用游标的SQL语句：</p><p>多条记录的选择语句、CURRENT形式的UPDATE和DELETE语句。</p><h3 id="动态sql">8.1.2 动态SQL</h3><p>上述的嵌入式SQL语句中使用的主变量、查询目标列、条件等都是固定的，是静态SQL语句。但有些应用可能要到执行时才能够确定要提交的SQL语句，这就需要动态SQL语句。</p><h4 id="sql语句主变量">SQL语句主变量</h4><p>程序主变量包含SQL语句的内容，这样的变量称为SQL语句主变量。</p><h4 id="动态参数">动态参数</h4><p>动态参数通过PREPARE语句准备主变量和执行语句绑定数据或主变量来完成。</p><h2 id="过程化sql">8.2 过程化SQL</h2><p>过程化SQL是对SQL的扩展，使其增加了过程化语句功能。</p><p>过程化SQL的基本结构是块。所有的过程化SQL程序都是由块组成。这些块之间可以相互嵌套，每个块完成一个逻辑操作。</p><p>基本结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">定义部分：<span class="hljs-keyword">DECLARE</span> 变量、常量、游标、异常等<br><br>执行部分：<span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">SQL</span>语句、过程化<span class="hljs-keyword">SQL</span>的流程控制语句<br><span class="hljs-keyword">EXCEPTION</span> 异常处理<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>流程控制：IF-THEN-END IF、IF-THEN-ELSE-END IF</p><p>循环控制：LOOP-END LOOP、WHILE-LOOP-END LOOP、FOR-LOOP-END LOOP</p><p>错误处理：过程化SQL提供了完善的异常处理机制</p><h4 id="存储过程与函数">存储过程与函数</h4><p>过程化SQL块主要有两种类型：命名块和匿名块，上述均为匿名块，每次执行都要编译，不能存储到数据库中，也不能在其他过程化SQL块中调用。过程和函数是命名块，被编译后保存在数据库中，称为持久性存储模块，可以被反复调用。</p><p>存储过程是由过程化SQL语句编写的过程，经编译和优化后存储在数据库服务器中。</p><p>函数，也称自定义函数，是用户自己使用过程化SQL设计定义的，和存储过程不同的是必须指定返回的类型。</p><h2 id="odbc编程">8.3 ODBC编程</h2><p>提出和产生ODBC的原因是存在不同的数据库系统。</p><p>ODBC是微软公司开放体系的一部分，建立了一组访问数据库的应用程序编程接口规范（ApplicationProgramming Interface，API）。</p><ul><li>ODBC一方面规范应用开发，另一方面规范关系数据库管理系统应用接口</li></ul><p>ODBC由四部分组成：用户应用程序、ODBC驱动程序管理器、数据库驱动程序、数据源</p><h3 id="用户应用程序">用户应用程序</h3><p>使用ODBC来开发应用系统的程序简称为ODBC应用程序，包括内容：</p><ol type="1"><li>请求连接数据库</li><li>向数据源发送SQL语句</li><li>为SQL语句执行分配空间，定义所读取的数据格式</li><li>获取数据库操作结果或处理错误</li><li>进行数据处理并向用户提交处理结果</li><li>请求事务的提交和回滚操作</li><li>断开与数据源的连接</li></ol><h3 id="odbc驱动程序管理器">ODBC驱动程序管理器</h3><p>驱动程序管理器用来管理各种驱动程序。</p><p>ODBC驱动程序管理器管理应用程序和驱动程序之间的通信，主要功能包括：</p><ul><li><p>装载ODBC驱动程序</p></li><li><p>选择和连接正确的驱动程序</p></li><li><p>管理数据源（建立、配置和删除）</p></li><li><p>检查ODBC调用参数的合法性</p></li><li><p>记录ODBC函数的调用</p></li><li><p>当应用层需要时，返回驱动程序的有关信息</p></li></ul><h3 id="数据库驱动程序">数据库驱动程序</h3><p>ODBC通过数据库驱动程序来提供应用系统和数据库平台的独立性。</p><p>ODBC应用程序的操作通过驱动程序管理器提交给某个驱动程序，调用驱动程序支持的函数来存取数据库。</p><p>单束与多束：</p><ul><li>单束：数据源和应用程序在同一台机器上，驱动程序直接完成对数据文件的输入/输出操作，驱动程序相当于数据管理器</li><li>多束：支持网络环境下数据访问，驱动程序完成数据库访问请求的提交和结果集接受</li></ul><h3 id="odbc数据源管理">ODBC数据源管理</h3><p>数据源时最终用户需要访问的数据，包含了数据库位置和数据库类型等信息，是一种数据连接的抽象。</p><p>ODBC给每个被访问的数据源指定唯一的数据源名，映射到所有必要的、用来存取数据的低层软件。</p><p>在连接中，用数据源名来代表用户名、服务器名、所连接的数据库名等。最终用户无须知道数据库管理系统或其他数据管理软件、网络以及有关ODBC驱动程序的细节，数据源对最终用户是透明的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我自横刀向天笑，去留肝胆两昆仑。&lt;/p&gt;</summary>
    
    
    
    <category term="数据管理基础" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据管理基础-第七章_数据库设计</title>
    <link href="http://example.com/2023/06/07/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2023/06/07/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-06-07T10:00:00.000Z</published>
    <updated>2023-06-13T02:55:13.623Z</updated>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第七章-数据库设计">第七章 数据库设计</h1><h2 id="概述">7.1 概述</h2><p>数据库设计是指对于一个给定的应用环境，构造(设计)优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</p><ul><li><p>信息管理要求：在数据库中应该存储和管理哪些数据对象。</p></li><li><p>数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作。</p></li></ul><p>数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境。</p><p>高效率的运行环境：</p><ul><li>数据库数据的存取效率高</li><li>数据库存储空间的利用率高</li><li>数据库系统运行管理的效率高</li></ul><h3 id="数据库设计的特点">7.1.1 数据库设计的特点</h3><h4 id="数据库建设的基本规律">数据库建设的基本规律</h4><p>三分技术、七分管理、十二分基础数据</p><ul><li><p>管理：数据库建设项目管理、企业业务管理</p></li><li><p>基础数据：数据的收集、整理、组织和不断更新</p></li></ul><p>结构（数据）设计和行为（处理）设计相结合</p><ul><li>将数据库结构设计和数据处理设计密切结合</li><li>结构和行为分离的设计：<ul><li>传统软件工程：重行为设计</li><li>早期数据库设计：重结构设计</li></ul></li></ul><h3 id="数据库设计方法">7.1.2 数据库设计方法</h3><p>大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。</p><p>它要求多方面的知识和技术。主要包括：</p><ul><li><p>计算机的基础知识</p></li><li><p>软件工程的原理和方法</p></li><li><p>程序设计的方法和技巧</p></li><li><p>数据库的基本知识</p></li><li><p>数据库设计技术</p></li><li><p>应用领域的知识</p></li></ul><p>数据库设计方法：</p><ul><li>手工试凑法</li><li>规范设计法<ul><li>新奥尔良方法</li><li>基于E-R模型的数据库设计方法</li><li>3NF的设计方法</li><li>面向对象的数据库设计方法</li><li>统一建模语言（UML）方法</li></ul></li></ul><h3 id="数据库设计的基本步骤">7.1.3 数据库设计的基本步骤</h3><p>数据库设计的6个阶段：</p><ul><li>需求分析</li><li>概念结构设计：概念模型</li><li>逻辑结构设计：数据模型</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行和维护</li></ul><p>需求分析和概念设计独立于任何数据库管理系统；</p><p>逻辑设计和物理设计与选用的数据库管理系统密切相关。</p><p>参加数据库设计的人员</p><ul><li>系统分析人员和数据库设计人员<ul><li>自始至终参与数据库设计，其水平决定了数据库系统的 质量</li></ul></li><li>数据库管理员和用户代表<ul><li>主要参加需求分析与数据库的运行和维护</li></ul></li><li>应用开发人员<ul><li>包括程序员和操作员</li><li>在实施阶段参与进来，分别负责编制程序和准备软硬件 环境</li></ul></li></ul><h3 id="数据库设计过程中的各级模式">7.1.4数据库设计过程中的各级模式</h3><ul><li>需求分析阶段：综合分析应用要求</li><li>概念结构设计阶段：概念模式</li><li>逻辑结构设计阶段：逻辑模式与面向应用的外模式</li><li>物理结构设计阶段：内模式</li></ul><h2 id="需求分析">7.2 需求分析</h2><h4 id="数据字典">数据字典</h4><p>数据字典是关于数据库中数据的描述，即元数据，而非数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善的。它在数据库设计中占有重要地位。</p><p>数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。</p><ul><li>数据项：不可再分的数据单位</li><li>数据结构：由若干数据项组成，反映了数据之间的组合关系</li><li>数据流：数据结构在系统内传输的路径</li><li>数据存储：数据结构停留或保存的地方</li><li>处理过程：一般用判定表或判定树来描述</li></ul><p>需求分析阶段收集到的基础数据是下一步进行概念设计的基础。</p><h2 id="概念设计">7.3 概念设计</h2><p>将需求分析得到的用户需求抽象为信息结构的过程就是概念结构设计。</p><h3 id="概念结构设计">概念结构设计</h3><h4 id="实体与属性的划分">实体与属性的划分</h4><p>现实世界事物能作为属性的尽量作为属性对待以简化E-R图。</p><ul><li>作为属性，不能再具有需要描述的物质</li><li>属性不能与其他实体具有联系</li></ul><p>方法：自顶向下地进行需求分析，自底向上地设计概念结构</p><ul><li>首先设计各子系统E-R图，再进行集成、重构</li><li>各子系统E-R图的冲突：<ul><li>属性冲突：属性域、取值单位冲突</li><li>命名冲突：同名异义，异名同义</li><li>结构冲突</li></ul></li></ul><h3 id="e-r模型">E-R模型</h3><p>用实体-联系（E-R）图来描述现实世界的概念模型。</p><p>E-R图提供了表示实体型、属性和联系的方法。</p><ul><li>实体型用矩形表示，矩形内写明实体名</li><li>属性用椭圆形表示，用无向边将其与相应的实体型连接</li><li>联系用菱形表示，菱形内写明联系名，用无向边分别与有关实体型连接，同时在边旁标上联系的类型（1:1、1:n或m:n）</li></ul><p>E-R图的绘制：</p><p>先绘制实体属性图、实体联系图，再进行综合。</p><h4 id="e-r扩展">E-R扩展</h4><h5 id="isa联系">ISA联系</h5><p>某些实体型是某个实体型的子类型，这种父类-子类联系称为ISA联系。</p><p>ISA联系描述了实体型中实体的一种分类方法：</p><ul><li>分类属性<ul><li>使用分类属性的值把父实体型中的实体分派到子实体型中</li></ul></li><li>不相交约束和可重叠约束<ul><li>父类中的一个实体是否能同时属于多个子类中的实体集</li></ul></li><li>完备性约束<ul><li>父类中的一个实体是否必须是某一个子类中的实体<ul><li>是，称为完全特化，双线连接，否则为部分特化，单线连接</li></ul></li></ul></li></ul><h5 id="基数约束">基数约束</h5><p>基数约束是对实体之间一对一、一对多和多对多的细化。</p><p>约束使用一个数对min..max表示</p><ul><li>min = 1的约束为强制参与约束；min = 0的约束为非强制参与约束。</li></ul><h5 id="part-of联系">Part-of联系</h5><p>部分联系，表明某个实体型是另外一个实体型的一部分。</p><ul><li>非独占联系：整体被破坏，部分实体可以存在，用非强制参与联系表示<ul><li>称该部分实体为强实体型</li></ul></li><li>独占联系：整体被破坏，部分实体不能存在<ul><li>称该部分实体为弱实体型，用双矩形表示，用双菱形表示识别联系</li></ul></li></ul><h3 id="uml">UML</h3><p>暂略</p><h2 id="逻辑结构设计">7.4 逻辑结构设计</h2><p>逻辑结构设计的任务就是把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。</p><h3 id="e-r图向关系模型的转换">7.4.1 E-R图向关系模型的转换</h3><p>一般原则：</p><ul><li><p>一个实体型转换为一个关系模式，关系的属性和码就是实体的属性和码。</p></li><li><p>对于实体间的联系：</p><ul><li>1:1联系可以转换为一个独立的关系模式，也可以和任一端的关系模式合并</li><li>1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</li><li>m:n联系可以转换为一个关系模式，与该联系相连的各实体的码以及联系本身的属性均转换成关系的属性，各实体的码组成关系的码或其一部分</li><li>3个及以上实体间的一个多元联系可以转换为一个关系模式</li><li>具有相同码的关系模式可以合并</li></ul></li></ul><h3 id="数据模型的优化">7.4.2 数据模型的优化</h3><p>数据库逻辑设计的结果不是唯一的。</p><p>规范化理论指导的优化方法：</p><ol type="1"><li>确定数据依赖</li><li>对各个关系模式之间的数据依赖进行极小化处理，消除冗余联系</li><li>按照数据依赖的理论对关系模式逐一进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式</li><li>根据需求分析阶段得到的处理要求分析对于这样的应用环境这些模式是否合适，是否要对某些模式进行合并或分解<ul><li>并不是规范化程度越高的关系就越优</li></ul></li><li>对关系模式进行必要分解<ul><li>水平分解：把关系的元组分为若干子集合，定义每个子集合为一个子关系</li><li>垂直分解：把关系模式的属性分解为若干子集合，形成若干子关系模式</li></ul></li></ol><h3 id="设计用户子模式">7.4.3 设计用户子模式</h3><ul><li>使用更符合用户习惯的别名</li><li>可以对不同级别的用户定义不同的视图</li><li>简化用户对系统的使用</li></ul><h2 id="物理结构设计">7.5 物理结构设计</h2><p>数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。</p><p>为一个给定的逻辑模型选取最适合应用要求物理结构的过程，就是数据库的物理设计。其内容主要包括为关系模式选择存取方法，以及设计关系、索引等数据库文件的物理存储结构。</p><p>物理设计一般分为两步：</p><ol type="1"><li>确定数据库物理结构，在关系数据库中主要指存取方法和存储结构</li><li>对物理结构进行评价，评价的重点是时间和空间效率</li></ol><h3 id="关系模式存取方法">7.5.1 关系模式存取方法</h3><p>常用的存取方法为索引方法和聚簇方法。</p><ul><li>B+树索引存取方法</li><li>hash索引存取方法</li><li>聚簇存取方法<ul><li>为了提高某个或某些属性的查询速度，把这个或这些属性上具有相同值的元组集中存放在连续的物理块中称为聚簇，该属性或属性组称为聚簇码</li></ul></li></ul><h3 id="确定数据库的存储结构">7.5.2 确定数据库的存储结构</h3><p>确定数据库物理结构主要指确定数据的存放位置和存储结构，需要综合考虑存取时间、存取空间利用率和维护代价三方面因素。</p><h2 id="数据库的实施和维护">7.6 数据库的实施和维护</h2><h3 id="数据的载入和应用程序的调试">7.6.1数据的载入和应用程序的调试</h3><p>数据库实施阶段包括两项重要工作：数据的载入、应用程序的编码与调试</p><ul><li>组织数据入库是数据库实施阶段最主要的工作。<ul><li>数据装载办法：人工、计算机辅助数据入库</li></ul></li><li>数据库应用程序的设计应该与数据库设计同时进行</li></ul><h3 id="数据库的试运行">7.6.2 数据库的试运行</h3><ul><li>先输入小批量数据调试，合格后再输入大批量数据，逐步完成运行评价</li><li>做好数据库转储和恢复工作</li></ul><h3 id="数据库的运行和维护">7.6.3 数据库的运行和维护</h3><ul><li>数据库的转储和恢复</li><li>数据库的安全性、完整性控制</li><li>数据库性能的监督、分析和改造</li><li>数据库的重组织和重构造</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我自横刀向天笑，去留肝胆两昆仑。&lt;/p&gt;</summary>
    
    
    
    <category term="数据管理基础" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据管理基础-第六章_关系数据理论</title>
    <link href="http://example.com/2023/06/06/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
    <id>http://example.com/2023/06/06/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</id>
    <published>2023-06-06T09:00:00.000Z</published>
    <updated>2023-06-14T15:39:23.475Z</updated>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第六章-关系数据理论">第六章 关系数据理论</h1><h2 id="关系模式与范式">6.1 关系模式与范式</h2><h3 id="数据依赖">数据依赖</h3><p>数据依赖是一个关系内部属性和属性之间的一种约束关系，这种约束关系是通过属性间值的相等与否体现出来的数据间相关联系，是数据内在的性质，语义的体现。</p><p>最重要的数据依赖：</p><ul><li>函数依赖（Functional Dependency，FD）</li><li>多值依赖（Multi-Valued Dependency，MVD）</li></ul><h3 id="关系模式">关系模式</h3><p>在第2章中的五元组关系模式：R(U,D,DOM,F)</p><ul><li>R为符号化的元组语义</li><li>U为一组属性</li><li>D为属性组U的属性所来自的域</li><li>DOM为属性到域的映射</li><li>F为U上的一组数据依赖</li></ul><p>由于D、DOM与模式设计关系不大，本章中把关系模式看作三元组R&lt;U,F&gt;，当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系。</p><h4 id="第一范式1nf">第一范式（1NF）</h4><p>每一个分量都是不可分的数据项的关系模式。</p><p>1NF的问题：</p><p>例：U={Sno,Sdept,Mname,Cno,Grade} //学号、系、系主任名、课程号、成绩</p><ul><li><p>数据冗余</p><p>每个系的系主任名重复出现</p></li><li><p>更新异常</p><p>数据冗余使得更新数据库的代价较大</p></li><li><p>插入异常</p><p>无学生的系无法存入系和系主任的信息</p></li><li><p>删除异常</p><p>学生全部毕业，则系和系主任信息也被删除</p></li></ul><p>改进：分成三个关系模式：</p><ul><li><p>S(Sno,Sdept,Sno-&gt;Sdept)</p></li><li><p>SC(Sno,Cno,Grade,(Sno,Cno)-&gt;Grade)</p></li><li><p>DEPT(Sdept,Mname,Sdept-&gt;Mname)</p></li></ul><h2 id="规范化">6.2 规范化</h2><h3 id="函数依赖">6.2.1 函数依赖</h3><p>定义较为抽象，总结为：</p><ul><li>关系R中两个属性组X和Y，对于Y的任一取值有唯一X确定它，则Y函数依赖于X<ul><li>记为X-&gt;Y</li><li>Y包含于X，此时为平凡的函数依赖</li></ul></li><li>不存在X的真子集能函数确定Y，则Y完全函数依赖于X，否则为部分函数依赖<ul><li>完全函数依赖在箭头上写F，部分写P</li></ul></li><li>Z平凡函数依赖于Y，Y平凡函数依赖于X，则Z传递函数依赖于X</li></ul><p>以下为定义：</p><p>设R(U)是属性集U上的关系模式，X和Y是U的子集，若对R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则X函数确定Y或Y函数依赖于X，记作X-&gt;Y。</p><p>函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。</p><ul><li>X-&gt;Y，Y不包含于X，则称X-&gt;Y为非平凡的函数依赖，一般都讨论这样的函数依赖</li><li>X-&gt;Y，Y包含于X，则称X-&gt;Y为平凡的函数依赖，它对任意关系模式都必然成立</li><li>X-&gt;Y，X称为这个函数依赖的决定属性组，称为决定因素</li><li>X-&gt;Y，Y-&gt;X，记作X&lt;--&gt;Y</li></ul><p>在R(U)中，如果X-&gt;Y，并且对于X的任意真子集X'，都有X'不函数确定Y，则称Y对X完全函数依赖，记作X-&gt;^FY，</p><p>若X-&gt;Y，但Y不对X完全函数依赖，则称Y对X部分函数依赖，记作X-&gt;^PY</p><p>在R(U)中，如果X-&gt;Y不平凡，Y-&gt;Z不平凡，则称Z对X传递函数依赖，记为X-&gt;^{传递}Z</p><ul><li>如果X-&gt;Y平凡，此处为直接函数依赖</li></ul><h3 id="码">6.2.2 码</h3><p>设K是R&lt;U,F&gt;中的属性或属性组合，若U完全函数依赖于K，则K为R的候选码。</p><ul><li>若U部分函数依赖于K，则K称为超码。候选码是最小的超码。</li></ul><p>若候选码多于一个，则选定其中的一个为主码。</p><ul><li><p>包含在任何一个候选码中的属性称为主属性，反之为非主属性或非码属性。</p></li><li><p>整个属性组是码，称为全码</p></li></ul><p>关系模式R中属性或属性组X并非R的码，但是另一个关系模式的码，称X为R的外码。</p><h3 id="范式">6.2.3 范式</h3><p>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</p><p>高级范式真包含于低级范式，从高到低有5NF、4NF、BCNF、3NF、2NF、1NF。</p><p>一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程称为规范化。</p><p>定义抽象，小结：</p><ul><li>1NF：候选码能函数确定每个非主属性</li><li>2NF：候选码能完全函数确定每个非主属性</li><li>3NF：存在码能直接（而非传递）完全函数确定每个非主属性</li><li>BCNF：每个码都能函数确定任意非主属性</li></ul><h4 id="nf">2NF</h4><p>若R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R属于2NF。</p><h4 id="nf-1">3NF</h4><p>若R属于1NF，且每一个非主属性既不传递依赖于码，也不部分依赖于码，则R属于3NF。</p><h4 id="bcnf">BCNF</h4><p>关系模式R中，若每一个决定因素都包含码，则R属于BCNF。</p><ul><li>所有非主属性对每一个码都是完全函数依赖</li><li>所有主属性对每一个不包含它的码也是完全函数依赖</li><li>没有任何属性完全依赖于非码的任何一组属性</li></ul><h4 id="多值依赖">多值依赖</h4><p>设R(U)是属性集U上的一个关系模式，X，Y，Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X-&gt;-&gt;Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。</p><p>性质：</p><ul><li>对称性：X-&gt;-&gt;Y， 则X-&gt;-&gt;Z，其中Z=U-X-Y。</li><li>传递性：X-&gt;-&gt;Y，Y-&gt;-&gt;Z，则X-&gt;-&gt;Z-Y</li><li>函数依赖是多值依赖的特殊情况</li><li>若X-&gt;-&gt;Y，X-&gt;-&gt;Z，则X-&gt;-&gt;YZ，X-&gt;-&gt;Y交Z，X-&gt;-&gt;Y-Z，X-&gt;-&gt;Z-Y</li></ul><p>特点：</p><ul><li><p>多值依赖的有效性与属性集的范围有关</p></li><li><p>若函数依赖X-&gt;-&gt;Y在R(U)上成立，则对于任何Y‘包含于Y，均有X-&gt;-&gt;Y'成立。而多值依赖X-&gt;-&gt;Y若在R(U)上成立，却不能断言对于任何Y'包含于Y有X-&gt;-&gt;Y'成立。</p></li></ul><h4 id="nf-2">4NF</h4><p>限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</p><h3 id="规范化小结">6.2.4 规范化小结</h3><p>规范化的基本思想是逐步消除数据依赖的不合适部分，实质上是概念的单一化。</p><p>关系模式的规范化过程是通过对关系模式的分解来实现的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我自横刀向天笑，去留肝胆两昆仑。&lt;/p&gt;</summary>
    
    
    
    <category term="数据管理基础" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据管理基础-第五章_数据库完整性</title>
    <link href="http://example.com/2023/06/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    <id>http://example.com/2023/06/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</id>
    <published>2023-06-05T08:00:00.000Z</published>
    <updated>2023-06-12T09:05:00.228Z</updated>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第五章-数据库完整性">第五章 数据库完整性</h1><p>数据库的完整性是指数据的正确性和相容性。</p><ul><li>数据的正确性是指数据是复合现实世界语义，反映当前实际情况的</li><li>数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的</li></ul><p>数据库管理系统为维护数据库完整性而实现的功能：</p><ul><li>提供定义完整性约束条件的机制</li><li>提供完整性检查的方法</li><li>进行违约处理</li></ul><p>关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能够为所有用户和应用提供一致的数据库完整性。</p><h2 id="实体完整性">5.1 实体完整性</h2><p>关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。</p><ul><li>对单属性构成的码，可以在列级定义，也可以在表级定义<ul><li>Sno CHAR(9) PRIMARY KEY</li><li>PRIMARY KEY (Sno)</li></ul></li><li>对多属性构成的码，只能在表级定义<ul><li>PRIMARY KEY(Sno, Cno)</li></ul></li></ul><p>实体完整性检查和违约处理</p><ul><li>检查主码的各个属性是否为空，有一个为空就拒绝插入或修改</li><li>检查主码值是否唯一，如果不唯一就拒绝插入或修改<ul><li>方法：全表扫描、B+树索引</li></ul></li></ul><h2 id="参照完整性">5.2 参照完整性</h2><p>关系模型的参照完整性在CREATE TABLE中用FOREIGNKEY来定义哪些列尾外码，用REFERENCES短语指明这些外码参照哪些表的主码。</p><p>参照完整性检查和违约处理</p><table><thead><tr class="header"><th>被参照表</th><th>参照表</th><th>违约处理</th></tr></thead><tbody><tr class="odd"><td>可能破坏参照完整性</td><td>插入元组</td><td>拒绝</td></tr><tr class="even"><td>可能破坏参照完整性</td><td>修改外码值</td><td>拒绝</td></tr><tr class="odd"><td>删除元组</td><td>可能破坏参照完整性</td><td>拒绝/级联删除/设置为空值</td></tr><tr class="even"><td>修改主码值</td><td>可能破坏参照完整性</td><td>拒绝/级联删除/设置为空值</td></tr></tbody></table><ul><li>拒绝（NO ACTION），一般为默认策略</li></ul><h2 id="用户定义的完整性">5.3 用户定义的完整性</h2><p>用户定义的完整性就是针对某一具体应用的数据必须满足的语义条件。</p><ul><li><p>属性上的约束条件</p><ul><li><p>非空（NOT NULL）</p></li><li><p>唯一（UNIQUE）</p></li><li><p>用CHECK语句指定列值条件</p><p><code>Sex CHAR(2) CHECK (Sex IN('男','女'))</code></p></li><li><p>修改或插入时检查；违约处理：拒绝执行</p></li></ul></li><li><p>元组上的约束条件</p><ul><li>用CHECK指定元组约束条件</li><li>修改或插入时检查；违约处理：拒绝执行</li></ul></li></ul><h2 id="完整性约束命名子句">5.4 完整性约束命名子句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>完整性约束条件名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>完整性约束条件<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student <br>(Sno <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">6</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span> (Sno <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">90000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">99999</span>), <br> Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C2 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br> Sage <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>), <br> Ssex <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C4 <span class="hljs-keyword">CHECK</span>(SSex <span class="hljs-keyword">IN</span>(<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>)), <br><span class="hljs-keyword">CONSTRAINT</span> StudentKey <span class="hljs-keyword">PRIMARY</span> KEY(Sno)<br>;)<br></code></pre></td></tr></table></figure><p>修改例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C3;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><h2 id="域中的完整性限制">5.5 域中的完整性限制</h2><p>域是一组具有相同数据类型的值的集合。</p><p>SQL中，可以用CREATEDOMAIN来创建一个域以及其应该满足的完整性约束条件以定义属性。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DOMAIN GenderDomain <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">CONSTRAINT</span> GD <span class="hljs-keyword">CHECK</span>(<span class="hljs-keyword">VALUE</span> <span class="hljs-keyword">IN</span>(<span class="hljs-string">&#x27;男&#x27;</span>，<span class="hljs-string">&#x27;女&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="断言">5.6 断言</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ASSERTION <span class="hljs-operator">&lt;</span>断言名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">CHECK</span>子句<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h2 id="触发器">5.7 触发器</h2><p>触发器（trigger）是用户定义在关系表上的一类由事件驱动的特殊过程。</p><ul><li>触发器又叫事件-条件-动作规则。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span><br>&#123;BEFORE<span class="hljs-operator">|</span>AFTER&#125; <span class="hljs-operator">&lt;</span>触发事件<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-comment">/* 指明触发器激活时间在事件前后 */</span><br><span class="hljs-keyword">REFERENCING</span> <span class="hljs-keyword">NEW</span><span class="hljs-operator">|</span><span class="hljs-keyword">OLD</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>变量<span class="hljs-operator">&gt;</span>  <span class="hljs-comment">/* 指明引用的变量 */</span><br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> &#123;<span class="hljs-type">ROW</span><span class="hljs-operator">|</span>STATEMENT&#125;<br>[<span class="hljs-keyword">WHEN</span> <span class="hljs-operator">&lt;</span>触发条件<span class="hljs-operator">&gt;</span>] <span class="hljs-operator">&lt;</span>触发动作体<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只有表的拥有者才能在表上创建触发器，且触发器数量有限</li><li>同一模式下，触发器名必须是唯一的，且触发器名和表名必须在同一模式下</li><li>触发器只能定义在基本表上，不能定义在视图上</li><li>触发事件可以是INSERT、DELETE或UPDATE，也可以是其组合</li><li>行级触发器每行都执行，语句级触发器只触发一次</li></ul><p>删除触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;我自横刀向天笑，去留肝胆两昆仑。&lt;/p&gt;</summary>
    
    
    
    <category term="数据管理基础" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据管理基础-第四章_数据库安全性</title>
    <link href="http://example.com/2023/06/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://example.com/2023/06/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</id>
    <published>2023-06-04T07:00:00.000Z</published>
    <updated>2023-06-13T09:25:24.255Z</updated>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第四章-数据库安全性">第四章 数据库安全性</h1><h2 id="数据库安全性概述">4.1 数据库安全性概述</h2><p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</p><p>系统安全保护措施是否有效是数据库系统的主要技术指标之一。</p><h3 id="数据库的不安全因素">数据库的不安全因素</h3><ul><li>非授权用户对数据库的恶意存取和破坏</li><li>数据库中重要或敏感的数据被泄露</li><li>安全环境的脆弱性</li></ul><h3 id="安全标准简介">安全标准简介</h3><p>TCSEC/TDI</p><table><thead><tr class="header"><th>安全级别</th><th>定义</th></tr></thead><tbody><tr class="odd"><td>A1</td><td>验证设计</td></tr><tr class="even"><td>B3</td><td>安全域</td></tr><tr class="odd"><td>B2</td><td>结构化保护</td></tr><tr class="even"><td>B1</td><td>标记安全保护</td></tr><tr class="odd"><td>C2</td><td>受控的存取保护</td></tr><tr class="even"><td>C1</td><td>自主安全保护</td></tr><tr class="odd"><td>D</td><td>最小保护</td></tr></tbody></table><ul><li><p>D级，最低级别，一切不符合更高标准的系统均归于D组</p></li><li><p>C1：能够实现对用户和数据的分离，进行自主存取控制(DAC)</p></li><li><p>B1：对系统数据加以标记，并对被标记的主客体实施强制存取控制(MAC)以及审计</p></li><li><p>B1以上为安全产品</p></li></ul><p>CC（Common Criteria）：安全功能要求和安全保证要求</p><h2 id="数据库安全性控制">4.2 数据库安全性控制</h2><p>主要内容：</p><ul><li>用户身份鉴别</li><li>多层存取控制</li><li>审计</li><li>视图</li><li>数据加密</li></ul><h3 id="用户身份鉴别">4.2.1 用户身份鉴别</h3><p>常见方法：</p><ul><li>静态口令鉴别</li><li>动态口令鉴别</li><li>生物特征鉴别</li><li>智能卡鉴别</li></ul><h3 id="存取控制">4.2.2 存取控制</h3><p>存取控制机制的组成：</p><ul><li>定义用户权限<ul><li>提供适当语言以定义用户权限，编译后存储在数据字典中，称为安全规则</li></ul></li><li>合法权限检查<ul><li>根据安全规则进行合法权限检查</li></ul></li><li>定义用户权限和合法权限检查机制一起组成了数据库管理系统的存取控制子系统。</li></ul><p>C2级的数据库管理系统支持自主存取控制（Discretionary AccessControl，DAC）；</p><p>B1级的数据库管理系统支持强制存取控制（Mandatory AccessControl，MAC）。</p><ul><li>在自主存取控制中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，用户可将其拥有的存取权限转授给其他用户</li><li>在强制存取控制中，每个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取</li></ul><h4 id="自主存取控制">自主存取控制</h4><p>用户权限的两个要素：数据库对象和操作类型</p><ul><li>在数据库系统中，定义存取权限称为授权</li></ul><p>关系数据库系统中，存取控制的对象不仅有数据本身，还有数据库模式</p><table><thead><tr class="header"><th>对象类型</th><th>对象</th></tr></thead><tbody><tr class="odd"><td>数据</td><td>基本表和视图、属性列</td></tr><tr class="even"><td>数据库模式</td><td>模式、基本表、视图、索引</td></tr></tbody></table><p>SQL使用GRANT语句向用户授予权限，REVOKE语句收回已经授予用户的权限。</p><h5 id="grant">GRANT</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION]<br></code></pre></td></tr></table></figure><ul><li>如果制定了WITH GRANTOPTION子句，则授权的用户可以把这种权限转授。</li><li>GRANT ALL PRIVILEGES可以将全部操作权限授予用户</li><li>授予全部用户：TO PUBLIC</li><li>对属性列授权时必须明确指出相应的属性列名</li></ul><h5 id="revoke">REVOKE</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...[CASCADE<span class="hljs-operator">|</span>RESTRICT];<br></code></pre></td></tr></table></figure><ul><li>一般默认CASCADE，将收回全部直接或间接从该用户获得的对应权限，而RESTRICT只收回指定用户的权限</li></ul><h5 id="创建数据库模式的权限">创建数据库模式的权限</h5><p>创建数据库模式一类的数据库对象的授权由数据库管理员在创建用户时完成。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WITH</span>] [DBA<span class="hljs-operator">|</span>RESOURCE<span class="hljs-operator">|</span><span class="hljs-keyword">CONNECT</span>];<br></code></pre></td></tr></table></figure><ul><li>只有系统的超级用户才有权创建一个新的数据库用户</li><li>新创建的数据库用户有三种权限：CONNECT、RESOURCE、DBA，默认CONNECT<ul><li>CONNECT权限用户不能创建新用户、模式、基本表</li><li>RESOURCE权限用户可以创建基本表，不能创建新用户和模式</li><li>DBA权限用户是系统的超级用户，可以创建新用户、模式和基本表，拥有所有数据库对象的存取权限</li></ul></li></ul><h5 id="数据库角色-role">数据库角色 ROLE</h5><p>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。</p><ul><li>为一组具有相同权限的用户创建一个角色，简化授权的过程</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ROLE <span class="hljs-operator">&lt;</span>角色名<span class="hljs-operator">&gt;</span>;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">3</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> ADMIN OPTION]<br><br><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br></code></pre></td></tr></table></figure><ul><li>如果指定了WITH ADMIN OPTION，那么获得权限的用户可以转授该权限。</li></ul><h4 id="强制存取控制">强制存取控制</h4><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类。</p><ul><li><p>主体是系统中的活动实体，既包括数据管理系统所管理的实际用户，也包括代表用户的各进程</p></li><li><p>客体是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引等。</p></li><li><p>对于主体和客体，数据库管理系统为它们每个实例指派一个敏感度标记（label）</p><p>敏感度标记被分为若干级别，如绝密（TopSecret，TS），机密（Secret，S），可信（Confidential，C），公开（Public，P），TS&gt;=S&gt;=C&gt;=P</p><p>主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级</p><ul><li>仅当主体的许可证级别大于等于客体的密级时，该主体才能读取该客体</li><li>仅当主体的许可证级别小于等于客体的密级时，该主体才能写该客体</li><li>即用户只能读低于或等于自己许可的数据，创建高于或等于自己许可的数据，以防止高级用户将数据泄露给低级用户</li></ul></li><li><p>强制存取控制对数据本身加以的密级标识和数据时一个整体</p></li></ul><h5id="自主存取控制强制存取控制dacmac">自主存取控制+强制存取控制（DAC+MAC）</h5><p>先进行自主存取控制审查，在进行强制存取控制检查</p><h2 id="一些安全性保护办法">4.3 一些安全性保护办法</h2><h3 id="视图机制">4.3.1 视图机制</h3><p>把要保密的数据对无权存取的用户隐藏起来，为数据提供一定程度的安全保护。</p><h3 id="审计audit">4.3.2 审计（audit）</h3><p>审计功能把用户对数据库的所有操作自动记录下来放入审计日志（auditlog）。</p><ul><li>审计通常是很费时间和空间的，所以数据库系统往往都将审计设置成可选的</li><li>审计设置以及审计日志一般存储在数据字典中，必须开启审计开关（设置audit_trail为true），才能在系统表SYS_AUDITTRAIL中看到审计信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">AUDIT <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>;<br><br>NOAUDIT <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>审计一般可以分为用户级审计和系统级审计。</p><p>数据库安全审计系统提供了一种事后检查的安全机制。安全审计机制将特定用户或者特定对象相关的操作记录到系统审计日志中，作为后续对操作的查询分析和追踪的依据。通过审计机制，可以约束用户可能的恶意操作。</p><h3 id="数据加密">4.3.3 数据加密</h3><p>加密的基本思想是依据一定的算法将原始数据——明文（plaintext）变换为不可直接识别的格式——密文（cipher text）。</p><p>数据加密主要包括存储加密和传输加密。</p><ul><li>存储加密<ul><li>透明存储加密：内核级加密保护，对用户完全透明</li><li>非透明存储加密：通过多个加密函数实现</li></ul></li><li>传输加密<ul><li>链路加密：对传输数据在链路层进行加密，加密报文和报头</li><li>端到端加密：在发送端加密，接收端解密，加密报文</li></ul></li></ul><h3 id="其他安全性保护">4.3.4 其他安全性保护</h3><ul><li><p>推理控制：避免由低级数据推导出高级数据</p></li><li><p>隐蔽信道：间接信息传递</p></li><li><p>数据隐私：控制不愿他人知道或他人不便知道的个人数据的能力</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我自横刀向天笑，去留肝胆两昆仑。&lt;/p&gt;</summary>
    
    
    
    <category term="数据管理基础" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据管理基础-第三章_SQL</title>
    <link href="http://example.com/2023/06/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%89%E7%AB%A0_SQL/"/>
    <id>http://example.com/2023/06/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%89%E7%AB%A0_SQL/</id>
    <published>2023-06-03T06:00:00.000Z</published>
    <updated>2023-06-13T07:56:32.900Z</updated>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第三章-sql">第三章 SQL</h1><p>结构化查询语言（Structured QueryLanguage，SQL）是关系数据库标准语言，功能包括</p><ul><li>数据库的查询</li><li>数据库模式创建</li><li>数据库数据的插入与修改</li><li>数据库安全性完整性定义与控制</li><li>……</li></ul><h2 id="sql概述">3.1 SQL概述</h2><h3 id="sql的特点">3.1.1 SQL的特点</h3><ul><li>综合统一<ul><li>集数据定义语言、数据操纵语言、数据控制语言于一体</li></ul></li><li>高度非过程化<ul><li>存取路径的选择以及SQL的操作过程由系统自动完成</li></ul></li><li>面向集合的操作方式<ul><li>操作对象、查找结果都可以是元组的集合</li></ul></li><li>以同一种语法结构提供多种使用方式<ul><li>能嵌入到C++、Java中</li></ul></li><li>语言简洁，易学易用<ul><li>数据查询：SELECT</li><li>数据定义：CREATE、DROP、ALTER</li><li>数据操纵：INSERT、UPDATE、DELETE</li><li>数据控制：GRANT、REVOKE</li></ul></li></ul><h3 id="sql的基本概念">3.1.2 SQL的基本概念</h3><h4 id="sql与三级模式">SQL与三级模式</h4><ul><li>内模式：存储文件</li><li>模式：基本表</li><li>外模式：视图</li></ul><p>用户可以用SQL对基本表和视图进行查询或其他操作。基本表和视图都是关系。</p><p>基本表是本事独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表，一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。</p><p>存储文件的逻辑结构组成了关系数据库的内模式，其逻辑结构对用户是隐蔽的。</p><p>视图是一个或几个基本表导出的表，它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据。这些数据仍存放在导出视图的基本表中，因而视图仅仅是一个虚表。用户可以在视图上再定义视图。</p><h2 id="数据定义">3.2 数据定义</h2><p>层次化的数据库对象命名机制：</p><p>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</p><p>SQL的数据定义：模式定义、表定义、视图定义和索引定义</p><table><thead><tr class="header"><th>操作对象</th><th>创建</th><th>删除</th><th>修改</th></tr></thead><tbody><tr class="odd"><td>模式</td><td>CREATE SCHEMA</td><td>DROP SCHEMA</td><td></td></tr><tr class="even"><td>表</td><td>CREATE TABLE</td><td>DROP TABLE</td><td>ALTER TABLE</td></tr><tr class="odd"><td>视图</td><td>CREATE VIEW</td><td>DROP VIEW</td><td></td></tr><tr class="even"><td>索引</td><td>CREATE INDEX</td><td>DROP INDEX</td><td>ALTER INDEX</td></tr></tbody></table><h3 id="模式">模式</h3><p>定义模式即定义了一个命名空间，在此空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">AUTHORIZATION</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-operator">&lt;</span>表定义子句<span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>视图定义子句<span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>授权定义子句<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure><p>不指定模式名时，模式名将隐含为用户名。</p><p>删除模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>CASCADE<span class="hljs-operator">|</span>RESTRICT<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><ol type="1"><li>CASCADE：删除模式的同时删除该模式中所有数据库对象</li><li>RESTRICT：如果该模式中定义了下属的数据库对象，则拒绝执行删除</li></ol><h3 id="基本表">基本表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]<br>[，<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]]<br>…<br>[，<span class="hljs-operator">&lt;</span>表级完整性约束条件<span class="hljs-operator">&gt;</span>]);<br></code></pre></td></tr></table></figure><p>列级完整性：PRIMARY KEY、UNIQUE、NOT NULL等</p><p>表级完整性：PRIMARY KEY(Sno, Cno)；FOREIGN KEY(Cno) REFERENCESCourse(Cno)</p><table><thead><tr class="header"><th>数据类型</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>CHAR(n),CHARACTER(n)</td><td>长度为n的定长字符串</td></tr><tr class="even"><td>VARCHAR(n)</td><td>最大长度为n的变长字符串</td></tr><tr class="odd"><td>CLOB</td><td>字符串大对象</td></tr><tr class="even"><td>BLOB</td><td>二进制大对象</td></tr><tr class="odd"><td>INT，INTEGER</td><td>长整数(4字节)</td></tr><tr class="even"><td>SMALLINT</td><td>短整数(2字节)</td></tr><tr class="odd"><td>BIGINT</td><td>大整数(8字节)</td></tr><tr class="even"><td>NUMERIC(p，d)</td><td>定点数，由p位数字(不包括符号、小数点)组成，小数后面有d位数字</td></tr><tr class="odd"><td>DECIMAL(p, d), DEC(p, d)</td><td>同NUMERIC</td></tr><tr class="even"><td>REAL</td><td>取决于机器精度的单精度浮点数</td></tr><tr class="odd"><td>DOUBLE PRECISION</td><td>取决于机器精度的双精度浮点数</td></tr><tr class="even"><td>FLOAT(n)</td><td>可选精度的浮点数，精度至少为n位数字</td></tr><tr class="odd"><td>BOOLEAN</td><td>逻辑布尔量</td></tr><tr class="even"><td>DATE</td><td>日期，包含年、月、日，格式为YYYY-MM-DD</td></tr><tr class="odd"><td>TIME</td><td>时间，包含一日的时、分、秒，格式为HH:MM:SS</td></tr><tr class="even"><td>TIMESTAMP</td><td>时间戳类型</td></tr><tr class="odd"><td>INTERVAL</td><td>时间间隔类型</td></tr></tbody></table><p>修改基本表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <br>[<span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>新列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [完整性约束]]<br>[<span class="hljs-keyword">ADD</span> <span class="hljs-operator">&lt;</span>表级完整性约束<span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">DROP</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [CASCADE<span class="hljs-operator">|</span> RESTRICT]]<br>[<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span><span class="hljs-operator">&lt;</span>完整性约束名<span class="hljs-operator">&gt;</span>[RESTRICT <span class="hljs-operator">|</span> CASCADE]]<br>[<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>]；<br></code></pre></td></tr></table></figure><ul><li><p>ADD用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件</p></li><li><p>DROP COLUMN用于删除表中列</p></li><li><p>DROP CONSTRAINT用于删除指定的完整性约束条件</p></li><li><p>ALTER COLUMN用于修改原有列定义，包括列名和数据类型</p></li></ul><h3 id="索引">索引</h3><p>作用：加快查询速度</p><p>建立索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>顺序<span class="hljs-operator">&gt;</span>]…);<br></code></pre></td></tr></table></figure><ul><li><p>顺序：</p><ul><li>升序：ASC</li><li>降序：DESC</li><li>缺省值：ASC</li></ul></li><li><p>UNIQUE：每个索引值只对应唯一的数据记录</p></li><li><p>CLUSTER：表示要建立的索引是聚簇索引</p></li></ul><p>修改索引：<code>ALTER INDEX &lt;旧名称&gt; RENAME TO &lt;新名称&gt;</code>;</p><p>删除索引：<code>DROP INDEX &lt;名称&gt;;</code></p><h2 id="数据查询">3.3 数据查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span><span class="hljs-operator">|</span><span class="hljs-keyword">DISTINCT</span>] <span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span>]…<br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表<span class="hljs-operator">/</span>视图名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>表<span class="hljs-operator">/</span>视图名<span class="hljs-operator">&gt;</span>]… <span class="hljs-operator">|</span> (<span class="hljs-keyword">SELECT</span>语句) [<span class="hljs-keyword">AS</span>] <span class="hljs-operator">&lt;</span>别名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件表达式<span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>条件表达式<span class="hljs-operator">&gt;</span>]]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]<br></code></pre></td></tr></table></figure><ul><li>DISTINCT：去除重复行，缺省为ALL</li><li>WHERE表示指定条件，作用于表<ul><li>BETWEEN AND（范围）、IN（集合）、LIKE（匹配字符）、ISNULL（空值）、AND OR（多重条件查询）、ORDER BY（升降排列）</li></ul></li><li>聚集函数只用于SELECT和GROUP BY中的HAVING子句<ul><li>COUNT、SUM、AVG、MAX、MIN（需要指定DISTINCT或ALL）</li></ul></li><li>GROUP BY按照某一列或多列的值分组<ul><li>指定属性值相同的元组为一组，然后对每一组作用聚集函数进行计算</li></ul></li></ul><table><thead><tr class="header"><th>查询条件</th><th>谓词</th></tr></thead><tbody><tr class="odd"><td>比较</td><td>=, &gt;, &lt;, &gt;=, &lt;=, !=, &lt;&gt;, !&gt;, !&lt;;NOT+上述比较运算符</td></tr><tr class="even"><td>确定范围</td><td>BETWEEN AND, NOT BETWEEN AND</td></tr><tr class="odd"><td>确定集合</td><td>IN, NOT IN</td></tr><tr class="even"><td>字符匹配</td><td>LIKE, NOT LIKE</td></tr><tr class="odd"><td>空值</td><td>IS NULL, IS NOT NULL</td></tr><tr class="even"><td>多重条件(逻辑运算)</td><td>AND, OR, NOT</td></tr></tbody></table><h4 id="字符匹配">字符匹配</h4><p>匹配串可以是一个完整的字符串，也可以含有通配符%(任意长度字符串)和_(任意单个字符)</p><p>用。</p><h4 id="空值">空值</h4><ul><li>产生：没赋值/修改/外连接/关系运算</li><li>判断：IS NULL / IS NOT NULL (注意IS一直有)</li><li>约束条件：NOT NULL / UNIQUE / PRIMARY KEY不能取空值</li><li>逻辑运算：TRUE FALSE UNKNOWN</li></ul><h4 id="聚集函数">聚集函数</h4><p>统计元组个数：COUNT(*)</p><p>统计一列中值的个数：COUNT([DISTINCT | ALL] <列名>)</p><p>计算一列值的总和(必须为数值型)：SUM([DISTINCT | ALL] <列名>)</p><p>计算一列值的平均值(必须为数值型)：AVG([DISTINCT | ALL] <列名>)</p><p>求最大最小值：MAX / MIN([DISTINCT | ALL] 列名)</p><h4 id="连接查询">连接查询</h4><p>连接查询即同时涉及两个以上表的查询，连接条件或连接谓词是连接两表的条件</p><p><列1> <比较运算符> <列2></p><p><列1> BETWEEN <列2> AND <列3></p><p>连接字段：连接谓词中的列名称。</p><ul><li><p>等值/自然连接：连接运算符为=。</p></li><li><p>自身连接：表与自己进行连接：需要给表起别名，并使用别名前缀以示区别。</p></li><li><p>多表连接</p></li></ul><p>连接操作的执行过程</p><ol type="1"><li>嵌套循环</li></ol><p>逐个对表1中每个元组执行遍历表2的连接操作。</p><ol start="2" type="1"><li>排序合并</li></ol><p>首先按连接属性对两表排序，然后查找表1中元组在表2中的连接，查找到大于表1字段值的元组后，查询不再继续。</p><ol start="3" type="1"><li>索引连接</li></ol><p>对表2按连接字段建立索引，依次查询表1中各元组的连接。</p><p>外连接：以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</p><p>SELECT <字段名> FROM <表名> LEFT JOIN <表名> ON <连接条件></p><h4 id="嵌套查询">嵌套查询</h4><p><字段名> IN/比较运算符 (ANY/ALL) <查询语句> (NOT) EXISTS<查询语句></p><h4 id="集合操作">集合操作</h4><ul><li>并 UNION、交 INTERSECT、差 EXCEPT</li></ul><p>参与集合操作的各查询结果的列数和各数据类型必须相同。</p><p>UNION：合并多个查询结果，去掉重复元组</p><p>UNION ALL：合并多个查询结果，保留重复元组</p><h4 id="派生表查询">派生表查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> (查询语句);<br></code></pre></td></tr></table></figure><p>若子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT语句子句后列名为其缺省属性。</p><h2 id="数据更新">3.4 数据更新</h2><ul><li><p>插入：INSERT INTO <表名> [<属性列>,…] VALUES (<常量>,…)</p><ul><li>指定要插入数据的表名及属性列，插入的元组在其余属性列取空值。</li><li>未指定属性列：插入完整元组，且属性列属性的顺序和表一致。</li><li>VALUES提供的值的个数与类型必须与INTO子句匹配。</li></ul></li><li><p>修改：UPDATE <表名> SET <列名>=<表达式>,… [WHERE 条件]</p></li><li><p>删除：DELETE FROM <表名> [WHERE 条件]</p></li></ul><h2 id="视图">3.5 视图</h2><p>视图是虚表，从一个或几个基本表导出，只存放定义而无数据，基表中数据变化，视图中数据也随之改变。</p><p>视图的更新是同步于基本表的，一般来说，行列子集视图可以更新，其他（如AVG）不可。</p><p>视图的作用：</p><ul><li>简化用户的操作</li><li>使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性<ul><li>外模式不变，即使模式变更也不影响</li></ul></li><li>对机密数据提供安全保护<ul><li>每个用户看到的视图不同</li></ul></li><li>可以更清晰地表达查询</li></ul><p>视图做不到的：</p><ul><li>部分特殊视图不允许更新</li><li>视图消解有局限性，有时不能正确地查询</li></ul><h3 id="建立视图">建立视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>,…)]<br><span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>子查询<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure><ul><li><p>WITH CHECKOPTION：对视图进行UPDATE、INSERT和DELETE时要保证更新的行满足视图定义中的谓词条件(即子查询中的条件表达式)。</p><ul><li>子查询可以是任意的select语句。</li></ul></li><li><p>行列子集视图：从单个表导出某些列，保留主码</p></li><li><p>组成视图的属性列名：全部省略或全部指定</p></li><li><p>实现增删改视图--&gt;增删改基本表：不写聚集函数</p></li></ul><p>关系数据库管理系统在执行CREATEVIEW的时候只是将视图定义存入数据字典，并不执行SELECT。查询时，按定义将其查出。</p><h3 id="删除视图">删除视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [CASCADE];<br></code></pre></td></tr></table></figure><p>CASCADE：级联地删除视图及其导出的视图。</p><h3 id="查询视图">查询视图</h3><p>用户查询视图与查询基本表一致。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我自横刀向天笑，去留肝胆两昆仑。&lt;/p&gt;</summary>
    
    
    
    <category term="数据管理基础" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据管理基础-第二章_关系数据库</title>
    <link href="http://example.com/2023/06/02/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2023/06/02/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2023-06-02T05:00:00.000Z</published>
    <updated>2023-06-17T07:02:52.121Z</updated>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第二章-关系数据库">第二章 关系数据库</h1><h2 id="关系数据结构及其形式化定义">2.1 关系数据结构及其形式化定义</h2><h3 id="关系">2.1.1 关系</h3><h4 id="关系数据结构的形式化定义">关系数据结构的形式化定义</h4><ol type="1"><li>域（domain）</li></ol><p>域是一组具有相同数据类型的值的集合</p><ol start="2" type="1"><li>笛卡尔积（cartesian product）</li></ol><p>笛卡尔积是域上的一种集合运算。</p><p>给定一组域<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>，允许其中某些域是相同的，<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>的笛卡尔积为</p><p><span class="math inline">\(D_1\times D_2\times ...\timesD_n=\{(d_1,d_2,...,d_n)|d_i\in D_i,i=1,2,...,n\}\)</span></p><p>其中，每个元素<spanclass="math inline">\((d_1,d_2,...,d_n)\)</span>称作一个n元组（n-tuple），或简称元组。元组中的每一个值<spanclass="math inline">\(d_i\)</span>称为一个分量。</p><p>一个域允许的不同取值个数称为这个域的基数（cardinal number）。</p><p>若<span class="math inline">\(D_i\)</span>为有限集，其基数为<spanclass="math inline">\(m_i(i=1,2,...,n)\)</span>，则<spanclass="math inline">\(D_1\times D_2\times ...\timesD_n\)</span>的基数M为</p><p><span class="math inline">\(M=\prod_{i=1}^n m_i\)</span></p><ol start="3" type="1"><li>关系</li></ol><p><span class="math inline">\(D_1\times D_2\times ...\timesD_n\)</span>的子集称为在域<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>上的关系，表示为<spanclass="math inline">\(R(D_1,D_2,...,D_n)\)</span>。</p><p>这里R表示关系的名字，n是关系的目或度（degree），关系中的每个元素是关系中的元组，通常用t表示。</p><ul><li>当<spanclass="math inline">\(n=1\)</span>时，称该关系为一元关系（unaryrelation）</li><li>当<spanclass="math inline">\(n=2\)</span>时，称该关系为二元关系（binaryrelation）</li></ul><p>关系是笛卡尔积的有限子集，故关系是一张每行对应一个元组的二维表，表的每列对应一个域。每列的名字为属性，n目关系必有n个属性。</p><p>若关系中的某一属性组能唯一地标识一个元组而其子集不能，则称该属性组为候选码（candidatekey）。</p><p>若一个关系有多个候选码，则选定其中一个为主码（primary key）。</p><p>候选码地各个属性为主属性（primeattribute）。不包含在任何候选码中的属性称为非主属性或非码属性。</p><p>在最简单地情况下，候选码只包含一个属性，在最极端地情况下，关系模式地所有属性是这个关系模式地候选码，称为全码（all-key）。</p><h5 id="关系的三种类型">关系的三种类型</h5><p>基本表、查询表和视图表，其中基本表为实际存在的表，查询表是查询结果对应的表，视图表是由基本表或其他视图表导出的表，是虚表。</p><h5 id="基本关系的性质">基本关系的性质</h5><ol type="1"><li>列是同质的，每一列中的分量是同一类型的数据，来自同一个域</li><li>不同的列可来自同一个域，但有不同的属性名</li><li>列和行都是无序的</li><li>任意两个元组的候选码不能取相同值</li><li>每个分量都是不可分的数据项</li></ol><p>关系模型要求关系必须是规范化的，满足一定的规范条件。规范化的关系称为范式（NormalForm，NF）。</p><h3 id="关系模式与关系数据库">2.1.2 关系模式与关系数据库</h3><p>关系的描述称为关系模式，可以形式化地表示为<spanclass="math inline">\(R(U,D,DOM,F)\)</span>。</p><p>其中R是关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间关系的依赖关系集合。</p><p>其中，<span class="math inline">\(DOM(属性名)=域名\)</span>。</p><p>关系模式可以简记为<spanclass="math inline">\(R(U)或R(A_1,A_2,...,A_n)\)</span>。其中<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>为属性名。</p><p>关系数据库的型称为关系数据库模式，包括若干域的定义和在这些域上定义的若干关系模式，是对关系数据库的描述。</p><p>关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</p><h2 id="关系操作">2.2 关系操作</h2><h3 id="基本关系操作">2.2.1 基本关系操作</h3><p>关系操作的对象和结果都是集合，这种方式也称为一次一集合方式，相应地，非关系数据模型的数据操作方式则为一次一记录的方式。</p><p>关系模型中常用的关系操作包括查询(query)操作和插入(insert)、删除(delete)、修改(update)操作两部分。</p><p>查询操作是关系操作中最主要的部分，包括：</p><p>选择(select)、投影(project)、连接(join)、除(divide)、并(union)、差(except)、交(intersection)、笛卡尔积等。</p><p>查询操作中，选择、投影、并、差、笛卡尔积是5种基本操作，其他操作可用基本操作来定义和导出。</p><h3 id="关系数据语言的分类">2.2.2 关系数据语言的分类</h3><p>早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数（relationalgebra）和关系演算（relation calculus）。</p><ul><li>关系代数用对关系的运算来表达查询要求</li><li>关系演算则用谓词来表达查询要求<ul><li>关系演算按谓词变元的基本对象是元组还是域变量分为元组关系演算和域关系演算</li></ul></li></ul><p>一个关系数据语言能够表示关系代数可以表示的查询，称为具有完备的表达能力，简称关系完备性。已经证明关系代数、元组关系演算和域关系演算在表达能力上是等价的。</p><p>结构化查询语言（Structured QueryLanguage，SQL）介于关系代数和关系演算之间。</p><p>SQL兼具查询、数据定义、数据控制功能，是集查询、数据定义语言、数据操纵语言和数据控制语言为一体的关系数据语言。</p><ul><li>SQL是一种高度非过程化的语言。</li></ul><h2 id="关系的完整性">2.3 关系的完整性</h2><p>关系模型中有三类完整性约束：实体完整性（entityintegrity）、参照完整性（referentialintegrity）和用户定义的完整性（user-defined integrity）</p><h3 id="实体完整性">实体完整性</h3><p>实体完整性规则：若属性A（一个或一组属性）是基本关系R的主属性，则A不能取空值</p><h3 id="参照完整性">参照完整性</h3><p>设F是基本关系R的一个或一组属性，但不是关系R的码，<spanclass="math inline">\(K_S\)</span>是基本关系S的主码。如果F与<spanclass="math inline">\(K_s\)</span>对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。</p><p>参照完整性规则：若属性F是基本关系R的外码，它与基本关系S的主码<spanclass="math inline">\(K_s\)</span>相对应，则对于R中每个原则在F上的值必须或者取空值，或者等于S中某个元组的主码值。</p><h3 id="用户定义的完整性">用户定义的完整性</h3><p>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</p><h2 id="关系代数">2.4 关系代数</h2><p>关系代数用对关系的运算来表达查询。</p><ul><li>关系代数的运算又分为传统的集合运算和专门的关系运算两类<ul><li>集合运算符：并<span class="math inline">\(\cup\)</span>、差<spanclass="math inline">\(-\)</span>、交<spanclass="math inline">\(\cap\)</span>、笛卡尔积<spanclass="math inline">\(\times\)</span></li><li>专门关系运算符：选择<spanclass="math inline">\(\sigma\)</span>、投影<spanclass="math inline">\(\prod\)</span>、连接<spanclass="math inline">\(\Join\)</span>、除<spanclass="math inline">\(\div\)</span></li></ul></li></ul><h3 id="传统的集合运算">2.4.1 传统的集合运算</h3><p>传统的集合运算是二目运算，包括并、差、交、笛卡尔积4种运算</p><p>（1）并（union）：<span class="math inline">\(R\cup S=\{t|t\in R \veet\in S\}\)</span></p><p>（2）差（except）：<span class="math inline">\(R-S=\{t|t\in R\wedget\notin S\}\)</span></p><p>（3）交（intersection）：<span class="math inline">\(R\cap S=\{t|t\inR\wedge t\in S\}\)</span></p><p>（4）笛卡尔积（cartesian product）：<spanclass="math inline">\(R\times S=\{t_rt_s|t_r\in R\wedge t_s\inS\}\)</span></p><h3 id="专门的关系运算">2.4.2 专门的关系运算</h3><p>专门的关系运算包括选择、投影、连接、除运算等。</p><p>引入几个记号：</p><ul><li><p>设关系模式为 <spanclass="math inline">\(R(A_1,A_2,...,A_n)\)</span>，它的一个关系设为<spanclass="math inline">\(R\)</span>。<span class="math inline">\(t\inR\)</span> 表示 <span class="math inline">\(t\)</span> 是 <spanclass="math inline">\(R\)</span> 的一个元组。<spanclass="math inline">\(t[A_i]\)</span> 则表示元组 <spanclass="math inline">\(t\)</span> 中相应于属性 <spanclass="math inline">\(A_i\)</span> 的一个分量。</p></li><li><p>若 <spanclass="math inline">\(A=\{A_{i1},A_{i2},...,A_{ik}\}\)</span>，其中<span class="math inline">\(A_{i1},A_{i2},...,A_{ik}\)</span> 是 <spanclass="math inline">\(A_1,A_2,...,A_n\)</span> 中的一部分，称<spanclass="math inline">\(A\)</span>为属性列或属性组。<spanclass="math inline">\(t[A]=(t[A_{i1}],t[A_{i2}],...,t[A_{in}])\)</span>为元组<spanclass="math inline">\(t\)</span>在属性列<spanclass="math inline">\(A\)</span>上诸分量的集合，<spanclass="math inline">\(\overline{A}\)</span>则表示<spanclass="math inline">\(\{A_1,A_2,...,A_n\}\)</span>中去掉<spanclass="math inline">\(\{A_{i1},A_{i2},...,A_{in}\}\)</span>后剩余的属性组。</p></li><li><p><span class="math inline">\(R\)</span>为<spanclass="math inline">\(n\)</span>目关系，<spanclass="math inline">\(S\)</span>为m目关系。<spanclass="math inline">\(t_r\in R\)</span>，<spanclass="math inline">\(t_s\in S\)</span>，<spanclass="math inline">\(t_rt_s\)</span>称为元组的连接或串接。它是一个<spanclass="math inline">\(n+m\)</span>列的新元组，前<spanclass="math inline">\(n\)</span>个分量为<spanclass="math inline">\(R\)</span>中的一个<spanclass="math inline">\(n\)</span>元组，后<spanclass="math inline">\(m\)</span>个分量为<spanclass="math inline">\(S\)</span>中的一个<spanclass="math inline">\(m\)</span>元组。</p></li><li><p>给定一个关系<span class="math inline">\(R(X,Y)\)</span>，<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Z\)</span>为属性组。当<spanclass="math inline">\(t[X]=x\)</span>时，<spanclass="math inline">\(x\)</span>在<spanclass="math inline">\(R\)</span>中的象集定义为</p><p><span class="math inline">\(Z_=\{t[Z]|t\in R,t[X]=x\}\)</span></p><p>它表示<span class="math inline">\(R\)</span>在属性组<spanclass="math inline">\(X\)</span>上值为<spanclass="math inline">\(x\)</span>的诸元组在<spanclass="math inline">\(Z\)</span>上分量的集合。</p></li></ul><h4 id="专门关系运算的定义">专门关系运算的定义</h4><h5 id="选择selection">选择（selection）</h5><p>选择又称为限制（restriction），是在关系<spanclass="math inline">\(R\)</span>中选择满足给定条件的诸元组，记作<spanclass="math inline">\(\sigma _F(R)=\{t|t\in R\wedgeF(t)=true\}\)</span></p><p>其中<spanclass="math inline">\(F\)</span>表示选择条件，它是一个逻辑表达式，取逻辑值真或假。</p><h5 id="投影projection">投影（projection）</h5><p>关系 <span class="math inline">\(R\)</span> 上的投影是从 <spanclass="math inline">\(R\)</span>中选择出若干属性列组成新的关系，记作</p><p><span class="math inline">\(\prod _{A}(R)=\{t[A]|t\inR\}\)</span></p><p>其中 <span class="math inline">\(A\)</span> 为 <spanclass="math inline">\(R\)</span> 的属性列。</p><h5 id="连接join">连接（join）</h5><p>连接也称为<spanclass="math inline">\(\theta\)</span>连接。它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作</p><p><span class="math inline">\(R\Join _{A\theta B}S=\{t_rt_s|t_r\in R\ort_s\in S\or t_r[A]\theta t_s[B] \}\)</span></p><p>其中，<span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 分别为 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 上列数相等且可比的属性组，<spanclass="math inline">\(\theta\)</span>是比较运算符。连接运算从 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 的笛卡尔积 <spanclass="math inline">\(R\times S\)</span> 中选取 <spanclass="math inline">\(R\)</span> 关系在 <spanclass="math inline">\(A\)</span> 属性组上的值与 <spanclass="math inline">\(S\)</span> 关系在 <spanclass="math inline">\(B\)</span> 属性组上的值满足比较关系 <spanclass="math inline">\(\theta\)</span>的元组。</p><ul><li><p><span class="math inline">\(\theta\)</span> 为 =的连接运算称为等值连接，它是从关系 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 的笛卡尔积中选取 <spanclass="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span>属性值相等的那些元组。</p></li><li><p>自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中去除重复属性列</p><ul><li>一般的连接操作是从行的角度进行运算，自然连接还需要去除重复列，因而是同时从行和列的角度进行运算</li><li>自然连接中被舍弃的元组称为悬浮元组（danglingtuple），把悬浮元组也保存在结果关系中，而在其他属性值上写<spanclass="math inline">\(null\)</span>，这种连接称为外连接；只保留左关系的悬浮元组称为左外连接，反之为右外连接</li></ul></li></ul><h5 id="除运算division">除运算（division）</h5><p>//以下定义过于抽象，其实就是选择R(X,Y)中Y与S(Y,Z)中的Y具有相同值的所有对应X。</p><p>设关系 <span class="math inline">\(R\)</span> 除以关系 <spanclass="math inline">\(S\)</span> 的结果为关系 <spanclass="math inline">\(T\)</span>，则 <spanclass="math inline">\(T\)</span> 包含所有在 <spanclass="math inline">\(R\)</span> 但不在 <spanclass="math inline">\(S\)</span> 中的属性及其值，且 <spanclass="math inline">\(T\)</span> 的元组与 <spanclass="math inline">\(S\)</span> 的元组的所有组合都在 <spanclass="math inline">\(R\)</span> 中。</p><p>除法的象集定义：</p><p>给定关系 <span class="math inline">\(R(X,Y)\)</span> 和 <spanclass="math inline">\(S(Y,Z)\)</span>，其中<spanclass="math inline">\(X\)</span>、<spanclass="math inline">\(Y\)</span>、<spanclass="math inline">\(Z\)</span>为属性组。<spanclass="math inline">\(R\)</span> 中的 <spanclass="math inline">\(Y\)</span> 与 <spanclass="math inline">\(S\)</span> 中的 <spanclass="math inline">\(Y\)</span>可以有不同的属性名，但必须出自相同的域集。</p><p><span class="math inline">\(R\)</span> 与 <spanclass="math inline">\(S\)</span> 的除运算得到一个新的关系 <spanclass="math inline">\(P(X)\)</span>，<spanclass="math inline">\(P\)</span> 是 <spanclass="math inline">\(R\)</span> 中满足下列条件的元组在 <spanclass="math inline">\(X\)</span> 属性列上的投影：元组在 <spanclass="math inline">\(X\)</span> 上分量值 <spanclass="math inline">\(x\)</span> 的象集 <spanclass="math inline">\(Y_x\)</span> 包含 <spanclass="math inline">\(S\)</span> 在 <spanclass="math inline">\(Y\)</span> 上投影的集合。记作</p><p><span class="math inline">\(R\div S=\{t_r[X] |t_r\in R \and \prod_Y(S)\subseteq Y_X \}\)</span></p><p>除操作也是同时从行和列的角度进行运算。</p><p>关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。</p><h2 id="关系演算">2.5 关系演算</h2><p>不考，暂略</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我自横刀向天笑，去留肝胆两昆仑。&lt;/p&gt;</summary>
    
    
    
    <category term="数据管理基础" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据管理基础-第一章_绪论</title>
    <link href="http://example.com/2023/06/01/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E7%BB%AA%E8%AE%BA/"/>
    <id>http://example.com/2023/06/01/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E7%BB%AA%E8%AE%BA/</id>
    <published>2023-06-01T04:00:00.000Z</published>
    <updated>2023-06-13T06:40:29.411Z</updated>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第一章-绪论">第一章 绪论</h1><h2 id="数据库系统概述">1.1 数据库系统概述</h2><h3 id="数据库的4个基本概念">1.1.1 数据库的4个基本概念</h3><p>数据、数据库、数据库管理系统、数据库系统</p><h4 id="数据data">数据（Data）</h4><p>数据是数据库中存储的基本对象，是描述事物的符号记录。</p><p>数据有多种表现形式，可以经过数字化后存入计算机。</p><p>数据的含义称为数据的语义，数据与其语义是不可分的。</p><h4 id="数据库databasedb">数据库（Database，DB）</h4><p>数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，可为各种用户共享。</p><p>数据库数据具有永久存储、有组织和可共享三个基本特点。</p><h4id="数据库管理系统database-management-systemdbms">数据库管理系统（DatabaseManagement System，DBMS）</h4><p>数据库管理系统是计算机的基础软件，主要功能包含以下几个方面：</p><h5 id="数据定义">(1) 数据定义</h5><p>提供数据定义语言（Data DefinitionLanguage，DDL），用以对数据库中的数据对象的组成与结构进行定义</p><h5 id="数据组织存储和管理">(2) 数据组织、存储和管理</h5><h5 id="数据操纵">(3) 数据操纵</h5><p>提供数据操纵语言（Data ManipulationLanguage，DML），用以操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。</p><h5 id="数据库的事务管理和运行管理">(4) 数据库的事务管理和运行管理</h5><h5 id="数据库的建立和维护">(5) 数据库的建立和维护</h5><h5 id="其他功能">(6) 其他功能</h5><p>包括数据库管理系统与网络中其他软件系统的通信功能，异构数据库之间的互访和互操作功能等。</p><h4 id="数据库系统database-systemdbs">数据库系统（DatabaseSystem，DBS）</h4><p>数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DatabaseAdministrator，DBA）组成的存储、管理、处理和维护数据的系统。</p><h3 id="数据库系统的特点">1.1.2 数据库系统的特点</h3><ul><li>文件系统管理数据的缺点：整体无结构，共享性低，冗余度高，独立性差</li></ul><h4 id="数据结构化">数据结构化</h4><p>数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。</p><p>整体结构化是指数据库中的数据不再仅仅针对一个应用，而是面向整个组织或企业；不仅数据内部是结构化的，而且整体是结构化的，数据之间是具有联系的。</p><h4id="数据的共享性高冗余度低且易扩充">数据的共享性高、冗余度低且易扩充</h4><p>数据共享可以大大减少数据冗余，节约存储空间，数据共享还能避免数据之间的不相容性与不一致性。</p><h4 id="数据独立性高">数据独立性高</h4><p>数据库的数据独立性包括数据的物理独立性和逻辑独立性。</p><ul><li><p>物理独立性是指用户的应用程序与数据库中数据的物理存储是相互独立的。</p></li><li><p>逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</p></li></ul><h4id="数据由数据库管理系统统一管理和控制">数据由数据库管理系统统一管理和控制</h4><p>为了保证数据库的并发共享与数据库中数据的正确与一致，数据库管理系统提供以下的数据控制功能：</p><h5 id="数据的安全性保护">(1) 数据的安全性保护</h5><p>保护数据以防止不合法使用造成的数据泄密和破坏。</p><h5 id="数据的完整性检查">(2) 数据的完整性检查</h5><p>数据的完整性指数据的正确性、有效性和相容性。</p><h5 id="并发控制">(3) 并发控制</h5><h5 id="数据库恢复">(4) 数据库恢复</h5><p>数据库管理系统必须具有将数据库从错误状态恢复到某一已知的正确状态的功能。</p><p>数据库是长期存储在计算机内有组织、大量、共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。</p><p>数据库系统的出现使信息系统从以加工数据的程序为中心转为围绕共享的数据库为中心的新阶段。</p><h2 id="数据模型">1.2 数据模型</h2><p>数据模型是对现实世界数据特征的抽象，是数据库系统的核心和基础。</p><p>数据模型分为两类，第一类为概念模型，第二类是逻辑模型和物理模型。</p><ul><li><p>概念模型也称信息模型，它按用户的观点来对数据和信息建模，主要用于数据库设计。</p></li><li><p>逻辑模型主要包括层次模型、网状模型、关系模型、面向对象数据模型和对象关系数据模型、半结构化数据模型等，它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。</p></li><li><p>物理模型是对数据最底层的抽象，描述数据在系统内部的表示和存取方式。物理模型的具体实现是数据库管理系统的任务，数据库设计人员要了解和选择物理模型，最终用户则不需考虑物理级细节。</p></li></ul><p>先将现实世界抽象为信息世界（概念模型），再将信息世界转换为机器世界。</p><h3 id="概念模型">1.2.1 概念模型</h3><p>概念模型是对现实世界的抽象，用于信息世界的建模。</p><h4 id="信息世界的基本概念">信息世界的基本概念</h4><ol type="1"><li>实体（entity）</li></ol><p>客观存在并可相互区别的事物称为实体。</p><ol start="2" type="1"><li>属性（attribute）</li></ol><p>实体所具有的某一特性。</p><ol start="3" type="1"><li>码（key）</li></ol><p>唯一标识实体的属性集称为码</p><ol start="4" type="1"><li>实体型（entity type）</li></ol><p>用实体及其属性名集合来抽象和刻画同类实体，称为实体型。</p><ol start="5" type="1"><li>实体集（entity set）</li></ol><p>同一类型实体的集合称为实体集。</p><ol start="6" type="1"><li>联系（relationship）</li></ol><p>实体内部的联系通常指组成实体的各属性之间的联系，实体之间的联系通常指不同实体集之间的联系。</p><p>实体之间的联系有一对一、一对多、多对多等多种类型。</p><h4id="概念模型的一种表示方法实体-联系方法entity-relationship-approach">概念模型的一种表示方法：实体-联系方法（Entity-Relationshipapproach）</h4><p>该方法用实体-联系图（E-Rdiagram）来描述现实世界的概念模型，E-R方法也称E-R模型。</p><h3 id="数据模型的组成要素">1.2.2 数据模型的组成要素</h3><p>数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成。</p><ol type="1"><li>数据结构</li></ol><p>数据结构描述数据库的组成对象以及对象之间的联系。</p><ol start="2" type="1"><li>数据操作</li></ol><p>数据操作是指对数据库中各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则。</p><ol start="3" type="1"><li>数据的完整性约束条件</li></ol><p>数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。</p><h3 id="常用的数据模型">1.2.3 常用的数据模型</h3><ul><li>层次模型（hierarchical model）</li><li>网状模型（network model）</li><li>关系模型（relational model）</li><li>面向对象数据模型（object oriented data model）</li><li>对象关系数据模型（object relational data model）</li><li>半结构化数据模型（semistructure data model）</li></ul><p>其中层次模型和网状模型称为格式化模型。</p><h4 id="层次模型">层次模型</h4><ol type="1"><li>有且只有一个结点没有双亲结点，该结点为根结点；</li><li>根以外的其他结点有且只有一个双亲结点。</li></ol><p>优点：结构简单清晰、查询效率高、完整性支持好</p><p>缺点：现实世界很多联系是非层次性的</p><h4 id="网状模型">网状模型</h4><ol type="1"><li>允许一个以上的结点没有双亲；</li><li>一个结点可以有一个以上的双亲。</li></ol><p>优点：直观地描述现实世界、存取效率高</p><p>缺点：结构复杂，因而DDL与DML也十分复杂</p><h2 id="数据库系统的结构">1.3 数据库系统的结构</h2><h3 id="数据库系统模式的概念">1.3.1 数据库系统模式的概念</h3><p>数据模型中，型（type）是对某一类数据的结构和属性的说明，值（value）是型的一个具体赋值。</p><p>模式（schema）是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体值。模式的一个具体值称为模式的一个实例。</p><p>模式是相对稳定的，实例时相对变动的。</p><h3 id="数据库系统的三级模式结构">1.3.2 数据库系统的三级模式结构</h3><p>数据库系统由外模式、模式和内模式三级构成。</p><ol type="1"><li>模式</li></ol><p>模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p><ol start="2" type="1"><li>外模式</li></ol><p>外模式也称子模式（subschema）或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用相关的数据的逻辑表示。</p><p>外模式通常是模式的子集。</p><ol start="3" type="1"><li>内模式</li></ol><p>内模式也称存储模式（storageschema），是数据物理结构和存储方式的描述，是数据库内部数据的组织方式。</p><p>一个数据库只有一个内模式</p><h3 id="数据库的二级映像功能与数据独立性">1.3.3数据库的二级映像功能与数据独立性</h3><ol type="1"><li>外模式/模式映像</li></ol><p>模式改变时，数据库管理员对各个外模式/模式映像作相应改变，使外模式保持不变，保证数据逻辑独立性。</p><ol start="2" type="1"><li>模式/内模式映像</li></ol><p>数据库存储结构改变时，数据库管理员对模式/内模式映像作相应改变，使模式保持不变，保证数据物理独立性。</p><p>数据与程序之间的独立性使得数据的定义和描述从应用程序中分离。数据的存取由数据库管理系统管理，简化了应用程序的编制，减少了应用程序的维护与修改。</p><ul><li>文件系统数据独立性是文件间相互独立，而数据库系统数据独立性是逻辑、物理独立性</li></ul><h2 id="数据库系统的组成">1.4 数据库系统的组成</h2><ol type="1"><li><p>硬件平台及数据库</p><ul><li>足够大的内存存放操作系统、数据库管理系统的核心模块、数据缓冲区和应用程序</li><li>足够大的磁盘存放数据库，足够大的磁带作数据备份</li><li>系统有较高的通道能力以提高数据传送率</li></ul></li><li><p>软件</p><ul><li>数据库管理系统</li><li>支持数据库管理系统运行的操作系统</li><li>具有与数据库接口的高级语言及其编译系统，便于开发应用程序</li><li>以数据库管理系统为核心的应用开发工具</li></ul></li><li><p>人员</p><ul><li><p>数据库管理员</p></li><li><p>系统分析员与数据库设计人员</p></li><li><p>应用程序员</p></li><li><p>用户</p></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;我自横刀向天笑，去留肝胆两昆仑。&lt;/p&gt;</summary>
    
    
    
    <category term="数据管理基础" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机操作系统-第六章_并发程序设计</title>
    <link href="http://example.com/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-05-06T04:00:00.000Z</published>
    <updated>2023-06-10T13:26:50.384Z</updated>
    
    <content type="html"><![CDATA[<p>长风破浪会有时，直挂云帆济沧海！</p><span id="more"></span><h1 id="第六章-并发程序设计">第六章 并发程序设计</h1><h2 id="并发进程">6.1 并发进程</h2><h3 id="顺序程序设计">6.1.1 顺序程序设计</h3><p>进程在处理器上的顺序执行是严格按序的，一个操作结束后，才能开始后续操作。</p><p>顺序程序设计：把一个程序设计成顺序执行的程序模块。</p><ul><li>顺序不仅在一个程序模块内部，也在多个程序模块之间。</li></ul><p>顺序程序设计的特点：</p><ul><li>程序执行的顺序性</li><li>程序环境的封闭性</li><li>执行结果的确定性</li><li>计算过程的可再现性</li></ul><h3 id="进程的并发性">6.1.2 进程的并发性</h3><p>进程的并发性（Concurrency）是指一组进程的执行在时间上是重叠的。</p><ul><li>宏观上，并发性反映一个时间段中几个进程都在同一处理器上，处于运行还未运行结束状态</li><li>微观上，任一时刻仅有一个进程在处理器上运行</li></ul><h4 id="并发程序设计">并发程序设计</h4><p>使一个程序分成若干个可同时执行的程序模块的方法称为并发程序设计（concurrentprogramming），每个程序模块和它执行时所处理的数据就组成一个进程。</p><p>并发进程的分类：无关的、交互的</p><ul><li>无关的并发进程：一个进程的执行与其他并发进程的进展无关<ul><li>并发进程的无关性是进程的执行与时间无关的一个充分条件，又称为Bernstein条件</li></ul></li><li>交互的并发进程：一个进程的执行可能影响其他并发进程的结果</li></ul><h4 id="bernstein条件">Bernstein条件</h4><ul><li><p>程序<spanclass="math inline">\(p_i\)</span>在执行期间引用的变量集，记为<spanclass="math inline">\(R(p_i)=\{a_{i1},a_{i2},...,a_{in}\}\)</span>，</p></li><li><p>程序<spanclass="math inline">\(p_i\)</span>在执行期间改变的变量集，记为<spanclass="math inline">\(W(p_i)=\{b_{i1},b_{i2},...,b_{im}\}\)</span></p></li><li><p>若两个进程的程序<span class="math inline">\(p_1\)</span>和<spanclass="math inline">\(p_2\)</span>能满足Beinstein条件，即满足</p><p><span class="math inline">\((R(p_1)\cap W(p_2))\cup (R(p_2)\capW(p_1))\cup (W(p_1)\cap W(p_2))=\varnothing\)</span>，</p><p>则这两个并发进程的执行与时间无关</p></li></ul><p>与时间有关的错误：对于一组交互的并发进程，执行的相对速度无法相互控制，各种与时间有关的错误就有可能出现。</p><ul><li>与时间有关错误的表现形式：结果不唯一、永远等待</li></ul><h3 id="进程的交互竞争和协作">6.1.3 进程的交互：竞争和协作</h3><p>进程之间存在两种基本关系：竞争关系和协作关系</p><ul><li>竞争关系：一个进程的执行可能影响到同其竞争资源的其他进程，如果两个进程要访问同一资源，那么一个进程通过操作系统分配得到该资源，另一个将不得不等待</li><li>协作关系：某些进程为了完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的信号之前应阻塞自己，直到其他合作进程发来协调信号后方被唤醒并继续执行。</li></ul><h4 id="资源竞争的两个控制问题">资源竞争的两个控制问题</h4><ul><li>死锁：一组进程如果都获得了部分的资源，还想要得到其他进程所占有的资源，最终所有的进程都将陷入死锁</li><li>饥饿：一个进程由于其他进程总是优先于它而被无限期拖延</li><li>操作系统需要保证诸进程能互斥地访问临界资源，既要解决饥饿问题，又要解决死锁问题</li></ul><h4 id="进程的互斥与同步">进程的互斥与同步</h4><p>进程的互斥（mutual exclusion）是解决进程间竞争关系的手段。</p><ul><li>若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源</li></ul><p>进程的同步（Synchronization）是解决进程间协作关系的手段。</p><ul><li>两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的信号，当一个进程没有得到来自于另一个进程的信号则需等待。</li></ul><p>进程的互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，是对进程使用资源次序上的一种协调。</p><h2 id="临界区管理">6.2 临界区管理</h2><h3 id="互斥与临界区">6.2.1 互斥与临界区</h3><ul><li><p>并发进程中与共享变量有关的程序段称为临界区（criticalsection）</p><p>共享变量代表的资源称为临界资源</p></li><li><p>与同一变量有关的临界区分散在各进程的程序段中，而各进程的执行速度不可预见</p></li><li><p>如果保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问互斥，就不会造成与时间有关的错误。</p></li></ul><p>临界区调度原则（Dijkstra，1965）</p><ul><li>一次至多一个进程能够进入临界区内执行</li><li>如果已有进程在临界区，其他试图进入的进程应等待</li><li>进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入</li></ul><h3 id="临界区管理-1">6.2.2 临界区管理</h3><p>临界区管理的简单方法（忙式等待/反复测试）：</p><ul><li>Peterson算法</li><li>关中断</li><li>对换指令</li><li>测试并建立指令</li></ul><p>存在的问题：</p><ul><li>对不能进入临界区的进程，采用忙式等待测试法，浪费CPU时间</li><li>将测试能否加入临界区的责任推给各个竞争的进程会削弱系统的可靠性，加重编程负担</li></ul><p>通用的解决方案：信号量与PV操作</p><h4 id="peterson算法">Peterson算法</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">bool</span> inside[<span class="hljs-number">2</span>];<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">enum</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125; turn;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">P0</span><span class="hljs-params">()</span></span>&#123;<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>turn = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(inside[<span class="hljs-number">1</span>]&amp;&amp;turn==<span class="hljs-number">1</span>);<br>&#123;临界区&#125;;<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P1</span><span class="hljs-params">()</span></span>&#123;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(inside[<span class="hljs-number">0</span>]&amp;&amp;turn==<span class="hljs-number">0</span>)<br>&#123;临界区&#125;;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 1:1交替</span><br><span class="hljs-keyword">enum</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125; turn;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">P0</span><span class="hljs-params">()</span></span>&#123;<br>turn = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(turn==<span class="hljs-number">1</span>);<br>&#123;临界区&#125;;<br>turn = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P1</span><span class="hljs-params">()</span></span>&#123;<br>turn = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(turn==<span class="hljs-number">0</span>);<br>&#123;临界区&#125;;<br>turn = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关中断">关中断</h4><ul><li>实现互斥的最简单方法</li></ul><h4 id="测试并建立指令">测试并建立指令</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//TS指令实现进程互斥</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TS</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(x)&#123;<br>    x = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> s = <span class="hljs-literal">true</span>;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">Pi</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">TS</span>(s)); <span class="hljs-comment">//上锁</span><br>  &#123;临界区&#125;;<br>  s = <span class="hljs-literal">true</span>;      <span class="hljs-comment">//开锁</span><br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h4 id="对换指令">对换指令</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//对换指令实现进程互斥</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SWAP</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> &amp;a, <span class="hljs-built_in">bool</span> &amp;b</span>)</span>&#123;<br><span class="hljs-built_in">bool</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-built_in">bool</span> <span class="hljs-keyword">lock</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">Process <span class="hljs-title">Pi</span>()</span>&#123;<br><span class="hljs-built_in">bool</span> key = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">do</span>&#123;<br>SWAP(key, <span class="hljs-keyword">lock</span>);<br>&#125;<span class="hljs-keyword">while</span>(key);<span class="hljs-comment">//上锁</span><br>&#123;临界区&#125;;<br>SWAP&#123;key, <span class="hljs-keyword">lock</span>&#125;;<span class="hljs-comment">//开锁</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号量与pv操作">6.3 信号量与PV操作</h2><h3id="信号量与pv操作的数据结构与原语操作">信号量与PV操作的数据结构与原语操作</h3><p>设s为一个记录型数据结构，一个分量为整型量value，另一个为信号量队列queue，P和V操作原语的定义：</p><ul><li>P(s)：将信号量s减去1，若结果小于0，则调用P(s)的进程被设置成等待信号量s的状态</li><li>V(s)：将信号量s加1，若结果不大于0，则释放一个等待信号量s的进程，其转为就绪态</li></ul><p>对于信号量，只允许使用P和V原语操作访问，不能直接对信号量的整型值和队列作操作</p><p>原语：CPU处于内核态，在关中断环境下执行的一段指令序列</p><ul><li>原子性：不被中断，确保安全且完整执行这段指令序列</li></ul><h4 id="几个经典问题">几个经典问题</h4><h5 id="哲学家就餐问题互斥">哲学家就餐问题（互斥）</h5><p>有五个哲学家围坐在一圆桌旁，桌中央有一盘通心面，每人面前有一只空盘子，每两人之间放一把叉子。每个哲学家思考、饥饿、然后吃通心面。为了吃面，每个哲学家必须获得两把叉子，且每人只能直接从自己左边或右边去取叉子。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">semaphore fork<span class="hljs-literal">[<span class="hljs-number">5</span>]</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>fork<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=<span class="hljs-number">1</span>;<br>semaphore room=<span class="hljs-number">4</span>; <span class="hljs-comment">//增加一个侍者，设想有两个房间1号房间是会议室，2号房间是餐厅</span><br>cobegin<br>process philosopher<span class="hljs-constructor">_i()</span>&#123; <span class="hljs-comment">//i=0,1,2,3,4</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>think<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">room</span>)</span>; <span class="hljs-comment">//控制最多允许4位哲学家进入2号房间餐厅取叉子</span><br><span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>; <span class="hljs-comment">//偶数哲学家先右手</span><br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span> % <span class="hljs-number">5</span> ]); <span class="hljs-comment">//后左手</span><br>eat<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>;<br>V (fork<span class="hljs-literal">[(<span class="hljs-identifier">i</span>+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span> % <span class="hljs-number">5</span> ]); <span class="hljs-comment">//奇数哲学家，先左手</span><br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>; <span class="hljs-comment">//后右手</span><br>eat<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span>%<span class="hljs-number">5</span>]);<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>;<br>&#125;<br><span class="hljs-constructor">V(<span class="hljs-params">room</span>)</span>;<br>&#125;<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h5 id="生产者与消费者问题同步">生产者与消费者问题（同步）</h5><p>有n个生产者和m个消费者，连接在一个有k个单位缓冲 区的有界缓冲上。</p><p>其中，生产者进程<spanclass="math inline">\(Producer_i\)</span>和消费者进程<spanclass="math inline">\(Consumer_j\)</span>都是并发进程，只要缓冲区未满，生产者<spanclass="math inline">\(Producer_i\)</span>生产的产品就可投入缓冲区；只要缓冲区不空，消费者进程<spanclass="math inline">\(Consumer_j\)</span>就可从缓冲区取走并消耗产品。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">产品 Buffer<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>semaphore put = k, get = <span class="hljs-number">0</span>;<span class="hljs-comment">//可以put或get的缓冲区数</span><br><span class="hljs-built_in">int</span> putPos = getPos = <span class="hljs-number">0</span>;<span class="hljs-comment">//put或get的位置</span><br>semaphore p = g = <span class="hljs-number">1</span>;<span class="hljs-comment">//互斥使用put或get的位置</span><br><br>process <span class="hljs-constructor">Producer_i()</span>&#123;<br>&#123;生产产品&#125;;<br><span class="hljs-constructor">P(<span class="hljs-params">put</span>)</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">p</span>)</span>;<br>Buffer<span class="hljs-literal">[<span class="hljs-identifier">putPos</span>]</span> = 产品;<br>putPos = (putPos + <span class="hljs-number">1</span>) % k;<br><span class="hljs-constructor">V(<span class="hljs-params">p</span>)</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">get</span>)</span>;<br>&#125;<br><br>process <span class="hljs-constructor">Consumer_i()</span>&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">get</span>)</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">g</span>)</span>;<br>产品 = Buffer<span class="hljs-literal">[<span class="hljs-identifier">getPos</span>]</span>;<br>getPos = (getPos + <span class="hljs-number">1</span>) % k;<br><span class="hljs-constructor">V(<span class="hljs-params">g</span>)</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">put</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管程">6.4 管程</h2><h3 id="管程和条件变量">6.4.1 管程和条件变量</h3><p>管程的引入：</p><ul><li>把分散在各进程中的临界区集中管理</li><li>防止进程的违法同步操作</li><li>便于用高级语言来编写程序</li></ul><h4 id="管程的定义">管程的定义</h4><p>由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。</p><p>管程的属性：共享性、安全性、互斥性</p><h4 id="管程的形式">管程的形式</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">type 管程名<span class="hljs-operator">=</span>monitor &#123;<br>局部变量说明<span class="hljs-comment">;</span><br>  条件变量说明<span class="hljs-comment">;</span><br>  初始化语句<span class="hljs-comment">;</span><br>define 管程内定义的，管程外可调用的过程或函数名列表<span class="hljs-comment">;</span><br>use 管程外定义的，管程内将调用的过程或函数名列表<span class="hljs-comment">;</span><br>过程名/函数名(形式参数表) &#123;<br>&lt;过程/函数体&gt;<span class="hljs-comment">;</span><br>&#125;<br>...<br>过程名/函数名(形式参数表) &#123;<br>&lt;过程/函数体&gt;<span class="hljs-comment">;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管程的条件变量">管程的条件变量</h4><p>只有在管程中才能被访问，它对管程内所有过程是全局的，只能通过两个原语操作来控制</p><ul><li><p>wait()：阻塞调用进程并释放管程，直到另一个进程在该条件变量上执行signal()</p></li><li><p>signal()：释放由于对条件变量执行wait()而被阻塞的其他进程，若无，信号不被保存</p></li><li><p>使用signal释放等待进程时，可能出现两个进程同时停留在管程内</p><ul><li><p>执行signal的进程等待，直到被释放进程退出管程或等待另一个条件变量</p></li><li><p>被释放进程等待，直到执行signal的进程退出管程或等待另一个条件</p></li><li><p>Hoare采用前一种方法。</p></li></ul></li></ul><h3 id="管程的实现">6.4.2 管程的实现</h3><p>Hoare管程</p><p>Hoare使用P和V操作原语来实现对管程中过程的互斥调用，以及实现对共享资源互斥使用的管理。</p><ul><li>wait和signal操作可被设计成可以中断的进程</li></ul><h4 id="hoare管程数据结构">Hoare管程数据结构</h4><ol type="1"><li>mutex</li></ol><ul><li>对于每个管程，使用用于管程中过程互斥调用的信号量mutex（初值为1）</li><li>进程调用管程中的任何过程时，应执行P(mutex)，进程退出管程时，需要判断是否有进程在next信号量等待，如果有（即next_count&gt;0），则通过V(next)唤醒一个发出signal的进程，否则应执行V(mutex)开放管程，以便让其他调用者进入</li><li>为了使进程在等待资源期间，其他进程能进入管程，在wait操作中也必须执行V(mutex)</li></ul><ol start="2" type="1"><li>next和next-count</li></ol><ul><li><p>对每个管程，引入信号量next（初值为0），发出signal操作的进程应该用P(next)阻塞自己，直到被释放进程退出管程或产生其他等待条件</p></li><li><p>next-count（初值为0），记录next上等待的进程个数</p></li></ul><ol start="3" type="1"><li>x-sem和x-count</li></ol><ul><li>x-sem（初值为0），申请资源无法满足时，执行P(x-sem)阻塞。由于释放资源时，需知道是否有其他进程在等待资源，用计数器x-count（初值为0）记录等待资源的进程数</li><li>执行signal操作时，应让等待资源的诸进程中的某个进程立即恢复运行，而不让其他进程抢先进入管程，这使用V(x-sem)实现</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">typedef <span class="hljs-keyword">struct</span> Monitor&#123;<br>semaphore mutex;<br>semaphore next;<br><span class="hljs-built_in">int</span> next_count;<br>&#125;<br>mutex = <span class="hljs-number">1</span>;<br>next = <span class="hljs-number">0</span>;<br>next_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//enter()和leave()操作</span><br>void enter(Monitor &amp;m)&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<br>&#125;<br>void leave<span class="hljs-literal">()</span>&#123;Monitor &amp;m&#125;&#123;<br><span class="hljs-keyword">if</span>(m.next_count&gt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">//wait()</span><br>void wait(semaphore &amp;x_sem, <span class="hljs-built_in">int</span> x_count, Monitor &amp;m)&#123;<br>x_count++;<span class="hljs-comment">//等待资源进程个数加1</span><br><span class="hljs-keyword">if</span>(m.next_count&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//判断是否有发出过signal的进程</span><br><span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<span class="hljs-comment">//释放</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<span class="hljs-comment">//开放管程</span><br><span class="hljs-constructor">P(<span class="hljs-params">x_sem</span>)</span>;<span class="hljs-comment">//等待资源进程阻塞自己</span><br>x_count--;<span class="hljs-comment">//等待资源进程个数减1</span><br>&#125;<br><br><span class="hljs-comment">//signal()</span><br>void signal(semaphore &amp;x_sem, <span class="hljs-built_in">int</span> x_count, Monitor &amp;m)&#123;<br><span class="hljs-keyword">if</span>(x_count&gt;<span class="hljs-number">0</span>)&#123;<br>m.next_count++;<span class="hljs-comment">//发出signal进程数加1</span><br><span class="hljs-constructor">V(<span class="hljs-params">x_sem</span>)</span>;<span class="hljs-comment">//释放一个等待资源的进程</span><br><span class="hljs-constructor">P(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<span class="hljs-comment">//发出signal的进程阻塞自己</span><br>m.next_count--;<span class="hljs-comment">//发出signal的进程个数减1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管程求解进程的同步和互斥问题">6.4.3管程求解进程的同步和互斥问题</h3><p>互斥问题：读者写者问题、哲学家就餐问题</p><p>同步问题：生产者与消费者问题、苹果桔子问题</p><h4 id="哲学家就餐问题">哲学家就餐问题</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs perl">type philosophers=monitor<br>enum &#123;thinking,hungry,eating&#125; <span class="hljs-keyword">state</span>[<span class="hljs-number">5</span>];<br>semaphore self[<span class="hljs-number">5</span>]; <span class="hljs-keyword">int</span> self_count[<span class="hljs-number">5</span>]; Monitor M;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++) <span class="hljs-keyword">state</span>[i] = thinking;<br>define pickup, putdown;<br><span class="hljs-keyword">use</span> enter, leave, <span class="hljs-keyword">wait</span>, signal;<br><br>void pickup(<span class="hljs-keyword">int</span> i)&#123;<br>enter(M);<br><span class="hljs-keyword">state</span>[i] = hungry;<br>test(i);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">state</span>[i] != eating)<br><span class="hljs-keyword">wait</span>(self[i], self_count[i], M);<br>leave(M);<br>&#125;<br><br>void putdown(<span class="hljs-keyword">int</span> i)&#123; <span class="hljs-regexp">//i</span>=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,..,<span class="hljs-number">4</span><br>enter(M);<br>  <span class="hljs-keyword">state</span>[i] = thinking;<br>    test((i-<span class="hljs-number">1</span>)%5);<br>    test((i+<span class="hljs-number">1</span>)%5);<br>leave(M);<br>&#125;<br><br>void test(<span class="hljs-keyword">int</span> k)&#123; <span class="hljs-regexp">//</span>k=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,...,<span class="hljs-number">4</span> <br><span class="hljs-keyword">if</span>((<span class="hljs-keyword">state</span>[(k-<span class="hljs-number">1</span>)%5] != eating) &amp;&amp; (<span class="hljs-keyword">state</span>[k] == hungry) <br>&amp;&amp;(<span class="hljs-keyword">state</span>[(k+<span class="hljs-number">1</span>)%5] != eating)) <br><span class="hljs-keyword">state</span>[k]=eating;<br>signal(self[k], self_count[k], IM);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生产者与消费者问题">生产者与消费者问题</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> <span class="hljs-built_in">product</span>=monitor<br>item Buffer[k];//缓冲区<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">in</span>, <span class="hljs-keyword">out</span>;//存取位置<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>;<br>semaphore full, empty;<br><span class="hljs-built_in">int</span> full_count, empty_count;<br>Monitor m;<br>define append, take;<br><span class="hljs-keyword">use</span> enter, leave, <span class="hljs-keyword">wait</span>, signal;<br><br>void append(item x)&#123;<br>enter(m);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">count</span> == k) <span class="hljs-keyword">wait</span>(full, full_count, m);<br>Buffer[<span class="hljs-keyword">in</span>] = x;<br><span class="hljs-keyword">in</span> = (<span class="hljs-keyword">in</span> + <span class="hljs-number">1</span>) % k;<br><span class="hljs-built_in">count</span>++;<br>signal(empty, empty_count, m);<br>leave(m);<br>&#125;<br><br>void take(item x)&#123;<br>enter(m);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">count</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">wait</span>(empty, empty_count, m);<br>x = Buffer[<span class="hljs-keyword">out</span>];<br><span class="hljs-keyword">out</span> = (<span class="hljs-keyword">out</span> + <span class="hljs-number">1</span>) % k;<br><span class="hljs-built_in">count</span>--;<br>signal(full, full_count, m);<br>leave(m);<br>&#125;<br><br>cobegin<br>process producer_i()&#123;<br><span class="hljs-built_in">product</span>.append(x);<br>&#125;<br>process consumer_i()&#123;<br><span class="hljs-built_in">product</span>.take(x);<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h2 id="进程通信">6.5 进程通信</h2><h3 id="进程通信-1">6.5.1 进程通信</h3><p>当进程互相交互时，必须满足两个基本要求：同步和通信</p><ul><li>为实施互斥，进程间需要同步</li><li>为了协作，进程间需要交换信息</li></ul><p>消息传递提供了最典型的消息传递原语：send和receive</p><h4 id="进程直接通信">进程直接通信</h4><ul><li>对称直接寻址，发送进程和接收进程必须命名对方以便通信，原语定义如下：<ul><li><code>send(P, message)</code>发送消息到进程P</li><li><code>receive(Q, message)</code>接收来自进程Q的消息</li></ul></li><li>非对称直接寻址，只要发送者命名接收者，而接收者不需命名发送者<ul><li><code>send(P, message)</code>发送消息到进程P</li><li><code>receive(id, message)</code>接收来自任何进程的消息，id置为与其通信的进程名称</li></ul></li></ul><p>进程P向Q发送消息：</p><pre><code class=" mermaid">graph LR进程P--&gt;内核--&gt;进程Q</code></pre><p>消息格式：消息头与消息体（即消息内容），</p><ul><li>消息头包括：消息类型、目标ID、源ID、消息长度、控制信息</li></ul><h4 id="进程间接通信">进程间接通信</h4><ul><li><p>消息不是直接从发送者发送到接收者，而是发送到由临时保存这些信息的队列组成的一个共享数据结构，这些队列通常称为信箱。</p></li><li><p>一个进程给合适的信箱发送消息，另一进程从信箱中获得消息。</p></li><li><p>间接通信的通信原语定义：</p><ul><li><p><code>send(A, message)</code>把消息传送到信箱A</p></li><li><p><code>receive(A, message)</code>从信箱A接收消息</p></li></ul></li></ul><p>信箱可以分成信箱头和信箱体两部分，信箱头指出信箱容量、信件格式、存放信件位置的指针等；信箱体用来存放信件。信箱体分成若干个可容纳一封信的区。</p><ul><li>send：若指定信箱未满，将信件送入信箱中指针指示的位置，并释放该信箱中信件的等待者，否则，发送信件者被置为等待信箱状态</li><li>receive：如果指定信箱中有信，则取出一封信件，并释放等待信箱的等待者，否则，接收信件者被置成等待信箱中信件的状态</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> box = record<br><span class="hljs-built_in">int</span> size;<span class="hljs-comment">//信箱大小</span><br><span class="hljs-built_in">int</span> count;<span class="hljs-comment">//现有信件数</span><br>message<span class="hljs-literal">[<span class="hljs-identifier">n</span>]</span> letter;<br>semaphore s1, s2;<span class="hljs-comment">//等信箱和等信件信号量</span><br><br>procedure send(box B, message M)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>size) <span class="hljs-constructor">W(B.<span class="hljs-params">s1</span>)</span>;<span class="hljs-comment">//R和W时让进程入队和出队的两个过程</span><br><span class="hljs-built_in">int</span> i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count + <span class="hljs-number">1</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = M;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count = i;<br><span class="hljs-constructor">R(B.<span class="hljs-params">s2</span>)</span>;<br>&#125;<br><br>procedure receive(box B, message M)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) <span class="hljs-constructor">W(B.<span class="hljs-params">s2</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count - <span class="hljs-number">1</span>;<br>x = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count;i++)&#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span> + <span class="hljs-number">1</span>]</span>;<br>&#125;<br>&#125;<br><span class="hljs-constructor">R(B.<span class="hljs-params">s1</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消息传递的若干问题">消息传递的若干问题</h4><ul><li>信箱容量问题</li><li>多进程与信箱相连的信箱接收问题</li><li>信箱的所有权问题<ul><li>信箱为操作系统所有，是指操作系统统一设置信箱，归系统所有，供相互通信的进程共享，例：消息缓冲机制</li></ul></li><li>信件的格式问题和其他有关问题</li><li>通信进程的同步问题</li></ul><h4 id="消息缓冲通信">消息缓冲通信</h4><h3 id="高级进程通信机制">6.5.2 高级进程通信机制</h3><h2 id="死锁">6.6 死锁</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;长风破浪会有时，直挂云帆济沧海！&lt;/p&gt;</summary>
    
    
    
    <category term="计算机操作系统" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机操作系统-第五章_文件管理</title>
    <link href="http://example.com/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2023-05-05T04:00:00.000Z</published>
    <updated>2023-06-12T10:44:22.084Z</updated>
    
    <content type="html"><![CDATA[<p>长风破浪会有时，直挂云帆济沧海！</p><span id="more"></span><h1 id="第五章-文件管理">第五章 文件管理</h1><h2 id="文件系统概述">5.1 文件系统概述</h2><h3 id="文件的概念">5.1.1 文件的概念</h3><p>具有符号名的，在逻辑上具有完整意义的一组相关信息项的序列</p><p>文件名是由字母、数字和其他符号组成的一个字符串，其格式和长度因系统而异</p><h4 id="文件的命名">文件的命名</h4><ul><li>一般包括文件名和扩展名<ul><li>前者用于识别文件，后者用于标识文件特性，两者用小数点隔开</li></ul></li><li>每个操作系统都有约定的扩展名，Windows系统中有：<ul><li>.com表示可执行的二进制代码文件</li><li>.exe表示可执行的浮动二进制代码文件</li><li>.lib表示库程序文件</li><li>.bat表示批命令文件</li><li>.obj表示编译或汇编生成的目标文件</li></ul></li></ul><h4 id="文件的分类">文件的分类</h4><ul><li>按用途：系统文件、库文件、用户文件</li><li>按保护级别：只读文件、读写文件、不保护文件</li><li>按信息时限：临时文件、永久文件、档案文件</li><li>按设备类型：磁盘文件、磁带文件、光盘文件、软盘文件</li><li>还可以按文件的逻辑结构或物理结构分类</li></ul><h4 id="引入文件的优点">引入文件的优点</h4><ul><li>用户使用方便</li><li>文件安全可靠</li><li>文件可备份</li><li>文件可共享</li></ul><h3 id="文件系统及其功能">5.1.2 文件系统及其功能</h3><h4 id="文件系统的概念">文件系统的概念</h4><p>操作系统中负责存取和管理信息的模块，用统一方式管理用户和系统信息的存储、检索、更新、共享和保护，为用户提供一整套方便有效的文件使用和操作方法。</p><ul><li>文件系统中的文件和用户概念中的逻辑结构以及存储器中的存储结构密切相关，因此，同一个文件需要从逻辑文件和物理文件两个侧面观察。</li></ul><h4 id="文件系统的功能">文件系统的功能</h4><p>文件系统面向用户的功能：</p><ul><li>文件的按名存取</li><li>文件的共享和保护</li><li>文件的操作和使用</li></ul><p>为了实现这些功能，操作系统必须考虑：</p><ul><li>文件目录的建立和维护</li><li>存储空间的分配和回收</li><li>数据的保密和保护</li><li>监督用户存取和修改文件的权限</li><li>实现在不同存储介质上信息的表示方式、编址方式、存储次序，以及信息检索等问题</li></ul><h4 id="文件系统的组成">文件系统的组成</h4><pre><code class=" mermaid">graph文件系统---文件的组织---组织方法---逻辑结构:\n流式文件\n记录式文件组织方法---物理结构:\n顺序文件\n连接文件\n直接文件\n索引文件文件系统---文件的存取---存取方法:\n顺序存取\n索引存取\n文件系统---文件的控制---控制系统:\n逻辑控制系统\n物理控制系统文件系统---文件的使用---文件操作:\n打开\n关闭\n读\n写\n控制</code></pre><h2 id="文件的组织">5.2 文件的组织</h2><h3 id="文件的存储">5.2.1 文件的存储</h3><h4 id="卷和块">卷和块</h4><p>文件存储介质有磁带、光盘和磁盘</p><ul><li>卷是存储介质的物理单位，对应于一盘磁带、一块软盘、一片光盘、一个硬盘分区</li><li>块是存储介质上连续信息所组成的一个区域，也称为物理记录<ul><li>块是主存储器和辅助存储器进行信息交换的物理单位，每次总是交换一块或整数块信息</li><li>决定块的大小要考虑用户使用方式、数据传输效率和存储设备类型等因素</li><li>不同类型的存储介质，块的长短常常不同；对同一类型的存储介质，块的大小一般相同，但也可以不同</li><li>外围设备由于机械动作或识别不同块的要求，两个相邻块之间必须留有间隙，间隙是块之间不记录用户代码信息的区域</li></ul></li></ul><h4 id="顺序存取存储设备的信息安排">顺序存取存储设备的信息安排</h4><p>顺序存储设备是严格依赖信息的物理位置次序进行定位和读写的存储设备。</p><ul><li>磁带是最常用的一种顺序存取存储设备，它具有存储容量大、稳定可靠、卷可装卸和易于保存等优点，广泛用于存档<ul><li>磁带的突出特点是块长的变化范围较大，块可以很小，也可以很大，原则上没有限制</li></ul></li><li>光盘也是一种顺序存取存储设备</li></ul><h4 id="直接存取存储设备的信息安排">直接存取存储设备的信息安排</h4><ul><li>磁盘是一种直接存取存储设备，又称为随机存取存储设备<ul><li>移臂与旋转两维组织，存取速度高</li><li>每个物理地址有确定的位置和唯一的地址，存取任何一个物理块所需的时间几乎不依赖于此信息的位置</li></ul></li></ul><h3 id="文件的逻辑结构">5.2.2 文件的逻辑结构</h3><p>逻辑文件，又称为文件的逻辑结构</p><ul><li>独立于物理环境的，用户概念中的抽象信息组织方式</li><li>用户能观察到并加以处理的数据集合</li></ul><p>文件的逻辑结构分为两种：流式文件和记录式文件</p><h4 id="流式文件">流式文件</h4><p>文件内的数据不再组成记录，只是由一串依次的字节组成的信息流序列。</p><ul><li>这种文件常常按长度来读取所需信息，也可以用插入的特殊字符作为分界。</li></ul><h4 id="记录式文件">记录式文件</h4><p>一种有结构的文件，是若干逻辑记录信息所组成的记录流文件。</p><ul><li>逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位</li></ul><p>记录式文件与数据库</p><ul><li>数据库管理系统也支持逻辑记录</li><li>有别于记录式文件的是，数据库中的记录之间可以通过数据冗余构成某种联系</li><li>数据库管理系统支持基于联系的数据查询，文件系统则不行</li></ul><h4 id="记录的成组与分解">记录的成组与分解</h4><p>一个物理记录只存放一个逻辑记录可能造成极大的浪费。</p><p>若干个逻辑记录合并成一组，写入一个块，称为记录的成组。</p><ul><li>每块中的逻辑记录数称为块因子</li></ul><p>对于流式文件，一个物理记录可以存放很多个连续字节</p><h5 id="成组与分解操作">成组与分解操作</h5><ol type="1"><li>系统设置独立于用户数据区的输入/输出缓冲区</li><li>记录的成组操作在输出缓冲区内进行，凑满一块后才将缓冲区内的信息写到存储介质上</li><li>当存储介质上的一个物理记录读进输入缓冲区后，把逻辑记录从块中分离出来的操作称为记录的分解操作</li></ol><p>成组与分解的特征：</p><ul><li>优点：记录成组与分解节省存储空间，减少输入/输出操作次数，提高系统效率</li><li>提前读与推迟写<ul><li>提前读：用户读请求，导致包含该逻辑记录的物理块读如输入缓冲区，这一操作可能读入了多个逻辑记录</li><li>推迟写：用户写请求，首先是写入输出缓冲区，只有当该缓冲区中的逻辑记录满后才会引起实际输出</li></ul></li></ul><h3 id="文件的物理结构">5.2.3 文件的物理结构</h3><p>文件的物理结构和组织是指文件在物理存储空间中的存放方法和组织关系，又称为物理文件。</p><ul><li>文件的存储结构涉及块的划分、记录的排列、索引的组织、信息的搜索等问题</li><li>直接影响文件系统性能</li></ul><h4 id="顺序文件">顺序文件</h4><p>将一个文件中逻辑上连续的信息存放到存储介质的依次相邻的块中形成顺序结构，这类文件称为顺序文件，也称连续文件。</p><ul><li><p>例：磁带文件、光盘文件</p></li><li><p>优点：顺序存取记录时速度较快</p><ul><li>常用于批处理文件和系统文件</li><li>采用磁带存放顺序文件，总可以保持快速存取存储的优点</li></ul></li><li><p>缺点：建立文件前需要能预先确定文件长度以便分配存储空间；修改、插入和增加文件记录有困难</p></li></ul><h4 id="连接文件">连接文件</h4><p>连接文件又称串联文件，使用连接字来表示文件中各个物理块之间的先后次序</p><ul><li><p>第一块文件信息的物理地址由文件目录给出，每一块的连接字指出了文件的下一个物理块位置，连接字内容为0时，表示文件至本块结束。</p></li><li><p>输入井、输出井都是连接文件</p></li><li><p>优点：易于对文件记录做增、删、改，易于动态增长记录；不必预先确知文件长度；存储空间利用率高</p></li><li><p>缺点：存放指针需要额外的存储空间，由于存取需通过缓冲区，待获得连接字后，才能找到下一物理块的地址，因而仅适用于顺序存取</p></li></ul><h4 id="直接文件">直接文件</h4><p>直接文件又称散列文件，通过计算记录的关键字建立与其物理存储地址之间的对应关系，这种变换通常采用散列。</p><ul><li>计算寻址结构可能出现冲突，解决办法有拉链法、循环探查法、二次散列法、溢出区法等</li></ul><h4 id="索引文件">索引文件</h4><p>索引文件为每个文件建立了一张索引表，其中每个表目包含一个记录的键（逻辑记录号）及其存储地址</p><ul><li>索引表的地址可由文件目录指出，查阅索引表先找到相应记录键，然后获得数据存储地址</li></ul><p>访问方式：</p><ul><li>索引文件在文件存储器上分为索引区和数据区</li><li>访问索引文件的两步操作：查找索引表，获得记录的物理地址</li><li>需要两次访问辅助存储器，若文件索引表已预先掉入主存储器，可减少一次内外存信息交换</li></ul><p>索引结构时连接结构的一种扩展，克服了连接文件只能作顺序存取的缺点，但增加了索引表的空间开销和查找时间。</p><p>索引表的组织：一级索引、二级索引、多级索引</p><h2 id="文件目录">5.3 文件目录</h2><h3 id="文件目录结构">5.3.1 文件目录结构</h3><p>文件目录是实现文件的按名存取的关键数据结构。</p><ul><li>文件系统的基本功能之一就是负责文件目录的建立、维护和检索，要求编排的目录便于查找、防止冲突</li><li>文件目录需要永久保存，因此也组织成文件存放在磁盘上</li></ul><p>一级目录结构：</p><p>在操作系统中构造一张线性表，与每个文件的相关属性占一个目录项，构成一级目录结构</p><ul><li>由于用户与文件众多，容易重名，不利于记忆</li></ul><p>二级目录结构：</p><ul><li>第一级为主文件目录，用于管理所有用户文件目录，目录项登记系统接受的用户名和该用户文件目录的地址</li><li>第二级为用户文件目录，为该用户的每个文件保存一个登记栏，内容与一级目录的目录项相同</li><li>每个用户只允许查看自己的文件目录</li></ul><p>二级目录结构的特点：</p><ul><li>可以检查访问文件者的存取权限，实现对文件的保密和保护</li><li>对同一个用户而言，依然存在文件多、易重名的问题</li></ul><p>树形目录结构：</p><p>每一级目录可以登记下一级目录，也可以登记文件，形成层次文件目录结构，一般采用树形目录结构，根是根目录，非叶节点为子目录，叶节点为文件</p><ul><li>较好地反映现实世界中具有层次关系的数据集合，较准确地反映系统内部文件的组织结构</li><li>不位于同一末端子目录的不同文件可以重名</li><li>易于规定不同层次货子树中文件的不同存取权限，便于文件的保护、保密和共享</li></ul><p>树形目录结构的文件定位</p><ul><li>一个文件的全名包括从根目录到文件为止的所有子目录路径</li><li>各子目录名间用文件分隔符分开</li><li>一个硬盘分区组织成一棵子树<ul><li>每棵子树对应一个逻辑盘符（Windows）</li><li>众多子树嫁接成一棵大树（UNIX）</li></ul></li></ul><h3 id="文件目录的管理">5.3.2 文件目录的管理</h3><h4 id="文件查找">文件查找</h4><p>系统跟去用户提供的文件路径（绝对/相对）搜索各级文件目录，找到文件。</p><ul><li>现代操作系统都有改变工作目录的命令。</li></ul><h4 id="目录项查找">目录项查找</h4><p>搜索具体目录项时，可以采用顺序查找法或二分查找、杂凑法等方式查找。</p><ul><li>目录项按一定顺序编排时可用二分查找</li><li>杂凑法，把每个文件名经过变换函数变换成唯一的目录表表项。</li></ul><h4 id="活动文件表">活动文件表</h4><ul><li><p>树形目录结构存在的问题：一个文件经过许多目录节点时，使用不方便，系统在沿路径查找目录时，要多次访问文件存储器，使访问速度大大减慢。</p></li><li><p>若将所有文件的目录都复制到主存，访问速度加快但主存开销大。</p></li><li><p>一种办法是，把常用的和正在使用的文件目录复制进主存</p></li></ul><p>系统为每个用户进程建立一张活动文件表，用户使用一个文件前，先通过打开操作，把该文件有关目录信息复制到指定主存区域，有关信息填入活动文件表，以建立用户进程和该文件索引的联系。</p><p>不再使用该文件时，使用关闭操作，切断用户进程和这个文件的联系，同时若该目录已被修改过，更新辅存中对应的文件目录。</p><h2 id="文件的共享保护和保密">5.4 文件的共享、保护和保密</h2><p>文件是计算机系统的重要资源，文件系统需要具有保障文件安全的手段，提供文件保密的措施，有效实现文件共享。</p><ul><li>文件共享是指不同用户共同使用某些文件</li><li>文件保护是指防止文件被破坏</li><li>文件保密是指防止文件及其内容被其他用户窃取</li></ul><h3 id="文件的共享">1. 文件的共享</h3><p>文件共享是计算机用户完成共同任务所必需的。</p><ul><li>好处：减少用户大量重复性劳动；免除系统复制文件的工作；节省文件占用的存储空间；减少程序设计输入/输出文件的次数</li></ul><p>文件共享的并发控制：</p><ul><li>在允许文件共享的系统中，操作系统应提供手段实现对共享文件的同步控制</li><li>多个进程可能同时存取一个文件如果它们同时进行读操作，操作系统应对文件进行公用控制</li><li>如果有进程进行写操作，操作系统须提供同步控制机制以保证文件数据完整性</li></ul><p>文件的保密：</p><ul><li>文件保密是指文件及其内容不能被未经文件主授权的其他用户窃取</li><li>保密措施：<ul><li>隐蔽文件目录</li><li>设置口令</li><li>使用密码</li></ul></li></ul><h3 id="文件的保护">2. 文件的保护</h3><p>文件保护是指防止文件被破坏。操作系统须提供文件保护机制，实现文件完整性。</p><p>常见的文件保护方法：文件副本；文件存取矩阵；文件属性</p><h4 id="文件副本">文件副本</h4><p>文件系统必须要有防止硬软件故障，保存信息完整性的能力，文件副本是主要实现机制。</p><ul><li>动态多副本技术</li><li>转储、备份和恢复</li></ul><h5 id="动态多副本">动态多副本</h5><p>在多个介质上维持同一内容的文件，在更新内容时同时进行。</p><p>增加了设备费用和系统负载，一般适用于容量较小且较为重要的文件，当文件发生故障时只需切换到备用设备即可。</p><p>一般适用于不需更新的系统文件及专用文件，</p><h5 id="文件转储">文件转储</h5><p>定时将文件复制转储到其他介质上，当某介质上出现故障时，复原转储文件。</p><p>转储的两种方式：</p><ul><li>一，一定时间间隔或一个单位处理结束时，系统自动复写更新过的文件和数据</li><li>二，每天或每周把文件信息全部复写，需要时再通过装入转储文件来恢复系统</li></ul><h4 id="文件的存取控制矩阵">文件的存取控制矩阵</h4><p>系统为每个用户设置访问每个文件对象的存取属性，则全部用户对全部文件的存取属性就组成一个二维矩阵，称为存取控制矩阵。</p><ul><li>由于操作系统具有很多用户和众多文件，存取控制矩阵是一个稀疏矩阵，可以将其简化为一张存取控制表<ul><li>每行包括：用户、文件、存取属性</li><li>仅登记那些对文件拥有存取属性的部分</li></ul></li></ul><p>基于存取控制矩阵/表的文件保护：</p><ul><li>存取属性：可以有访问、读、写、执行、创建、删除、授权等</li><li>系统通过查阅矩阵/表核对用户对文件的存取权限</li><li>文件主通过命令进行授权甚至授权权的转授</li><li>系统管理用户等同于文件主权限，获得对系统文件的授访问权权限</li></ul><h4 id="文件属性">文件属性</h4><p>存取控制表的一种简化方法是用户分类，再针对每类用户规定文件属性。</p><ul><li>用户分类：属主、合作者、其他</li><li>文件属性：读、写、执行</li><li>文件属性可以放在文件目录项中，管理大为简化</li><li>用户使用文件时，通过核对文件属性，实现保护</li></ul><h2 id="文件的使用">5.5 文件的使用</h2><h3 id="文件存取方法">5.5.1 文件存取方法</h3><p>文件存取方法是操作系统为用户程序提供的使用文件的技术和手段，在某种程度上依赖于文件的物理结构。</p><h4 id="顺序存取">顺序存取</h4><p>按记录顺序进行读写操作的存取方法。</p><ul><li>读操作根据读指针读出当前记录，同时推进读指针，指向下一次要读出的记录</li><li>写操作则设置写指针，把一个记录写到文件末端，同时推进写指针</li><li>允许对读指针进行前进或后退整数个记录的操作</li></ul><h4 id="直接存取">直接存取</h4><p>快速地以任意次序直接读写某个记录。</p><h4 id="索引存取">索引存取</h4><p>基于索引文件的索引存取方法。</p><ul><li>信息块的地址可以通过查找记录键换算出</li><li>也可以采用顺序存取或直接存取的方法</li><li>实际都采用多级索引加速记录查找</li></ul><h3 id="文件的使用-1">5.5.2 文件的使用</h3><p>用户通过两类接口与文件系统联系。</p><ul><li>一类是与文件有关的操作命令</li><li>另一类是提供给用户程序的文件类系统调用，如下</li></ul><h4 id="建立文件">建立文件</h4><p>参数：文件名、设备类、文件属性及存取控制信息</p><p>流程：在相应设备上建立一个文件目录项，分配第一个物理块，在活动文件表中申请一个项，登记有关目录信息，返回一个文件句柄。</p><h4 id="撤销文件">撤销文件</h4><p>参数：文件名、设备类</p><p>流程：若文件未关闭，先关闭文件；若为共享文件，进行联访处理；在目录文件中删除对应目录项，释放文件占用的文件存储空间</p><h4 id="打开文件">打开文件</h4><p>参数：文件名、设备类、打开方式</p><p>流程：在主存活动文件表中申请一个项，返回一个文件句柄；跟踪文件名查找目录文件，把目录信息复制到活动文件表相应栏，按存取控制说明检查访问的合法性；对共享文件进行相应的额外处理</p><h4 id="关闭文件">关闭文件</h4><p>参数：文件句柄</p><p>流程：将活动文件表中该文件的当前使用用户数减一，若此值为0，则收回此活动文件表，完成推迟写；若活动文件表目内容已被改过，则应先将表目内容写回文件存储器上相应表目中，使文件目录保存最新状态。</p><h4 id="读写文件">读写文件</h4><p>参数：文件句柄、用户数据区地址、读写的记录或字节数</p><p>按文件句柄从活动文件表中找到该目录的目录项信息；根据目录项指出的该文件逻辑和物理组织方式，把相关逻辑记录转换成物理块</p><h4 id="定位文件">定位文件</h4><p>调整所打开文件的读写指针位置</p><p>参数：文件句柄，定位指针</p><h2 id="文件系统的实现">5.6 文件系统的实现</h2><h3 id="辅存空间管理">1. 辅存空间管理</h3><h4 id="辅存空间的分配方式">辅存空间的分配方式</h4><ul><li>连续分配：存放在辅存空间连续存储区中（连续的存储块号）<ul><li>优点是顺序访问速度快，管理简单</li><li>为了获得足够大的连续存储区，需要定时进行碎片整理</li></ul></li><li>非连续分配：动态分配给若干扇区或簇，不要求连续<ul><li>辅存空间管理效率高，便于文件动态增长和收缩</li></ul></li></ul><h4 id="空闲块的管理">空闲块的管理</h4><h5 id="位示图">位示图</h5><p>使用若干字节构成一张表，表中每一字位对应一个物理块，字位的顺序和块的相对次序一致，字位为1表示相应块已占用，字位为0表示该块空闲。</p><p>优点：可以把位示图全部或大部分保存在主存中，配合位操作指令实现高速物理块分配与去配。</p><h5 id="空闲块成组连接法">空闲块成组连接法</h5><h3 id="文件系统的实现层次">2. 文件系统的实现层次</h3><ul><li>用户接口：接受用户发来的系统调用，进行语法检查，进入逻辑文件控制子系统</li><li>逻辑文件控制子系统：根据文件路径名，搜索文件目录，建立活动文件表，根据文件结构和存取方法，把逻辑记录转换成相对物理块号和块内相对地址</li><li>文件保护子系统：识别调用者身份，验证存取权限，判定本次文件操作的合法性</li><li>物理文件控制子系统：实现缓冲区管理，根据物理结构，将对应相对物理块号转换为实际物理块号，负责文件存储空间的分配，生存输入/输出控制系统调用形式</li><li>输入/输出控制子系统：执行具体的物理块输入/输出操作</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;长风破浪会有时，直挂云帆济沧海！&lt;/p&gt;</summary>
    
    
    
    <category term="计算机操作系统" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机操作系统-第四章_设备管理</title>
    <link href="http://example.com/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</id>
    <published>2023-05-04T04:00:00.000Z</published>
    <updated>2023-06-17T09:38:48.388Z</updated>
    
    <content type="html"><![CDATA[<p>长风破浪会有时，直挂云帆济沧海！</p><span id="more"></span><h1 id="第四章-设备管理">第四章 设备管理</h1><h2 id="设备管理基础">4.1 设备管理基础</h2><h3 id="设备管理概述">4.1.1 设备管理概述</h3><h4 id="输入输出设备及其分类">1. 输入/输出设备及其分类</h4><ul><li><p>输入/输出设备，又称外围设备、外设，用于计算机系统与外部世界的信息交换或存储。</p></li><li><p>输入/输出操作：内存和外设间的信息传送操作</p><ul><li>影响计算机系统的通用性和可扩展性</li><li>影响计算机系统综合处理能力及性价比</li></ul></li></ul><p>输入/输出设备分类：</p><ul><li>信息传输视角：分为输入设备、输出设备和输入输出设备</li><li>交互功能视角：分为人机交互设备、存储设备和机机通信设备</li><li>设备管理视角：分为字符设备、块设备和网络设备</li></ul><h4 id="设备管理的目标">2. 设备管理的目标</h4><p>解决设备和CPU速度的不匹配，使主机和设备充分并行工作，提高设备使用效率。</p><p>屏蔽设备的物理细节和操作过程，配置驱动程序，提供同一界面。</p><ul><li>抽象为裸设备</li><li>抽象为设备文件</li></ul><h4 id="设备管理的功能">3. 设备管理的功能</h4><ul><li>设备中断管理</li><li>缓冲区管理</li><li>设备的分配与去配</li><li>设备驱动调度</li><li>虚拟设备的实现</li></ul><h4 id="设备管理的实现层次">4. 设备管理的实现层次</h4><ul><li>输入/输出硬件<ul><li>输入/输出设备及其借口线路</li><li>控制部件</li><li>通道</li></ul></li><li>输入/输出软件<ul><li>系统输入/输出软件</li><li>用户空间输入/输出软件</li></ul></li></ul><h3 id="输入输出控制方式">4.1.2 输入/输出控制方式</h3><h4 id="设备控制器">1. 设备控制器</h4><p>为达到模块化和通用性的设计目标，通常分开设置设备的机械部件和电子部件。</p><p>电子部件成为设备控制器，又称为设备适配器、输入/输出控制器(模块/接口等)。</p><p>系统与控制器交互，而非与设备交互，设备控制器具体控制设备进行输入/输出。</p><h5 id="设备控制器的功能">设备控制器的功能</h5><p>设备控制器是CPU与设备之间的接口。</p><ul><li>接受和识别CPU或通道发来的命令</li><li>实现数据交换</li><li>发现和记录设备及其自身的状态信息，供CPU处理时使用</li><li>当连接多台设备时，识别设备地址</li></ul><h4 id="三种基本输入输出控制方式">2. 三种基本输入/输出控制方式</h4><h5 id="轮询方式">轮询方式</h5><ul><li>处理器向控制器发送输入/输出命令，轮询输入/输出结果</li><li>若设备未就绪，则重复测试过程，直至设备就绪</li><li>执行内存数据交换</li><li>等待输入/输出操作完成后，处理器才可以继续其他操作</li></ul><h5 id="中断方式">中断方式</h5><ul><li>处理器向控制器发出具体输入/输出命令，然后继续执行后续指令<ul><li>若进程支持异步输入/输出，后续指令仍然可以是该进程中指令</li><li>否则该进程在这个中断上挂起，处理器执行其他工作</li></ul></li><li>控制器检查设备状态，就绪后发出中断</li><li>CPU响应中断，进行中断处理，执行内存数据交换</li></ul><h5 id="dmadirect-memory-access直接存储器访问方式">DMA（Direct MemoryAccess，直接存储器访问）方式</h5><p>DMA模块：替代处理器来控制主存和设备控制器间的数据交换</p><ul><li>处理器向DMA模块发出输入/输出命令</li><li>处理器继续执行其他工作，DMA模块负责传送全部数据</li><li>数据传送结束后，DMA中断处理器</li></ul><h5 id="dma方式中的周期窃取">DMA方式中的周期窃取</h5><p>DMA和CPU同时通过总线访问内存，CPU会把总线的占有权让给DMA一个或几个主存周期。</p><p>周期窃取对CPU与主存的数据交换影响不大</p><ul><li>数据传送过程是不连续、不规则的</li><li>CPU大部分情况下与Cache进行数据交换，直接访问内存较少</li></ul><p>总结：</p><ul><li>轮询：CPU等待设备就绪，参与内存数据交换</li><li>中断：CPU不等待设备就绪，响应中断后参与内存数据交换</li><li>DMA：CPU不等待设备就绪，不参与主存数据交换</li></ul><h4 id="输入输出通道及其工作方式">3. 输入/输出通道及其工作方式</h4><h5 id="输入输出通道">输入/输出通道</h5><p>又称为通道控制器、输入/输出处理器，用于完成逻辑上独立的输入/输出任务。</p><p>采用四级连接：处理器、通道、控制器、设备</p><ul><li>通道可控制多台同类或不同类设备</li></ul><p>处理器不再执行输入/输出指令，而是在主存中组织通道程序，由输入/输出通道执行。</p><h5 id="输入输出通道的工作流程">输入/输出通道的工作流程</h5><ol type="1"><li>CPU遇到输入/输出任务，组织通道程序，置通道程序地址字CAW，启动指定通道</li><li>通道从CAW获得通道程序，控制输入/输出设备进行操作，CPU执行其他任务</li><li>输入/输出操作完成后，输入/输出通道发出中断，CPU处理中断，并从通道程序状态字CSW获得通道执行情况，处理输入/输出操作</li></ol><ul><li>CPU与通道高度并行工作</li></ul><h3 id="总线与输入输出">4.1.3 总线与输入/输出</h3><h4 id="总线对输入输出的影响">1. 总线对输入/输出的影响</h4><ul><li>输入/输出和CPU速度不匹配、各设备输入/输出速度不匹配</li><li>总线使主机和设备充分并行，提高系统效率</li></ul><h4 id="几种经典总线模型">2. 几种经典总线模型</h4><h5 id="单总线结构模型">单总线结构模型</h5><p>将CPU、主存和输入/输出模块连接到同一总线</p><ul><li><p>优点：结构简单、易于扩充</p></li><li><p>缺点：设备多时总线压力大，传输时间延长，慢速外设占用带宽多</p></li></ul><h5 id="三级总线模型">三级总线模型</h5><p>主存和Cache通过主存总线连接，主存总线和扩展总线上的输入/输出设备通过扩展总线接口缓冲</p><ul><li>优点：主存和输入/输出之间的数据传送、处理器的内存活动分离，可以支持更多输入/输出设备</li><li>缺点：不适用于输入/输出设备数据速率相差太大的情形</li></ul><h5id="南桥输入输出控制器与北桥主存控制器">南桥（输入/输出控制器）与北桥（主存控制器）</h5><p>通过存储总线、PCI总线、E(ISA)总线分别连接主存、高速输入/输出设备和低速输入/输出设备。</p><p>优点：可以支持不同数据速率的输入输出设备。</p><pre><code class=" mermaid">graph LRCPU--处理器总线---北桥--存储总线---Cache北桥--桥间接口---南桥南桥---PCI总线---E总线</code></pre><h5 id="一种基于通道的服务器总线模型">一种基于通道的服务器总线模型</h5><p>支持CPU、主存和多个输入/输出通道之间的数据传送</p><p>支持输入/输出通道和输入/输出控制器，以及输入/输出控制器和设备之间的数据传送。</p><ul><li>CPU通过主存控制器连接主存</li><li>CPU、主存和主存控制器均连接在一条与各个输入/输出通道连接的总线上</li><li>各个输入/输出通道分别与负责的输入/输出控制器连接</li><li>各个输入/输出控制器分别与负责的设备连接</li></ul><h2 id="设备管理软件">4.2 设备管理软件</h2><h3 id="输入输出软件的实现层次">4.2.1 输入/输出软件的实现层次</h3><h4 id="输入输出软件的设计">1. 输入/输出软件的设计</h4><p>设计目标：</p><ul><li>高效率：改善设备效率，尤其是磁盘输入/输出操作的效率</li><li>通用性：用统一标准来管理所有设备</li></ul><p>设计思路：</p><ul><li>把软件组织成层次结构，底层软件用来屏蔽硬件细节，高层软件向用户提供简洁、友善、统一的界面</li></ul><p>设计需要考虑的问题：</p><ul><li>设备无关性：访问设备的程序与具体设备无关</li><li>出错处理：低层软件能处理的错误不让高层软件感知</li><li>同步/异步传输：支持阻塞和中断驱动两种工作方式</li><li>缓冲技术：建立内存数据缓冲区，提高吞吐量</li></ul><h4 id="输入输出软件的实现层次-1">2. 输入/输出软件的实现层次</h4><p>从低到高有：</p><ol type="1"><li>输入/输出硬件：执行输入/输出操作</li><li>输入/输出中断处理程序：处理输入/输出中断，报告输入/输出错误，唤醒输入/输出设备驱动程序</li><li>输入/输出设备驱动程序：设备寄存器初始化，启动输入/输出操作，检查输入/输出状态</li><li>独立于设备的输入/输出软件：设备的命名、保护、阻塞、缓冲、分配、跟踪</li><li>用户空间的输入/输出软件：输入/输出系统调研、输入/输出格式化、SPOOLing</li></ol><h3 id="输入输出软件的实现">4.2.2 输入/输出软件的实现</h3><h4 id="输入输出中断处理程序">1. 输入/输出中断处理程序</h4><p>输入/输出中断处理程序位于操作系统底层，与硬件设备密切相关，与系统其余部分尽可能少地发生联系。</p><ul><li>进程请求输入/输出操作时，通常被阻塞</li><li>数据传输结束后产生输入/输出中断</li><li>CPU响应请求并转入中断处理程序</li></ul><h5 id="输入输出中断处理程序的功能">输入/输出中断处理程序的功能</h5><p>检查设备状态寄存器，判断中断原因，根据输入/输出操作完成情况进行相应处理</p><ul><li>如果数据传输有误，向上层软件报告设备出错信息，实施重新执行</li><li>如果正常结束，唤醒等待传输的进程，使其转换为就绪态</li><li>如果有等待传输的输入/输出命令，通知相应软件开启下一个输入/输出请求</li></ul><h4 id="设备驱动程序">2. 设备驱动程序</h4><ul><li>包括与设备密切相关的所有代码</li><li>从独立于设备的软件中接受输入/输出请求</li><li>把用户提交的逻辑输入/输出请求转化为物理输入/输出操作的启动和执行</li><li>监督设备是否正确执行，访问数据缓冲区，进行必要的纠错处理</li></ul><h5 id="设备驱动程序的功能">设备驱动程序的功能</h5><ul><li>设备初始化：在设备传输数据时，预置设备、控制器以及通道状态</li><li>执行设备驱动例程：负责启动设备，进行数据传输；对于通道，负责组织通道程序，启动通道工作</li><li>执行与设备相关的具体中断处理，负责处理设备、控制器及通道所发出的各种具体中断</li></ul><h5 id="设备驱动程序的层次">设备驱动程序的层次</h5><p>每个设备驱动程序原则上只处理一种设备，或者一类紧密相关的设备。</p><p>设备驱动程序的分层实现：</p><ul><li>高层/处理类设备，底层/处理具体设备</li><li>系统建立栈，接到输入/输出请求时先调用栈顶的驱动程序，然后继续向下调用底层驱动程序，直至所有物理操作被处理</li><li>这一方式使设备驱动的实现结构清晰，易于移植，但会增加一部分系统开销</li></ul><h4 id="独立于设备的输入输出软件">3. 独立于设备的输入/输出软件</h4><p>执行适用于所有设备的常用输入/输出功能，并向用户层软件提供一致性接口，包括：</p><ul><li>设备命名：通过路径名寻址设备</li><li>设备保护：用户是否有权访问设备</li><li>提供与设备无关的数据单位：字符、块</li><li>缓冲技术：调整CPU与输入/输出速度不匹配</li><li>分配和状态跟踪：分配设备</li><li>错误处理与报告：驱动无法处理的错误</li></ul><h4 id="用户空间的输入输出软件">4. 用户空间的输入/输出软件</h4><ul><li>库函数：操作系统内核外，使用库函数实现的输入/输出软件，运行时与应用程序链接</li><li>虚拟设备：用一类设备模拟另一类设备的仿真输入/输出软件</li></ul><h3 id="输入输出缓冲">4.2.3 输入/输出缓冲</h3><h4 id="输入输出缓冲-1">1. 输入/输出缓冲</h4><h5 id="设置输入输出缓冲的目的">设置输入/输出缓冲的目的</h5><ul><li>解决CPU与设备之间速度不匹配的矛盾</li><li>协调逻辑记录大小和物理记录大小不一致的问题</li><li>提高CPU和设备的并行性</li><li>减少输入/输出操作对CPU的中断次数</li><li>放宽对CPU中断响应时间的要求</li></ul><h5 id="输入输出缓冲区">输入/输出缓冲区</h5><p>在内存中开辟的存储区，专门用于临时存放输入/输出操作的数据</p><p>操作过程：</p><ul><li>写操作：将数据送至缓冲区，直到写满或需要写出，待适当时候系统将缓冲区内容写到设备上</li><li>读操作：系统将设备上的物理记录读至缓冲区，根据要求将当前所需要的数据从缓冲区中读出并传送给进程</li></ul><h4 id="几种缓冲技术">2. 几种缓冲技术</h4><h5 id="单缓冲技术">单缓冲技术</h5><p>操作系统在主存系统区中开设一个缓冲区。</p><ul><li>输入：先把数据读至缓冲区，再把缓冲区数据送至用户区，应用程序处理数据，如此往复，系统继续读入后续数据</li><li>输出，把数据从用户区传送至缓冲区，再将数据输出至设备，应用程序继续请求输出</li></ul><h5 id="双缓冲技术">双缓冲技术</h5><p>操作系统在主存系统区开设两个缓冲区。</p><ul><li>输入：先把数据输入缓冲区1，再从缓冲区1把数据传到用户区，供应用程序处理（同时设备可将数据传送到缓冲区2）</li><li>输出：先将数据从用户区传送到缓冲区1，再将数据传送到设备（同时应用程序可将数据传送到缓冲区2）</li></ul><h5 id="循环缓冲技术">循环缓冲技术</h5><p>操作系统分配一组缓冲区，每个缓冲区有指向下一个缓冲区的链接指针，构成循环</p><ul><li>调节设备和进程速度不匹配的问题</li></ul><h2 id="独占型外围设备的分配">4.3 独占型外围设备的分配</h2><h3 id="设备独立性">4.3.1 设备独立性</h3><ul><li><p>用户通常不指定物理设备，而是指定逻辑设备，使得用户进程和物理设备分离，再通过其他途径建立逻辑设备和物理设备间的映射。</p></li><li><p>设备管理中需要将逻辑设备名转换为物理设备名，为此系统需要提供逻辑设备名和物理设备名的对应表以供转换使用</p></li></ul><h4 id="设备独立性的优点">设备独立性的优点</h4><ul><li>应用程序与具体物理设备无关，系统增减或变更设备时不需要修改原程序</li><li>易于应对各种输入/输出设备故障，提高系统的可靠性</li><li>增加设备分配的灵活性，有利于更加有效地利用设备资源，实现多道程序设计</li></ul><h3 id="独占型外围设备的分配-1">4.3.2 独占型外围设备的分配</h3><h4 id="设备分配方式">设备分配方式</h4><p>独占型外围设备：一次只能由一个进程独占使用</p><p>分配方式：</p><ul><li>静态分配：进程运行前申请<ul><li>实现简单，能防止系统发生死锁，但会降低设备利用率</li></ul></li><li>动态分配：进程随用随申请<ul><li>提高设备利用率</li></ul></li></ul><h4 id="设备分配的数据结构">设备分配的数据结构</h4><p>设备类表</p><ul><li>每类设备对应于设备类表中的一栏</li><li>包括设备类、总台数、空闲台数、设备表起始地址等</li><li>支持设备独立性</li></ul><p>设备表</p><ul><li>每类设备有各自的设备表，用来登记这类设备的每台物理设备</li><li>包括：物理设备名，逻辑设备名，占有设备的进程，分配标志，好/坏标志等</li></ul><h2 id="共享型外围设备的驱动">4.4 共享型外围设备的驱动</h2><h3 id="磁盘的物理结构">4.4.1 磁盘的物理结构</h3><h4 id="磁盘结构">1. 磁盘结构</h4><ul><li>磁盘一般由多个盘片组成</li><li>每个盘片一般由两个盘面</li><li>盘面包括多个同心圆结构的磁道，不同盘面上位于相同位置的磁道构成柱面</li><li>每个磁道分为固定多个扇区，相邻扇区组合成簇</li><li>物理块的地址：<ul><li>柱面号，磁道号，扇区号</li><li>0面0道1扇区（此处面指磁头而不是柱面）</li></ul></li></ul><h4 id="磁盘读写数据的方式">2. 磁盘读写数据的方式</h4><p>读写数据时，磁头必须定位到指定磁道上的指定扇区的开始处，过程为：</p><ol type="1"><li>寻道：控制移动臂到达指定柱面</li><li>旋转：等待要读写的扇区旋转到磁头下</li><li>选择磁头号，进行数据传送</li></ol><h4 id="磁盘存取时间">3. 磁盘存取时间</h4><p>磁盘完成数据读写所需要的时间，是寻道时间、旋转延迟、传送时间的总和。</p><p><spanclass="math inline">\(T_a=T_s+\frac{1}{2r}+\frac{b}{rN}\)</span></p><p>其中，<span class="math inline">\(T_a\)</span>为存取时间，<spanclass="math inline">\(T_s\)</span>为寻道时间，<spanclass="math inline">\(r\)</span>为磁盘旋转速度（转/秒），<spanclass="math inline">\(b\)</span>为要传送的字节数，<spanclass="math inline">\(N\)</span>为一个磁道中的字节数。</p><h3 id="磁盘的驱动调度">4.4.2 磁盘的驱动调度</h3><p>磁盘可能同时接收到若干输入/输出请求，如果随机响应，性能会很差。</p><p>驱动调度：操作系统的磁盘调度策略，按照最佳次序执行处理访问磁盘的多个输入/输出请求，以减少磁盘访问的总处理时间。</p><p>驱动调度策略有移臂调度和旋转调度。</p><h4 id="移臂调度及其算法">移臂调度及其算法</h4><ul><li><p>目的：使移动臂的移动时间最短以减少寻道总时间</p></li><li><p>算法：</p><ul><li>先来先服务：移臂距离大，性能差</li><li>最短查找时间优先<ul><li>先执行查找时间最短的请求，寻道性能较好</li><li>存在“饥饿”现象</li></ul></li><li>单向扫描：移动臂向一个方向扫描，归途不提供服务</li><li>双向扫描：移动臂向一个方向移动，到达最后一个柱面再向反方向移动</li><li>电梯调度：改进双向扫描，当前移动方向没有访问请求时就改变方向</li></ul></li></ul><h4 id="旋转调度及其策略">旋转调度及其策略</h4><p>目的：使旋转延迟的总时间最少</p><p>循环排序：</p><ul><li><p>通过优化输入/输出请求排序，在最少旋转圈数内完成位于同一柱面的访问请求</p></li><li><p>旋转位置测定硬件和多磁头同时读写技术有利于提高旋转调度的效率</p></li></ul><p>优化分布：</p><ul><li>通过信息在存储空间的排列方式来减少旋转延迟</li><li>交替排序：由于磁盘匀速旋转，可能处理当前扇区数据时，下个扇区已经跳过。因此，可对扇区间隔编号，交叉因子为n:1表示相邻编号间间隔n-1个扇区</li><li>相邻扇区集中成簇读写</li><li>按柱面集中存储数据，可以减少数据读写时的移臂操作</li></ul><h2 id="虚拟设备">4.5 虚拟设备</h2><h3 id="spooling系统">4.5.1 SPOOLing系统</h3><h4 id="虚拟设备-1">1. 虚拟设备</h4><p>使用一类物理设备模拟另一类物理设备的技术。</p><p>示例：</p><ul><li>内存模拟磁盘</li><li>块设备模拟字符设备</li><li>输入输出重定向</li></ul><h4 id="spooling系统-1">2. SPOOLing系统</h4><p>SPOOLing（Simultaneous Peripheral OperationsOn-Line，外部设备联机并行操作），是关于慢速字符设备如何与计算机主机交换信息的一种技术，通常称为“假脱机技术”。</p><p>一个经典的SPOOLing系统：</p><ul><li>用高速的磁盘设备来模拟慢速的字符设备，缩短进程在内存中的驻留时间</li><li>慢速输出设备先输出到输出井</li><li>进程运行过程中只从输入井读入数据，只向输出井输出数据，使得全部输入/输出都基于磁盘</li><li>加快进程周转时间，提高系统吞吐量</li></ul><p>该系统的软件组成：</p><ul><li>预输入系统：预先把数据从输入设备传送到磁盘输入井</li><li>缓输出设备：把数据从磁盘输出并传送到输出设备</li><li>井管理程序：控制进程和井之间的数据交换（输入/输出重定向）</li></ul><p>打印SPOOLing系统：打印机守护进程和SPOOLing打印目录</p><ul><li>守护进程是唯一有特权使用打印机设备的进程</li><li>打印文件前，用户进程先产生完整的待输出文件，存放在打印目录下</li><li>打印机空闲时，启动守护进程，打印待输出文件</li></ul><h3 id="批处理系统的作业管理">4.5.2 批处理系统的作业管理</h3><ul><li>作业说明语言：用于作业控制的语言</li><li>作业说明书：刻画具体作业的控制方式</li><li>作业状态：输入状态（预输入）、后备状态（空闲）、运行状态（运行）、完成状态（缓输出）</li><li>作业调度：从后备状态作业中选择部分进入运行状态</li><li>作业调度算法：优先数、短作业、响应比、设备搭配等</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;长风破浪会有时，直挂云帆济沧海！&lt;/p&gt;</summary>
    
    
    
    <category term="计算机操作系统" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机操作系统-第三章_存储管理</title>
    <link href="http://example.com/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</id>
    <published>2023-05-03T04:00:00.000Z</published>
    <updated>2023-06-17T09:55:33.155Z</updated>
    
    <content type="html"><![CDATA[<p>长风破浪会有时，直挂云帆济沧海！</p><span id="more"></span><h1 id="第三章-存储管理">第三章 存储管理</h1><h2 id="存储管理基础">3.1 存储管理基础</h2><h3 id="基本内容">3.1.1 基本内容</h3><p>逻辑地址(相对地址)，用户编程所使用的地址空间，从0开始编号，两种形式：</p><ol type="1"><li>一维，即地址</li><li>二维，段号：段内地址</li></ol><p>物理地址(绝对地址)，处理器执行指令时按照物理地址进行。</p><h4 id="段式程序设计">段式程序设计</h4><p>将一个程序设计成多个段(代码段、数据段、堆栈段，等等)。</p><p>用户可以应用段覆盖技术(程序设计技术)扩展内存空间使用量。</p><h4 id="主存储器的复用">主存储器的复用</h4><p>多道程序设计需要复用主存</p><ol type="1"><li>按照分区复用</li></ol><p>主存划分为多个固定/可变尺寸的分区，一个程序/程序段占用一个分区</p><ol type="1"><li>按照页架复用</li></ol><p>主存划分为多个固定大学的页架，一个程序/程序段占用多个页架</p><h4 id="存储管理的基本模式">存储管理的基本模式</h4><ol type="1"><li>单连续存储管理：一维逻辑地址空间的程序占用一个主存固定/可变分区</li><li>段式存储管理：段式二维逻辑地址空间的程序占用多个主存可变分区</li><li>页式存储管理：一维逻辑地址空间的程序占用多个主存页架区</li><li>段页式存储管理：段式二维逻辑地址空间的程序占用多个主存页架区</li></ol><figure><img src="/image/计算机操作系统/存储管理基本模式.png"alt="存储管理基本模式" /><figcaption aria-hidden="true">存储管理基本模式</figcaption></figure><h3 id="存储管理功能">3.1.2 存储管理功能</h3><p>地址转换：又称重定位，将逻辑地址转换为绝对地址</p><p>静态重定位：程序装入内存时进行重定位，早期小型OS使用，由装入程序执行</p><p>动态重定位：CPU执行程序时进行重定位，效率依赖硬件地址转换机构</p><h4 id="主存储器空间的分配和去配">主存储器空间的分配和去配</h4><ol type="1"><li>分配：进程装入主存时，存储管理软件进行具体的主存分配操作，并设置表格记录主存空间的分配情况</li><li>去配：当某个进程撤离或主动归还主存资源时，存储管理软件收回其占用的全部或部分存储空间，调整主存分配表信息</li></ol><h4 id="主存储器空间的共享">主存储器空间的共享</h4><ol type="1"><li>多个进程共享主存储器资源：多道程序设计技术使若干个程序同时进入主存储器，各自占用一定数量的存储空间，共同使用一个主存储器</li><li>多个进程共享主存储器的某些区域：若干个协作进程有共同的主存程序或者主存数据块</li></ol><h4 id="存储保护">存储保护</h4><p>为避免主存中多个进程相互干扰，须对主存中程序和数据进行保护：</p><ol type="1"><li>私有主存区信息：可读写</li><li>公共区共享信息：根据授权</li><li>非本进程信息：不可读写</li></ol><p>需软硬件协同完成：CPU检查是否允许访问，不允许则产生地址保护异常。</p><h4 id="主存空间的扩充">主存空间的扩充</h4><p>存储扩充：把磁盘作为主存扩充，只把部分进程或进程的部分内容装入内存</p><ol type="1"><li>对换技术：把部分不运行的进程调出</li><li>虚拟技术：只调入进程的部分内容</li></ol><p>需软硬件协同完成：</p><ol type="1"><li>对换进程决定对换，硬件机构调入</li><li>CPU处理到不在主存的地址，发出虚拟地址异常，OS将其调入再执行指令</li></ol><h3 id="虚拟存储器">3.1.3 虚拟存储器</h3><p>主存容量限制了用户编程与多道程序设计的道数—&gt;部分调入进程内容。</p><h4 id="虚拟存储器的基本思想">虚拟存储器的基本思想</h4><ol type="1"><li>存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，之后根据执行行为随用随调</li><li>若主存空间不足，存储管理根据执行将主存中暂时不用的信息调出到辅存</li></ol><h4 id="实现思路">实现思路</h4><p>建立和自动管理两个地址空间</p><ol type="1"><li>主存：实际地址空间，承载进程执行</li><li>辅存：虚拟地址空间，容纳进程装入</li></ol><p>对于用户，计算机系统具有一个容量大得多的主存空间，即虚拟存储器</p><p>虚拟存储器是一种地址空间扩展技术，通常意义上对用户编程是透明的，除非用户需要进行高性能程序设计。</p><h3 id="存储管理的硬件支撑">3.1.4 存储管理的硬件支撑</h3><h4 id="存储器的组织层次">存储器的组织层次</h4><figure><img src="/image/计算机操作系统/存储器组织层次.png"alt="存储器组织层次" /><figcaption aria-hidden="true">存储器组织层次</figcaption></figure><p>存储管理是操作系统管理主存储器的软件部分。</p><p>为了更好的处理性能，部分主存程序与数据被调入Cache；</p><p>为了获得更大虚拟地址空间，存储管理需要管理更大的虚拟存储器。</p><h4 id="高速缓冲存储器cache">高速缓冲存储器(Cache)</h4><p>介于CPU和主存间的高速小容量存储器。</p><p>构成：高速存储器、联想存储器、地址转换部件、替换部件等。</p><ol type="1"><li>联想存储器：根据内容进行寻址的存储器</li><li>地址转换部件：通过联想存储器建立目录表以实现快速地址转换，命中时直接访问Cache，未命中时从内存读取放入Cache</li><li>替换部件：缓存已满时按一定策略进行数据块替换，并修改地址转换部件</li></ol><p>组织：由于中央处理器芯片面积和成本，Cache很小</p><p>根据成本控制，划分为L1、L2、L3三级。</p><ol type="1"><li>L1Cache：分为数据缓存和指令缓存，内置，成本最高，对CPU性能影响最大，通常在32-256KB</li><li>L2 Cache：分内置和外置两种，后者性能低。通常在512KB-8MB</li><li>L3 Cache：多为外置，在游戏和服务器领域有效。</li></ol><p>对很多应用而言，改善总线比设置L3更加有利于提升系统性能</p><h4 id="存储管理与硬件支撑">存储管理与硬件支撑</h4><ol type="1"><li>程序执行与数据访问的局部性原理—&gt;使用Cache可大幅提升程序执行效率</li><li>动态重定位、存储保护等，无硬件支撑在效率上无意义</li><li>无虚拟地址中断，虚拟存储器无法实现</li><li>无页面替换等硬件支撑机制，虚拟存储器在效率上无意义</li></ol><p>存储保护的硬件支撑：限长寄存器与逻辑地址比较判断是否越界</p><p>地址转换的硬件支撑：基址寄存器与逻辑地址运算得物理地址</p><h2 id="单连续分区存储管理">3.2 单连续分区存储管理</h2><p>每个进程占用一个物理上完全连续的存储空间。</p><p>分为：单用户连续分区存储管理、固定分区存储管理、可变分区存储管理</p><h3 id="单用户连续分区存储管理">3.2.1 单用户连续分区存储管理</h3><ol type="1"><li>主存区域划分为系统区和用户区</li><li>设置一个栅栏寄存器界分两个区域，硬件用其在执行时进行存储保护</li><li>一般使用静态重定位进行地址转换</li></ol><p>硬件实现代价低，适用于单用户单任务操作系统，如DOS。</p><h4 id="静态重定位">静态重定位</h4><p>装入作业时，把该作业中程序的指令地址和数据地址全部转换为绝对地址。</p><h3 id="固定分区存储管理">3.2.2 固定分区存储管理</h3><p>硬件实现代价低，早期操作系统采用</p><p>基本思想：支持多个数量、大小固定的分区</p><p>使用主存分配表(分区号，起始地址，长度，占用标志)，执行主存分配/去配。</p><p>固定分区会产生内存内零头，即内存分区中空闲的部分。</p><h3 id="三可变分区存储管理">三、可变分区存储管理</h3><p>创建进程时，根据进程所需主存查看主存中是否有足够空闲空间，有则分配，无则等待。由于分区大小为实际分配，其个数是随机变化的。</p><h4 id="主存分配表">主存分配表</h4><p>分为已分配区表和未分配区表，采用链表。</p><h4 id="内存分配">内存分配</h4><ul><li>最先适应分配算法</li><li>邻近适应分配算法</li><li>最优适应分配算法</li><li>最坏适应分配算法</li></ul><p>可变分区会随着进程的内存分配产生不可用的小内存分区，称为内存外零头。</p><p>任何算法难免产生外零头，最优适配算法最容易产生外零头。</p><h4 id="移动技术程序浮动技术">移动技术（程序浮动技术）</h4><p>移动分区以解决内存外零头，需要动态重定位支撑</p><h2 id="页式存储管理">3.3 页式存储管理</h2><h3 id="页式存储管理的基本原理">3.3.1 页式存储管理的基本原理</h3><ol type="1"><li>分页存储器将主存划分为多个大小相等的页架</li><li>逻辑地址被页架分成页</li><li>不同的页可以放在不同页架中，不需要连续</li><li>页表用于维系进程的主存完整性</li></ol><h4 id="地址">地址</h4><ol type="1"><li>逻辑地址由页号和单元号组成</li><li>物理地址由页架号和单元号组成</li><li>地址转换可以通过查页表完成</li></ol><h4 id="内存分配去配">内存分配/去配</h4><ol type="1"><li>可用位示图记录主存分配情况asff</li><li>建立进程页表维护主存逻辑完整性</li></ol><p>位示图：使用0和1表示磁盘中块的使用情况。</p><h4 id="页的共享">页的共享</h4><ol type="1"><li>数据共享：不同进程可以使用不同页号共享数据页</li><li>程序共享：不同进程必须使用相同页号共享代码页</li></ol><p>原因：共享代码页中的JMP <页内地址>使用不同页号是做不到的。</p><h3 id="页式存储管理的地址转换">3.3.2 页式存储管理的地址转换</h3><h4 id="页式存储管理的代价">页式存储管理的代价</h4><p>页表放在主存，每次地址转换需访问两次主存</p><ol type="1"><li>按页号读出页表中相应页架号</li><li>按计算出来的绝对地址进行读写</li></ol><p>这降低了存取速度—&gt;使用Cache存放部分页表，即快表。</p><h4 id="快表">快表</h4><p>存放在高速缓冲存储器中的页表部分s</p><p>快表的表项：页号和页架号</p><p>这种高速存储器是联想存储器，即按照内容寻址，而非按照地址寻址。</p><p>基于快表的地址转换流程：</p><ol type="1"><li>按逻辑地址中的页号查快表</li><li>若在快表中，则由页架号和单元号生成绝对地址</li><li>不在快表中，再查主存页表形成绝对地址，同时登记该页到快表中</li><li>快表填满后，按一定策略淘汰一个旧登记项，登记新页</li></ol><h4 id="多道程序环境下的进程表">多道程序环境下的进程表</h4><p>进程表中登记了每个进程的页表，进程占有处理器运行时，其页表起始地址和长度送入页表控制寄存器。</p><p>多道程序环境下的地址转换：</p><figure><img src="/image/计算机操作系统/多道程序环境下的地址转换.png"alt="多道程序环境下的地址转换" /><figcaption aria-hidden="true">多道程序环境下的地址转换</figcaption></figure><h3 id="页式虚拟存储管理">3.3.3 页式虚拟存储管理</h3><p>基本思想：</p><p>把进程全部页面装入虚拟存储器，执行时先把部分页面装入实际内存，然后根据执行行为动态调入不在主存的页，并进行必要的页面调出。</p><ul><li>这是现代操作系统主流存储管理技术。</li></ul><p>首次只把进程第一页信息装入主存，称为请求页式存储管理。</p><h4 id="页式虚拟存储管理的页表">页式虚拟存储管理的页表</h4><p>扩充页表项，指出：</p><ul><li><p>每页的虚拟地址、实际地址</p></li><li><p>主存驻留标志、写回标志、保护标志、引用标志、可移动标志，等等</p></li></ul><p>实现</p><ul><li>中央处理器处理地址<ul><li>若页驻留，则获得块号形成绝对地址</li><li>若页不在内存，则中央处理器发出缺页中断</li></ul></li><li>操作系统处理缺页中断<ul><li>若有空闲页架，则根据辅存地址调入页，更新页表和快表等</li><li>若无空闲页架，则决定淘汰页，调出已修改页，调入页，更新页表与快表</li></ul></li></ul><figure><img src="/image/计算机操作系统/页式虚拟存储管理.png"alt="页式虚拟存储管理" /><figcaption aria-hidden="true">页式虚拟存储管理</figcaption></figure><figure><img src="/image/计算机操作系统/页式虚拟存储管理2.png"alt="页式虚拟存储管理2" /><figcaption aria-hidden="true">页式虚拟存储管理2</figcaption></figure><h3 id="页式存储管理的页面调度">3.3.4 页式存储管理的页面调度</h3><p>当主存空间已满又需要装入新页时，页式虚拟存储管理必须按一定的算法把已在主存的一些页调出去。选择淘汰页的工作即为页面调度。</p><p>若页面调度算法设计不当，会导致页面被反复淘汰、调入，这称为页面抖动。</p><h4 id="缺页中断率">缺页中断率</h4><p>衡量存储管理性能和用户编程水平的重要依据</p><p>假定进程P共n页，系统分配页架数m个，P运行中成功访问次数S，不成功访问次数F，总访问次数A=S+F，缺页中断率为：f=F/A。</p><p>影响缺页中断率的因素：</p><ul><li>分配给进程的页架数：可用页架数越多，缺页中断率越低</li><li>页面大小：页面尺寸越大，缺页中断率越低</li><li>用户编程方法：大数据条件下，对缺页中断率影响也很大</li></ul><h4 id="页面调度算法">页面调度算法</h4><ul><li><p>OPT页面调度算法</p><ul><li><p>由Belady提出，又称Belady算法。</p></li><li><p>只可模拟，不可实现。</p></li></ul><p>当要调入新页面时，先淘汰以后不再访问的页，后选择距现在最长时间后再访问的页。</p></li><li><p>先进先出算法(FIFO)：总是淘汰最先调入主存的页</p></li><li><p>最近最少用算法(LRU)：淘汰最近一段时间较久未被访问的页</p><ul><li>严格实现的代价大：维持特殊队列</li></ul></li><li><p>最不常用算法(LFU)：淘汰最近一段时间内访问次数较少的页</p></li><li><p>时钟调度算法：用循环队列构造页面队列，队列指针指向可能要淘汰的页</p></li></ul><p>LFU模拟OPT比LRU更接近。</p><p>时钟调度算法使用页引用标志位，工作流程：</p><ol type="1"><li><p>页面调入主存时，引用标志位置1</p></li><li><p>访问主存页面时，引用标志位置1</p></li><li><p>淘汰页面时，从指针当前指向的页面开始扫描循环队列</p><ul><li>将所遇到的引用标志位是1的页面的引用标志位清0，跳过</li><li>将所遇到的引用标志位是0的页面淘汰，指针推进</li></ul></li></ol><h3 id="反置页表">3.3.5 反置页表</h3><h4 id="反置页表的提出">反置页表的提出</h4><ol type="1"><li>页表及相关硬件机制在地址转换、存储保护、地址虚拟中发挥了关键作用</li><li>为页式存储管理设置专门硬件机构</li><li>内存管理单元(MMU)：中央处理器管理虚拟/物理存储器的控制线路，把虚拟地址映射成物理地址，提供存储保护，必要时确定淘汰页面</li><li>反置页表(IPT)：MMU的数据结构</li></ol><h4 id="反置页表的基本设计思想">反置页表的基本设计思想</h4><ol type="1"><li>对内存中每个页架建立一个页表，按照块号排序</li><li>用以完成内存页架到访问进程页号的对应，即物理到逻辑地址的转换</li></ol><h4 id="反置页表的页表项">反置页表的页表项</h4><ol type="1"><li>页号：虚拟地址页号</li><li>进程标识符：使用该页的进程号</li><li>标志位：有效、引用、修改、保护和锁定等标志信息</li><li>链指针：哈希链</li></ol><h4 id="基于反置页表的地址转换过程">基于反置页表的地址转换过程</h4><ol type="1"><li>MMU通过哈希表把进程标识和虚页号转换成一个哈希值，指向反置页表的一个表目</li><li>MMU遍历哈希链找到所需进程的虚页号，该项的索引就是页架号，通过拼接移位即可生成物理地址</li><li>若遍历反置页表未能找到匹配页表项，则产生缺页中断</li><li>选择淘汰页面也由MMU完成</li></ol><h2 id="段式存储管理">3.4 段式存储管理</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;长风破浪会有时，直挂云帆济沧海！&lt;/p&gt;</summary>
    
    
    
    <category term="计算机操作系统" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机操作系统-第二章_处理器管理文件</title>
    <link href="http://example.com/2023/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2023/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6/</id>
    <published>2023-05-02T04:00:00.000Z</published>
    <updated>2023-06-20T08:43:17.239Z</updated>
    
    <content type="html"><![CDATA[<p>长风破浪会有时，直挂云帆济沧海！</p><span id="more"></span><h1 id="第二章-处理器管理文件">第二章 处理器管理文件</h1><h2 id="处理器">2.1 处理器</h2><h3 id="处理器与寄存器">2.1.1 处理器与寄存器</h3><h4 id="处理器部件的简单示意">处理器部件的简单示意</h4><figure><img src="/image/计算机操作系统/处理器部件简单示意.png"alt="处理器部件简单示意" /><figcaption aria-hidden="true">处理器部件简单示意</figcaption></figure><h4 id="用户程序可见寄存器">用户程序可见寄存器</h4><ul><li><p>可以让程序员减少访问主存储器次数，提高指令执行的效率</p></li><li><p>所有程序可使用，包括应用程序和系统程序</p></li></ul><ol type="1"><li>数据寄存器，又称通用寄存器</li><li>地址寄存器：索引、栈指针、段地址等寄存器</li></ol><h4 id="控制与状态寄存器">控制与状态寄存器</h4><p>用于控制处理器的操作，主要被具有特权的操作系统程序使用</p><ol type="1"><li>程序计数器：存储将取指令的地址</li><li>指令寄存器：存储最近使用的指令</li><li>条件码：中央处理器为指令操作结果设置的位，标志正/负/零、溢出等结果</li><li>标志位：中断位、中断允许位、中断屏蔽位、处理器模式位、内存保护位等</li></ol><h4 id="程序状态字psw">程序状态字（PSW）</h4><p>记录当前程序运行的动态信息。</p><p>通常包含：</p><ul><li>程序计数器、指令寄存器、条件码</li><li>中断字、中断允许/禁止、中断屏蔽、处理器模式、内存保护、调试控制</li></ul><p>程序状态字也是计算机系统的寄存器。</p><ul><li>通常设置一组控制与状态寄存器，也可以专设一个程序状态字寄存器</li></ul><h3 id="指令与处理器模式">2.1.2 指令与处理器模式</h3><h4 id="机器指令">机器指令</h4><p>计算机系统执行的基本命令，中央处理器执行的基本单位</p><ul><li><p>指令由一个或多个字节组成，包括操作码、操作数地址、状态字以及特征码。</p></li><li><p>指令完成各种算术逻辑运算、数据传输、控制流跳转。</p></li></ul><p>指令执行过程</p><ol type="1"><li>取指：根据程序计数器从存储器或高速缓冲存储器中取指令到指令寄存器</li><li>译码：解译指令寄存器中的指令</li><li>执行：连接中央处理器，执行运算</li></ol><h4 id="特权指令与处理器模式">特权指令与处理器模式</h4><p>与计算机核心资源相关的特殊指令会被保护，只能被操作系统程序使用</p><p>特权指令：只能被操作系统内核使用的指令。</p><p>处理器模式：管理特权指令</p><p>设置0、1、2、3等运行模式，执行规定的指令子集。</p><p>0：操作系统内核</p><p>1：系统调用</p><p>2：共享库程序</p><p>3：用户程序</p><p>0模式可执行全部指令，3模式只能执行非特权指令。</p><p>一般而言，现代操作系统只使用0和3两种模式，即内核模式与用户模式。</p><p>处理器模式切换：中断、异常或系统异常等事件导致用户程序向OS内核切换。</p><h2 id="中断">2.2 中断</h2><h3 id="中断的概念">2.2.1 中断的概念</h3><p>在程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转而执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程，称为中断。</p><ul><li>操作系统是中断驱动的，换言之，中断是激活操作系统的唯一方式。</li></ul><p>由硬件产生的中断称为硬中断，可分为外中断和内中断</p><ol type="1"><li>外中断，也称中断（狭义）、异步中断，是来自处理器外的中断，如设备中断</li><li>内中断，也称异常，是来自处理器内部的中断，通常是程序执行过程中发生的与当前指令关联的不正常的事件，如访管、硬件故障、程序性异常</li></ol><p>外中断会根据中断优先级处理，内中断一旦出现则立即由异常处理程序处理。</p><h3 id="中断的响应和处理">2.2.2 中断的响应和处理</h3><p>在指令执行周期最后增加一个检查中断的微操作以响应中断。</p><p>中断系统是响应和处理中断的系统，包括硬件(响应)和软件(处理)子系统两部分</p><p>中断装置是计算机系统中发现并响应中断/异常的硬件装置。</p><ul><li><p>外中断；中断控制器发现和响应</p></li><li><p>异常：由指令的控制逻辑和实现线路发现和响应，Trap机制</p></li></ul><h4 id="中断控制器">中断控制器</h4><p>CPU的一个控制部件，包括中断控制逻辑线路、中断寄存器</p><ol type="1"><li>外部设备向其发出中断请求，在中断寄存器中设置已发生的中断</li><li>指令处理结束前，检查中断寄存器，若有不被屏蔽的中断产生，则改变处理器内操作顺序，引出操作系统中的中断处理程序</li></ol><h4 id="中断响应的一般过程">中断响应的一般过程</h4><ol type="1"><li>发现中断源：发现中断寄存器中中断，根据优先级决定是否响应</li><li>保护现场：将当前程序的PSW/PC保存至核心栈</li><li>处理中断</li><li>恢复现场</li></ol><h4 id="不同中断源的处理原则">不同中断源的处理原则</h4><ol type="1"><li>硬件故障中断：由处理器、内存储器、总线等硬件故障引起</li></ol><p>保护现场，停止设备，停止中央处理器，报告操作员，等待人工干预</p><ol start="2" type="1"><li>程序性中断：处理器执行机器指令引起</li></ol><p>算术异常—简单处理，报告用户；也可由用户编写中断续元程序处理</p><p>非法指令、用户态使用特权指令、地址越界、非法存取等指令异常：终止进程</p><p>虚拟地址异常：调整内存后重新执行指令</p><ol start="3" type="1"><li>访管/自愿性中断：由系统调用引起</li></ol><p>保护现场，跳转具体处理程序</p><ol start="4" type="1"><li>输入/输出中断：外围设备报告输入/输出状态<ul><li>输入/输出完成：调整进程状态，释放等待进程</li><li>出错：等待人工干预</li></ul></li><li>外部中断：外围设备发出的信号引起<ul><li>时钟中断、间隔时钟中断：记时和时间片处理</li><li>设备报到与结束中断：调整设备表</li><li>键盘/鼠标信号中断：根据信号相应反应</li><li>关机/重启中断：写回文件，停止设备和中央处理器</li></ul></li></ol><h3 id="多中断的响应和处理">2.2.3 多中断的响应和处理</h3><p>中断优先级：中断装置预设的对不同中断的响应顺序</p><p>中断屏蔽：高级中断事件屏蔽低级中断源（中断屏蔽位）</p><p>中断嵌套：高级中断嵌套在低级中断中，嵌套层数不宜太多。</p><h2 id="进程">2.3 进程</h2><h3 id="进程-1">2.3.1 进程</h3><p>进程是操作系统进行资源分配和调度的基本单位。</p><p>进程的概念：具有一定独立功能的程序关于某个数据集合的一次运行活动。</p><p>包括五个实体部分：</p><ol type="1"><li>操作系统管理运行程序的数据结构P</li><li>程序的内存代码C</li><li>程序的内存数据D</li><li>程序的通用寄存器信息R</li><li>操作系统控制程序执行的程序状态字PSW</li></ol><h4 id="三态模型">三态模型</h4><ul><li>就绪态：进程具有运行条件等待处理器运行</li><li>等待态：进程由于等待资源、输入输出、信号等而不具备运行条件</li><li>运行态：进程占有处理器运行</li></ul><ol type="1"><li>就绪态—&gt;运行态：处理器空闲时选择、优先进程抢占</li><li>运行态—&gt;等待态：等待资源、输入输出、信号</li><li>等待态—&gt;就绪态：资源满足、输入输出结束、信号完成</li><li>运行态—&gt;就绪态：运行时间片到、优先进程抢占</li></ol><p>此外，也有短暂的新建态和结束态，但并不属于三态模型的循环中。</p><h4 id="进程挂起">进程挂起</h4><ol type="1"><li>操作系统无法预期进程的数目和资源需求，系统运行过程中可能资源不足</li><li>运行资源不足将导致低性能与死锁</li><li>解决办法：剥夺某些进程的内存及其他资源，调入操作系统管理对换区，不参加进程调度，等合适时机调入内存、恢复资源、参与运行<ul><li>等待态占有已申请的资源，而挂起态不具有任何资源。</li></ul></li></ol><p>进程挂起和恢复的过程：</p><ol type="1"><li>一般使等待态进程进入挂起等待态，也可使就绪态进程进入挂起就绪态</li><li>运行态进程可以挂起自己进入挂起就绪态</li><li>等待事件结束后，挂起等待态进入挂起就绪态</li><li>一般恢复挂起就绪态进程为就绪态进程，也可恢复挂起等待态为等待态</li></ol><h3 id="进程的数据描述">2.3.2 进程的数据描述</h3><h4 id="进程映像">进程映像</h4><p>某时刻进程的内容及其状态集合，包括</p><ol type="1"><li>进程控制块 (Process Control Block，PCB)</li><li>进程程序块：被进程执行的程序，规定进程运行所应完成的功能</li><li>进程数据块：进程的私有地址空间，存放各种私有数据，用户栈也在数据块中，用于在函数调用时存放栈帧、局部变量和返回地址等</li><li>进程核心栈：进程在内核态工作时使用，用于保存中断现场，以及函数调用参数、局部变量和返回地址等</li></ol><h4 id="进程上下文">进程上下文</h4><p>进程物理实体和支持进程运行的环境，由三部分组成</p><ol type="1"><li>用户级上下文：程序块、数据块、共享内存区、用户栈</li><li>寄存器上下文：处理器状态寄存器、程序计数器、栈指针、通用寄存器</li><li>系统级上下文：进程控制块、内存管理信息、核心栈等操作系统管理进程所需信息</li></ol><p>当系统调度新进程占有处理器，新老进程随之发生上下文切换。</p><h4 id="进程控制块">进程控制块</h4><p>进程创建时建立进程控制块，进程销毁时回收进程控制块，与进程一一对应。</p><p>操作系统根据进程控制块对进程进行控制和管理。</p><p>进程控制块是操作系统记录和刻画进程状态及环境信息的数据结构，包含：</p><ol type="1"><li><p>标识信息：唯一地标识一个进程</p></li><li><p>现场信息：通用、控制寄存器内容、核心与用户栈指针、程序状态字等</p></li><li><p>控制信息：用于管理和调度进程</p></li><li><p>进程调度相关信息：进程状态、等待事件及原因、优先级、队列指针等</p></li><li><p>进程组成信息：代码、数据地址，进程映像在外存的地址</p></li><li><p>进程队列指引元：进程队列指针、父子进程指针</p></li><li><p>进程通信相关信息：消息队列、信号量、锁</p></li><li><p>进程处理器使用信息：占用的处理器、时间片、处理器使用时间</p></li><li><p>进程特权信息：内存访问权限、处理器特权</p></li><li><p>进程资源清单：正占有的资源、已使用的资源</p></li></ol><h3 id="进程管理">2.3.3 进程管理</h3><p>关键进程管理软件包括：</p><ol type="1"><li>系统调用/中断/异常处理</li><li>队列管理</li><li>进程控制</li><li>进程调度</li><li>进程通信</li><li>终端登录与作业控制、性能监控、审计程序等外围程序</li></ol><h4 id="进程队列">进程队列</h4><p>将处于同一状态的所有进程的PCB链接在一起的数据结构。</p><p>不同状态的进程可以排列成运行、就绪或等待队列，组织方式有：</p><ol type="1"><li>链接方式</li></ol><p>通过PCB的链接指针将同一状态进程的PCB链接，可采用单/双链表</p><ol start="2" type="1"><li>索引方式</li></ol><p>建立索引表，存放PCB地址或在PCB表中的编号</p><p>队列管理模块是操作系统实现进程管理的核心模块，进程与资源调度围绕进程队列展开。</p><h4 id="进程管理原语">进程管理原语</h4><p>操作系统通过原语来完成进程管理。常见的进程管理原语有：</p><ol type="1"><li>进程创建：在进程列表添加新进程，申请PCB并完成初始化</li><li>进程撤销：从队列中移除，归还资源，回收PCB，移除进程表项</li><li>进程阻塞：保存现场信息，修改PCB，移入等待队列，调度其他进程执行</li><li>进程唤醒：修改PCB，从等待队列移入就绪队列</li><li>进程挂起：修改状态，出入相关队列，收回资源</li><li>进程激活：修改状态，出入相关队列，分配内存</li><li>其他，如修改进程特权</li></ol><h4 id="处理器状态模式切换">处理器状态（模式）切换</h4><p>处理器状态从用户态到内核态，或从内核态到用户态</p><p>当发生中断或系统调用，处理器状态从用户态到内核态切换过程：</p><ol type="1"><li>保存被中断进程的处理器现场信息</li><li>处理器从用户态转换到内核态</li><li>处理中断或进行系统调用</li></ol><p>此时进程仍在自己的上下文中执行，仅处理器状态发生变化。</p><h4 id="进程切换">进程切换</h4><p>收回运行中进程占用的处理器，让待运行进程执行</p><p>实质上，进程切换就是进程上下文的切换：</p><ol type="1"><li>保存被中断进程的上下文</li><li>进程调度(队列管理)</li><li>恢复待运行进程的上下文</li></ol><p>进程切换的发生时机：一定发生在中断处理过程，也就是在内核态中。</p><p>P：可再入程序是能够被多个程序同时调用的程序，它是纯代码的。</p><h2 id="线程">2.4 线程</h2><h3 id="多线程环境">2.4.1 多线程环境</h3><h4id="单线程结构在并发程序设计上的问题">单线程结构在并发程序设计上的问题</h4><ul><li>进程切换、通信开销大</li><li>进程并发粒度受限，并行计算效率低</li></ul><p>解决办法：进程分配资源，线程调度执行。</p><h4 id="多线程">多线程</h4><p>在多线程环境中，进程是操作系统中进行资源分配与保护的独立单位，具有：</p><ul><li><p>容纳进程映像的虚拟地址空间</p></li><li><p>对进程、文件和设备的存取保护机制</p></li></ul><p>线程是进程的一条执行路径，是调度的基本单位。</p><p>同一个进程中所有线程共享进程获得的主存空间和资源，具有：</p><ul><li>线程唯一标识符和其状态</li><li>受保护的线程上下文</li><li>独立的程序计数器</li><li>执行堆栈</li><li>容纳局部变量的静态存储器</li></ul><p>线程的状态：运行(Active)、就绪(Runnable)和睡眠(Sleeping)</p><p>线程状态变化的相关操作：孵化、封锁、活化、剥夺、指派、结束</p><p>线程的调度：</p><ol type="1"><li><p>操作系统感知线程环境：</p></li><li><p>处理器调度线程</p></li><li><p>进程只有挂起状态</p></li><li><p>操作系统不感知线程环境：</p></li><li><p>处理器调度进程</p></li><li><p>用户空间中的用户调度程序调度线程</p></li></ol><h4 id="并发多线程程序设计的优点">并发多线程程序设计的优点</h4><ol type="1"><li>快速线程切换</li><li>减少系统管理开销</li><li>线程通信易于实现</li><li>并行程度提高</li><li>节省内存空间</li></ol><h3 id="多线程的实现">2.4.2 多线程的实现</h3><h4 id="内核级线程kltkernel-level-thread">内核级线程（KLT，Kernel-levelThread）</h4><ol type="1"><li>线程管理的所有工作交由操作系统内核</li><li>操作系统提供了使用KLT的程序设计接口</li><li>操作系统直接调度KLT</li></ol><p>内核级线程的特点：</p><ol type="1"><li>进程的一个线程阻塞，内核能调度同一进程的其他线程运行</li><li>多处理器环境中，内核能同时调度同一进程的多个线程并行执行</li><li>内核自身也可用多线程技术实现，提高操作系统执行速度和效率</li><li>应用程序线程在用户态而线程调度在内核态，因而线程切换需要模式切换，系统开销大</li></ol><h4 id="用户级线程ultuser-level-thread">用户级线程（ULT，User-levelThread）</h4><ol type="1"><li>用户空间运行的线程库提供多线程应用程序的开发和运行环境</li><li>任何应用程序需通过线程库进行程序设计，与线程库连接后运行</li><li>线程管理的所有工作由应用程序完成，内核不知线程的存在</li></ol><p>用户级线程的特点</p><ol type="1"><li>线程切换不需要模式切换，系统开销小</li><li>允许进程按特定需要选择调度算法</li><li>能运行在任何操作系统上</li><li>不能利用多处理器，操作系统调度进程，只有一个ULT能执行</li><li>一个ULT的阻塞将引起整个进程的阻塞</li></ol><h4 id="jacketing技术">Jacketing技术</h4><p>将阻塞式操作系统改造为非阻塞的。</p><p>当线程陷入系统调用，执行Jacketing程序，检查资源使用，决定是否进行进程切换或线程切换。</p><h4 id="混合式线程">混合式线程</h4><p>在用户空间进行线程创建、调度与同步，单应用多个ULT可映射成一些KLT。</p><p>混合式线程的特点：</p><ol type="1"><li>组合用户级线程/内核级线程设施</li><li>程序员可针对特定应用和机器调节内核级线程数目以达更好效果</li><li>结合了纯粹用户级、内核级线程优点，减少其缺点</li></ol><figure><img src="/image/计算机操作系统/混合式线程调用.png"alt="混合式线程调用" /><figcaption aria-hidden="true">混合式线程调用</figcaption></figure><h2 id="处理器调度">2.5 处理器调度</h2><h3 id="处理器调度的层次">2.5.1 处理器调度的层次</h3><ul><li><p>高级调度，又称长程调度，作业调度，决定能否加入执行的进程池中</p><p>分时操作系统中，高级调度决定：</p><ul><li>是否接受终端用户连接</li><li>命令是否被系统接纳并构成进程</li><li>新建的进程是否加入就绪进程队列</li></ul><p>批处理操作系统中，高级调度又称为作业调度，按某种原则从后备作业队列中选取作业进入主存，并为作业做好运行前的准备和完成后的完善。</p></li><li><p>中级调度，又称平衡负载调度，决定主存中的可用进程集合</p><ul><li>提高内存利用率和作业吞吐量。</li><li>决定哪些进程被允许驻留在主存中参与竞争处理器及其他资源，起到短期调整系统负荷的作用。（将一些进程挂起）</li></ul></li><li><p>低级调度，又称短程调度，进程调度，决定哪个进程占用处理器执行</p><ul><li>按某种原则将处理器分配给就绪态进程或内核级线程。</li></ul></li></ul><p>进程调度程序，又称分派程序，是操作系统中实现处理器调度的程序。</p><figure><img src="/image/计算机操作系统/处理器调度.png" alt="处理器调度" /><figcaption aria-hidden="true">处理器调度</figcaption></figure><h3 id="处理器调度算法">2.5.2 处理器调度算法</h3><h4 id="选择处理器调度算法的原则">选择处理器调度算法的原则</h4><ol type="1"><li>资源利用率</li><li>响应时间：尽快处理实时任务</li><li>周转时间：提交给系统开始到执行完成获得结果为止的时间</li><li>吞吐量：单位时间处理的进程数</li><li>公平性：每个用户每个进程获得合理的资源份额</li></ol><h4 id="优先数调度算法">优先数调度算法</h4><p>根据分配给进程的优先数决定运行进程，分为抢占式和非抢占式</p><p>优先数的确定准则：</p><ul><li>任务的紧迫程度</li><li>交互性</li><li>使用外设的频度</li><li>进入系统时间长短</li></ul><p>一些优先数选择：</p><ul><li>计算时间短优先</li><li>剩余时间短优先</li><li>响应比(等待时间/进入时间)高优先</li><li>先来先服务FCFS：先进队先选择 (多用于高级调度)</li></ul><h4 id="时间片轮转调度算法">时间片轮转调度算法</h4><ul><li>根据各个进程进入就绪队列的顺序轮流占有CPU一个时间片</li></ul><p>时间片的确定：适中，过长则为FCFS，过短则开销大</p><p>分为单时间片、多时间片和动态时间片</p><h4 id="分级调度算法">分级调度算法</h4><ul><li>又称多队列策略，反馈循环队列</li></ul><p>基本思想：</p><ol type="1"><li>建立多个不同优先级的就绪进程队列</li><li>多个就绪进程队列间按照优先数调度</li><li>高优先级就绪进程分配的时间片短</li><li>单个就绪进程队列中进程的优先数和时间片相同</li></ol><h4 id="随机调度算法">随机调度算法</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;长风破浪会有时，直挂云帆济沧海！&lt;/p&gt;</summary>
    
    
    
    <category term="计算机操作系统" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机操作系统-第一章_概述</title>
    <link href="http://example.com/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2023-05-01T04:00:00.000Z</published>
    <updated>2023-06-20T08:44:03.872Z</updated>
    
    <content type="html"><![CDATA[<p>长风破浪会有时，直挂云帆济沧海！</p><span id="more"></span><h1 id="第一章-计算机操作系统概述">第一章 计算机操作系统概述</h1><h2 id="计算机系统">1.1 计算机系统</h2><h3 id="计算机系统概述">1.1.1 计算机系统概述</h3><p>电子数字计算机：能够自行按照已设定的程序进行数据处理的电子设备。</p><h4 id="计算机发展历史">计算机发展历史</h4><ul><li><p>1945～：电子真空管、机器语言，应用于科学计算</p></li><li><p>1956～：晶体管、批处理控制、Fortran/COBOL，扩展到数据处理</p></li><li><p>1959～：集成电路、多道程序、操作系统/数据库/高级语言</p></li><li><p>1976～：大规模集成电路，向快速化、小型化、系统化、网络化、智能化发展</p></li><li><p>1980～：微机出现</p></li><li><p>1990～：图形化人机交互</p></li><li><p>2003～：移动计算</p></li></ul><h4 id="计算机系统组成">计算机系统组成</h4><p>包括硬件子系统和软件子系统</p><ul><li><p>硬件：借助电、磁、光、机械等原理构成的各种物理部件的有机组合</p></li><li><p>软件：各种程序和文件，包括系统软件、支撑软件和应用软件</p><ul><li>关键系统软件：操作系统和语言处理程序</li></ul></li></ul><h4 id="计算机系统视图">计算机系统视图</h4><ul><li><p>用户视图：应用、语言处理、操作系统、计算机硬件</p></li><li><p>应用程序员视图：语言处理、操作系统、计算机硬件</p></li><li><p>语言处理程序设计者视图：操作系统、计算机硬件</p></li><li><p>操作系统设计者视图：计算机硬件</p></li></ul><h3 id="计算机硬件系统">1.1.2 计算机硬件系统</h3><h4 id="一计算机硬件系统的组成">一、计算机硬件系统的组成</h4><ol type="1"><li>中央处理器：运算单元、控制单元</li><li>主存储器</li><li>外围设备：输入/输出设备、存储设备、网络通信设备</li><li>总线</li></ol><h4 id="二冯氏计算机存储程序计算机">二、冯氏计算机：存储程序计算机</h4><p>冯·诺伊曼等人在1946年总结提出，称为冯·诺伊曼计算机模型</p><ol type="1"><li>以运算单元为中心，控制流由指令流产生</li><li>采用存储程序原理，面向主存组织数据流</li><li>主存是按地址访问、线性编址的空间</li><li>指令由操作码和地址码组成</li><li>数据以二进制编码</li></ol><h4 id="三总线">三、总线</h4><p>总线是计算机各种功能部件之间传送信息的公共通信干线，是CPU、内存、输入输出设备传递信息的公用通道。</p><p>计算机各个部件通过总线相连接，外围设备通过相应的接口电路与总线相连接，形成了计算机硬件系统。</p><p>总线的组成：一组控制线、一组数据线、一组地址线</p><p>总线的类型：</p><ol type="1"><li>内部总线：用于CPU芯片内部连接各元件</li><li>系统总线：用于连接CPU、存储器和各种输入/输出模块等主要部件</li><li>通信总线：用于计算机系统间通信</li></ol><p>片上系统 (SoC: System on a Chip)</p><p>在单个芯片上集成一个完整的系统(包括中央处理器、存储器以及外围电路等)，对所有或部分必要的电子电路进行包分组的技术。</p><p>SoC是与其他技术(如绝缘硅，提高增强时钟频率，降低功耗)并行发展的。</p><h4 id="四中央处理器">四、中央处理器</h4><p>中央处理器是计算机的运算核心和控制单元，主要包括：</p><ol type="1"><li>运算逻辑部件：一个或多个运算器</li><li>寄存器部件：包括通用寄存器、控制与状态寄存器、高速缓冲存储器</li><li>控制部件：实现各部件之间联系的数据、控制与状态内部总线；指令译码、控制指令执行、实现数据传输等功能的部件</li></ol><figure><img src="/image/计算机操作系统/中央处理器.png" alt="中央处理器" /><figcaption aria-hidden="true">中央处理器</figcaption></figure><p>存储器组织层次：越往下，容量越大、速度越慢、价格越低</p><p>L0：寄存器</p><p>L1：L1 Cache</p><p>L2：L2 Cache</p><p>L3：L3 Cache</p><p>L4：主存</p><p>L5：本地固态硬盘</p><p>L6：本地硬盘</p><p>外围设备：输入/输出设备、存储设备、通信设备</p><p>输入/输出控制方式：</p><ol type="1"><li>轮询：CPU忙式控制输入/输出，执行内存数据交换</li><li>中断：CPU启动输入/输出设备，设备中断CPU</li><li>DMA方式：CPU启动DMA，DMA独立进行输入/输出和内存数据交换，DMA中断CPU</li></ol><h3 id="计算机软件系统">1.1.3 计算机软件系统</h3><h4 id="一计算机软件系统的组成">一、计算机软件系统的组成</h4><ol type="1"><li>系统软件</li></ol><p>操作系统、实用程序、语言处理程序、数据库管理系统</p><ol start="2" type="1"><li>支撑软件</li></ol><p>接口软件、工具软件、环境数据库，也可认为是系统软件的一部分</p><ol start="3" type="1"><li>应用软件</li></ol><p>用户按其需要自行编写的专用程序</p><h4 id="二程序员的计算机系统视图">二、程序员的计算机系统视图</h4><ol type="1"><li>机器语言：计算机硬件系统</li><li>机器指令：操作系统和实用程序</li><li>数据库语言：数据库管理系统</li><li>高级语言：支撑软件</li><li>更高：支撑软件</li></ol><p>软件开发的不同层次</p><ol type="1"><li>计算机硬件系统：机器语言</li><li>操作系统资源管理：机器语言+广义指令</li><li>操作系统文件系统：机器语言+系统调用</li><li>数据库管理系统：数据库语言</li><li>语言处理程序：面向问题的语言</li></ol><h4 id="三计算机程序的执行过程">三、计算机程序的执行过程</h4><figure><img src="/image/计算机操作系统/计算机程序执行过程.png"alt="计算机程序执行过程" /><figcaption aria-hidden="true">计算机程序执行过程</figcaption></figure><h2 id="计算机操作技术">1.2 计算机操作技术</h2><h3 id="计算机操作技术的发展">1.2.1 计算机操作技术的发展</h3><h4 id="操作平台与操作系统">1. 操作平台与操作系统：</h4><p>任何一台机器都有其操作平台与操作系统，操作平台的精细化和系统化，产生了操作系统。</p><h4 id="计算机人工操作">2. 计算机人工操作</h4><p>计算机手工操作的问题：手工操作速度和电子计算速度不匹配</p><p>装入程序的引进：</p><ol type="1"><li>引入卡片和打孔纸带描述程序指令和数据</li><li>装入程序：自动化执行程序装入，必要时进行地址切换，存放在ROM中</li></ol><p>外存储设备变迁：过去的磁带与软盘，使用逐渐减少的光盘</p><p>计算机控制</p><p>汇编语言：先将汇编语言程序编译为可执行程序，再由计算机执行</p><p>高级语言：高级语言程序编译为目标代码，后编译成可执行程序，再执行</p><h4 id="简单批处理系统的操作方式">3. 简单批处理系统的操作方式</h4><p>简单批处理系统的操作控制：</p><p>引入作业控制语言，用户编写作业说明书，描述对一次计算机作业的控制。</p><p>操作员控制计算机成批输入作业，成批执行作业。</p><p>这一方式缩短了手工操作时间，提高了计算机系统的使用效率。</p><p>进展：</p><ol type="1"><li>出现了初步的资源管理程序，屏蔽了硬件处理细节</li><li>输入/输出中断出现，实现CPU与输入/输出设备并行</li><li>磁带出现，磁盘文件系统形成，但输入/输出效率还是不支持多道程序</li></ol><h4 id="操作系统与自动化操作方式">4. 操作系统与自动化操作方式</h4><p>操作系统与自动化操作控制：</p><ol type="1"><li>电子计算速度与机械输入/输出速度的矛盾</li><li>程序执行过程中输入作业，重叠时间</li></ol><p>需要多道程序同时执行，程序切换需要高速外存储设备</p><ol start="3" type="1"><li>磁盘设备出现，于是有了计算机操作系统，实现自动化控制</li></ol><h3 id="计算机操作系统">1.2.2 计算机操作系统</h3><h4 id="操作系统基本概念">1. 操作系统基本概念</h4><p>操作系统是计算机系统最基础的系统软件，管理软硬件资源、控制程序执行、改善人机界面，合理组织计算机工作流程，为用户使用计算机提供良好运行环境。</p><h4 id="操作系统组成">2. 操作系统组成</h4><ol type="1"><li>进程调度子系统</li><li>进程通信子系统</li><li>内存管理子系统</li><li>设备管理子系统</li><li>文件管理子系统</li><li>网络通信子系统</li><li>作业控制子系统</li></ol><h4 id="操作系统分类">3. 操作系统分类</h4><p>从操作方式看：</p><ol type="1"><li>多道批处理操作系统，脱机控制方式</li><li>分时操作系统，交互式操作系统</li><li>实时操作系统</li></ol><p>按应用领域分类：</p><p>服务器操作系统、并行操作系统、网络操作系统、分布式操作系统、个人机操作系统、手机操作系统、嵌入式操作系统、传感器操作系统</p><p>普适计算 Pervasive/Ubiquitous Computing</p><p>物联网 Things of Internet, CPS</p><p>移动计算 Mobile Computing (移动互联网)</p><p>嵌入式的操作系统: μC/OS-II, VxWorks, LiteOS, 翼辉SylixOS......</p><p>移动终端的操作系统： Android, iOS, 鸿蒙OS......</p><p>PC的OS: 微软的桌面系统</p><p>服务器的OS: CentOS, Ubuntu等Linux各类发行版, EulerOS, ...</p><h2 id="操作系统的不同视角">1.3 操作系统的不同视角</h2><h3 id="资源管理的视角">1.3.1 资源管理的视角</h3><h4 id="计算机系统的资源">计算机系统的资源</h4><ul><li>硬件资源：处理器、内存、外设</li><li>信息资源：数据、程序</li></ul><h4 id="软硬件资源管理">软硬件资源管理</h4><ul><li>处理器资源：占有处理器运行的程序</li><li>内存资源：程序、数据在内存中的分布</li><li>设备资源：分配、去配和使用资源</li><li>信息资源管理：访问文件信息</li><li>信号量资源：管理进程间通信</li></ul><h4 id="屏蔽资源使用的底层细节">屏蔽资源使用的底层细节</h4><p>驱动程序：最底层的、直接控制和监视各类硬件资源的地方</p><ul><li>隐藏底层硬件的具体细节，为其他部分提供抽象、具体的接口</li></ul><h4 id="资源的共享独占与并发">资源的共享：独占与并发</h4><p>资源的分配：</p><ul><li>静态分配：进程运行前一次拿到所有全部独占资源</li><li>动态分配：使用资源前临时申请</li></ul><p>可能产生竞争资源的死锁。</p><p>资源抢占方式：被抢占资源的进程需要回滚执行</p><h3 id="控制程序执行的视角">1.3.2 控制程序执行的视角</h3><p>由于中央处理器速度和输入/输出速度不匹配的矛盾，只有让多道程序同时进入内存争抢中央处理器运行，才可以使中央处理器与外围设备充分并行，提高计算机系统使用效率。</p><h4 id="多道程序设计">多道程序设计</h4><p>让多个程序同时进入计算机主存储器进行计算。</p><p>特点：</p><ol type="1"><li>中央处理器与外部设备充分并行</li><li>外部设备间充分并行</li><li>发挥中央处理器使用效率</li><li>提高单位时间算题量</li><li>单道程序的运算时间会增加</li></ol><p>多道程序系统的实现：</p><ol type="1"><li>为进入内存执行的程序建立管理实体：进程</li><li>操作系统管理和控制进程程序的执行</li><li>操作系统协调管理各类资源在进程间使用</li></ol><ul><li>处理器的管理与调度</li><li>主存储器的管理与调度</li><li>其他资源的管理与调度</li></ul><p>实现要点：</p><ol type="1"><li>如何使用资源：调用操作系统提供的服务例程</li><li>如何复用中央处理器：调度程序，让其他程序在中央处理器空闲时运行</li><li>如何使中央处理器和输入/输出设备充分并行：设备控制器和通道</li><li>如何让正在运行的程序让出中央处理器：中断</li></ol><h3 id="操作控制计算机的视角">1.3.3 操作控制计算机的视角</h3><ol type="1"><li>计算机操作控制方式</li><li>脱机作业控制方式</li><li>联机作业控制方式</li><li>命令解释程序及其处理过程</li></ol><h4 id="计算机系统操作方式">计算机系统操作方式</h4><ol type="1"><li>操作系统规定了合理操作计算机的工作流程</li><li>操作系统的操作接口：系统程序</li><li>两类作业级接口：</li></ol><p>脱机作业控制方式、联机作业控制方式</p><h4 id="脱机作业控制方式">脱机作业控制方式</h4><p>例：shell程序</p><ul><li>操作系统：提供作业说明语言</li><li>用户：编写作业说明书，确定作业加工控制步骤，并与程序数据一起提交</li><li>操作员：通过控制台输入作业</li><li>操作系统：通过作业控制程序自动控制作业的执行</li></ul><h4 id="联机作业控制方式">联机作业控制方式</h4><p>例：分时操作系统的交互控制方式</p><ul><li>计算机：提供终端 (键盘、显示器)</li><li>用户：登录系统</li><li>操作系统：提供命令解释程序</li><li>用户：联机输入操作控制命令，直接控制作业的执行</li></ul><h4 id="命令解释程序">命令解释程序</h4><p>接受和执行一条用户提出的对作业的加工处理命令</p><ul><li>会话语言：可编程的命令解释语言</li><li>图形化的命令控制方式</li><li>多通道交互的命令控制方式</li></ul><p>处理过程：</p><ol type="1"><li>操作系统启动命令解释程序，输出命令提示符，等待键盘中断、鼠标点击、多通道识别</li><li>每当用户输入命令并按回车换行，将命令暂存在命令缓冲区后，申请中断</li><li>中央处理器响应后，将控制权交给命令解释器程序，读入命令缓冲区内容，分析命令、接受参数，执行处理代码</li></ol><p>前台命令和后台命令</p><ul><li><p>前台命令执行结束后，再次输出命令提示符，等待下一条命令</p></li><li><p>后台命令处理启动后，即可接收下一条命令</p></li></ul><h3 id="人机交互的视角">1.3.4 人机交互的视角</h3><h4 id="操作系统的人机交互部分">操作系统的人机交互部分</h4><ol type="1"><li>操作系统改善人机界面，为用户使用计算机提供良好的环境</li><li>人机交互设备包括传统终端设备和新型模式识别设备</li><li>人机交互部分用于控制有关设备运行、理解执行设备传来命令</li><li>人机交互功能决定了计算机系统的友善性</li></ol><h4 id="人机交互的发展">人机交互的发展</h4><p>交互式控制方式：</p><ul><li><p>行命令控制方式：1960年代开始使用</p></li><li><p>全屏幕控制方式：1970年代开始使用</p></li></ul><p>人，而不是技术，是人机交互的中心——&gt;鼠标、菜单、窗口控制</p><h4 id="wimp界面">WIMP界面</h4><p>窗口(Window)、图标(Icon)、菜单(Menu)、指示装置(Pointing Devices)</p><ul><li><p>1990年代开始广泛使用。</p></li><li><p>不足：不能同时使用多个交互通道，产生人机交互的不平衡。</p></li></ul><h4 id="多媒体计算机">多媒体计算机</h4><p>将音频视频、图形图像和人机交互控制结合，进行综合处理</p><h4 id="虚拟现实系统">虚拟现实系统</h4><p>例：VR</p><h3 id="程序接口的视角">1.3.5 程序接口的视角</h3><h4 id="操作系统的程序接口">操作系统的程序接口</h4><p>操作系统为程序运行扩充的编程接口。</p><p>系统调用：操作系统实现的完成某种特定功能的过程</p><p>POSIX支持</p><h4 id="系统调用的实现机制">系统调用的实现机制</h4><p>中断。</p><p>系统调用的实现要点：</p><ol type="1"><li>编写系统调用处理程序</li><li>系统调用入口地址表</li><li>系统调用时，需保存当时的处理器情况</li></ol><h4 id="系统调用的实现流程">系统调用的实现流程</h4><figure><img src="/image/计算机操作系统/系统调用的实现流程.png"alt="系统调用的实现流程" /><figcaption aria-hidden="true">系统调用的实现流程</figcaption></figure><h3 id="系统结构的视角">1.3.6 系统结构的视角</h3><p>操作系统是计算机软件发展史上第一个大规模软件系统。</p><h4 id="操作系统软件的结构设计">操作系统软件的结构设计</h4><ul><li>操作系统构件：内核、进程、线程、管程等</li><li>设计概念：模块化、层次化、虚拟化</li><li>内核设计是操作系统设计中最为复杂的部分</li></ul><h4 id="操作系统内核">操作系统内核</h4><ul><li>单内核：内核中各部件杂然混居</li><li>微内核：结构性部件与功能性部件分离</li><li>混合内核：微内核和单内核的折中，较多组件在核心态中运行以更快执行</li><li>外内核：减少内核的软件抽象化和传统微内核的消息传递机制，使得开发者专注于硬件的抽象化</li></ul><h4id="操作系统实现的一种层次式结构">操作系统实现的一种层次式结构：</h4><ul><li><p>用户模式：用户与文件系统</p></li><li><p>内核模式：进程交互、输入/输出设备管理、虚拟内存、基本进程管理、硬件</p></li></ul><p>另一种层次式结构：</p><ol type="1"><li>用户：命令、进程、库、环境</li><li>文件系统调用：用户进程管理、目录管理、设备文件、文件系统、管道等高阶通信</li><li>软硬件协同内核：内存与虚拟内存管理、块设备管理与输入/输出控制、核心进程管理和控制与通信原语、中断管理</li><li>硬件电路：过程机制、指令解译、电路执行</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;长风破浪会有时，直挂云帆济沧海！&lt;/p&gt;</summary>
    
    
    
    <category term="计算机操作系统" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>软工2-三-软件需求</title>
    <link href="http://example.com/2023/04/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%B8%89-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/"/>
    <id>http://example.com/2023/04/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%B8%89-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/</id>
    <published>2023-04-03T07:00:00.000Z</published>
    <updated>2023-06-17T08:28:25.733Z</updated>
    
    <content type="html"><![CDATA[<p>单纯的软件系统是不能解决问题的，只有和现实世界之间形成有效互动才能实现问题的解决。</p><span id="more"></span><h1 id="第三部分-软件需求">第三部分 软件需求</h1><h2 id="一需求工程">一、需求工程</h2><h3 id="需求工程的概念">需求工程的概念</h3><p>所有需求处理活动的总和。它收集信息、分析问题、整合观点、记录需求并验证其正确性，最终描述出软件被应用后与其环境互动形成的期望效应。</p><p>三个主要任务：</p><ul><li><p>需求工程必须说明软件系统将被应用的应用环境及其目标，说明用来达成这些目标的软件行动（为什么、做什么）</p></li><li><p>需求工程必须将目标和功能反映到软件系统中，映射为可行的软件行为，并对软件行为进行准确的规格说明</p></li><li><p>现实世界是不断变化的世界，因此需求工程还需要妥善处理目标和功能随着时间演化的变动情况</p></li></ul><h3 id="需求工程的活动">需求工程的活动</h3><ul><li>需求开发<ul><li>需求获取</li><li>需求分析</li><li>需求规格说明</li><li>需求验证</li></ul></li><li>需求管理</li></ul><h4 id="需求获取">1. 需求获取</h4><p>从人、文档或者环境中利用各种方法和技术获取需求</p><ul><li>目标分析：根据问题确定目标、分析利害关系人确定目标</li><li>常见困难：用户与开发人员的认知差异</li><li>获取方法：面谈、问卷、文档分析、头脑风暴、专题讨论、原型</li></ul><h4 id="需求分析">2. 需求分析</h4><ol type="1"><li>通过建模整合各种信息</li><li>为问题定义出一个需求集合，该集合能界定一个问题的解决方案</li><li>检查需求中的错漏，加以修正</li></ol><h5 id="边界分析">(1) 边界分析</h5><ol type="1"><li>定义项目的范围</li><li>系统边界的定义要保证系统能和周围环境形成有效互动</li><li>系统用例图常被用于定义系统边界</li></ol><h5 id="需求建模">(2) 需求建模</h5><p>为展现和解释信息而进行的抽象描述活动</p><ul><li>常用类图、顺序图、状态图</li></ul><h4 id="需求规格说明">3. 需求规格说明</h4><p>在系统用户间交流需求信息</p><ul><li><p>要简洁、精确、一致和易于理解</p></li><li><p>需求工程师在该阶段的重要工作：定制文档模版、编写文档</p></li></ul><h4 id="需求验证">4. 需求验证</h4><p>需求规格说明文档的要求：</p><ol type="1"><li>每条需求都正确、准确地反映了用户意图</li><li>需求集在整体上具有整体性和一致性</li><li>文档的组织方式和需求的书写方式具有可读性和可修改性</li></ol><p>验证的方法：同级评审、原型、模拟</p><h3 id="需求管理">需求管理</h3><ol type="1"><li>保证需求作用的持续、稳定和有效发挥<ul><li>在需求开发活动后，设计、测试、实现等后续的软件系统开发活动都需要以围绕需求开展工作</li></ul></li><li>进行变更控制<ul><li>纳入实现合理的变更需求、拒绝不合理变更需求，控制变更成本和影响范围</li></ul></li></ol><h2 id="二需求基础">二、需求基础</h2><h3 id="需求的定义">需求的定义</h3><ul><li>用户为了解决问题或达到某种目标所需要的条件或能力</li><li>系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力</li><li>对上述中的一个条件或一种能力的一种文档化表述</li></ul><p>需求是一种解决问题后所能达到的期望。</p><p>问题域：</p><ul><li>现实世界运行规律的一种反映</li><li>需求的产生地与解决地</li><li>最终的软件产品要在现实中部署，它能够部分影响问题域，但不能任意改变现实<ul><li>软件开发必须尊重问题域，不能因为技术原因妄自修改现实情况</li></ul></li></ul><p>问题的解决：</p><ul><li>基础：模拟与共享现象</li><li>方法：直接、间接</li><li>解决方案：需求规格说明</li></ul><h3 id="需求开发的目标">需求开发的目标</h3><p>将现实世界问题域描述转化为计算世界的规格说明。</p><p>规格说明：软件产品的方案描述，以软件产品的运行机制为主要内容。</p><ul><li>关注对外交互的方式描述软件解决方案</li></ul><p>需求层次性</p><ul><li><p>业务需求：系统具备的特性</p></li><li><p>用户需求：系统能帮助用户做些什么</p></li><li><p>系统需求：用户对系统行为的期望</p></li></ul><h3 id="需求分类">需求分类</h3><h4 id="需求谱系">需求谱系</h4><ul><li>需求<ul><li>项目需求</li><li>过程需求</li><li>系统需求<ul><li>软件需求</li><li>硬件需求</li><li>其他需求</li></ul></li></ul></li><li>不切实际的期望</li></ul><h4 id="需求分类-1">需求分类</h4><ul><li>功能需求<ul><li>不考虑物理约束的情况下，用户希望系统能够执行的活动</li><li>主要表现为系统和环境之间的行为交互</li></ul></li><li>性能需求<ul><li>系统整体或系统组成部分应该拥有的性能特征</li></ul></li><li>质量属性<ul><li>系统完成工作的质量</li></ul></li><li>对外接口<ul><li>系统和环境中其他系统需要建立的接口</li></ul></li><li>约束<ul><li>进行系统构造时需要遵守的约束</li></ul></li></ul><h2 id="三需求分析">三、需求分析</h2><h3 id="需求分析的任务">需求分析的任务</h3><ul><li>建立分析模型，达成开发者和用户对需求信息的共同理解</li><li>依据共同的理解发挥创造性，创建软件系统解决方案</li></ul><h3 id="需求分析模型">需求分析模型</h3><p>模型是对事物的抽象，帮助人们在创建一个事物之前可以有更好的理解。</p><h4 id="面向对象方法模型">面向对象方法模型</h4><table><thead><tr class="header"><th>模型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>用例图</td><td>描述用户与系统的交互。从交互的角度说明了系统的边界和功能范围。</td></tr><tr class="even"><td>类图</td><td>描述应用领域中重要的概念以及概念之间的关系。它捕获了系统的静态结构。</td></tr><tr class="odd"><td>顺序图</td><td>描述系统中一次交互的行为过程，说明了在交互中的对象协作关系。</td></tr><tr class="even"><td>状态图</td><td>描述系统、用例或者对象在其整个生命期内的状态变化和行为过程。</td></tr></tbody></table><h4 id="结构化方法模型">结构化方法模型</h4><table><thead><tr class="header"><th>模型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>数据流图</td><td>从数据传递和加工的角度，描述了系统从输入到输出的功能处理过程。运用功能分解的方法，用层次结构简化处理复杂的问题。</td></tr><tr class="even"><td>实体关系图</td><td>描述系统中的数据对象及其关系，定义了系统中使用、处理和产生的所有数据。</td></tr></tbody></table><h4 id="建模">建模</h4><p>建立模型的过程被称为建模。</p><ul><li><p>建模是对系统进行思考和推理的一种方式</p></li><li><p>建模的目标是建立系统的一个表示，这个表示以精确一致的方式描述系统，使得系统的使用更加容易</p></li><li><p>建模的常用手段：抽象和分解</p></li></ul><h2 id="四面向对象分析">四、面向对象分析</h2><h3 id="简单过程">简单过程</h3><ul><li><p>系统用例图——细化系统的对外交互——&gt;用例模型/用例描述</p></li><li><p>用例模型/用例描述——明确用例中的协作对象——&gt;概念类图/领域模型</p></li><li><p>用例模型/用例描述——明确用例中的协作行为——&gt;顺序图、状态图、对象约束语言</p></li></ul><h3 id="用例图">1. 用例图</h3><h4 id="用例的定义">用例的定义</h4><p>在系统（或者子系统或者类）和外部对象的交互当中所执行的行为序列的描述，包括各种不同的序列和错误的序列，它们能够联合提供一种有价值的服务。</p><h4 id="用例图的基本元素">用例图的基本元素</h4><p>参与者、用例、关系、系统边界</p><ul><li>参与者（小人形）<ul><li>一个与正在开发的系统进行交互的用户或系统所扮演的角色</li><li>用例图中的一个参与者可以代表多个用户或系统、扮演多种角色</li></ul></li><li>用例（椭圆）</li><li>关系（不同的线和箭头及上面的补充文字）</li><li>系统边界（矩形）<ul><li>参与者总在系统边界外</li></ul></li></ul><h4 id="用例图的建立">用例图的建立</h4><ol type="1"><li>目标分析与解决方向的确定</li><li>寻找参与者</li><li>寻找用例</li><li>细化用例</li></ol><ul><li>如果用例的粒度不合适就需要进行细化和调整<ul><li>判断标准：用例描述了为应对一个业务事件，由一个用户发起，并在一个连续时间段内完成，可以增加业务价值的任务。</li></ul></li></ul><h4 id="常见错误">常见错误</h4><ul><li>不要把用例细化为单个操作<ul><li>例：不要将用户管理细化为增加、修改和删除三个更小的用例，因为它们要联合起来才能体现出业务价值。</li></ul></li><li>不要把同一个业务目标细化为不同用例<ul><li>例：特价策略制定和赠送策略制定。</li></ul></li><li>不要把没有业务价值的内容作为用例<ul><li>例：“登录”(应该描述为安全性质量需求)、“数据验证”(应该描述为数据需求)、“连接数据库”(属性软件内部实现而不是需求)等。</li></ul></li></ul><h3 id="概念类图">2. 概念类图</h3><p>概念类图又被称为领域模型。</p><p>类图是面向对象分析方法的核心，描述类和类之间的关系。</p><ul><li>和设计类图的不同：关注系统与外界的交互，而不是软件系统的内部构造机制</li><li>类型、方法、可见性等复杂的软件构造细节不会在概念类图中</li></ul><h4 id="概念类图的基本元素">概念类图的基本元素</h4><p>对象、类、链接、关联、继承</p><p>继承、组合、聚合、关联的图示：</p><pre><code class=" mermaid">classDiagram A &lt;|-- BC *-- DE o-- FG -- H</code></pre><h4 id="建立概念类图">建立概念类图</h4><p>先对每个用例文本描述，尤其是场景描述建立局部概念类图，再合并为整体概念类图。</p><ol type="1"><li>根据用例文本描述识别候选类<ul><li>软件系统与外界交互时可能设计的对象与类</li></ul></li><li>筛选候选类，确定概念类<ul><li>准则：依据系统需求；该类的对象实例的状态与行为是否完全必要</li><li>候选类向概念类的转化：<ul><li>需要维护状态、表现行为：概念类</li><li>需要维护状态，不需要表现行为：其他概念类的属性</li><li>不需要维护状态，需要表现行为：审视需求，转交行为</li><li>不需要维护状态、表现行为：剔除</li></ul></li></ul></li><li>识别关联</li><li>识别重要属性</li></ol><h3 id="顺序图">3. 顺序图</h3><p>也称交互图。</p><h4 id="消息种类">消息种类</h4><ul><li>同步消息：实线，实心三角箭头</li><li>异步消息：实线，&gt;</li><li>返回消息：虚线，&gt;</li></ul><h4 id="顺序图的建立">顺序图的建立</h4><ol type="1"><li>确定上下文环境</li><li>根据用例描述找到交互对象</li><li>按照用例描述中的流程顺序逐步添加信息</li></ol><h3 id="状态图">4. 状态图</h3><h4 id="概念">概念</h4><ul><li>状态：描述系统在特定时间行为的可视化状况的集合</li><li>状态转换：从一个状态到另一个状态</li><li>事件：导致系统表现一些可预测的行为</li><li>活动：作为状态转换的结果发生的过程</li></ul><h4 id="状态图的建立">状态图的建立</h4><ol type="1"><li>确立上下文环境</li><li>识别状态</li><li>建立状态转换</li><li>完善状态图</li></ol><h2 id="五需求文档化与验证">五、需求文档化与验证</h2><h3 id="用例文档">1. 用例文档</h3><p>在用户的角度以用例文本为主描述软件系统与外界的交互。</p><ul><li>基本职责是把问题域信息和需求传达给软件系统解决方案的设计者</li></ul><h4 id="用例文档结构示例">用例文档结构示例</h4><ul><li>文档的信息</li><li>用例图或用例列表</li><li>用例描述</li></ul><h3 id="软件需求规格说明文档">2. 软件需求规格说明文档</h3><p>在软件产品的角度以系统级需求列表的方式描述软件系统解决方案。</p><table><thead><tr class="header"><th>用例</th><th>系统规格</th></tr></thead><tbody><tr class="odd"><td>侧重于交互流程</td><td>侧重于独立需求</td></tr><tr class="even"><td>基于一次交互</td><td>基于一次交互中的软件系统处理细节</td></tr></tbody></table><h4 id="需求规格说明文档结构示例">需求规格说明文档结构示例</h4><ul><li>引言</li><li>总体描述</li><li>详细需求描述<ul><li>对外接口需求</li><li>功能需求</li><li>性能需求</li><li>约束</li><li>质量属性</li><li>其他需求</li></ul></li><li>附录</li><li>索引</li></ul><h3 id="文档化需求的注意事项">3. 文档化需求的注意事项</h3><h4 id="技术文档写作要点">技术文档写作要点</h4><ul><li>简洁</li><li>精确</li><li>易读<ul><li>有效使用引言、目录、索引等</li><li>使用系统化的方式组织内容信息<ul><li>使用相同的语句格式来组织相似、关联的信息</li><li>使用列表或表格来组织独立、并列的信息</li><li>使用编号来表达繁杂信息之间的关系，包括顺序、嵌套、层次关系</li></ul></li></ul></li><li>易修改<ul><li>独立性</li><li>ID</li><li>引用，不重复</li></ul></li></ul><h4 id="需求书写要点">需求书写要点</h4><ul><li>使用用户属于</li><li>可验证</li><li>可行性</li></ul><h4 id="需求规格说明文档书写要点">需求规格说明文档书写要点</h4><ul><li>充分利用标准文档模版，保持所有内容位置得当</li><li>保持文档内的需求集具有完备性和一致性</li><li>为需求划分优先级</li></ul><h3 id="验证需求文档">4. 验证需求文档</h3><p>方法：评审、开发系统测试用例、度量</p><h4 id="开发系统测试用例">开发系统测试用例</h4><ol type="1"><li>以需求为线索，开发测试用例套件</li><li>使用测试技术确定输入/输出数据，开发测试用例</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;单纯的软件系统是不能解决问题的，只有和现实世界之间形成有效互动才能实现问题的解决。&lt;/p&gt;</summary>
    
    
    
    <category term="软件工程与计算2" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
  </entry>
  
  <entry>
    <title>软工2-二-项目启动</title>
    <link href="http://example.com/2023/04/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/"/>
    <id>http://example.com/2023/04/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/</id>
    <published>2023-04-02T06:00:00.000Z</published>
    <updated>2023-06-17T06:59:13.785Z</updated>
    
    <content type="html"><![CDATA[<p>原神，启动！</p><span id="more"></span><h1 id="第二部分-项目启动">第二部分-项目启动</h1><h2 id="项目和项目管理">1. 项目和项目管理</h2><h3 id="项目的概念">项目的概念</h3><p>项目是具有下列特征的一系列活动和任务：</p><ul><li>具有一个明确的目标</li><li>有限定的开始和结束日期</li><li>有成本限制</li><li>消耗人力和非人力资源</li><li>多工种合作</li></ul><h3 id="项目管理的目标">项目管理的目标</h3><p>在限定时间内、一定成本内、要求的质量水平上，高效使用资源，获得用户认可。</p><h3 id="过程组与活动">过程组与活动</h3><p>过程组：</p><ol type="1"><li>项目启动</li><li>项目计划</li><li>项目执行</li><li>项目跟踪</li><li>项目收尾</li></ol><p>活动：计划制定、团队管理、成本控制、质量保障、度量、过程管理、进度跟踪与控制、风险管理、配置管理</p><h2 id="团队组织与管理">2. 团队组织与管理</h2><ul><li>一个协作良好的团队是任何项目成功的基础</li><li>软件项目尤其依赖于有效的团队组织和管理</li><li>软件开发是一个以人为主的活动，人力资源是软件项目最大的资产</li></ul><h3 id="团队的概念">团队的概念</h3><p>为了一致的目的、绩效标准、方法而共担责任并且技能互补的少数人。</p><ul><li>团队内部要有一个明确的结构</li></ul><h3 id="团队的结构">团队的结构</h3><ul><li>主程序员团队</li><li>民主团队</li><li>开放团队</li></ul><h3 id="团队建设">团队建设</h3><ol type="1"><li><p>建立团队章程</p></li><li><p>持续成功</p><p>项目阶段性成功/团队活动成功</p></li><li><p>和谐沟通</p></li><li><p>避免团队杀手</p></li></ol><ul><li>防范式管理</li><li>官僚主义</li><li>地理分散</li><li>时间分割</li><li>产品质量的降低</li><li>虚假的最后期限</li><li>小圈子控制</li></ul><h2 id="软件质量保障">3. 软件质量保障</h2><p>软件工程师需要对软件产品的质量负责。</p><p>人们通常会选用系统的某些质量要素进行量化处理，建立质量特征，这些特征被称为质量属性。</p><p>为了根据质量属性描述和评价系统的整体质量，人们从很多质量属性的定义中选择了一些能够相互配合、相互联系的特征集，它们被称为质量模型。</p><p>质量模型的因素</p><ul><li>功能性、可靠性、易用性、效率、可维护性、可移植性</li></ul><h3 id="质量保障">质量保障</h3><table><thead><tr class="header"><th>里程碑</th><th>质量保障活动</th></tr></thead><tbody><tr class="odd"><td>需求开发</td><td>需求评审、需求度量</td></tr><tr class="even"><td>体系结构</td><td>体系结构评审、集成测试</td></tr><tr class="odd"><td>详细设计</td><td>详细设计评审、设计度量、集成测试</td></tr><tr class="even"><td>实现</td><td>代码评审、代码度量、测试</td></tr><tr class="odd"><td>测试</td><td>测试、测试度量</td></tr></tbody></table><h3 id="评审">评审</h3><ol type="1"><li><p>在规划阶段(Planning)，制定审查计划，决定审查会议的次数，安排每次审查会议的时间、地点、参与人员、审查内容等等。</p></li><li><p>在总体部署阶段(Overview)，向所有参与审查会议的人员描述待审查材料的内容、审查的目标以及一些假设，并分发文档。</p></li><li><p>在准备阶段(Preparation)，审查人员各自独立执行检查任务。在检查的过程当中，他们可能会被要求使用检查清单、场景等检查方法。检查中发现的问题会被记录下来，以准备开会讨论或者提交给收集人员。</p></li><li><p>在审查会议阶段(InspectionMeeting)，通过会议讨论，识别、确认、分类发现的错误。</p></li><li><p>在返工阶段(Rework)，修改发现的缺陷。</p></li><li><p>在跟踪阶段(Follow-up)，要确认所有发现的问题都得到了解决，所有的错误都得到了修正。</p></li></ol><h3 id="质量度量">质量度量</h3><p>度量是软件产品在特点属性的量化测试程度。</p><h2 id="软件配置管理">4. 软件配置管理</h2><h3 id="配置管理的概念">配置管理的概念</h3><p>用技术的和管理的指导和监督方法，来标识和说明配置项的功能和物理特征，控制对这些特征的变更，记录和报告变更处理及其实现状态，并验证与规格需求的一致性。</p><p>配置项：</p><p>置于软件配置管理之下的软件配置的各种有关项目，包括各类文档、评审记录与文档、软件文档、源码及其可执行码、运行所需的系统软件和支持软件以及有关数据等。</p><h3 id="配置管理活动">配置管理活动</h3><ul><li>标识配置项</li><li>版本管理</li><li>变更控制</li><li>配置审计</li><li>状态报告</li><li>软件发布管理</li></ul><h3 id="分支管理常见策略">分支管理常见策略</h3><ul><li>主分支</li><li>开发分支</li><li>临时分支<ul><li>功能</li><li>预发布</li><li>修补bug</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;原神，启动！&lt;/p&gt;</summary>
    
    
    
    <category term="软件工程与计算2" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/"/>
    
    
  </entry>
  
</feed>
