<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Geternitier的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-16T03:32:10.642Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Geternitier</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>习概_布局安排</title>
    <link href="http://example.com/2024/09/03/%E4%B9%A0%E6%A6%82/%E5%B8%83%E5%B1%80%E5%AE%89%E6%8E%92/"/>
    <id>http://example.com/2024/09/03/%E4%B9%A0%E6%A6%82/%E5%B8%83%E5%B1%80%E5%AE%89%E6%8E%92/</id>
    <published>2024-09-03T04:00:00.000Z</published>
    <updated>2024-12-16T03:32:10.642Z</updated>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1 id="布局安排">布局安排</h1><h2 id="经济">6. 经济</h2><p>新发展理念、新发展格局、社会主义基本经济制度、现代化经济体系、乡村振兴</p><h3 id="新发展理念">新发展理念</h3><ol type="1"><li><p>我国经济进入新发展阶段：</p><ul><li>“三期叠加”：我国当前经济发展正处于增长速度换挡期、结构调整阵痛期、前期刺激政策消化期叠加的阶段，进入了新常态。</li><li>我国经济已由高速增产阶段转向高质量发展阶段。</li></ul></li><li><p>新发展理念：创新、协调、绿色、开放、共享。</p><ul><li><p>创新是引领发展的第一动力。</p></li><li><p>协调是持续健康发展的内在要求。</p></li><li><p>绿色是永续发展的必要条件和人民对美好生活追求的重要体现。</p></li><li><p>开放是国家繁荣发展的必要之路。</p></li><li><p>共享是中国特色社会主义的本质要求。</p></li><li><p>怎样贯彻新发展理念：从根本宗旨上、问题导向上、忧患意识上把握新发展理念。</p></li></ul></li><li><p>高质量发展是体现新发展理念的发展。</p><ul><li>高质量发展是全面建设社会主义现代化国家的首要要求，是遵循经济规律发展的必然要求。</li><li>高质量发展的含义：<ul><li>能够很好满足人民日益增长的美好生活需要的发展。</li><li>体现新发展理念的发展。</li><li>从有没有转向好不好的发展。</li></ul></li><li>高质量发展的重大战略意义：<ul><li>为全面建设社会主义现代化国家提供更为坚实的物质基础。</li><li>是不断满足人民对美好生活需要的重要保证。</li><li>是维护国家长治久安的必然要求。</li></ul></li><li>高质量发展的战略导向：<ul><li>一方面，要更好统筹质的有效提升和量的合理增长。</li><li>另一方面，要保持经济社会发展稳定性坚持稳中求进工作总基调。</li></ul></li><li>高质量发展的历史性成就：我国进入创新型国家行列。</li></ul></li><li><p>高质量发展的相关论点：</p><ul><li>加快实现高水平科技自立自强，是推动高质量发展的必由之路。</li><li>加快构建新发展格局，是推动高质量发展的战略基点。</li><li>农业强国是社会主义现代化强国的根基，推进农业现代化是高质量发展的必然要求。</li><li>人民幸福安康市推动高质量发展的最终目的。</li></ul></li><li><p>发展新质生产力是推动高质量发展的内在要求和重要着力点。</p></li><li><p>新发展格局：以国内大循环为主体、国内国际双循环相互促进。</p><ul><li><p>原因：</p><ul><li><p>国际政治经济形势剧变下，必须进一步把发展立足点放在国内，更多依靠国内市场实现经济发展。</p></li><li><p>党提出构建新发展格局，是对我国客观经济规律和发展趋势的自觉把握。</p></li></ul></li><li><p>新发展格局是开放的国内国际双循环，不是国内单循环，更不是各地小循环。</p></li><li><p>如何构建新发展格局：</p><ul><li><p>具备强大的国内经济循环体系和稳固的基本盘。</p></li><li><p>发挥比较优势，以国内大循环吸引全球资源要素。</p></li><li><p>保证经济循环畅通无阻，生产、分配、流通、消费各环节有机衔接。</p></li><li><p>构建新发展格局的举措：</p><ul><li><p>推动实施扩大内需战略同深化供给侧结构性改革有机结合。</p></li><li><p>发展实体经济。</p></li><li><p>加快科技自立自强。</p></li><li><p>推动产业链供应链优化升级。</p></li></ul></li></ul></li></ul></li></ol><h3 id="经济制度">经济制度</h3><ol type="1"><li><p>社会主义基本经济制度：公有制为主体、多种所有制共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等。</p><ul><li><p>社会主义基本经济制度的新概括包含了所有制、分配制、资源配置体制等方面。</p><ul><li><p>所有制结构是基本经济制度的基础，决定分配方式和资源配置方式。</p></li><li><p>合理有效的分配方式和资源配置方式有利于进一步完善所有制结构。</p></li><li><p>这三个方面是经济制度体系中具有长期性和稳定性的部分，起着规范方向的作用，对经济制度属性和经济发展方式有决定性影响，是新时代推动经济高质量发展的制度支撑。</p></li></ul></li></ul></li><li><p>所有制：两个毫不动摇</p><ul><li><p>公有制经济和非公有制经济都是社会主义市场经济的重要组成部分，都是我国经济社会发展的重要基础。要毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展。</p></li><li><p>公有制经济包括国有经济和集体经济、混合所有制经济中的国有成分和集体成分。</p><ul><li>国有企业是中国特色社会主义的重要物质基础和政治基础，是我们党执政兴国的重要支柱和依靠力量。</li></ul></li><li><p>非公有制经济包括个体经济、私营经济、港澳台投资经济、外商投资经济以及混合所有制经济中的非国有成分和非集体成分。</p><ul><li>非公有制经济是社会主义市场经济的重要组成部分，是稳定经济的重要基础，是国家税收的重要来源，是就业创业的重要领域，是技术创新的重要主体，是金融发展的重要依托，是经济持续发展的重要力量。</li><li>民营经济是非公有制经济的主要经济组织形式，是推进中国式现代化的主力军，是高质量发展的重要基础，是推动我国全面建成社会主义现代化强国、实现第二个百年奋斗目标的重要力量。</li></ul></li></ul></li><li><p>分配制：按劳分配为主体、多种分配方式并存。</p><ul><li>所有制决定分配制。</li><li>分配制是促进共同富裕的基础性制度。<ul><li>发挥初次分配的基础性作用。</li><li>发挥再分配的调节作用。</li><li>建立健全第三次分配机制，引导公益慈善事业。</li></ul></li></ul></li><li><p>构建高水平社会主义社会主义市场经济体制，关键是要处理好政府和市场的关系。</p><ul><li>把市场能有效调节的经济活动交给市场。</li><li>政府管好那些市场管不了或管不好的事情。</li></ul></li><li><p>建设现代化产业体系：</p><ul><li>巩固优势产业领先地位。保持优势产业的领先地位是支撑我国国际竞争力的基石。</li><li>大力发展战略性新兴产业。战略性新兴产业是引领国家未来产业发展的决定性力量。</li><li>构建优势高效的服务业新体系。现代服务业是现代产业体系的重要支撑。</li><li>发展现代流通产业。</li><li>加快发展数字经济。数字化是新的时代特征。</li><li>构建现代化基础设施体系。基础设施是经济社会发展的重要支撑。</li></ul></li><li><p>全面建设社会主义现代化强国，最艰巨繁重的任务仍然在农村，最广泛最深厚的基础依然在农村。</p></li><li><p>全面推进乡村振兴：</p><ul><li>总目标：农业农村现代化。</li><li>总方针：农业农村优先发展。</li><li>总要求：产业兴旺、生态宜居、乡风文明、治理有效、生活富裕。</li><li>具体举措：头等大事是保障粮食和重要农产品稳定安全供给。</li></ul></li><li><p>区域协调发展是贯彻新发展理念的重要内容，也是实现高质量发展的必然要求。</p></li></ol><h2 id="科教">7. 科教</h2><ol type="1"><li><p>教育、科技、人才是全面建设社会主义现代化国家的基础性、战略性支撑。</p><ul><li><p>全面建设社会主义现代化国家，教育是根本，科技是关键，人才是基础。</p></li><li><p>必须坚持科技是第一生产力，人才是第一资源，创新是第一动力。</p></li><li><p>坚持教育优先发展、科技自立自强、人才引领驱动，加快教育强国、科技强国、人才强国。</p><ul><li><p>教育优先发展重在夯实人力资源深度开发基础。</p></li><li><p>科技自立自强重在坚持独立自主开拓创新。</p></li><li><p>人才引领驱动重在巩固发展优势赢得竞争主动。</p></li><li><p>我国已建成世界上规模最大的教育体系，进入创新型国家行列，发展成为全球规模最宏大、门类最齐全的人才资源大国。</p></li></ul></li></ul></li><li><p>科教兴国战略，就是要全面落实科学技术是第一生产力的思想。</p><ul><li>科教兴国是我国的基本国策。</li></ul><p>创新驱动发展战略，就是要坚持创新是第一动力，</p><ul><li>创新在国家发展全局中居于核心位置。</li></ul><p>人才强国战略，就是要牢固树立人才资源是第一资源的理念。</p></li><li><p>建设教育强国是全面建成社会主义现代化强国的战略先导，是实现高水平科技自立自强的重要支撑，是促进全体人民共同富裕的有效途径，是以中国式现代化全面推进中华民族伟大复兴的基础工程：</p><ul><li>必须坚持教育为人民服务，为党治国理政服务。</li><li>坚持党对教育方针的全面领导是办好教育的根本保证。</li><li>坚持根据中国国情办教育。</li></ul><p>落实立德树人根本任务，必须着力解决好培养什么人、怎样培养人、为谁培养人的问题，这是教育的根本问题，也是建设教育强国的核心课题。</p><ul><li>培养什么人：社会主义建设者和接班人。</li><li>怎样培养人：系统思维，整体规划各个环节，整合各种资源，统筹多方力量。</li></ul></li><li><p>办好人民满意的教育：</p><ul><li>大力促进教育公平。</li><li>加快建设高质量教育体系。</li><li>提升教育服务经济社会发展能力。</li><li>坚持深化教育改革创新。</li><li>坚持把教师队伍建设作为基础工作。</li></ul></li><li><p>自主创新，就是从增强国家创新能力出发，加强原始创新、集成创新和开放创新，确保国家拥有自主可控的科技创新能力。</p><ul><li><p>抓住了自主创新，就抓住了科学技术发展的战略基点，抓住了结构调整和增长方式改变的中心环节，抓住了把握战略机遇期、实现经济长期稳定较快发展的关键。</p></li><li><p>我国面临的很多卡脖子问题，根子是基础理论研究跟不上。</p></li></ul></li><li><p>人才是人力资源中能力和素质较高的劳动者，在国家发展中具有重要战略地位，已经成为推动社会发展最活跃、最积极的因素。</p></li><li><p>做好人才工作：</p><ul><li>根本保证：坚持党对人才工作的全面领导。</li><li>重要保障：坚持深化人才发展体制机制改革。</li><li>社会条件：坚持营造识才爱才敬才用才的环境。</li></ul></li></ol><h2 id="民主">8. 民主</h2><ol type="1"><li><p>全过程人民民主是社会主义民主政治的本质属性。</p><ul><li>实现了过程民主和成果民主、程序民主和实质民主、直接民主和间接民主、人民民主和国家意志相统一。</li><li>全过程人民民主是最广泛、最真实、最管用的民主。</li><li>人民代表大会制度是实现全过程人民民主的重要载体。</li></ul></li><li><p>中国特色社会主义政治制度是中国共产党带领人民在革命、建设、改革的长期实践中形成的，集中体现了我国人民民主的本质属性，是保证人民当家做主科学有效的制度安排。</p><p>中国特色社会主义政治制度构成：根本政治制度、基本政治制度、重要政治制度等。</p><p>党的领导是人民当家做主和依法治国的根本保证，人民当家做主是社会主义民主政治的本质特征，依法治国是党领导人民治理国家的基本方式。</p></li><li><p>人民代表大会制度是我国的根本政治制度。</p><ul><li>是符合我国国情与实际、体现社会主义国家性质、保证人民当家做主、保障实现中华民族伟大复兴的好制度，是我们党在人类政治制度史上的伟大创造。</li></ul><p>中国共产党领导的多党合作和政治协商制度、民族区域自治制度以及基层群众自治制度构成了我国的基本政治制度。</p><ul><li>中国人民政治协商会议是实行中国共产党领导的多党合作和政治协商制度的重要机构。</li><li>民族区域自治制度是中国特色解决民族问题的正确道路的重要内容和制度保障。</li><li>基层群众自治制度是社会主义民主政治建设的基础。<ul><li>要实现人民自我管理、自我服务、自我教育、自我监督。</li></ul></li></ul></li><li><p>协商民主：在决策前和决策实施中开展广泛协商。</p><ul><li>保证和支持人民当家做主，通过依法选举、让人民代表来参与国家生活和社会生活的管理是十分重要的，通过选举以外的制度和方式让人民参与国家生活和社会生活的管理也是十分重要的。</li><li>政党协商、人大协商、政府协商、政协协商、人民团体协商、基层协商、社会组织协商。</li></ul></li><li><p>基层民主的形式：村民委员会、居民委员会等。</p><p>发展基层民主，是实现人民有效政治参与的重要渠道，是人民当家做主的有效途径，是社会主义民主最广泛的实践。</p></li><li><p>爱国统一战线：</p><ul><li>统战工作的本质要求是大团结大联合，解决的就是人心和力量问题。</li><li>统战工作的关键是要坚持求同存异。</li><li>统战是为了壮大共同奋斗的力量。</li><li>坚持党的领导是统战最根本最核心的问题。</li></ul></li><li><p>民族团结是我国各族人民的生命线，中华民族共同体意识是民族团结之本。</p><ul><li>对中华民族形成起决定作用的是对中华民族共同体的认可。</li><li>宗教工作本质上是群众工作。</li></ul></li><li><p>海外儿女大团结：</p><ul><li>高举爱国主义、社会主义旗帜。</li><li>抓好重点领域统战工作。</li><li>辩证把握四方面关系：<ul><li>固守圆心和扩大共识。</li><li>潜绩和显绩。</li><li>原则性和灵活性。</li><li>团结和斗争。</li></ul></li></ul></li></ol><h2 id="法治">9. 法治</h2><ol type="1"><li><p>法律是治国理政最大最重要的规矩。</p><p>党的十八大以来，全面依法治国总体格局基本形成。</p></li><li><p>全面依法治国是坚持和发展中国特色社会主义的本质要求和重要保障。</p></li><li><p>全面依法治国的唯一正确道路是中国特色社会主义法治道路。</p><ul><li><p>核心要义：坚持党的领导，坚持中国特色社会主义制度，贯彻中国特色社会主义法治理论。</p><ul><li>党的领导是社会主义法治的根本保证。</li><li>中国特色社会主义制度是中国特色社会主义法治体系的根本制度基础，是全面推进依法治国的根本制度保障。</li><li>中国特色社会主义法治理论是全面推进依法治国的行动指南。</li></ul></li><li><p>中国特色社会主义法治道路的基本原则：</p><ul><li>坚持中国共产党领导。</li><li>坚持以人民为中心。</li><li>坚持法律面前人人平等。</li><li>坚持依法治国和以德治国相结合。</li><li>坚持从中国实际出发。</li></ul></li><li><p>全面依法治国的重大关系：</p><ul><li><p>政治和法治的关系：</p><p>党和法的关系是政治和法治关系的集中反映，是全面依法治国的一个根本问题。</p><p>党的领导和社会主义法治是一致的，社会主义法制必须坚持党的领导，党的领导必须依靠社会主义法治。</p></li><li><p>改革和法治的关系：</p><p>法治下改革，改革中完善法治。深化改革离不开法律规范，法治建设紧跟改革开放步伐。</p></li><li><p>依法治国和以德治国的关系：</p><p>既重视发挥法律的规范作用，又重视发挥道德的教化作用，以法治体系道德理念、强化法律对道德建设的促进作用，以道德滋养法治精神、强化道德对法治文化的支撑作用。</p></li><li><p>依法治国和依规治党的关系。</p></li></ul></li><li><p>全面推进依法治国的总抓手是建设中国特色社会主义法治体系。</p></li></ul></li><li><p>宪法是国家的根本法，是治国安邦的总章程，是党和人民意志的体现，是国家各种制度和法律法规的总依据，具有最高的法律地位、法律权威、法律效力。</p><ul><li>坚持依宪治国、依宪执政要求：必须坚持党的领导和国体、政体不动摇；必须全面贯彻实施宪法。</li></ul></li><li><p>建设法治中国的总目标：</p><p>实现法律规范科学完备统一，执法司法公正高效权威，权力运行受到有效制约监督，人民合法权益得到充分尊重保障，法治信仰普遍确立，法治国家、法治政府、法治社会全面建成。</p><ul><li>到2025年，中国特色社会主义法治体系初步形成。</li><li>到2035年，法治国家、法治政府、法治社会基本建成，中国特色社会主义法治体系基本形成，人民平等参与、平等发展权利得到充分保障，国家治理体系和治理能力现代化基本实现。</li></ul></li><li><p>法治中国建设的工作布局：</p><ul><li>坚持依法治国、依法执政、依法行政共同推进。</li><li>坚持法治国家、法治政府、法治社会一体建设。<ul><li>法治国家是法治建设的目标。</li><li>法治政府建设是全面依法治国的重点任务和主体工程。</li><li>法治社会是构筑法治国家的基础。</li></ul></li><li>坚持统筹推进国内法治和涉外法治。</li></ul></li><li><p>建设更高水平法治中国的四个方面：</p><ul><li>完善以宪法为核心的中国特色社会主义法律体系。</li><li>扎实推进依法行政。</li><li>严格公正司法。</li><li>加快建设法治社会。</li></ul></li></ol><h2 id="文化">10. 文化</h2><ol type="1"><li><p>文化是一个国家、一个民族的灵魂。文化繁荣兴盛是实现中华民族伟大复兴的必然要求：</p><ul><li>文化繁荣兴盛是实现中华民族伟大复兴的精神支撑。</li><li>文化繁荣兴盛是建设社会主义现代化强国的应有之义。</li><li>文化繁荣兴盛是满足人民日益增长的美好生活需要的内在要求。</li><li>文化繁荣兴盛是在世界文化激荡中站稳脚跟的前提基础。</li></ul><p>建设社会主义文化强国、推动社会主义文化繁荣兴盛，关键在于坚定中国特色社会主义文化自信。</p><ul><li>文化自信的依据和来源：<ul><li>深厚基础：中华优秀传统文化。</li><li>坚强基石：党在带领人民在伟大斗争中孕育的革命文化和社会主义先进文化。</li><li>现实基础：中国特色社会主义伟大实践。</li></ul></li></ul><p>中国特色社会主义文化发展道路：</p><ul><li>坚持为人民服务、为社会主义服务的根本方向，是决定社会主义文化事业前途命运的关键。</li><li>坚持百花齐放、百家齐鸣，是繁荣发展社会主义文化的重要方针。</li><li>激发全民族文化创新创造活力。<ul><li>创新创造是文化的生命所在，是文化的本质特征。</li></ul></li></ul></li><li><p>建设具有强大凝聚力和引领力的社会主义意识形态：</p><ul><li>为什么要坚持马克思主义在意识形态领域指导地位的根本制度：<ul><li>这是历史的结论。</li><li>这是坚持和巩固我国社会主义制度、保证我国文化建设正确方向的必然要求。</li></ul></li><li>如何大力加强马克思主义理论建设：<ul><li>坚持用马克思主义，特别是中国化时代化的马克思主义武装全党、教育人民、指导实践。</li><li>深化马克思主义理论研究和建设。</li><li>加快构建中国特色哲学社会科学，坚持以马克思主义为指导，是当代中国哲学社会科学区别于其他哲学社会科学的根本标志。</li></ul></li><li>积极塑造主流舆论新格局：<ul><li>坚持正确的政治方向。<ul><li>党性原则是新闻舆论工作的根本原则。</li><li>坚持党性原则最根本的是坚持党对新闻舆论工作的领导。</li></ul></li><li>做大做强主流舆论阵地。</li><li>管好用好互联网是关键。<ul><li>互联网是意识形态工作的主阵地、主战场、最前沿。</li></ul></li></ul></li></ul></li><li><p>如何传承中华优秀传统文化：</p><ul><li>深刻把握中华文明的突出特性：连续性、创新性、统一性、包容性、和平性。</li><li>推动中华优秀传统文化创造性转化、创新性发展。</li><li>保护好、传承好文化遗产。</li></ul></li><li><p>繁荣发展文化事业和文化产业，是满足人民精神文化需求、保障人民文化权益的基本途径：</p><ul><li>把为人民服务作为文艺工作者的天职。<ul><li>中国精神是社会主义文艺的灵魂。</li></ul></li><li>文化产业在促进国民经济发展、满足人民文化需求等方面发挥着重要作用。<ul><li>衡量文化产业发展质量和水平，最重要的不是看经济效益，而是看能不能提供更多既能满足人民文化需求、又能增强人民精神力量的文化产品。</li></ul></li></ul></li><li><p>文化软实力集中体现了一个国家基于文化而具有的凝聚力和生命力，以及由此产生的吸引力和影响力。</p><ul><li>一个国家的文化软实力，根本上取决于其核心价值观的生命力、凝聚力、感召力。</li><li>讲好中国故事、传播好中国声音，根本在于传播理念，以我为主，以理服人，以情动人。</li></ul></li></ol><h2 id="民生">11. 民生</h2><ol type="1"><li><p>全面建设社会主义现代化国家，出发点和落脚点是让人民生活越过越好。</p><p>增进民生福祉是发展的根本目的。</p><ul><li>增进民生福祉是坚持立党为公、执政为民的本质要求。</li><li>增进民生福祉是社会主义生产的根本目的。</li><li>增进民生福祉是全面建设社会主义现代化国家的应有之义。</li></ul><p>要坚持在发展中增进民生福祉：</p><ul><li><p>发展是改善民生的物质基础，抓民生也是抓发展。</p></li><li><p>工作思路：坚守底线、突出重点、完善制度、引导预期。</p></li><li><p>重中之重：解决人民群众最关系最直接最现实的利益问题。</p></li><li><p>重要方针：坚持尽力而行、量力而行。</p></li><li><p>重要原则：坚持人人尽责、人人享有，让所有劳动者在推动发展中分享发展成果。</p></li></ul></li><li><p>就业是最基本的民生，是劳动者赖以生存和发展的基础、共享经济发展成果的基本条件，关系到亿万劳动者及其家庭的切身利益。</p></li><li><p>新时代加强社会建设的重要着力点就是健全和完善社会保障体系。</p><ul><li><p>我国基本建成以社会保险为主体、功能完备的社会保障体系，但仍存在不足：</p><p>要完善覆盖全民、统筹城乡、公平统一、安全规范、可持续的多层次社会保障体系。</p></li></ul></li><li><p>加强和创新社会治理，就是要在党的领导下，以政府为主导，以社会多元主体参与为基础，以维护人民群众根本利益为核心，通过合作、对话、协商、沟通等方式，依法对社会事务、社会组织和社会生活进行引导和规范，协调社会矛盾，化解社会矛盾，促进社会公平，推进社会稳定有序发展。</p><p>社会治理体系是进行社会治理的基础，也是提高社会治理效能的保障。</p><ul><li>社会治理理念：共建、共治、共享。<ul><li>共建是基础，共治是关键，共享是目标。</li></ul></li></ul></li></ol><h2 id="生态">12. 生态</h2><ol type="1"><li><p>生态环境是人类生存最为基础的条件，生态文明建设是关系中华民族永续发展的根本大计。</p><p>大自然是人类赖以生存发展的基本条件，尊重自然、顺应自然、保护自然是全面建设社会主义现代化国家的内在要求。</p><p>生态环境问题归根到底是经济发展方式和生活方式问题。</p><p>绿水青山就是金山银山，这是重要的发展理念。</p><ul><li>生态环境保护和经济发展是辩证统一、相辅相成的关系。</li><li>处理好绿水青山和金山银山的关系，关键在人，关键在思路。</li></ul><p>生态文明建设是重大经济问题，也是关系党的使命宗旨的重大政治问题、关系民生福祉的重大社会问题，我国开展的一系列工作：</p><ul><li>生态文明建设战略地位更加凸显。</li><li>生态文明制度体系更加健全。</li><li>污染防治和生态保护更加有力。</li></ul></li><li><p>绿色发展，就其要义来讲，是要解决好人与自然和谐共生问题。</p><p>要加快推动发展方式绿色低碳转型，坚持把绿色低碳发展作为解决生态环境问题的治本之策。</p><ul><li>生态环境问题，归根到底是资源过度开发、粗放利用、奢侈浪费造成的。</li><li>要处理好双碳承诺和自主行动的关系，目标确定，但是路径、节奏是自主的。</li></ul></li><li><p>用最严格制度最严密法治保护生态环境：</p><ul><li>实行最严格的生态环境保护制度。</li><li>全面建立资源高效利用制度。</li><li>严明生态环境保护责任制度。</li></ul></li><li><p>如何共建清洁美丽世界：</p><ul><li>坚持以人为本。</li><li>坚持科学治理。</li><li>坚持多边主义。</li><li>坚持共同但有区别的责任原则。</li></ul></li><li><p>如何推动全球可持续发展：</p><ul><li>积极参与全球气候治理。</li><li>积极推进全球生物多样性治理。</li><li>积极打造绿色一带一路。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;今客沧桑登舞榭，万灵且待命无疆！&lt;/p&gt;</summary>
    
    
    
    <category term="习近平新时代中国特色社会主义理论概论" scheme="http://example.com/categories/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E6%A6%82%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>习概_基本问题</title>
    <link href="http://example.com/2024/09/02/%E4%B9%A0%E6%A6%82/%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2024/09/02/%E4%B9%A0%E6%A6%82/%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</id>
    <published>2024-09-02T04:00:00.000Z</published>
    <updated>2024-12-16T03:31:18.853Z</updated>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1 id="基本问题">基本问题</h1><h2 id="中国特色社会主义">1. 中国特色社会主义</h2><h3 id="方向决定道路道路决定命运">方向决定道路，道路决定命运</h3><ol type="1"><li><p>一个国家实行什么样的主义，关键要看这个主义能否解决这个国家面临的历史性课题。</p><ul><li>中国特色社会主义具有广泛的现实基础，是历史的结论、人民的选择。</li><li>中国特色社会主义既坚持了科学社会主义基本原则，又根据时代条件赋予其鲜明的中国特色。</li></ul></li><li><p>四个自信：道路自信、理论自信、制度自信、文化自信</p><ul><li><p>改革开放以来我们取得一切成绩和进步的根本原因，归结起来就是开辟了中国特色社会主义道路，形成了中国特色社会主义理论体系，确立了中国特色社会主义制度，发展了中国特色社会主义文化。</p><ul><li>中国特色社会主义道路是实现途径，理论体系是行动指南，制度是根本保障，文化是精神力量，四者统一于中国特色社会主义伟大实践。</li></ul></li><li><p>四个自信来源于实践、来源于人民、来源于真理。</p></li><li><p>四个自信的坚实根基是深厚的实践基础和人民的广泛参与、深切认同。</p></li><li><p>四个自信的理论支撑和根本依据是社会主义必然代替资本主义的客观规律。</p></li><li><p>四个自信的根基和底气：</p><ul><li>我们有中国共产党的领导，这是中国特色社会主义最本质的特征、中国特色社会主义制度的最大优势。</li><li>我们有新中国成立、改革开放以来特别是党的十八大以来形成的更为完善的制度保证、更为坚实的物质基础、更为主动的精神力量，这是中国特色社会主义独具的发展优势。</li><li>我们有连绵不绝的五千年中华文明，这是中国特色社会主义的文化根脉和突出优势。</li></ul></li><li><p>坚持道路自信、理论自信、制度自信，说到底是要坚持文化自信。文化自信是更基础、更广泛、更深厚的自信，是一个国家、一个民族发展中最基本、最深沉、最持久的力量。</p></li></ul></li></ol><h3 id="中国特色社会主义新时代">中国特色社会主义新时代</h3><ol type="1"><li><p>中国特色社会主义新时代是我国发展新的历史方位，标志着中国特色社会主义事业进入新的发展阶段。</p><ul><li>2012年党的十八大开启了中国特色社会主义新时代。</li><li>主要依据：<ul><li><p>我国社会主要矛盾发生新变化，这是基本依据。</p></li><li><p>党的主要任务发生新变化。</p></li><li><p>中国和世界关系发生新变化。</p></li><li><p>中国特色社会主义新时代的内涵：</p><ul><li>是承前启后、继往开来，在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代。</li><li>是决胜全面建成小康社会，进而全面建设社会主义现代化强国的时代。</li><li>是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代。</li><li>是全体中华儿女戮力同心、奋力实现中华民族伟大复兴中国梦的时代。</li><li>是我国不断为人类作出更大贡献的时代。</li></ul></li><li><p>重大意义：</p><ul><li><p>第一，从中华民族复兴的历史进程看，意味着近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的伟大飞跃，迎来了实现中华民族伟大复兴的光明前景。</p></li><li><p>第二，从科学社会主义发展进程看，意味着科学社会主义在21世纪的中国焕发出强大生机活力，在世界上高高举起了中国特色社会主义伟大旗帜。</p></li><li><p>第三，从人类文明进程看，意味着中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径，为解决人类问题贡献了中国智慧和中国方案。</p></li></ul></li></ul></li></ul></li><li><p>我国社会主要矛盾变化：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</p><ul><li><p>社会主要矛盾变化的依据：</p><ul><li><p>社会生产力水平总体上显著提高。</p></li><li><p>人民生活水平显著提高，对美好生活的向往更加强烈。</p></li><li><p>影响满足人们美好生活需要的因素主要是发展的不平衡不充分问题。</p></li><li><p>两个没有变：我国仍处于并将长期处于社会主义初级阶段的基本国情没有变，我国是世界上最大发展中国家的国际地位没有变。</p></li><li><p>新时代我国社会主要矛盾的变化，反映了社会发展的客观实际，明确了当代解决中国发展主要问题的根本着力点。</p></li></ul></li></ul></li><li><p>全面贯彻党的基本理论、基本路线、基本方略。</p><ul><li>党的基本理论是坚持和发展中国特色社会主义的行动指南。</li><li>党的基本路线是国家的生命线、人民的幸福线。</li><li>党的基本方略反映了党对中国特色社会主义的规律性认识。</li></ul></li><li><p>中国特色社会主义事业布局：“五位一体”总体布局和“四个全面”战略布局</p><ul><li><p>总体布局：经济建设、政治建设、文化建设、社会建设和生态文明建设五位一体，全面推进。</p></li><li><p>战略布局：全面建设社会主义现代化国家、全面深化改革、全面依法治国、全面从严治党。</p><ul><li>全面建设社会主义现代化国家是战略目标，居于引领地位；</li></ul></li><li><p>全面深化改革、全面依法治国、全面从严治党是战略举措，提供重要保障。</p></li></ul></li></ol><h2 id="中国式现代化">2. 中国式现代化</h2><h3 id="中国梦">中国梦</h3><ol type="1"><li><p>实现中华民族伟大复兴的中国梦，本质是国家富强、民族振兴、人民幸福。</p></li><li><p>2021年7月1日，习近平庄严宣告全面建成小康社会。</p><ul><li>伟大意义：<ul><li>践行了党为中国人民谋幸福、为中华民族谋复兴的初心使命。</li><li>第一个百年奋斗目标实现，中华民族实现了从大幅落后于时代到大踏步赶上时代的新跨越。</li><li>极大彰显了中国特色社会主义制度的优势。</li><li>探索了人类解决贫困问题的新路径，为推动人类文件进步作出了重大贡献。</li></ul></li></ul></li><li><p>党的二十大对全面建成社会主义现代化强国的战略安排：</p><ul><li>第一步，从2020年到2035年基本实现社会主义现代化。<ul><li>GDP达到中等发达国家水平。</li><li>实现高水平科技自立自强，进入创新型国家前列。</li><li>建成现代化经济体系，形成新发展格局。</li><li>建成教育、科技、人才、文化、体育、健康强国。</li><li>人的全面发展、全体人民共同富裕取得更为明显的实质性进展。</li><li>广泛形成绿色生产生活方式，生态环境根本好转。</li></ul></li><li>第二步，从2035年到21世纪中叶把我国建成富强民主文明和谐美丽的社会主义现代化强国。<ul><li>全体人民共同富裕基本实现。</li></ul></li></ul></li></ol><h3 id="中国式现代化-1">中国式现代化</h3><ol type="1"><li><p>中国式现代化是党领导人民长期实践的重大成果：</p><ul><li>新民主主义革命为实现现代化创造了根本社会条件。</li><li>社会主义革命和建设为现代化建设奠定了根本政治前提和制度基础，提供了宝贵经验、理论准备和物质基础。</li><li>改革开放和社会主义现代化建设为中国式现代化提供了充满活力的体制保证和快速发展的物质条件。</li><li>新时代提供了更为完善的制度保证、更为坚实的物质基础、更为主动的精神力量。<ul><li>习近平中国特色社会主义思想为中国式现代化提供了根本遵循；</li><li>“五位一体”总体布局和“四个全面”战略布局为中国式现代化提供坚实战略支撑；</li></ul></li></ul></li><li><p>中国式现代化的中国特色：</p><ul><li>人口规模巨大。这是中国式现代化的显著特征。</li><li>全体人民共同富裕。这是区别于西方现代化的显著标志。</li><li>物质文明和精神文明相协调。这是中国式现代化的崇高追求。</li><li>人与自然和谐共生。这是中国式现代化的鲜明特点。</li><li>走和平发展道路。这是中国式现代化的突出特征。</li></ul></li><li><p>中国式现代化的本质要求：坚持中国共产党的领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。</p><ul><li>为什么要强调党在中国式现代化建设中的领导地位：<ul><li>党的领导决定中国式现代化的根本性质。</li><li>党的领导确保中国式现代化锚定奋斗目标行稳致远。</li><li>党的领导激发建设中国式现代化的强劲动力。</li><li>党的领导凝聚建设中国式现代化的磅礴力量。</li></ul></li></ul></li><li><p>中国式现代化创造了人类文明新形态：</p><ul><li>提供了一种全新的现代化模式，是对西方现代化理论和实践的重大超越，为广大发展中国家提供了全新选择。</li></ul></li><li><p>推行中国式现代化的重大原则：</p><ul><li>坚持和加强党的全面领导</li><li>坚持中国特色社会主义道路</li><li>坚持以人民为中心的发展思想</li><li>坚持深化改革开放</li><li>坚持发扬斗争精神</li></ul></li><li><p>推行中国式现代化需要正确处理的关系：</p><ul><li>顶层设计与实践探索。</li><li>战略与策略。</li><li>守正与创新。</li><li>效率与公平。</li><li>活力与秩序。</li><li>自立自强与对外开放。</li></ul></li><li><p>推进中国式现代化必须团结奋斗：</p><ul><li>团结奋斗是中国共产党和中国人民最显著的精神标识，是中国人民创造历史伟业的必由之路。</li><li>中华民族是有着伟大团结奋斗精神的民族，团结奋斗的价值理念深深融入并影响着中国人的精神世界。</li><li>中国式现代化是一项伟大而艰巨的任务。</li></ul></li></ol><h2 id="坚持党的全面领导">3. 坚持党的全面领导</h2><ol type="1"><li>中国最大的国情就是中国共产党的领导：<ul><li>中国共产党的领导是在历史奋斗中形成的。</li><li>中国共产党的领导是人民当家做主的可靠保障。</li><li>中国共产党的领导关系中国特色社会主义的性质、方向和命运。</li><li>中国共产党的领导是实现中华民族伟大复兴的根本保证。</li></ul></li><li>为什么中国共产党是最高政治领导力量：<ul><li>中国共产党得到最广大人民群众的支持和拥护。</li><li>由我国国家性质和政治制度体系决定。</li><li>由中华民族伟大复兴事业决定。</li></ul></li><li>中国共产党的领导是全面的、系统的、整体的。</li><li>如何维护党的中央权威和集中统一领导：<ul><li>坚决贯彻党的理论、路线方针政策和党中央决策部署。</li><li>最关键的是坚决维护习近平同志党中央的核心、全党的核心地位。</li><li>维护党中央权威和集中统一领导，同坚持党的民主集中制是完全一致的。</li></ul></li><li>中国共产党的领导是国家治理体系的核心，党的领导制度是中国特色社会主义制度建设的关键。<ul><li>党的领导制度是中国特色社会主义制度的核心，是国家治理体系和治理能力现代化的关键。</li><li>如何健全党的全面领导制度：<ul><li>完善党在各种组织发挥领导作用的制度。</li><li>完善党协调各方的机制。</li><li>完善党领导各项事业的具体制度。</li></ul></li><li>1948年初，毛泽东为中共中央起草《关于建立报告制度》的党内指示，推动建立健全全党全军向党中央报告工作的制度，加强了党中央对重大工作的领导。</li></ul></li><li>中国共产党的领导是中国特色社会主义制度的最大优势：<ul><li>中国共产党以马克思主义为行动指南，在实践中不断推进马克思主义中国化时代化，为坚持和完善中国特色社会主义制度提供强大理论优势。</li><li>中国共产党的自身优势是中国特色社会主义制度优势的主要来源。</li><li>中国共产党能够集中全党力量、凝聚全民族共同意志，在各项事业中发挥总揽全局、协调各方的作用，确保中国特色社会主义制度的显著优势充分彰显。</li></ul></li></ol><h2 id="坚持以人民为中心">4. 坚持以人民为中心</h2><ol type="1"><li><p>坚持以人民为中心，是新时代坚持和发展中国特色社会主义的根本立场，是贯穿党治国理政全部活动的一条红线。</p><ul><li>党和国家事业取得历史性成就、发生历史性变革，根本原因就在于我们党始终坚守了为中国人民谋幸福、为中华民族谋复兴的初心和使命。</li></ul></li><li><p>人民立场是中国共产党的根本政治立场，这是我们党区别于其他政党的显著标志。</p><ul><li>坚持人民立场，就要始终牢记党的初心和使命。</li><li>坚持人民立场，就要始终保持党同人民群众的血肉联系。</li><li>坚持人民立场，就要热爱人民、尊重人民、敬畏人民。</li></ul></li><li><p>坚持人民至上是新时代党治国理政的根本价值取向。</p><ul><li><p>人民是党的工作的最高裁决者和最终评判者。</p></li><li><p>党永远要依靠人民创造新的历史伟业。</p><ul><li><p>必须尊重人民主体地位：中国共产党之所以能发展壮大，中国特色社会主义之所以能不断前进，正是因为依靠了人民。</p></li><li><p>必须尊重人民首创精神：正是因为充分尊重人民首创精神，最大程度激发人民的创造热情，党的事业才能保持与时俱进的活力。</p></li></ul></li></ul></li><li><p>群众路线是党始终坚持的根本工作方法，是党的生命线和根本工作路线。</p><ul><li>调查研究是贯彻群众路线的有效途径。</li></ul></li><li><p>共同富裕是中国特色社会主义的本质要求，是中国式现代化的重要特征。</p><ul><li>实现共同富裕是关系党的执政基础的重大政治问题。<ul><li>首先通过全国人民共同的奋斗把蛋糕做大做好，然后通过合理的制度安排正确处理增长和分配关系，把蛋糕切好分好。</li><li>其次，要从全局角度来把握共同富裕。</li><li>最后，要处理好先富和共富的关系</li></ul></li><li>必须坚持正确的原则和科学的思路。<ul><li>鼓励勤劳创新致富、坚持基本经济制度、尽力而为量力而行、坚持循序渐进的原则。</li></ul></li><li>推动全体人民共同富裕与促进人的全面发展是高度统一的。</li></ul></li></ol><h2 id="全面深化改革开放">5. 全面深化改革开放</h2><h3 id="改革开放">改革开放</h3><ol type="1"><li><p>改革开放是我们前进的重要法宝。</p><ul><li>改革开放是党和人民大踏步赶上时代的重要法宝。</li><li>改革开放是坚持和发展中国特色社会主义的必由之路。</li><li>全面深化改革开放是完成新时代目标任务的必然要求。</li></ul></li><li><p>改革开放是我们党的一次伟大觉醒，孕育了我们党从理论到实践的伟大创造。</p><p>改革开放是中国人民和中华民族发展史上的一次伟大革命，推动了中国特色社会主义事业的伟大飞跃。</p><p>改革开放是当代中国最显著的特征、最壮丽的气象，是决定当代中国命运的关键一招。</p></li><li><p>党的十一届三中全会是划时代的，开启了改革开放和社会主义现代化建设新时期；</p><p>党的十八届三中全会也是划时代的，实现改革从局部探索、破冰完成到系统集成、全面深化的转变，开创了我国改革开放新局面。</p></li><li><p>新时代全面深化改革开放，就其艰巨性、复杂性和系统性来说，是一场深刻的革命。</p><ul><li><p>全面深化改革开放的基本思路：</p><ul><li>必须勇于破除一切不合时宜的思维定势和固有观念。</li><li>必须勇于打破部门利益、行业利益、本位思想。</li><li>必须勇于跳出条条框框限制。</li><li>必须勇于破解我国开放型经济体制建设中的突出问题。</li></ul></li><li><p>全面深化改革开放是一场全面、系统、整体的制度创新：</p><ul><li><p>全面深化改革开放是一场思想理论的深刻变革、改革组织方式的深刻变革、国家制度和治理体系的深刻变革、人民广泛参与的深刻变革。</p></li><li><p>坚持以供给侧结构性改革为主线，加快建设现代化经济体系。</p></li></ul></li></ul></li><li><p>全面深化改革开放的正确方向：</p><ul><li>坚持和改善党的领导、坚持和完善中国特色社会主义制度。</li><li>坚持以人民为中心，促进社会公平正义、增进人民福祉。<ul><li>社会主义改革开放的出发点和落脚点，是为了更好实现和维护人民利益、为了让人民过上好日子。</li></ul></li><li>必须有利于进一步解放思想、进一步解放和发展生产力、进一步解放和增强社会活力。<ul><li>解放思想，是开启改革开放事业的思想前提。</li><li>解放和发展生产力，是改革开放的鲜明特征和首要任务。</li><li>解放和增强社会活力，是社会主义改革的内在要求和基本目的，也是新时代全面深化改革的关键所在。</li><li>三个“进一步”，既是改革的目的，也是改革的条件。</li></ul></li></ul></li></ol><h3 id="统筹推进">统筹推进</h3><ol type="1"><li><p>全面深化改革的总目标：完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化。</p><ul><li><p>改革的根本方向是完善和发展中国特色社会主义制度。</p></li><li><p>改革的鲜明指向和时代要求是推进国家治理体系和治理能力现代化。</p></li><li><p>统筹推进各领域各方面改革开放，必须以全面深化改革总目标为引领，以制度建设为主线，以经济体制改革为重点，以重要领域和关键环节改革为突破口。</p></li></ul></li><li><p>国家治理体系是管理国家的制度体系，国家治理能力是运用国家制度管理社会的能力。</p><ul><li>国家治理体系和能力是一个国家制度和执行能力的集中体现，是相辅相成的。</li><li>怎样推进国家治理体系和治理能力现代化：<ul><li>必须坚定中国特色社会主义制度自信。</li><li>必须更好发挥中国特色社会主义制度自信。</li><li>必须把中国特色社会主义制度优势转化为国家治理效能。</li></ul></li></ul></li><li><p>全面深化改革开放的正确方法论：</p><ul><li>增强全面深化改革的系统性、整体性、协同性。</li><li>加强顶层设计和摸着石头过河相结合。</li><li>统筹改革发展稳定。<ul><li>改革是经济社会发展的强大动力，发展是解决一切经济社会问题的关键，稳定是改革发展的前提。</li></ul></li><li>胆子要大，步子要稳。</li><li>坚持重大改革于法有据。</li></ul></li><li><p>改革开放永无止境。全面深化改革开放，是新时代坚持和发展中国特色社会主义的根本动力。</p><ul><li>改革开放永无止境是社会基本矛盾运动规律的深刻反映。<ul><li>改革开放以来，我国经济社会发展取得重大成就，根本原因就是改革调整生产关系，完善上层建筑，使之适应我国生产力发展的要求，激发我国社会发展的强大活力。</li></ul></li><li>改革开放永无止境是总结世界社会主义实践经验得出的重要结论。</li><li>改革开放永无止境是推进党和人民事业发展的必然要求。</li></ul></li><li><p>开放也是改革。</p><ul><li>开放带来进步，封闭必然落后。</li><li>构建更高水平开放型经济新体制。</li><li>对外政策：坚持经济全球化正确方向，反对保护主义和单边制裁。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;今客沧桑登舞榭，万灵且待命无疆！&lt;/p&gt;</summary>
    
    
    
    <category term="习近平新时代中国特色社会主义理论概论" scheme="http://example.com/categories/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E6%A6%82%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>习概_导论</title>
    <link href="http://example.com/2024/09/01/%E4%B9%A0%E6%A6%82/%E5%AF%BC%E8%AE%BA/"/>
    <id>http://example.com/2024/09/01/%E4%B9%A0%E6%A6%82/%E5%AF%BC%E8%AE%BA/</id>
    <published>2024-09-01T04:00:00.000Z</published>
    <updated>2024-12-16T03:30:33.984Z</updated>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1 id="导论">导论</h1><h2 id="基本内容">基本内容</h2><ol type="1"><li><p>习近平新时代中国特色社会主义思想创立的时代背景：</p><ul><li>世界百年未有之大变局加速演进。</li><li>中华民族伟大复兴进入关键时期。</li><li>中国式现代化全面推进拓展。</li><li>科学社会主义在21世纪的中国焕发新的蓬勃生机。</li><li>中国共产党自我革命开辟新的境界。</li></ul></li><li><p>两个结合是我们党在探索中国特色社会主义道路中得出的规律性认识，是我们成功的最大法宝。</p><ul><li>马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合。</li></ul></li><li><p>习近平新时代中国特色社会主义思想是完整的科学体系：</p><ul><li>科学回答的重大时代课题：<ul><li>新时代坚持和发展怎样的中国特色社会主义。</li><li>建设什么样的社会主义现代化强国。</li><li>建设什么样的长期执政的马克思主义政党。</li></ul></li><li>主体内容：十个明确，集中体现了主要观点和基本精神，发挥统摄作用。</li><li>坚持和发展中国特色社会主义的基本方略：十四个坚持。</li><li>理论与实践成果：十三个方面成就。</li><li>世界观和方法论：六个必须坚持。</li></ul></li><li><p>习近平中国特色社会主义思想的历史地位：</p><ul><li><p>是当代中国马克思主义、21世纪马克思主义，是中华文化和中国精神的时代精华，实现了马克思主义中国化时代化新的飞跃。</p></li><li><p>使魂脉和根脉内在贯通，相互成就，是中华民族的文化主体性最有力的体现，是中华文化和中国精神的时代精华。</p></li><li><p>是全党全国各族人民为实现中华民族伟大复兴而奋斗的行动指南，是新时代党和国家事业发展的根本遵循。</p></li></ul></li><li><p>两个确立：</p><ul><li>确立习近平同志党中央的核心、全党的核心地位。</li><li>确立习近平新时代中国特色社会主义思想的指导地位。</li></ul></li><li><p>两个确立的决定性意义：</p><ul><li>坚强的领导核心和科学的理论指导是关乎党和国家前途命运、党和人民事业成败的根本性问题。</li><li>两个确立对新时代党和国家事业发展、对推进中华民族伟大复兴历史进程具有决定性意义。</li></ul></li></ol><h2 id="六个必须坚持">六个必须坚持</h2><p>必须坚持人民至上、自信自立、守正创新、问题导向、系统观念、胸怀天下。</p><ol type="1"><li>坚持人民至上是根本立场，体现了历史唯物主义群众观。</li><li>坚持自信自立是内在精神特质，体现了客观规律性和主观能动性的有机结合。</li><li>坚持守正创新是鲜明理论品格，体现了变与不变、继承与发展的内在联系。</li><li>坚持问题导向是重要实践要求，体现了矛盾的普遍性和客观性。</li><li>坚持系统观念是基本思想和工作方法，体现了辩证唯物主义普遍联系的原理。</li><li>坚持胸怀天下是中国共产党人的境界格局，体现了马克思主义追求人类进步和解放的崇高理想。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;今客沧桑登舞榭，万灵且待命无疆！&lt;/p&gt;</summary>
    
    
    
    <category term="习近平新时代中国特色社会主义理论概论" scheme="http://example.com/categories/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E6%A6%82%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>软件质量管理_工程技术</title>
    <link href="http://example.com/2024/06/24/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/4.%20%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2024/06/24/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/4.%20%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/</id>
    <published>2024-06-24T04:00:00.000Z</published>
    <updated>2024-06-27T12:26:01.951Z</updated>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="工程技术">4. 工程技术</h1><h2 id="需求">4.1 需求</h2><ol type="1"><li>需求开发</li></ol><p>需求是一切工程活动的基础。</p><p>需求类别：</p><ul><li>客户需求</li><li>产品需求</li><li>产品组件需求</li></ul><ol start="2" type="1"><li>需求获取</li></ol><p>客户所受到的限制也应当作为需求开发过程中需要重点关注的内容。</p><ul><li><p>通常采取所谓的需求“诱导”方式进行。</p></li><li><p>“诱导”一词的含义不仅仅是普通的需求采集，它隐含了应更加积极地、前瞻性地识别那些客户没有明确提供的额外需求。</p></li></ul><ol start="3" type="1"><li>需求汇总</li></ol><ul><li>整理各种来源的信息，识别缺失的信息</li><li>解决冲突的需求</li><li>需求的整理和转化</li><li>推导未显式描述的需求内容</li></ul><ol start="4" type="1"><li>需求验证</li></ol><p>对需求进行分析和确认，以确保符合使用者预期</p><p>典型活动包括</p><ul><li>建立和维护操作概念和相关的场景</li><li>分析需求</li><li>确认需求</li></ul><ol start="5" type="1"><li>需求文档</li></ol><p>需求开发工作完成的一个基本标志是形成了一份完整的、规范的、经过评审的需求规格说明书。</p><p>需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。</p><p>特征：内聚、完整、一致、原子、可跟踪、非过期、可行性、非二义性、强制、可验证</p><h2 id="设计">4.2 设计</h2><p>考虑点：</p><ol type="1"><li><p>团队智慧</p><p>发挥团队智慧两大挑战：</p><ul><li>确定整体架构之前很难进行分工</li><li>鼓励团队成员在讨论和评审会议中的参与程度</li></ul></li><li><p>设计标准</p><p>命名规范、接口标准、系统出错信息、设计表示标准</p></li><li><p>复用</p><p>建立一套复用管理流程，具体而言，包括</p><ul><li><p>复用接口标准</p></li><li><p>复用文档标准</p></li><li><p>复用质量保证机制</p></li></ul></li><li><p>可测试性</p><p>尽可能减少测试代码的数量，制作合理的测试计划。</p></li><li><p>可用性</p><ul><li>在设计阶段就开始考虑。</li><li>针对每一个关键功能都定义操作概念和操作场景。</li><li>可以邀请最终用户参与场景的评审，使用模拟、原型等技术，更好的把握用户真实意图。</li></ul></li></ol><h2 id="实现">4.3 实现</h2><p>考虑点：评审、复用、可用性。</p><h2 id="集成">4.4 集成</h2><ul><li>大爆炸集成策略</li><li>逐一添加集成策略</li><li>集簇集成策略</li><li>扁平化集成策略</li></ul><h2 id="验证和确认">4.5 验证和确认</h2><p>都是为了提升最终产品的质量而采取的措施。</p><p>目的不同。</p><ul><li><p>验证是目的是确保选定的工作产品与事先指定给该工作产品的需求一致。</p></li><li><p>确认的目标则是确保开发完成的产品或者产品组件在即将要使用该产品或者产品组件的环境中工作正确。</p></li></ul><p>验证和确认活动：</p><ol type="1"><li><p>环境准备</p></li><li><p>对象选择</p></li><li><p>活动实施</p></li><li><p>结果分析</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;高堂明镜悲白发，朝如青丝暮成雪。&lt;/p&gt;</summary>
    
    
    
    <category term="软件质量管理" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>软件质量管理_质量管理</title>
    <link href="http://example.com/2024/06/23/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/3.%20%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2024/06/23/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/3.%20%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/</id>
    <published>2024-06-23T04:00:00.000Z</published>
    <updated>2024-06-27T15:20:59.245Z</updated>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="质量管理">3. 质量管理</h1><h2 id="概念">3.0 概念</h2><p>软件质量：</p><p>与软件产品满足规定的和隐含的需求能力有关的特征或者特性的全体。</p><h3 id="面向用户的质量观">3.0.1 面向用户的质量观</h3><p>定义质量为满足用户需求的程度。在这个定义中，就需要进一步明确：</p><ul><li>用户究竟是谁？</li><li>用户需求的优先级是什么？</li><li>这种用户的优先级对软件产品的开发过程产生什么样的影响？</li><li>怎样来度量这种质量观下的质量水平？</li></ul><h3 id="质量管理策略">3.0.2 质量管理策略</h3><p>用缺陷管理来替代质量管理。</p><ul><li><p>高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷。</p></li><li><p>PSP：各个组件的高质量是通过高质量评审来实现的</p></li></ul><h4 id="测试消除缺陷流程">测试消除缺陷流程</h4><ol type="1"><li>发现异常行为</li><li>理解工作方式</li><li>找出出错原因</li><li>确定修改方案</li><li>测试修改有效</li></ol><h4 id="评审发现缺陷流程">评审发现缺陷流程</h4><ol type="1"><li>理解程序流程</li><li>发现缺陷的位置和原因</li><li>修正缺陷</li></ol><h2 id="评审">3.1 评审</h2><h3 id="质量控制指标">3.1.1 质量控制指标</h3><h4 id="yield">Yield</h4><p>度量每个阶段在消除缺陷方面的效率。</p><ul><li>Phase Yield = <spanclass="math inline">\(100\times\frac{某阶段发现的缺陷个数}{某阶段注入的缺陷个数+进入该阶段前遗留的缺陷个数}\)</span></li><li>Process Yield = <spanclass="math inline">\(100\times\frac{第一次编译前发现的缺陷个数}{第一次编译前注入的缺陷个数}\)</span></li></ul><h4 id="afr">A/FR</h4><p>PSP质检成本/PSP失效成本。</p><ul><li>理论上，A/FR的值越大，往往意味着越高的质量。</li><li>过高的A/FR往往意味着做了过多的评审，反而会导致开发效率的下降。</li><li>作为指南，在PSP中A/FR的期望值就是2.0。</li></ul><h4 id="pqi">PQI</h4><p>5个数据乘积：</p><ul><li>设计质量：设计的时间应该大于编码的时间</li><li>设计评审质量：设计评审的时间应该大于设计时间的50%</li><li>代码评审质量：代码评审时间应该大于编码时间的50%</li><li>代码质量：代码的编译缺陷密度应当小于10个/千行</li><li>程序质量：代码单元测试缺陷密度应当小于5个/千行</li></ul><h4 id="评审速度">评审速度</h4><p>评审速度(Review Rate)是一个用以指导软件工程师开展有效评审的指标。</p><ul><li>高质量的评审需要软件工程师投入足够的时间进行评审。</li><li>在PSP的实践中，代码评审速度小于200 LOC/小时，文档评审速度小于4Page/小时。</li></ul><h4 id="drl">DRL</h4><p>缺陷消除效率比，度量的是不同缺陷消除手段消除缺陷的效率。</p><ul><li><p>计算方式：</p><p>以某个测试阶段（一般为单元测试）每小时发现的缺陷数为基础，其他阶段每小时发现缺陷数与该测试阶段每小时发现的缺陷的比值就是DRL。</p></li></ul><h3 id="其他因素">3.1.2 其他因素</h3><p>打印后评审往往效果更好</p><ul><li>单个屏幕可以展现的内容比较有限</li><li>评审人员的注意力</li></ul><p>评审时机选择：编译（UT）之前 VS. 之后</p><p>个人评审和小组评审</p><ul><li><p>小组评审意义</p></li><li><p>先后顺序</p></li></ul><h2 id="质量路径">3.2 质量路径</h2><h3 id="质量路径-1">3.2.1 质量路径</h3><p>Step 1：各种测试</p><p>Step 2：进入测试之前的产物质量提升</p><p>Step 3：评审过程度量和稳定</p><p>Step 4：质量意识和主人翁态度</p><p>Step 5：个体review的度量和稳定</p><p>Step 6：诉诸设计</p><p>Step 7：缺陷预防</p><p>Step 8：用户质量观——其他质量属性</p><h3 id="设计">3.2.2 设计</h3><h4 id="设计内容">设计内容</h4><table><thead><tr class="header"><th></th><th><strong>动态信息</strong></th><th><strong>静态信息</strong></th></tr></thead><tbody><tr class="odd"><td><strong>外部信息</strong></td><td>交互信息（服务、消息等）</td><td>功能（继承、类结构等）</td></tr><tr class="even"><td><strong>内部信息</strong></td><td>行为信息（状态机）</td><td>结构信息（属性、业务逻辑等）</td></tr></tbody></table><h5 id="psp设计模板">PSP设计模板</h5><ul><li><p>操作规格模板（Operational Specification Template，简称OST）</p></li><li><p>功能规格模板（Functional Specification Template，简称FST）</p></li><li><p>状态规格模板（State Specification Template，简称SST）</p></li><li><p>逻辑规格模板（Logical Specification Template，简称LST）</p></li></ul><table><thead><tr class="header"><th></th><th><strong>动态信息</strong></th><th><strong>静态信息</strong></th></tr></thead><tbody><tr class="odd"><td><strong>外部信息</strong></td><td>OST/FST</td><td>FST</td></tr><tr class="even"><td><strong>内部信息</strong></td><td>SST</td><td>LST</td></tr></tbody></table><h5 id="uml图">UML图</h5><table><thead><tr class="header"><th></th><th><strong>动态信息</strong></th><th><strong>静态信息</strong></th></tr></thead><tbody><tr class="odd"><td><strong>外部信息</strong></td><td>用例图、时序图</td><td>类图</td></tr><tr class="even"><td><strong>内部信息</strong></td><td>状态机图</td><td>？</td></tr></tbody></table><h4 id="设计层次">设计层次</h4><figure><img src="/image/软件质量管理/设计层次.png" alt="设计层次" /><figcaption aria-hidden="true">设计层次</figcaption></figure><p>PSP模板</p><figure><img src="/image/软件质量管理/PSP设计模板.png" alt="PSP设计模板" /><figcaption aria-hidden="true">PSP设计模板</figcaption></figure><h3 id="设计评审">3.2.3 设计评审</h3><h4 id="状态机验证">状态机验证</h4><p>正确状态机：完整、正交</p><p>验证方法：</p><ul><li>检验状态机，消除死循环和陷阱状态。</li><li>检查状态转换，验证完整性和正交性。</li><li>评价状态机，检验是否体现设计意图。</li></ul><h4 id="符号化执行">符号化执行</h4><p>符号化验证方法的基本思想是将描述设计的逻辑规格（一般用伪代码程序表示）用代数符号来表示，然后系统地开展分析和验证。具体步骤如下：</p><ol type="1"><li>识别伪码程序中的关键变量</li><li>将这些变量用代数符号表示，重写伪码程序</li><li>分析伪码程序的行为</li></ol><p>优缺点：</p><ol type="1"><li><p>实施简单，可以给出一般化的验证结果。</p></li><li><p>通常用在验证一些复杂算法中，特别是对遗留系统的改造中，往往应用这种方法来识别和理解原有的设计。</p></li><li><p>不适用于有复杂逻辑的场合，而且，纯手工的验证方法也容易引入一些人为的错误。</p></li></ol><h4 id="执行表">执行表</h4><p>用一种有序的方法来跟踪伪码程序的执行状况，分析程序行为，从而验证设计。具体步骤如下：</p><ol type="1"><li>识别伪码程序的关键变量</li><li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量</li><li>初始化被选定的变量</li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ol><h4 id="跟踪表">跟踪表</h4><p>跟踪表验证方法是对执行表验证方法的一种扩充。具体步骤如下：</p><ol type="1"><li>识别伪码程序的关键变量</li><li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量</li><li>初始化被选定的变量</li><li>识别将伪码程序符号化的机会，并加以符号化</li><li>定义并且优化用例组合</li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ol><h4 id="正确性检验">正确性检验</h4><p>将伪码程序当成数学定理，采用形式化方法加以推理和验证。这种方法的步骤如下：</p><ol type="1"><li>分析和识别用例</li><li>对于复杂伪码程序的结构，应用正确性检验的标准问题逐项加以验证</li><li>对于不能明确判断的复杂程序结构，使用跟踪表等辅助验证。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;高堂明镜悲白发，朝如青丝暮成雪。&lt;/p&gt;</summary>
    
    
    
    <category term="软件质量管理" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>软件质量管理_项目管理</title>
    <link href="http://example.com/2024/06/22/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/2.%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2024/06/22/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/2.%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2024-06-22T04:00:00.000Z</published>
    <updated>2024-06-27T15:19:31.254Z</updated>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="项目管理">2. 项目管理</h1><p>管理的三大关键要素：</p><ul><li>目标</li><li>状态</li><li>纠偏</li></ul><h2 id="概念">2.0 概念</h2><p>应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。</p><h3 id="三大目标">三大目标</h3><p>成本、质量、工期。</p><h2 id="团队动力学">2.1 团队动力学</h2><h3 id="知识工作">2.1.1 知识工作</h3><p>软件开发是一项既复杂又富有创造性的知识工作。</p><ul><li>处理和讨论极其抽象的概念</li><li>把不同的部分（不可见）整合成一个可以工作的系统</li></ul><h4 id="知识工作管理">知识工作管理</h4><p>关键规则：管理者无法管理工作者，知识工作者必须实现并且学会自我管理。</p><p>知识工作者必须</p><ul><li>有积极性</li><li>能做出准确的估算和计划</li><li>懂得协商承诺</li><li>有效跟踪他们的计划</li><li>持续地按计划交付高质量产物</li></ul><h4 id="领导者">领导者</h4><p>知识工作者的管理需要的是领导者，而不是经理。</p><h4 id="激励手段">激励手段</h4><p>三种主要手段</p><ol type="1"><li>威逼</li><li>利诱</li><li>鼓励承诺</li></ol><h5 id="领导方式">领导方式</h5><p>交易型</p><ul><li>承诺奖励激励</li><li>人们通常能找到新的方式来获得奖励，同时少做工作。</li><li>威逼和利诱属于交易型领导方式。</li></ul><p>转变型</p><ul><li>用成就激励</li><li>鼓励承诺属于转变型领导方式。</li></ul><p>交易型领导方式很少能产生成功并且有创造性的团队，因此转变型领导方式是首选。</p><h6 id="承诺激励">承诺激励</h6><p>个人级别的差异</p><ul><li>有些人对待承诺十分认真。</li><li>有些人对待承诺十分轻率。</li></ul><p>当满足以下情况，团队承诺比个人承诺的激励作用更大</p><ul><li>所有团队成员共同参与作出承诺。</li><li>团队依赖于每一位成员履行自己的承诺。</li></ul><p>一个软件开发团队在制定承诺时，要保证</p><ul><li>承诺是自愿的</li><li>承诺是公开的</li><li>承诺是可信（行）的</li><li>向团队承诺</li></ul><h6 id="维持激励">维持激励</h6><p>维持激励需要及时的绩效反馈。</p><p>包括</p><ul><li>根据一个详细计划衡量进度</li><li>当前计划不准确时重做计划</li><li>为漫长而富有挑战性的项目提供中间反馈，即里程碑</li></ul><h5 id="马斯洛需求层次理论">马斯洛需求层次理论</h5><figure><img src="/image/软件质量管理/maslo.png" alt="maslo" /><figcaption aria-hidden="true">maslo</figcaption></figure><ol type="1"><li>自我实现是最高的层次</li><li>激励来自为没有满足的需求而努力奋斗</li><li>低层次的需求必须在高层次需求满足之前得到满足</li><li>满足高层次的需求的途径比满足低层次的途径更为广泛</li></ol><h5 id="期望理论">期望理论</h5><ol type="1"><li><p>海兹伯格：</p><ul><li>激励因素（内在因素）：<ul><li>成就感，责任感，晋升，被赏识、认可</li></ul></li><li>保健因素（外在因素）：<ul><li>工作环境，薪金，工作关系，安全等</li></ul></li></ul></li><li><p>麦克勒格X理论</p><ul><li>不喜欢他们的工作并努力逃避工作</li><li>缺乏进取心，没有解决问题与创造的能力</li><li>更喜欢经常的指导，避免承担责任，缺乏主动性</li><li>自我中心，对组织需求反应淡漠，反对变革</li></ul><p>用马斯洛的底层需求（生理和安全）进行激励。</p></li><li><p>麦克勒格Y理论</p><ul><li>如果给予适当的激励和支持性的工作氛围，会达到很高的绩效预期</li><li>具有创造力，想象力，雄心和信心来实现组织目标</li><li>能够自我约束，自我导向与控制，渴望承担责任</li></ul><p>用马斯洛的高层需求（自尊和自我实现）进行激励。</p></li><li><p>期望理论</p><p>人们在下列情况下能够受到激励并且出大量成果<spanclass="math inline">\(M=V\times E\)</span></p><ul><li>相信他们的努力很可能会产生成功的结果（V）</li><li>他们也相信自己会因为成功得到相应的回报（E）</li></ul></li></ol><h3 id="自主团队">2.1.2 自主团队</h3><p>自主团队具备如下的特点：</p><ul><li>自行定义项目的目标</li><li>自行决定团队组成形式以及成员的角色</li><li>自行决定项目的开发策略</li><li>自行定义项目的开发过程</li><li>自行制定项目的开发计划</li><li>自行度量、管理和控制项目工作</li></ul><h4 id="外部环境">外部环境</h4><p>项目启动阶段获得管理层的支持。</p><ul><li>体现出已经尽最大的可能在满足管理层的需求的工作态度。</li><li>在计划中体现定期需要向管理层报告的内容。</li><li>向管理层证明他们所制定的工作计划是合理的。</li><li>在计划中体现为了追求高质量而开展的工作。</li><li>在工作计划中允许必要的项目变更。</li><li>向管理层寻求必要的帮助。</li></ul><p>在项目进展过程中获得管理层的支持</p><ul><li>严格遵循定义好的开发过程开展项目开发工作。</li><li>维护和更新项目成员的个人计划和团队计划。</li><li>对产品质量进行管理。</li><li>跟踪项目进展，并定期向管理层报告。</li><li>持续地向管理层展现优异的项目表现。</li></ul><h4 id="tsp启动过程">TSP启动过程</h4><ol type="1"><li>第一次会议：建立产品目标和业务目标</li><li>第二次会议：角色分配、小组目标定义</li><li>第三次会议：开发流程定义与策略选择</li><li>第四次会议：整体计划</li><li>第五次会议：质量计划</li><li>第六次会议：个人计划以及计划平衡</li><li>第七次会议：风险评估</li><li>第八次会议：准备向管理层汇报计划</li><li>第九次会议：向管理层汇报计划内容</li><li>启动总结</li></ol><h4 id="tsp角色和职责">TSP角色和职责</h4><p>领导者和经理的区别</p><table><thead><tr class="header"><th><strong>角色经理</strong></th><th><strong>团队领导者</strong></th></tr></thead><tbody><tr class="odd"><td>告知</td><td>倾听</td></tr><tr class="even"><td>指导</td><td>询问</td></tr><tr class="odd"><td>说服</td><td>激励/挑战</td></tr><tr class="even"><td>决定</td><td>促进达成一致</td></tr><tr class="odd"><td>控制</td><td>教练</td></tr><tr class="even"><td>监控</td><td>授权</td></tr><tr class="odd"><td>设定目标</td><td>挑战</td></tr></tbody></table><ol type="1"><li><p>项目组长：</p><ul><li>建设和维持高效率的团队。</li><li>激励团队成员积极工作。</li><li>合理处理团队成员的问题。</li><li>向管理层提供项目进度相关的完整信息。</li><li>充当合格的会议组织者和协调者。</li></ul></li><li><p>计划经理：</p><p>开发完整的、准确的团队计划和个人计划，每周准确的报告项目小组状态。</p></li><li><p>开发经理：</p><p>开发优秀的软件产品，充分利用团队成员的技能。</p></li><li><p>质量经理：</p><ul><li><p>项目团队严格按照质量计划开展工作，开发出高质量的软件产品</p></li><li><p>所有的小组评审工作都正常开展，并且都形成了评审报告</p></li></ul></li><li><p>过程经理：</p><ul><li>所有团队成员准确的记录、报告和跟踪过程数据。</li><li>所有的团队会议都有相应会议记录。</li></ul></li><li><p>支持经理</p><ul><li>项目小组在整个开发过程中都有合适的工具和环境</li><li>跟踪项目小组的风险和问题</li><li>项目小组在开发过程中满足复用目标</li></ul></li><li><p>开发人员</p></li></ol><h4 id="scrum角色和职责">SCRUM角色和职责</h4><p>典型SCRUM团队由一名产品负责人、开发团队和一名SCRUM Master组成。</p><ul><li>SCRUM团队是跨职能的自组织团队</li></ul><ol type="1"><li><p>产品负责人：</p><p>职责：将开发团队开发的产品价值最大化。</p><p>工作：管理产品待办列表的唯一负责人。</p></li><li><p>开发团队：</p><p>负责在每个 Sprint 结束时交付潜在可发布并且“完成”的产品增量。</p></li><li><p>Scrum Master：</p><p>促进和支持SCRUM，帮助每个人理解 SCRUM理论、实践、规则和价值。</p></li></ol><h2 id="估算计划和跟踪">2.2 估算、计划和跟踪</h2><h3 id="估算">2.2.1 估算</h3><p>目的：给各类计划提供决策依据</p><p>对象：规模、时间和日程</p><p>怎么做估算？</p><ol type="1"><li><p>估算要的是过程，而非结果；估算的过程是相关干系人达成一致共识的过程</p></li><li><p>最终目标是达成共识</p></li><li><p>建立信心</p><ul><li><p>足够详细</p></li><li><p>依赖数据</p></li><li><p>最好的猜测（注意检验猜测所依据的假设）</p></li></ul></li></ol><h4 id="probe估算方法">PROBE估算方法</h4><p>精确度量往往不便于早期估算，有助于早期估算的度量往往难以产生精确结果。</p><p>PROBE：精确度量和早期规划之间的桥梁。</p><p>PROBE估算流程：</p><ol type="1"><li>概要设计</li><li>代理识别和代理规模</li><li>估算并调整程序规模/资源</li><li>计算预测区间</li></ol><p>概要设计过程：</p><ol type="1"><li>确定产品功能，以及产生这些功能所需的程序组件/模块</li><li>将这些程序组件/模块与你以前写的程序相比较，估算它们的规模</li><li>将程序组件/模块估算综合给出总规模</li></ol><p>估算结果整合：</p><ul><li>整合一个开发人员做的多个估算<ul><li>累积各个部分的估算</li><li>进行一次线性回归计算</li><li>计算一个预测区间</li></ul></li><li>多个开发人员可以整合独立进行的估算，通过以下方式<ul><li>进行单独的线性回归预测</li><li>将计划的规模或者时间相加</li><li>将个人范围的平方相加，再对其计算平方根获得预测区间</li></ul></li></ul><h4 id="srum故事点">SRUM故事点</h4><p>度量实现一个故事需要付出的工作量。</p><ul><li><strong>抽象：</strong>混合了对于开发特性所要付出的努力、开发复杂度、个中风险以及类似东西</li><li><strong>相对：</strong>设定标准之后，考虑其他特性与标准之间的相对大小关系</li></ul><h3 id="计划">2.2.2 计划</h3><h4 id="工作分解结构">工作分解结构</h4><p>创建方法：</p><ol type="1"><li>识别和分析可交付成果及相关工作；</li><li>确定工作分解结构的结构与编排方法；</li><li>自上而下逐层细化分解；</li><li>为工作分解结构组成部分制定和分配标志编码；</li><li>核实工作分解的程度是必要且充分的。</li></ol><p>检查标准：</p><ol type="1"><li>最底层要素不能重复，即任何一个工作包只应该在 WBS中的一个地方出现。</li><li>所有要素必须清晰完整定义，即相应的数据词典必须完整定义。</li><li>最底层要素必须有定义清晰的责任人，可以支持成本估算和进度安排。</li><li>最底层的要素是实现目标的成分必要条件，即项目的工作范围得到完整体现。</li></ol><h4 id="通用计划框架">通用计划框架</h4><figure><img src="/image/软件质量管理/通用计划框架.png" alt="通用计划框架" /><figcaption aria-hidden="true">通用计划框架</figcaption></figure><h4 id="各类计划">各类计划</h4><ol type="1"><li><p>质量计划</p><ul><li><p>确定需要开展的质量保证活动。</p></li><li><p>典型的质量保证活动：个人评审、团队评审、单元测试、集成测试、系统测试、验收测试等。</p></li><li><p>需要解决的关键问题：该开展哪些活动，以及这些活动开展的程度，如时间、人数和目标。</p></li></ul></li><li><p>风险计划</p><ul><li>目的：在风险发生前，识别出潜在的问题，以便在产品或项目的生命周期中规划和实施风险管理活动，以消除潜在问题对项目产生的负面影响。</li><li>风险管理：<ul><li>风险识别<ul><li>识别与成本、进度及绩效相关的风险，审查可能影响项目的环境因素、工作分解结构的所有组件、项目计划的所有组件</li><li>记录风险的内容、条件及可能的结果，识别每一风险相关的干系人</li><li>利用已定义的风险参数，评估已识别的风险，依照定义的风险类别，将风险分类并分组，排列降低风险的优先级</li></ul></li><li>风险应对：制定相应的风险管理策略。<ul><li>风险转嫁</li><li>风险解决</li><li>风险缓解</li></ul></li></ul></li></ul></li></ol><h3 id="跟踪">2.2.3 跟踪</h3><p>目的：了解项目进度。</p><ul><li><p>在项目实际进展与计划产生严重偏离时，可采取适当的纠正措施。</p></li><li><p>项目进度滞后与否需要参照物，即项目计划。</p></li><li><p>项目跟踪需要管理针对偏差而采取的纠偏措施。</p></li></ul><h4 id="挣值管理方法">挣值管理方法</h4><p>Earned Value Management，简称EVM。</p><ul><li><p>每项任务实现附以一定价值</p></li><li><p>100%完成该项任务，就获得相应价值</p></li></ul><p>采用与进度计划、成本预算和实际成本相联系的三个独立的变量，进行项目绩效测量。</p><ul><li><p>简单实现：</p><p>仅仅关注进度信息。</p><ol type="1"><li><p>建立 WBS，定义工作范围</p></li><li><p>为 WBS 中每一项工作定义一个价值（PV）</p></li><li><p>最后按照一定的规则将某一数值赋给已经完成的工作或者正在进行的工作。</p><p>常用规则分别为 0-100 规则和 50-50规则，前者只有当某项任务完成时，该任务的 PV 值将转化成 EV值；后者只需要开始某项任务，即可以赋原 PV 值的 50%作为 EV值，完成时，再加上另外的 50%。而实际完成的工作所需成本 AC 不对 EV值产生任何影响。</p></li></ol></li><li><p>中级实现在简单实现的基础上，加入日程偏差的计算。典型计算方式有：</p><ul><li>日程偏差 SV = EV – PV；</li><li>日程偏差指数 SPI = EV/PV；</li></ul></li><li><p>高级实现在中级实现的基础上，还需要考察项目的实际成本。</p></li></ul><h5 id="常用evm度量">常用EVM度量</h5><p>BAC表示按照PV值的曲线，当项目完成的时候所需预算或者时间</p><p>成本差异CV = EV-AC</p><p>成本差异指数CPI = EV/AC</p><p>日程偏差SV = EV – PV</p><p>日程偏差指数SPI = EV/PV</p><p>预计完成成本EAC = AC+(BAC-EV)/CPI = BAC/CPI</p><h5 id="燃尽图">燃尽图</h5><p>纵坐标为总估计时间，横坐标为迭代时间线，估计曲线为估计的剩余任务，实际曲线为实际的剩余任务。</p><h5 id="局限性">局限性</h5><p>EVM 一般不能应用软件项目的质量管理。</p><p>EVM需要定量化的管理机制，这就使其在一些探索型项目以及常用的敏捷开发方法中的应用受到限制</p><p>EVM完全依赖项目的准确估算，然而在项目早期，很难对项目进行非常准确的估算。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;高堂明镜悲白发，朝如青丝暮成雪。&lt;/p&gt;</summary>
    
    
    
    <category term="软件质量管理" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>软件质量管理_概述</title>
    <link href="http://example.com/2024/06/21/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/1.%20%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2024/06/21/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/1.%20%E6%A6%82%E8%BF%B0/</id>
    <published>2024-06-21T04:00:00.000Z</published>
    <updated>2024-06-27T08:42:17.823Z</updated>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="概述">1. 概述</h1><h2 id="软件危机">1.0 软件危机</h2><p>软件在改变（定义？颠覆？）我们的世界。</p><p>软件自身的变化：规模、比例。</p><h3 id="软件四大本质困难和挑战">软件四大本质困难和挑战</h3><p>复杂性、不可见性、可变性、一致性</p><ul><li>除了不可见性，其他三个本质难题因项目而异</li><li>四大本质难题相互促进</li><li>本质难题变化带动软件方法（过程）演变</li></ul><h3 id="软件危机-1">软件危机</h3><p>软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。</p><h3 id="软件工程">软件工程</h3><p>一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。</p><p>软件工程的两大视角</p><ul><li>管理视角——能否复制成功？</li><li>技术视角——是否可以将问题解决得更好？</li></ul><h2 id="软件项目与过程管理">1.1 软件项目与过程管理</h2><p>管理的三大关键要素：</p><ul><li>目标</li><li>状态</li><li>纠偏</li></ul><h3 id="软件项目管理">1.1.1 软件项目管理</h3><p>应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。</p><ul><li>三大目标：成本、质量、工期</li><li>估算、计划、跟踪、风险管理、范围管理、人员管理、沟通管理，等等</li></ul><p>核心问题：复制成功</p><h4 id="软件过程">软件过程</h4><p>为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合</p><ul><li>这组实践间往往有一定先后顺序，作为整体来实现事先定义的一个或者多个目标。</li></ul><h4 id="广义软件过程">广义软件过程</h4><p>理论基石：软件产品和服务的质量，很大程度上取决于生产维护该软件或者服务的过程的质量。</p><p>广义软件过程包括技术、人员以及狭义过程。</p><ul><li>也称软件开发方法、软件开发过程。</li><li>极限编程方法、SCRUM方法、Gate方法</li><li>敏捷软件过程／方法、轻量型过程／方法以及重型过程／方法等</li></ul><h4 id="生命周期模型">生命周期模型</h4><p>对软件过程的一种人为的划分。</p><ul><li>生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分。</li><li>生命周期模型往往不包括技术实践。</li><li>瀑布模型、迭代式模型、增量模型、螺旋模型、原型法等等</li></ul><h3 id="软件过程管理">1.1.2 软件过程管理</h3><p>管理对象：软件过程</p><p>目的：让软件过程在开发效率、质量等方面有着更好性能绩效</p><ul><li>软件项目管理：产品生产管理（SCRUM、Kanban）</li><li>软件过程管理：流水线的设计、建设、维护、优化（CMMI、SPICE）</li></ul><h4 id="软件过程改进">软件过程改进</h4><ul><li>管理参考模型：CMM/CMMI、SPICE</li><li>改进参考元模型：PDCA、IDEAL</li></ul><h2 id="软件发展三大阶段">1.2 软件发展三大阶段</h2><ol type="1"><li>软硬件一体化阶段（50年代~70年代）</li></ol><ul><li>软件完全依附于硬件</li><li>软件作坊</li></ul><ol start="2" type="1"><li>软件成为独立的产品（70年代~90年代）</li><li>网络化和服务化（90年代中期迄今）</li></ol><h3 id="软硬件一体化">1.2.1 软硬件一体化</h3><h4 id="软件完全依附于硬件">软件完全依附于硬件</h4><p>软件应用典型特征：</p><ul><li><p>软件支持硬件完成计算任务</p></li><li><p>功能单一</p></li><li><p>复杂度有限</p></li><li><p>几乎不需要需求变更</p></li></ul><p>软件开发典型特征</p><ul><li>硬件太贵</li><li>团队以硬件工程师和数学家为主</li></ul><p>实践：Measure twice, cut once</p><h4 id="软件作坊">软件作坊</h4><p>软件应用典型特征</p><ul><li>功能简单</li><li>规模小</li></ul><p>软件开发典型特征</p><ul><li>很多非专业领域的人员涌入软件开发领域</li><li>高级程序语言出现</li><li>质疑权威文化盛行</li></ul><p>实践：Code and fix</p><h3 id="软件成为独立产品">1.2.2 软件成为独立产品</h3><p>软件应用特征</p><ul><li>摆脱了硬件束缚</li><li>功能强大</li><li>规模和复杂度剧增</li><li>个人电脑出现，普通人成为软件用户<ul><li>需求多变</li><li>兼容性要求</li></ul></li><li>来自市场的压力</li></ul><p>实践：</p><ul><li>形式化方法</li><li>结构化程序设计、瀑布模型</li><li>CMM/CMMI</li></ul><h3 id="网格化和服务化">1.2.3 网格化和服务化</h3><p>软件应用特征</p><ul><li>功能更复杂，规模更大</li><li>用户数量急剧增加（这会带来什么问题？）</li><li>快速演化和需求不确定</li><li>分发方式的变化（SaaS）</li></ul><p>典型软件过程和实践</p><ul><li><p>迭代式</p></li><li><p>敏捷宣言</p><ul><li>个体和互动胜过流程和工具</li><li>可以工作的软件胜过详尽的文档</li><li>客户合作胜过合同谈判</li><li>响应变化胜过遵循计划</li></ul></li><li><p>XP、SCRUM、Kanban</p></li><li><p>开源软件开发方法</p></li></ul><h3 id="软件发展现状">1.2.4 软件发展现状</h3><p>软件应用典型特征</p><ul><li><p>进一步服务化和网络化（移动是主流）</p></li><li><p>用户需求多样性进一步凸显</p></li><li><p>软件产品和服务的地位变化</p></li><li><p>错综复杂的部署环境</p></li><li><p>近乎苛刻的用户期望</p><ul><li>多：功能丰富，个性化</li><li>快：快速使用，及时更新，快速解决问题</li><li>好：稳定，可靠，安全，可信</li><li>省：用户的获得成本低，最好免费</li></ul></li></ul><p>软件开发典型特征</p><ul><li>空前强大的开发和部署环境——XaaS<ul><li>IaaS</li><li>PaaS</li><li>SaaS, FaaS</li></ul></li><li>盛行共享和开源</li><li>潜在支撑获得了长足进步（AI，Bigdata， Cloud，etc.）</li></ul><p>典型DevOps实践和方法</p><ul><li>方法论基础：敏捷软件开发、精益思想以及Kanban方法。</li><li>以领域驱动设计为指导的微服务架构方式</li><li>大量虚拟化技术的使用</li><li>一切皆服务的理念指导</li><li>构建了强大的工具链，支持高水平自动化</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;高堂明镜悲白发，朝如青丝暮成雪。&lt;/p&gt;</summary>
    
    
    
    <category term="软件质量管理" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>软件系统设计_软件架构复习</title>
    <link href="http://example.com/2024/06/14/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2024/06/14/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%A4%8D%E4%B9%A0/</id>
    <published>2024-06-14T04:00:00.000Z</published>
    <updated>2024-06-23T16:49:06.534Z</updated>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="软件架构复习">软件架构复习</h1><h2 id="总览">0. 总览</h2><ol type="1"><li>软件架构</li><li>质量属性</li><li>架构模式</li><li>架构设计</li><li>架构文档化</li><li>架构评价</li><li>微服务</li></ol><h2 id="软件架构">1. 软件架构</h2><h3 id="什么是软件架构">1.1 什么是软件架构？</h3><p>程序或计算系统的结构，由软件元素、这些元素外部可⻅的属性、这些元素的关系组成。</p><h3 id="软件架构师做什么">1.2 软件架构师做什么？</h3><p>联络：客户、技术团队和业务需求分析师</p><p>软件工程</p><p>技术知识</p><p>风险管理。</p><h3 id="架构来自哪里">1.3 架构来自哪里？</h3><p>NFRs、ASRs、质量要求、涉众、组织、技术环境、业务目标</p><h3 id="架构41视图">1.4 架构4+1视图</h3><p>逻辑视图：描述架构中重要的元素及其之间的关系</p><p>进程视图：描述架构的并发和通信元素</p><p>物理视图：描述主要过程和元素是如何被映射到应⽤程序硬件</p><p>开发视图：捕获软件组件的内部组织</p><p>架构⽤例：捕获架构的需求；与多个特定视图关联</p><h3 id="架构活动和过程">1.5 架构活动和过程</h3><h4 id="架构活动">架构活动</h4><ul><li><p>创造系统的商业案例</p></li><li><p>理解需求</p></li><li><p>创造和选择架构</p></li><li><p>与包括开发者在内的涉众沟通架构</p></li><li><p>分析或评估架构</p><ul><li><p>总的⽅法</p></li><li><p>质量特定技术</p></li></ul></li><li><p>实现架构</p></li><li><p>确保架构符合要求</p></li></ul><h4 id="架构过程">架构过程</h4><ol type="1"><li>确定ASRs</li><li>架构设计</li><li>文档化</li><li>架构评估</li></ol><h3 id="软件架构知识领域">1.6 软件架构知识领域</h3><p>软件设计基本概念</p><ul><li><p>总体设计概念</p></li><li><p>上下⽂：软件开发⽣命周期——需求、设计、构建和测试</p></li><li><p>设计过程（⻆⾊、活动、⼯作产品）</p></li><li><p>软件设计的可⽤⼯具</p></li></ul><p>关键技术问题：并⾏性、事件控制和处理、分布式、异常处理、交互式系统、持久化</p><p>软件结构和架构</p><ul><li><p>架构结构和视点</p></li><li><p>架构样式和模式（宏观架构）</p></li><li><p>设计模式（微观架构）</p></li></ul><p>软件设计⽅法</p><ul><li><p>架构⽅法（如属性驱动设计）</p></li><li><p>设计⽅法（如动态系统开发⽅法）</p></li></ul><p>软件设计质量分析和评估</p><ul><li><p>质量属性</p></li><li><p>质量分析和评估⽅法、技术、⼯具</p><ul><li><p>设计审查（如 SEI 的架构权衡分析⽅法）</p></li><li><p>静态分析和动态分析</p></li><li><p>模拟和原型</p></li></ul></li><li><p>度量</p><ul><li><p>指标：架构层次</p></li><li><p>与技术有关的度量</p></li></ul></li></ul><p>设计建模和表示</p><ul><li><p>架构和设计标记（架构描述语⾔ ADL Architecture DescriptionLanguages）</p></li><li><p>统⼀建模语⾔（UML）</p></li><li><p>设计⽂档（视图和超越视图）</p></li><li><p>其他：视能⼒、关注点和领域⽽定</p></li></ul><h2 id="质量属性">2. 质量属性</h2><h3 id="软件需求">2.1 软件需求</h3><h4 id="功能需求">功能需求</h4><p>系统必须完成的、为涉众提供价值的内容。</p><ul><li>功能的实现可能⽤了很多的结构，但功能是与结构⽆关的。</li></ul><h4 id="质量需求nfrs">质量需求（NFRs）</h4><p>整个系统的期望特征，在功能需求之上。</p><ul><li>如果质量属性很重要，软件架构将约束功能的分配到不同的结构。</li></ul><h4 id="约束">约束</h4><p>0 ⾃由度、预定义的设计决定</p><ul><li>接受设计决定、协调其他受影响的设计决定，如此来满⾜约束</li></ul><h3 id="质量属性-1">2.2 质量属性</h3><p>内部/外部属性</p><h4 id="建模质量属性场景">建模质量属性场景</h4><p>源、刺激、制品、环境、响应、度量</p><h4 id="举例">举例</h4><p>可用性、互操作性、可修改性、性能、安全性、可测试性、其他</p><h4 id="质量属性战术">质量属性战术</h4><p>战术是影响质量属性响应控制的设计决定。</p><ul><li>战术的集合被称为架构策略。</li></ul><h4 id="架构设计决策检查列表">架构设计决策检查列表</h4><h3 id="架构重要需求">2.3 架构重要需求</h3><p>在架构上有深刻影响的需求。</p><p>如何收集、确认ASRs：</p><ol type="1"><li>从需求文档收集</li><li>采访涉众</li><li>理解业务目标</li><li>质量属性效用树</li></ol><h2 id="架构模式">3. 架构模式</h2><h3 id="架构模式-1">3.1 架构模式</h3><p>⼀系列在实践中能反复地看到的设计决定。</p><ul><li>上下文：经常出现的、普遍的、引起问题的情形</li><li>问题：适当地概括的，在给定上下⽂中出现</li><li>解决方案：成功的、适当抽象的架构解决⽅案</li></ul><h3 id="模块模式">3.2 模块模式</h3><p>分层模式（微内核模式）</p><h3 id="组件-连接件模式">3.3 组件-连接件模式</h3><p>代理人模式、MVC模式、管道、过滤器模式、C/S模式、P2P模式、SO模式、发布-订阅模式、数据共享模式</p><h3 id="分配模式">3.4 分配模式</h3><p>Map-Reduce模式、Multi-Tier模式</p><h3 id="模式与战术">3.5 模式与战术</h3><ol type="1"><li><p>战术⽐模式简单：使⽤单⼀的结构或机制来处理单⼀的架构要求</p></li><li><p>模式通常将多个设计决定合并到⼀个包</p></li><li><p>模式和战术⼀起构成了软件架构师的主要⼯具</p></li><li><p>战术是设计的建造⽅块，⽤来创建架构模式</p></li><li><p>⼤多数模式由⼏个不同的战术组成</p><ul><li><p>所有战术为了⼀个共同⽬的</p></li><li><p>经常被选择来保证不同的质量属性</p></li></ul></li></ol><h2 id="架构设计">4. 架构设计</h2><h3 id="通用设计策略">4.1 通用设计策略</h3><p>抽象、分解、迭代、重用</p><h3 id="设计决策分类">4.2 设计决策分类</h3><p>职责、协调、数据、资源、元素映射、技术</p><h3 id="属性驱动设计add">4.3 属性驱动设计（ADD）</h3><p>输⼊：需求</p><p>输出：软件元素、⻆⾊、职责、属性、关系</p><p>步骤：</p><ol type="1"><li>确认需求</li><li>选择并分解元素</li><li>识别ASR</li><li>选择满足ASR的设计<ul><li>确认关注点</li><li>列出可选项（模式/战术）</li><li>选择模式/战术</li><li>决定模式/战术和ASR间关系</li><li>捕捉初步架构视图</li><li>解决不一致</li></ul></li><li>实例化元素，分配职责</li><li>定义元素接口</li><li>验证、细化需求</li><li>重复2-7直到所有架构重要需求被满足</li></ol><h2 id="架构文档化">5. 架构文档化</h2><h3 id="视图">5.1 视图</h3><h4 id="样式模式和视图">样式、模式和视图</h4><p>架构样式：元素和关系类型的专⻔化，以及如何使⽤它们的⼀组约束。</p><p>架构模式：软件系统中的基础结构组织⽅法的表达。</p><ul><li>架构模式关注问题和上下午，样式侧重方法。</li></ul><p>样式的三个分类：</p><ul><li>一组样式单元：模块样式</li><li>一组有运行时行为和交互的元素：组件-连接件样式</li><li>与环境中的非软件结构关联：分配样式</li></ul><p>架构视图：⼀组系统元素及其关系的表示。</p><ul><li>视图让我们将系统实体划分成感兴趣和易于管理的系统表示。</li><li>不同的视图⽀持不同的⽬标和⽤户，凸显出不同系统元素和关系</li><li>不同视图在不同程度上展现不同的质量属性</li></ul><h4 id="结构性视图">结构性视图</h4><h5 id="模块视图">模块视图</h5><p>模块是提供⼀套连贯的职责的实现单元。</p><p>包含：</p><ul><li>分解视图 Decomposition view</li><li>使⽤视图 Uses view</li><li>概括视图 Generalization view</li><li>分层视图 Layered view</li><li>⽅⾯视图 Aspects view</li><li>数据模型视图 Data model view</li></ul><p>元素：模块，提供⼀套连贯职责的实现单元</p><p>关系：</p><ul><li><p>“⼀部分”：部分⼦模块和整体聚合模块之间的部分、整体关系</p></li><li><p>“依赖于”：两个模块之间的依赖关系。特定的模块视图详细说明了依赖关系的含义</p></li><li><p>“是”：更具体的⼦模块和更⼀般的⽗模块之间的泛化、专⻔化关系</p></li></ul><p>约束：不同模块视图可能会施加特定的拓扑约束，例如限制模块之间的可⻅性。</p><p>⽤途</p><ul><li><p>代码构建蓝图</p></li><li><p>变更影响分析</p></li><li><p>规划增量开发</p></li><li><p>需求追踪分析</p></li></ul><h5 id="组件-连接件视图">组件-连接件视图</h5><p>显示运行时组件。</p><ul><li><p>例如进程、对象、客户机、服务器和数据存储</p></li><li><p>“连接”指明了哪些连接器连接到哪些组件。</p></li></ul><p>包含：</p><ul><li>管道-过滤器视图 Pipe-and-filter view</li><li>客户机-服务端视图 Client-server view</li><li>点对点视图 Peer-to-peer view</li><li>⾯向服务架构视图 Service-oriented view</li><li>发布-订阅视图 Publish-subscribe view</li><li>共享数据视图 Shared-data view</li><li>多层视图 Multi-tier view</li></ul><p>元素：</p><ul><li><p>组件。主要处理单元和数据存储。组件有⼀组端⼝，通过这些端⼝与其他组件进⾏交互（通过连接器）</p></li><li><p>连接器。组件间交互的途径。连接器有⼀组⻆⾊（接⼝），指示组件如何在交互中使⽤连接器</p></li></ul><p>约束：</p><ul><li><p>组件只能连接到连接器，⽽不是直连其他组件</p></li><li><p>连接器只能连接到组件，⽽不是直连其他连接器</p></li><li><p>连接只能在相容的端⼝和⻆⾊上建⽴</p></li><li><p>接⼝委托只能在两个相容端⼝或⻆⾊上定义</p></li><li><p>连接器不能孤⽴出现，必须连接到组件</p></li></ul><p>⽤途</p><ul><li><p>演示系统如何⼯作</p></li><li><p>通过指定运⾏时元素的结构和⾏为来指导开发</p></li><li><p>帮助解释运⾏时系统质量属性，如性能和可⽤性</p></li></ul><h5 id="分配视图">分配视图</h5><p>描述了软件单元到软件开发或执⾏环境元素的映射。</p><p>包含：</p><ul><li>部署视图 Deployment view</li><li>安装视图 Install view</li><li>⼯作安排视图 Work assignment view</li><li>其他分配视图 Other allocation view</li></ul><p>元素</p><ul><li><p>软件元素。软件元素具有环境所需的属性</p></li><li><p>环境元素。环境元素具有提供给软件的属性</p></li></ul><p>关系：被分配。软件元素被分配到环境元素，属性取决于特定视图。</p><p>⽤途：</p><ul><li><p>⽤于对性能、可⽤性、安全性 security 和安全性 safety进⾏解释</p></li><li><p>⽤于解释分布式开发和将⼯作分配给团队</p></li><li><p>⽤于解释软件版本的并⾏访问</p></li><li><p>⽤于解释系统安装的形式和机制</p></li></ul><h4 id="质量视图">质量视图</h4><p>包含</p><ul><li><p>安全视图 Security view</p></li><li><p>性能视图 Performance view</p></li><li><p>可靠性视图 Reliability view</p></li><li><p>通信视图 Communication view</p></li><li><p>异常视图 Exception view（错误处理视图 error- handlingview）</p></li></ul><h3 id="视图文档化">5.2 视图文档化</h3><h3 id="选择视图">选择视图</h3><h4 id="选择视图-1">选择视图</h4><ol type="1"><li><p>构建涉众-视图表</p></li><li><p>组合视图</p><ol type="1"><li>确定上表中的边缘视图</li><li>通过将⼀个视图的元素与另⼀个视图中的元素相关联，将每个边缘视图与另⼀个更具⽀持性的视图相结合</li></ol></li><li><p>确定优先级和阶段</p><ul><li><p>分解视图</p></li><li><p>⼋⼆开原则</p></li><li><p>按顺序完成所有视图</p></li></ul></li></ol><h4 id="涉众文档">涉众文档</h4><p>左列是涉众的类别，右列是对应涉众如何使⽤这个⽂档。</p><h4 id="涉众-视图表">涉众-视图表</h4><p>左边是涉众，右边每⼀列都是⼀个视图，值分别表示：</p><ul><li>d 详细信息</li><li>s ⼀些细节</li><li>o ⼤概信息</li><li>x ⽆所谓。</li></ul><h3 id="超越视图">5.3 超越视图</h3><p>文档信息、架构信息、视图间映射。</p><h2 id="架构评价">6. 架构评价</h2><h3 id="架构分析评价方法">6.1 架构分析+评价方法</h3><p>软件架构分析⽅法 SAAM，Software Architecture Analysis Method</p><p>架构层级可修改性分析 ALMA，Architecture Level ModifiabilityAnalysis</p><p>软件架构性能评估 PASA，Performance Assessment of SoftwareArchitecture</p><p>架构权衡分析⽅法 ATAM，Architecture Trade-off Analysis Method</p><h3 id="atam">6.2 ATAM</h3><p>架构权衡分析⽅法，Architecture Tradeoff Analysis Method</p><ol start="0" type="1"><li><p>合作与准备</p><p>参与者：团队领导和主要项目决策者</p><p>输入：架构文档</p><p>输出：评价计划</p></li><li><p>评估1</p><p>参与者：评估团队和项目决策者</p><p>输出：架构展示、业务驱动因素、质量属性需求优先级列表、效用树、风险、敏感点和权衡点</p><ol type="1"><li>展示 ATAM</li><li>展示业务驱动因素</li><li>展示架构</li><li>识别架构⽅法</li><li>⽣成效⽤树</li><li>分析架构⽅法</li></ol></li><li><p>评估2</p><p>参与者：评估团队、项目决策者、架构涉众</p><p>输出：涉众社区的优先级场景列表、风险主题和受威胁的业务驱动因素</p><ol type="1"><li>展示 ATAM 和结果</li><li>头脑⻛暴和定优先级</li><li>分析架构⽅法</li><li>展示结果</li></ol></li><li><p>后续⾏动</p><p>参与者：评估团队和主要涉众</p><p>输出：最终评估报告</p></li></ol><h4 id="atam输出">ATAM输出</h4><ul><li>架构的简短展示</li><li>业务⽬标的表达</li><li>由质量属性场景表达的定优先级的质量属性需求</li><li>效⽤树</li><li>⼀组⻛险和⾮⻛险</li><li>⼀组⻛险主题</li><li>从架构决定到质量需求的映射</li><li>⼀组确定的敏感点和权衡点</li><li>最终评估报告</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;天生我材必有用，千金散尽还复来。&lt;/p&gt;</summary>
    
    
    
    <category term="软件系统设计" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>软件系统设计_详细设计复习</title>
    <link href="http://example.com/2024/06/13/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2024/06/13/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/</id>
    <published>2024-06-13T04:00:00.000Z</published>
    <updated>2024-06-23T08:50:39.269Z</updated>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="详细设计复习">详细设计复习</h1><h2 id="软件模式">1. 软件模式</h2><p>软件开发的总体指导思路或参照样板。</p><ul><li>软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等。</li><li>在软件生存期的每一个阶段都存在着一些被认同的模式。</li></ul><h3 id="组成">组成</h3><ul><li>问题描述</li><li>前提条件(环境或约束条件)</li><li>解法</li><li>效果。</li></ul><h3 id="大三律">大三律</h3><p>只有经过三个以上不同类型(或不同领域)系统的校验，一个解决方案才能从候选模式升格为模式。</p><h2 id="设计模式">2.设计模式</h2><p>被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><h3 id="基本要素">基本要素</h3><ul><li>模式名称 (Pattern name)</li><li>问题 (Problem)</li><li>解决方案 (Solution)</li><li>效果 (Consequences)</li></ul><h3 id="分类">分类</h3><p>根据其目的分为</p><ul><li>创建型（Creational）：创建对象</li><li>结构型（Structural）：处理类或对象的组合</li><li>行为型（Bahavioral）：描述对类或对象怎样交互和分配职责</li></ul><p>根据范围，即模式主要用于处理类/对象之间关系分为</p><ul><li>类模式：处理类和子类的关系，这些关系在编译时确定，是静态的</li><li>对象模式：处理对象间关系，这些关系在运行时变化，是动态的</li></ul><h3 id="考察内容">考察内容</h3><table><thead><tr class="header"><th>范围/目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr class="odd"><td>类模式</td><td>工厂方法模式</td><td>（类）适配器模式</td><td>模板方法模式</td></tr><tr class="even"><td>对象模式</td><td>抽象工厂模式<br />原型模式</td><td>（对象）适配器模式<br />组合模式<br />装饰模式<br />外观模式</td><td>命令模式<br />中介者模式<br />观察者模式<br />状态模式<br />策略模式</td></tr></tbody></table><h3 id="设计模式与类库框架">设计模式与类库框架</h3><ol type="1"><li><p>设计模式比库的层次更高。设计模式告诉我们如何构建类和对象以解决特定问题。</p></li><li><p>框架和库不是设计模式；它们提供了具体的实现，我们将这些实现链接到我们的代码中。</p></li></ol><h2 id="设计原则">3. 设计原则</h2><p>对于面向对象的软件系统设计来说，在支持可维护性的同时，需要提高系统的可复用性。</p><ul><li>软件的复用可以提高软件的开发效率和软件质量，节约开发成本。</li><li>恰当的复用还可以改善系统的可维护性。</li></ul><p>目标：开闭原则</p><p>指导：最小知识原则</p><p>基础：单一职责原则、可变性封装原则</p><p>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</p><ol type="1"><li><p>开闭原则：一个软件实体应当对扩展开放，对修改关闭。</p></li><li><p>单一职责原则：一个类只负责一个功能领域中的相应职责。</p></li><li><p>里氏代换原则：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</p></li><li><p>依赖倒转原则：</p><p>抽象不应该依赖于细节，细节应该依赖于抽象</p><p>针对接口编程，不要针对实现编程。</p></li><li><p>接口隔离原则：客户端不应该依赖那些它不需要的接口。</p><ul><li>将一些大的接口细化成一些小的接口供客户端使用。</li></ul></li><li><p>合成复用原则：复用时尽量使用对象组合，而不使用继承。</p></li><li><p>迪米特法则：一个软件实体应当尽可能少的与其他实体发生相互作用。</p></li></ol><h2 id="表驱动法">4. 表驱动法</h2><h3 id="目标">目标</h3><p>将复杂逻辑从代码中⽴出来，以便于单独维护。</p><h3 id="原理">原理</h3><p>从表⾥⾯查找信息⽽不使⽤逻辑语句。</p><h3 id="查询">查询</h3><h4 id="直接访问">直接访问</h4><p>通过索引值（如下标）直接从表中找到对应的条⽬。</p><h4 id="索引访问">索引访问</h4><p>当⽆法直接从表中查询需要的条⽬时，就需要借助其他⽅法先获取表键值</p><ul><li>⽅法：先⽤⼀个基本类型的数据从索引表中查出⼀个键值，然后再⽤这⼀键值查出主数据。</li></ul><h4 id="阶梯访问">阶梯访问</h4><p>基本思想：通过确定每项命中的阶梯层次确定其归类。</p><ul><li>⽐索引访问⽅法节省空间，当阶梯多了⽐较次数就多。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;天生我材必有用，千金散尽还复来。&lt;/p&gt;</summary>
    
    
    
    <category term="软件系统设计" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>软件系统设计_设计模式</title>
    <link href="http://example.com/2024/06/12/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2024/06/12/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-06-12T04:00:00.000Z</published>
    <updated>2024-06-23T08:37:10.042Z</updated>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="设计模式">设计模式</h1><p>被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><h2 id="概念">0. 概念</h2><h3 id="基本要素">基本要素</h3><ul><li>模式名称 (Pattern name)</li><li>问题 (Problem)</li><li>解决方案 (Solution)</li><li>效果 (Consequences)</li></ul><h3 id="分类">分类</h3><p>根据其目的分为</p><ul><li>创建型（Creational）：创建对象</li><li>结构型（Structural）：处理类或对象的组合</li><li>行为型（Bahavioral）：描述对类或对象怎样交互和分配职责</li></ul><p>根据范围，即模式主要用于处理类/对象之间关系分为</p><ul><li>类模式：处理类和子类的关系，这些关系在编译时确定，是静态的</li><li>对象模式：处理对象间关系，这些关系在运行时变化，是动态的</li></ul><h3 id="设计模式与类库框架">设计模式与类库框架</h3><ol type="1"><li><p>设计模式比库的层次更高。设计模式告诉我们如何构建类和对象以解决特定问题。</p></li><li><p>框架和库不是设计模式；它们提供了具体的实现，我们将这些实现链接到我们的代码中。</p></li></ol><h3 id="考察内容">考察内容</h3><table><thead><tr class="header"><th>范围/目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr class="odd"><td>类模式</td><td>工厂方法模式</td><td>（类）适配器模式</td><td>模板方法模式</td></tr><tr class="even"><td>对象模式</td><td>抽象工厂模式<br />原型模式</td><td>（对象）适配器模式<br />组合模式<br />装饰模式<br />外观模式</td><td>命令模式<br />中介者模式<br />观察者模式<br />状态模式<br />策略模式</td></tr></tbody></table><h2 id="工厂模式">1. 工厂模式</h2><h3 id="简单工厂模式">简单工厂模式</h3><p>专门定义一个类来负责创建其他类的实例，根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><ul><li><p>又称静态工厂模式。</p></li><li><p>将对象的创建和对象本身业务处理分离可以降低系统的耦合度。</p></li></ul><h3 id="工厂方法模式">工厂方法模式</h3><p>简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这违背了开闭原则。</p><h4 id="概念-1">概念</h4><p>工厂方法模式（Factory Method Pattern）又称为工厂模式。</p><ul><li>也叫虚拟构造器（Virtual Constructor）模式、多态工厂（PolymorphicFactory）模式。</li></ul><ol type="1"><li>工厂父类负责定义创建产品对象的公共接口</li><li>工厂子类则负责生成具体的产品对象</li></ol><p>通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><ul><li>允许系统在不修改工厂角色的情况下引进新产品。</li></ul><h4 id="优缺点">优缺点</h4><p>优点：</p><ol type="1"><li>用户只需要关心所需产品对应的工厂，无须关心创建细节、具体产品类名。</li><li>工厂可以自主确定创建何种对象、如何创建对象。</li><li>在系统中加入新产品时，只要添加具体工厂和具体产品。</li></ol><p>缺点：</p><ol type="1"><li>添加新产品时系统中类的个数成对增加，提高了系统复杂度。</li><li>系统中加入抽象层，提高了系统理解难度和实现难度。</li></ol><h4 id="适用环境">适用环境</h4><ol type="1"><li>一个类不知道它所需要的对象的类。</li><li>一个类通过其子类来指定创建哪个对象。</li><li>客户端不需要关心是哪一个工厂子类，需要时动态指定。<ul><li>可将具体工厂类名存储在数据库或配置文件中。</li></ul></li></ol><h4 id="配置文件实例化具体工厂">配置文件实例化具体工厂</h4><p>将具体类的类名写入配置文件中，再通过Java的反射机制，读取XML格式的配置文件，根据存储在XML文件中的类名字符串生成对象。</p><h3 id="抽象工厂模式">抽象工厂模式</h3><p>有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p><ul><li>产品等级结构：产品的继承结构</li><li>产品族：由同一个工厂生产的 ，位于不同产品等级结构中的一组产品</li></ul><h4 id="问题">问题</h4><p>系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品。</p><h4 id="概念-2">概念</h4><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p><ul><li><p>又称为Kit模式。</p></li><li><p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p></li><li><p>工厂方法模式针对一个产品等级结构，而抽象工厂模式需要面对多个。</p></li></ul><h4 id="优缺点-1">优缺点</h4><p>优点：</p><ol type="1"><li>隔离了具体类的生成，只需改变具体工厂的实例，就在某种程度上改变整个软件系统的行为。</li><li>实现高内聚低耦合的设计目的。</li><li>保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的具体工厂和产品族修改已有系统，符合开闭原则。</li></ol><p>缺点：</p><p>添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品。</p><ul><li>即：增加新的工厂和产品族容易，增加新的产品等级结构麻烦。</li></ul><h4 id="和工厂方法模式区别">和工厂方法模式区别</h4><p>工厂模式创建同一个产品的不同类型，抽象工厂模式创建不同类的产品。</p><ul><li>产品种类单一，适合用工厂模式。</li><li>有多个种类，各种类型时，适合抽象工厂模式。</li></ul><h4 id="适用环境-1">适用环境</h4><p>对所有的工厂模式：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节。</p><ol type="1"><li>系统中有多于一个的产品族，属于同一个产品族的产品将在一起使用。</li><li>所有的产品以同样的接口出 现，从而使客户端不依赖于具体实现。</li></ol><h3 id="模式扩展">模式扩展</h3><h4 id="开闭原则的倾斜性">开闭原则的倾斜性</h4><ol type="1"><li><p>增加产品族：对于增加新的产品族，工厂模式很好的支持了开闭原则，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</p></li><li><p>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持开闭原则。</p></li></ol><h4 id="工厂模式的退化">工厂模式的退化</h4><ol type="1"><li>只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式。</li><li>工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li></ol><h2 id="原型模式">2. 原型模式</h2><h3 id="概念-3">概念</h3><p>用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><ul><li><p>基本工作原理：</p><p>将一个原型对象传给要发动创建的对象，该对象请求原型对象拷贝原型自身来实现创建。</p></li><li><p>包含角色：抽象原型类、具体原型类、客户类</p></li><li><p>类包含一些成员对象，在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为深克隆和浅克隆。</p></li><li><p>clone()满足：</p><ol type="1"><li>对任何的对象x，都有x.clone() !=x，即克隆对象与原对象不是同一个对象。</li><li>对任何的对象x，都有x.clone().getClass()==x.getClass()，克隆对象与原对象类型一样。</li><li>如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</li></ol></li></ul><h3 id="优缺点-2">优缺点</h3><p>优点：</p><ol type="1"><li>简化对象的创建过程，通过已有实例提高新实例的创建效率。</li><li>动态增加或减少产品类。</li><li>可以使用深克隆保存对象的状态。</li></ol><p>缺点：</p><ol type="1"><li>需要为每一个类配备一个克隆方法。</li><li>实现深克隆的代码较为复杂。</li></ol><h3 id="适用环境-2">适用环境</h3><ol type="1"><li>创建新对象成本较大。</li><li>系统要保存对象的状态。</li><li>避免使用分层次的工厂类来创建分层次的对象。</li></ol><h3 id="模式扩展-1">模式扩展</h3><p>相似对象复制：通过原型模式获得相同对象后再对其属性进行修改，从而获取所需对象。</p><h2 id="适配器模式">3. 适配器模式</h2><h3 id="概念-4">概念</h3><p>将一个接口转换成客户希望的另一个接口。</p><ul><li>也称包装器（Wrapper）。</li><li>既可以作为类结构型模式，也可以作为对象结构型模式。</li><li>包含角色：目标抽象类、适配器类、适配者类、客户类</li></ul><h3 id="优缺点-3">优缺点</h3><p>适配器模式优点：</p><ol type="1"><li>将目标类和适配者类解耦。<ul><li>通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li></ul></li><li>增加了类的透明性和复用性。</li><li>灵活性和扩展性好。<ul><li>通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合开闭原则。</li></ul></li></ol><p>类适配器：</p><p>优点：适配器类是适配者类的子类，可以置换一些适配者的方法，灵活性强。</p><p>缺点：在很多编程语言中适配器类不能同时适配多个适配者类。</p><p>对象适配器：</p><p>优点：同一个适配器可以把适配者类和它的子类都适配到目标接口。</p><p>缺点：不容易置换适配者类的方法。</p><h3 id="适用环境-3">适用环境</h3><ol type="1"><li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ol><h3 id="模式扩展-2">模式扩展</h3><h4 id="默认适配器模式">默认适配器模式</h4><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式。</p><h4 id="双向适配器">双向适配器</h4><p>如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器。</p><h2 id="组合模式">4. 组合模式</h2><h3 id="概念-5">概念</h3><p>组合多个对象形成树形结构以表示“整体-部分”的结构层次。</p><ul><li><p>对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。</p></li><li><p>又称“整体-部分”（Part-Whole）模式</p></li><li><p>包含角色：抽象构件、叶子构件、容器构件、客户类</p></li><li><p>关键：</p><p>定义一个抽象构件类，既可以代表叶子，又可以代表容器，递归组合成树形结构。</p><p>而客户端针对该抽象构件类进行编程。</p></li></ul><h3 id="优缺点-4">优缺点</h3><p>优点：</p><ol type="1"><li>清楚地定义分层次的复杂对象。</li><li>客户端可以一致的使用组合结构或其中单个对象。</li><li>定义了包含叶子对象和容器对象的类层次结构，递归组合成树形结构。</li><li>更容易在组合体内加入对象构件。</li></ol><p>缺点：</p><ol type="1"><li>设计更加抽象困难。</li><li>很难对容器中的构件类型进行限制。</li></ol><h3 id="适用环境-4">适用环境</h3><ol type="1"><li>需要表示一个对象整体或部分层次。</li><li>客户端可以针对抽象构件编程，无须关心对象层次结构的细节。</li><li>对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们。</li></ol><h2 id="装饰模式">5. 装饰模式</h2><h3 id="概念-6">概念</h3><p>动态地给一个对象增加一些额外的职责。</p><ul><li><p>又称包装器（Wrapper），和适配器别名相同，但使用场合不同。</p></li><li><p>包含角色：抽象构件、具体构件、抽象装饰类、具体装饰类</p></li><li><p>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性。</p><ul><li>继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。</li><li>关联关系使系统具有较好的松耦合性， 因此使得系统更加容易维护。</li><li>关联关系的缺点是比继承关系要创建更多的对象。</li></ul></li></ul><h3 id="优缺点-5">优缺点</h3><p>优点：</p><ol type="1"><li>提供比继承更多的灵活性。</li><li>通过一种动态的方式来扩展一个对象的功能。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。</li><li>具体构件类与具体装饰类可以独立变化。</li></ol><p>缺点：</p><ol type="1"><li>产生很多小对象。</li><li>装饰模式比继承更加易于出错，排错也很困难。<ul><li>对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul></li></ol><h3 id="适用环境-5">适用环境</h3><ol type="1"><li>以动态、透明的方式给单个对象添加职责。</li><li>动态地给一个对象增加、撤销功能。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。<ul><li>系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长</li><li>类定义不能继承（final类）。</li></ul></li></ol><h3 id="模式扩展-3">模式扩展</h3><h4 id="装饰模式简化">装饰模式简化</h4><ol type="1"><li>一个装饰类的接口必须与被装饰类的接口保持相同。</li><li>不要把太多的逻辑和状态放在具体构件类中。</li><li>如果只有一个具体构件类而没有抽象构件类，抽象装饰类可以作为具体构件类的直接子类。</li></ol><h4 id="透明装饰模式和半透明装饰模式">透明装饰模式和半透明装饰模式</h4><ul><li>透明装饰模式：完全针对抽象编程，不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型。</li><li>半透明装饰模式：允许声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li></ul><h2 id="外观模式">6. 外观模式</h2><h3 id="概念-7">概念</h3><p>外部与一个子系统的通信通过统一的外观对象进行，为子系统中的一组接口提供一致的界面。</p><ul><li><p>Facade Pattern</p></li><li><p>包含角色：外观、子系统</p></li><li><p>在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性。</p></li><li><p>通过引入一个新的外观类降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p></li></ul><h3 id="优缺点-6">优缺点</h3><p>优点：</p><ol type="1"><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。</li><li>实现了子系统与客户之间的松耦合关系。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ol><p>缺点：</p><ol type="1"><li>不能很好地限制客户使用子系统类。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了开闭原则。</li></ol><h3 id="适用环境-6">适用环境</h3><ol type="1"><li>为一个复杂子系统提供一个简单接口。</li><li>客户程序与多个子系统之间存在很大的依赖性。</li><li>使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ol><h3 id="模式扩展-4">模式扩展</h3><ol type="1"><li>在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互。</li><li>不要试图通过外观类为子系统增加新行为。</li><li>抽象外观类。</li></ol><h2 id="模板方法模式">7. 模板方法模式</h2><h3 id="概念-8">概念</h3><p>定义一个操作中算法的骨架，而将一些步骤延迟到子类中。</p><ul><li><p>使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></li><li><p>包含角色：抽象类、具体子类</p></li><li><p>只有类之间的继承关系，没有对象关联关系</p></li><li><p>模板方法：</p><p>定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。</p></li></ul><h3 id="优缺点-7">优缺点</h3><p>优点：</p><ol type="1"><li>在一个类中抽象地定义算法，而由它的子类实现细节的处理。</li><li>是代码复用的一项基本技术。</li><li>导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合开闭原则。</li></ol><p>缺点：</p><p>导致类的个数增加。</p><h3 id="适用环境-7">适用环境</h3><ol type="1"><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类。</li><li>对一些复杂的算法进行分割。</li><li>控制子类的扩展。</li></ol><h3 id="模式扩展-5">模式扩展</h3><h4 id="好莱坞原则">好莱坞原则</h4><p>子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，父类控制对子类的调用。</p><h4 id="钩子方法的使用">钩子方法的使用</h4><p>使得子类可以控制父类的行为。</p><ol type="1"><li><p>最简单的钩子方法就是空方法，也可以在钩子方法中定义一个默认的实现，如果子类不覆盖钩子方法，则执行父类的默认实现代码。</p></li><li><p>比较复杂一点的钩子方法可以对其他方法进行约束，这种钩子方法通常返回一个boolean类型，即返回true或false，用来判断是否执行某一个基本方法。</p></li></ol><h2 id="命令模式">8. 命令模式</h2><p>动机：对发送者和接收者完全解耦，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p><h3 id="概念-9">概念</h3><p>将请求封装为对象，从而使我们可用不同的请求对客户进行参数化。</p><ul><li><p>对请求排队或者记录请求日志，以及支持可撤销的操作。</p></li><li><p>包含如下角色：抽象命令类、具体命令类、调用者、接收者、客户类</p></li><li><p>本质：对命令进行封装，将发出命令的责任和执行命令的责任分割开。</p></li><li><p>允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口。</p></li><li><p>关键：引入了抽象命令接口，发送者针对抽象命令接口编程。</p></li></ul><h3 id="优缺点-8">优缺点</h3><p>优点：</p><ol type="1"><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的Undo和Redo。</li></ol><p>缺点：</p><p>可能会导致某些系统有过多的具体命令类。</p><h3 id="适用环境-8">适用环境</h3><ol type="1"><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销操作和恢复操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令。</li></ol><h2 id="中介者模式">9. 中介者模式</h2><p>动机：</p><p>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式。</p><h3 id="概念-10">概念</h3><p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><ul><li><p>Mediator Pattern</p></li><li><p>又称调停者模式</p></li><li><p>包含如下角色：抽象中介者、具体中介者、抽象同事类、具体同事类</p></li><li><p>职责：中转与协调</p></li></ul><h3 id="优缺点-9">优缺点</h3><p>优点：</p><ol type="1"><li>简化对象之间交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ol><p>缺点：</p><p>具体中介者类非常复杂，使得系统难以维护。</p><h3 id="适用环境-9">适用环境</h3><ol type="1"><li><p>系统中对象间存在复杂引用关系。</p></li><li><p>一个对象由于引用了其他很多对象并且直接和这些对象通信而难以复用。</p></li><li><p>通过一个中间类来封装多个类中的行为。</p></li></ol><h2 id="观察者模式">10. 观察者模式</h2><p>动机：</p><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系。</p><h3 id="概念-11">概念</h3><p>定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</p><ul><li><p>又称发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p></li><li><p>让主题和观察者之间松耦合。</p></li></ul><h3 id="优缺点-10">优缺点</h3><p>优点：</p><ol type="1"><li>实现表示层和数据逻辑层的分离。<ul><li>定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li></ul></li><li>在观察目标和观察者之间建立一个抽象的耦合。</li><li>支持广播通信。</li><li>符合开闭原则的要求。</li></ol><p>缺点：</p><ol type="1"><li>如果观察者太多，将所有的观察者都通知到会花费很多时间。</li><li>观察者和观察目标之间的循环依赖会导致系统崩溃。</li><li>没有相应的机制让观察者知道所观察的目标对象如何发生变化。</li></ol><h3 id="适用环境-10">适用环境</h3><ol type="1"><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li></ol><h2 id="状态模式">11. 状态模式</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的（stateful）对象。</p><h3 id="概念-12">概念</h3><p>一个对象在其内部状态改变时改变它的行为。</p><ul><li><p>包含角色：环境类、抽象状态类、具体状态类。</p></li><li><p>关键：引入抽象状态类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</p></li><li><p>环境类与抽象状态类：</p><ul><li><p>环境类：拥有状态的对象</p></li><li><p>环境类有时候可以充当状态管理器(StateManager)的角色，可以在环境类中对状态进行切换操作。</p></li><li><p>状态类的产生是由于环境类存在多个状态，并且</p><ul><li>这些状态经常需要切换， 在不同的状态下对象的行为不同</li></ul><p>因此将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为。</p></li></ul></li></ul><h3 id="优缺点-11">优缺点</h3><p>优点：</p><ol type="1"><li>封装了转换规则。</li><li>枚举可能的状态，可以方便地增加新的状态。</li><li>状态转换逻辑与状态对象合成一体。</li><li>让多个环境对象共享一个状态对象。</li></ol><p>缺点：</p><ol type="1"><li>增加系统类和对象的个数</li><li>使用不当将导致程序结构和代码的混乱。</li><li>对开闭原则的支持并不太好<ul><li>增加新的状态类需要修改那些负责状态转换的源代码。</li></ul></li></ol><h3 id="适用环境-11">适用环境</h3><ol type="1"><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句。</li></ol><h3 id="模式扩展-6">模式扩展</h3><ol type="1"><li>共享状态</li><li>简单状态模式（状态不变）</li><li>可切换状态的状态模式</li></ol><h2 id="策略模式">12. 策略模式</h2><h3 id="概念-13">概念</h3><p>一组各自封装的算法族，可以相互替换。策略让算法可以独立于使用它的用户而变化。</p><h3 id="适用环境-12">适用环境</h3><ol type="1"><li>当许多相关类仅在其行为上有所不同时。</li><li>算法的不同变体。</li><li>算法使用用户不应知道的数据。</li><li>一个类定义了许多行为，而这些行为在它的操作中表现为多个条件语句。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;天生我材必有用，千金散尽还复来。&lt;/p&gt;</summary>
    
    
    
    <category term="软件系统设计" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>软件系统设计_面向对象设计原则</title>
    <link href="http://example.com/2024/06/11/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2024/06/11/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2024-06-11T04:00:00.000Z</published>
    <updated>2024-06-23T08:37:17.503Z</updated>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="面向对象设计原则">面向对象设计原则</h1><p>需求：系统需要满足的目标</p><p>规约：系统的外部可观察到的行为</p><p>架构：</p><ul><li><p>系统一级的主要组成部分</p></li><li><p>各部分的交互方法</p></li><li><p>使用的技术</p></li></ul><p>设计：</p><ul><li>如何完成任务</li><li>需要写的代码<ul><li>可维护、可复用</li></ul></li></ul><p>面向对象软件设计：将实现的约束条件应用到面向对象分析所产生的概念模型的过程。</p><ul><li><p>用方法和属性来描述用于构成系统的类</p></li><li><p>添加不明显属于领域的类，比如接口</p></li><li><p>描述类是如何构成组件的</p></li></ul><p>难点：将一个系统分解成对象</p><h2 id="面向对象设计原则概述">0. 面向对象设计原则概述</h2><p>目标：提高软件的可维护性和可复用性</p><p>Robert C.Martin认为一个软件设计可维护性较低通常的4个原因：</p><ul><li><p>过于僵硬（Rigidity）</p></li><li><p>过于脆弱（Fragility）</p></li><li><p>复用率低（Immobility）</p></li><li><p>黏度过高（Viscosity）</p></li></ul><p>Peter Coad认为，一个好的系统设计具备的三个性质:</p><ul><li>可扩展性（Extensibility）</li><li>灵活性（Flexibility）</li><li>可插入性（Pluggability）</li></ul><p>软件的复用拥有众多优点，如可以提高软件的开发效率，提高软件质量，节约开发成本。</p><p>恰当的复用还可以改善系统的可维护性。</p><p>面向对象设计复用的目标在于实现支持可维护性的复用。</p><p>在面向对象的设计里面，可维护性复用都是以面向对象设计原则为基础的，这些设计原则首先都是复用的原则，遵循这些设计原则可以有效地提高系统的复用性，同时提高系统的可维护性。</p><p>面向对象设计原则也是对系统进行合理重构的指南针，重构是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。</p><p>常用的7个面向对象设计原则：</p><ul><li>单一职责原则</li><li>开闭原则</li><li>里氏代换原则</li><li>依赖倒转原则</li><li>接口隔离原则</li><li>合成复用原则</li><li>迪米特法则</li></ul><p>这些原则并不是孤立存在的，它们相互依赖，相互补充。</p><h2 id="单一职责原则">1. 单一职责原则</h2><p>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类里。</p><ul><li>对一个类而言，应该仅有一个引起它变化的原因。</li></ul><p>一个类承担的职责越多，它被复用的可能性越小。让一个类承担过多的职责相当于将这些职责耦合，当其中一个职责变化时，可能会影响其他职责的运作。</p><p>数据职责（属性）和行为职责（方法）。</p><h2 id="开闭原则">2. 开闭原则</h2><p>一个软件实体应当对扩展开放，对修改关闭。</p><ul><li><p>在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。</p></li><li><p>软件实体可以指一个软件模块，一个由多个类组成的局部结构或一个独立的类。</p></li></ul><p>抽象化是开闭原则的关键。</p><p>对可变性封装原则：找到系统的可变因素并将其封装起来。</p><h2 id="里氏代换原则">3. 里氏代换原则</h2><p>如果对每一个类型为<span class="math inline">\(S\)</span>的对象<spanclass="math inline">\(o_1\)</span>，都有类型为<spanclass="math inline">\(T\)</span>的对象<spanclass="math inline">\(o_2\)</span>，使得以<spanclass="math inline">\(T\)</span>定义的所有程序<spanclass="math inline">\(P\)</span>在所有的对象<spanclass="math inline">\(o_2\)</span>都代换成<spanclass="math inline">\(o_1\)</span>时，程序<spanclass="math inline">\(P\)</span>的行为没有变化，那么类型<spanclass="math inline">\(S\)</span>是类型<spanclass="math inline">\(T\)</span>的子类型。</p><ul><li>所有引用基类的地方必须能透明地使用其子类的对象。</li></ul><p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h2 id="依赖倒转原则">4. 依赖倒转原则</h2><p>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><ul><li><p>要针对接口编程，不要针对实现编程。</p></li><li><p>代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。</p></li></ul><p>如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。</p><p>依赖倒转原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件中。</p><p>类之间的耦合：</p><ul><li>零耦合关系</li><li>具体耦合关系</li><li>抽象耦合关系</li></ul><p>依赖倒转原则要求客户端依赖于抽象耦合，以抽象方式耦合是依赖倒转原则的关键。</p><h2 id="接口隔离原则">5. 接口隔离原则</h2><p>客户端不应该依赖那些它不需要的接口。</p><ul><li>一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。</li></ul><p>使用多个专门的接口，而不使用单一的总接口。每一个接口应该承担一种相对独立的角色。</p><p>使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</p><ul><li>只提供用户需要的行为，而隐藏用户不需要的行为。</li></ul><h2 id="合成复用原则">6. 合成复用原则</h2><p>尽量使用对象组合，而不是继承来达到复用的目的。</p><p>合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。</p><h2 id="迪米特法则">7. 迪米特法则</h2><p>也称最小知识原则。几种典型定义：</p><ol type="1"><li><p>不和“陌生人”说话。</p></li><li><p>只与你的直接朋友通信。</p></li><li><p>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p></li></ol><ul><li>一个软件实体应当尽可能少的与其他实体发生相互作用。</li></ul><p>对于一个对象，其朋友包括以下几类:</p><ul><li>当前对象本身</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ul><p>狭义迪米特法则：</p><p>如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p>广义的迪米特法则：</p><p>指对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制。</p><p>迪米特法则的主要用途在于控制信息的过载：</p><ol type="1"><li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及;</li><li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限;</li><li>在类的设计上，只要有可能，一个类型应当设计成不变类;</li><li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ol><h2 id="小结">8. 小结</h2><ol start="0" type="1"><li><p>对于面向对象的软件系统设计来说，在支持可维护性的同时，需要提高系统的可复用性。</p></li><li><p>软件的复用可以提高软件的开发效率，提高软件质量，节约开发成本，恰当的复用还可以改善系统的可维护性。</p></li><li><p>单一职责原则要求在软件系统中，一个类只负责一个功能领域中的相应职责。</p></li><li><p>开闭原则要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</p></li><li><p>里氏代换原则可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</p></li><li><p>依赖倒转原则要求抽象不应该依赖于细节，细节应该依赖于抽象;要针对接口编程，不要针对实现编程。</p></li><li><p>接口隔离原则要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</p></li><li><p>合成复用原则要求复用时尽量使用对象组合，而不使用继承。</p></li><li><p>迪米特法则要求一个软件实体应当尽可能少的与其他实体发生相互作用。</p></li></ol><p>目标：开闭原则</p><p>指导：最小知识原则</p><p>基础：单一职责原则、可变性封装原则</p><p>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;天生我材必有用，千金散尽还复来。&lt;/p&gt;</summary>
    
    
    
    <category term="软件系统设计" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程_4_内核驱动</title>
    <link href="http://example.com/2024/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E7%AB%A0%20%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"/>
    <id>http://example.com/2024/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E7%AB%A0%20%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/</id>
    <published>2024-05-04T04:00:00.000Z</published>
    <updated>2024-06-21T07:24:02.689Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第4章-内核驱动">第4章 内核驱动</h1><h2 id="什么是内核">0. 什么是内核？</h2><p>操作系统是一系列程序的集合，其中最重要的部分构成了内核。</p><p>单内核/微内核</p><ul><li>单内核是一个很大的进程，内部可以分为若干模块，运行时是一个独立的二进制文件，模块间通讯通过直接调用函数实现</li><li>微内核中大部分内核作为独立的进程在特权下运行，通过消息传递进行通讯</li></ul><p>Linux内核的能力</p><ul><li>内存管理，文件系统，进程管理，多线程支持，抢占式，多处理支持</li></ul><p>Linux内核区别于其他UNIX商业内核的优点</p><ul><li>单内核，模块支持</li><li>免费/开源</li><li>支持多种CPU，硬件支持能力非常强大</li><li>Linux开发者都是非常出色的程序员</li><li>通过学习Linux内核的源码可以了解现代操作系统的实现原理</li></ul><h3 id="配置内核">配置内核</h3><p>下载源码、解压、make clean、<strong>make menuconfig</strong></p><figure><img src="/image/Linux系统编程/menu.png" alt="menu" /><figcaption aria-hidden="true">menu</figcaption></figure><p>编译内核：</p><ul><li>make</li><li>make zImage、make bzImage：生成压缩内核镜像</li><li>make modules：编译模块</li></ul><p>make install：将编译好的内核copy到/boot</p><h2 id="驱动">1. 驱动</h2><p>许多常见驱动的源代码集成在内核源码里，也有第三方开发的驱动，可以单独编译成模块.ko。编译需要内核头文件的支持。</p><p>驱动运行在内核态。</p><h3 id="加载模块">加载模块</h3><p>底层命令：</p><p>insmod：<code>insmod [options] module_file</code></p><ul><li><code>-f</code>: 强制加载模块，即使模块已被其他进程使用。</li><li><code>-o</code>: 指定模块的参数。</li><li><code>-v</code>: 显示详细信息。</li></ul><p>rmmod：<code>rmmod [options] module_name</code></p><ul><li><code>-f</code>: 强制卸载模块，即使模块已被其他进程使用。</li><li><code>-s</code>: 模块卸载后，不更新/proc/modules文件。</li><li><code>-w</code>: 在卸载模块之前，等待其关闭所有文件描述符。</li></ul><p>高层命令：</p><p>modprobe：<code>modprobe [options] module_name</code></p><ul><li><code>-a</code>: 自动加载所有依赖的模块。</li><li><code>-c</code>: 从 /etc/modprobe.conf 中读取配置。</li><li><code>-d</code>: 检测模块依赖，但不加载它们。</li><li><code>-e</code>: 禁止使用某些内核特性（如 SMP）。</li><li><code>-k</code>: 保留内核符号表。</li><li><code>-l</code>: 列出可以加载的模块，而不实际加载它们。</li><li><code>-n</code>: 禁止自动插入已指定名字的模块。</li><li><code>-p</code>: 使用预设的模块参数。</li><li><code>-r</code>: 删除模块及其依赖的模块。</li><li><code>-s</code>: 使模块静默加载，不输出信息。</li><li><code>-v</code>: 输出更多的信息。</li></ul><p>模块依赖</p><p>自动按需加载/卸载</p><p>moddep：列出指定内核模块所依赖的其他模块</p><p>lsmod：列出当前内核加载的所有模块及其各种信息</p><p>modinfo：显示关于内核模块的详细信息</p><h3 id="模块编写">模块编写</h3><p>不能使用c库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/moduleparam.h&gt;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> test;<br><span class="hljs-built_in">module_param</span>(test, <span class="hljs-type">int</span>, <span class="hljs-number">0644</span>);<span class="hljs-comment">//module_param(变量名称，类型, 访问许可掩码)</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">hello_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(KERN_INFO “Hello world test=%d \n” , test);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">hello_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;Goodbye world\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-built_in">MODULE_DESCRIPTION</span>(<span class="hljs-string">&quot;Test&quot;</span>);<br><span class="hljs-built_in">MODULE_AUTHOR</span>(<span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-built_in">module_init</span>(hello_init);<br><span class="hljs-built_in">module_exit</span>(hello_exit);<br></code></pre></td></tr></table></figure><h4 id="导出符号">导出符号</h4><p>如果一个模块需要向其他模块导出符号（方法或全局变量），需要使用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">EXPORT_SYMBOL(<span class="hljs-params">name</span>)</span>;<br><span class="hljs-constructor">EXPORT_SYMBOL_GPL(<span class="hljs-params">name</span>)</span>;<br></code></pre></td></tr></table></figure><p>符号必须在模块文件的全局部分导出。</p><p>/proc/kallsyms 可以显示所有导出的符号。</p><h3 id="字符设备">字符设备</h3><h4 id="设备号">设备号</h4><p>一个字符设备或者块设备都有一个主设备号和次设备号。</p><ul><li>主设备号和次设备号统称为设备号。<ul><li>主设备号用来表示一个特定的驱动程序。</li><li>次设备号用来表示使用该驱动程序的各设备。</li></ul></li></ul><h4 id="cdev">cdev</h4><p>linux内核中使用cdev结构体来描述字符设备。该结构体是所有字符设备的抽象，其包含了大量字符设备所共有的特性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> cdev *my_cdev = cdev<span class="hljs-constructor">_alloc()</span>;<br>my_cdev-&gt;ops = &amp;my_fops;<br>void cdev<span class="hljs-constructor">_init(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">cdev</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file_operations</span> <span class="hljs-operator">*</span><span class="hljs-params">fops</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="初始化加载过程">初始化加载过程</h4><ol type="1"><li>申请设备号</li><li>定义文件操作结构体 file_operations</li><li>创建并初始化定义结构体 cdev</li><li>将cdev注册到系统，并和对应的设备号绑定</li><li>在/dev文件系统中用mknod创建设备文件，并将该文件绑定到设备号上</li></ol><p>申请释放设备号：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">first</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>;<br><span class="hljs-built_in">int</span> alloc<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">firstminor</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>;<br>void unregister<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">first</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span>;<br></code></pre></td></tr></table></figure><p>设备注册与释放</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> cdev<span class="hljs-constructor">_add(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">dev_t</span> <span class="hljs-params">num</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span>;<br>void cdev<span class="hljs-constructor">_del(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程_3_编程</title>
    <link href="http://example.com/2024/05/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0%20Linux%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/05/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0%20Linux%E7%BC%96%E7%A8%8B/</id>
    <published>2024-05-03T04:00:00.000Z</published>
    <updated>2024-06-21T07:23:49.037Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第3章-linux编程">第3章 Linux编程</h1><h2 id="编程前的准备">0. 编程前的准备</h2><h3 id="编译命令">0.1 编译命令</h3><p>gcc -c（编译）</p><p>gcc（链接 或者 编译 + 链接）</p><p>g++（C++对应的命令，其实就是换了前端）</p><p>gcc [options] [filename]</p><p>基础可选项:</p><ul><li>-E: 只对源程序进行预处理(调用cpp预处理器)</li><li>-S: 只对源程序进行预处理、编译</li><li>-c: 执行预处理、编译、汇编而不链接</li><li>-o output_file: 指定输出文件名</li><li>-g: 产生调试工具必需的符号信息</li><li>-O/On: 在程序编译、链接过程中进行优化处理</li><li>-Wall: 显示所有的警告信息</li><li>-Idir: 指定额外的头文件搜索路径</li><li>-Ldir: 指定额外的库文件搜索路径</li><li>-lname: 链接时搜索指定的库文件</li><li>-DMACRO[=DEFN]: 定义MACRO宏</li></ul><h3 id="make">0.2 make</h3><p>make [-f Makefile] [option] [target]</p><p>makefile描述模块间的依赖关系，make命令根据makefile对程序进行管理和维护；make判断被维护文件的时序关系。</p><h4 id="make执行顺序">make执行顺序</h4><ol type="1"><li>make会在当前目录下找名字叫“Makefile” 或“makefile” 的文件。</li><li>查找文件中的第一个目标文件（target），举例中的hello</li><li>如果hello文件不存在，或是hello所依赖的文件修改时间要比hello新，就会执行后面所定义的命令来生成hello文件。</li><li>如果hello所依赖的.o文件不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（类似一个堆栈的过程）</li><li>make根据.o文件的规则生成 .o 文件，然后再用 .o文件生成hello文件。</li></ol><h4 id="makefile规则结构">Makefile规则结构</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">target <span class="hljs-string">...</span> : prerequisites <span class="hljs-string">...</span><br><span class="hljs-keyword">command</span>```<br></code></pre></td></tr></table></figure><ul><li>target是一个目标文件，可以是Object File，也可以是执行文件</li><li>prerequisites是要生成target所需要的文件或是目标</li><li>command是make需要执行的命令。（可以是任意的Shell命令）</li></ul><p>例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hello : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span><br>gcc -o hello <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span><br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs<span class="hljs-selector-class">.h</span><br>cc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br><span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.c</span> defs<span class="hljs-selector-class">.h</span> command<span class="hljs-selector-class">.h</span><br>cc -c <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.c</span><br>clean :<br>rm edit <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span>.o<br></code></pre></td></tr></table></figure><p>伪目标：clean</p><p>取名不能和文件名重名，可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”。</p><ul><li><p>一般没有依赖的文件，但也可以为伪目标指定所依赖的文件。</p></li><li><p>伪目标同样可以作为“默认目标”，只要将其放在第一个。</p></li></ul><h4 id="预定义变量">预定义变量</h4><ul><li>$&lt; 第一个依赖文件的名称</li><li>$?所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚</li><li>$+所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件</li><li>$^ 所有的依赖文件，以空格分开，不包含重复的依赖文件</li><li>$* 不包括扩展名的目标文件名称</li><li>$@ 目标的完整名称</li><li>$% 如果目标是归档成员，则该变量表示目标的归档成员名称</li></ul><h4 id="多目标扩展">多目标扩展</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">targets</span> <span class="hljs-attr">...</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">target-pattern</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">prereq-patterns</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">commands</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = foo.o bar.o<br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br><span class="hljs-variable">$(objects)</span>: %.o: %.c<br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><ul><li>目标从$object中获取</li><li>“%.o”表明要所有以“.o”结尾的目标，即“foo.obar.o”，就是变量$object集合的模式</li><li>依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是依赖的目标就是“foo.c bar.c”</li></ul><h4 id="函数">函数</h4><p>调用语法：</p><ul><li><p><code>$(&lt;function&gt; &lt;arguments&gt;)</code></p></li><li><p><code>$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</code></p></li><li><p>字符串处理函数</p><ul><li><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></li><li><code>$(strip &lt;string&gt;)</code></li></ul></li><li><p>文件名操作函数</p><ul><li><code>$(dir &lt;names...&gt;)</code></li><li><code>$(basename &lt;names...&gt;)</code></li></ul></li><li><p>foreach函数：<code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></p></li><li><p>if函数：<code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code></p></li><li><p>call函数：<code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code></p></li></ul><h2 id="文件系统">1. 文件系统</h2><p>文件：可以被读写的对象。</p><ul><li>文件的属性包含访问权限、文件类型。</li></ul><p>文件系统：文件及其属性的集合。</p><h3 id="文件类型和结构">1.1 文件类型和结构</h3><p>文件类型：</p><ul><li>-：常规文件</li><li>d：目录</li><li>l：链接</li><li>c：字符设备文件</li><li>b：块设备文件</li><li>p：管道</li><li>s：套接字</li></ul><p>文件结构：字节流</p><h3 id="vfsvirtual-file-system-switch">1.2 VFS：Virtual File SystemSwitch</h3><p>用户程序系统调用的统一接口，连接Ext2、FAT等多种不同的文件系统。</p><p>虚拟、只存在于内存。</p><p>组件：</p><ul><li>超级块：文件系统的元数据，它包含了文件系统的全局信息，如块大小、inode和数据块的数量、分配策略等。</li><li>i-node：文件的元数据，如文件的大小、创建时间、最后访问时间、最后修改时间、文件权限等，但不包括文件名和文件数据本身。</li><li>文件：打开的文件，包含了读写文件的当前位置、文件的状态等。</li><li>dentry：文件系统中的一个目录入口，即一个路径名与一个i-node的映射。</li></ul><h3 id="硬链接和符号链接">1.3 硬链接和符号链接</h3><p>硬链接：</p><ul><li>不同的文件名对应同一个inode</li><li>不能跨越文件系统</li><li>对应系统调用link</li></ul><p>符号链接</p><ul><li>存储被链接文件的文件名(而不是inode)实现链接</li><li>可跨越文件系统</li><li>对应系统调用symlink</li></ul><h3 id="系统调用和库函数">1.4 系统调用和库函数</h3><p>都是C函数。</p><p>系统调用：Linux内核的对外接口；用户程序和内核之间唯一的接口。</p><p>库函数：依赖于系统调用，提供较复杂功能。</p><h4 id="基础io系统调用">基础I/O系统调用</h4><ul><li>文件描述符：非负整数<ul><li>STDIN_FILENO (0)、STDOUT_FILENO (1)、STDERR_FILENO (2)</li></ul></li><li>基础I/O函数<ul><li>open/creat、close、read、write、lseek</li><li>dup/dup2</li><li>fcntl</li><li>ioctl</li></ul></li></ul><h5 id="opencreat">open/creat</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br>(Return: a <span class="hljs-keyword">new</span> file descriptor <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>flags：文件访问模式。</p><ul><li>O_RDONLY：只读</li><li>O_WRONLY：只写</li><li>O_RDWR：读写</li><li>O_APPEND：追加</li><li>O_TRUNC：如果文件存在，截断到0字节</li><li>O_CREAT：文件不存在则创建</li><li>O_EXCL：与 <code>O_CREAT</code>标志结合使用。如果文件已存在则报错。</li></ul><p>mode：八进制数，文件权限。</p><figure><img src="/image/Linux系统编程/权限.png" alt="权限" /><figcaption aria-hidden="true">权限</figcaption></figure><p>umask：一个环境变量，决定了文件创建时的权限掩码。</p><ul><li>mode &amp; ~umask，得到最终创建的文件权限。</li></ul><h5 id="close">close</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h5 id="readwrite">read/write</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br>(返回值: 读到的字节数，若已到文件尾为<span class="hljs-number">0</span>，若出错为<span class="hljs-number">-1</span>)<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br>(返回值: 若成功为已写的字节数，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h5 id="lseek">lseek</h5><p>改变文件读写位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br>(Return: the resulting offset location <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>whence（出发点）：</p><ul><li>SEEK_SET</li><li>SEEK_CUR</li><li>SEEK_END</li></ul><h5 id="dupdup2">dup/dup2</h5><p>复制文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span></span>;<br>(Return: the <span class="hljs-keyword">new</span> file descriptor <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h5 id="fcntl">fcntl</h5><p>管理文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">long</span> arg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> flock *lock)</span></span>;<br>(返回值: 若成功则依赖于cmd，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><p>cmd：</p><ul><li>F_DUPFD：复制文件描述符</li><li>F_GETFD/F_SETFD：获取设置文件描述符控制标志</li><li>F_GETFL/F_SETFL：获取设置文件描述符状态标志</li><li>F_GETOWN/F_SETOWN：获取设置I/O可用性标志</li><li>F_GETLK/F_SETLK/F_SETLKW：获取设置文件锁</li></ul><h5 id="ioctl">ioctl</h5><p>控制设备。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> request, ...)</span></span>;<br></code></pre></td></tr></table></figure><p>重定向用到了哪些系统调用？</p><h4 id="标准io库">标准I/O库</h4><p>主要考察缓冲。</p><p>文件流</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs julia">FILE* fp;<br>// <span class="hljs-literal">stdin</span> <span class="hljs-literal">stdout</span> <span class="hljs-literal">stderr</span><br></code></pre></td></tr></table></figure><p>三种缓冲：</p><ul><li>块缓冲</li><li>线性缓冲</li><li>无缓冲</li></ul><p>setbuf、setvbuf</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setvbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> mode, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>mode：_IOFBF（满缓冲）、_IOLBF（行缓冲）、_IONBF（无缓冲）</p><p>流式I/O函数：</p><ul><li><p>open/close</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fclose</span><span class="hljs-params">(FILE *stream)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>mode：r w a r+(读写) w+(读写，无则新建，有则清空)a+(读与追加，无则新建)</p></li><li><p>read/write</p><ul><li><p>每次一个字符的I/O</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getc</span>(<span class="hljs-params">FILE *fp</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fgetc</span>(<span class="hljs-params">FILE *fp</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getchar</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span>;<br>（Result: Reads the next character <span class="hljs-keyword">from</span> a stream <span class="hljs-keyword">and</span> returns it <span class="hljs-keyword">as</span> an unsigned <span class="hljs-built_in">char</span> cast to an <span class="hljs-built_in">int</span>, <span class="hljs-keyword">or</span> EOF <span class="hljs-keyword">on</span> end of file <span class="hljs-keyword">or</span> error.）<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">ungetc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> c, FILE *stream</span>)</span>; <span class="hljs-comment">// 将字符插回流中</span><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> putc(<span class="hljs-built_in">int</span> c, <span class="hljs-keyword">FILE</span> *fp);<br><span class="hljs-built_in">int</span> fputc(<span class="hljs-built_in">int</span> c, <span class="hljs-keyword">FILE</span> *fp);<br><span class="hljs-built_in">int</span> putchar(<span class="hljs-built_in">int</span> c);<br>(<span class="hljs-keyword">Return</span>: the <span class="hljs-keyword">character</span> <span class="hljs-keyword">if</span> success; -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure></li><li><p>每次一行的I/O</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span>; <span class="hljs-comment">//not recommended.</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>直接I/O(二进制I/O)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span></span>;<br>(Return: the number of a items successfully read <span class="hljs-keyword">or</span> written.)<br></code></pre></td></tr></table></figure></li><li><p>格式化I/O</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">scanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sscanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>reposition</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">ftell</span><span class="hljs-params">(FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rewind</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fgetpos</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">fpos_t</span> *pos)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fsetpos</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">fpos_t</span> *pos)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>flush</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fflush</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>流与文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fileno</span><span class="hljs-params">(FILE *fp)</span></span>;<br><span class="hljs-function">FILE *<span class="hljs-title">fdopen</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>临时文件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">char *<span class="hljs-built_in">tmpnam</span>(char *s);<br>(返回值: 指向唯一路径名的指针)<br>FILE *<span class="hljs-built_in">tmpfile</span>(void);<br>(返回值: 若成功为文件指针，若出错为NULL)<br></code></pre></td></tr></table></figure></li></ul><h4 id="高级系统调用">高级系统调用</h4><p>stat、fstat：返回文件状态信息，存储在buf中</p><p>lstat：获取符号链接本身的状态信息，存储在buf中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> filedes, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> &#123;<br><span class="hljs-type">mode_t</span> st_mode; <span class="hljs-comment">/*file type &amp; mode*/</span><br><span class="hljs-type">ino_t</span> st_ino; <span class="hljs-comment">/*inode number (serial number)*/</span><br><span class="hljs-type">dev_t</span> st_rdev; <span class="hljs-comment">/*device number (file system)*/</span><br><span class="hljs-type">nlink_t</span> st_nlink; <span class="hljs-comment">/*link count*/</span><br><span class="hljs-type">uid_t</span> st_uid; <span class="hljs-comment">/*user ID of owner*/</span><br><span class="hljs-type">gid_t</span> st_gid; <span class="hljs-comment">/*group ID of owner*/</span><br><span class="hljs-type">off_t</span> st_size; <span class="hljs-comment">/*size of file, in bytes*/</span><br><span class="hljs-type">time_t</span> st_atime; <span class="hljs-comment">/*time of last access*/</span><br><span class="hljs-type">time_t</span> st_mtime; <span class="hljs-comment">/*time of last modification*/</span><br><span class="hljs-type">time_t</span> st_ctime; <span class="hljs-comment">/*time of last file status change*/</span><br><span class="hljs-type">long</span> st_blksize; <span class="hljs-comment">/*Optimal block size for I/O*/</span><br><span class="hljs-type">long</span> st_blocks; <span class="hljs-comment">/*number 512-byte blocks allocated*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>测试文件类型：sys/stat.h</p><ul><li>S_ISREG()</li><li>S_ISDIR()</li><li>S_ISCHAR()</li><li>S_ISBLK()</li><li>S_ISFIFO()</li><li>S_ISLNK()</li><li>S_ISSOCK()</li></ul><p>文件权限</p><ul><li><p>rwx</p></li><li><p>SUID：需要有效uid</p></li><li><p>SGID：需要有效gid</p></li><li><p>Sticky bit：只有owner</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchmod</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">mode_t</span> mode)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchown</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lchown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">mode_t</span> <span class="hljs-title">umask</span><span class="hljs-params">(<span class="hljs-type">mode_t</span> mask)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">symlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">readlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> bufsiz)</span></span>;<br>(Return: the count of characters placed in the buffer <span class="hljs-keyword">if</span> success;<span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>目录</p><ul><li>mkdir/rmdir</li><li>chdir/fchdir, getcwd</li><li>读取目录：DIR数据结构<ul><li>opendir/closedir</li><li>readdir</li><li>telldir</li><li>seekdir</li></ul></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rmdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchdir</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dir)</span></span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *<span class="hljs-built_in">readdir</span>(DIR *dir);<br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">telldir</span><span class="hljs-params">(DIR *dir)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seekdir</span><span class="hljs-params">(DIR *dir, <span class="hljs-type">off_t</span> offset)</span></span>;<br></code></pre></td></tr></table></figure><p>文件锁 important</p><ul><li><p>记录锁</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fcntl</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> fd, <span class="hljs-built_in">int</span> cmd, <span class="hljs-keyword">struct</span> flock *<span class="hljs-keyword">lock</span></span>)</span>;<br>(返回值: 若成功则依赖于cmd，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure></li><li><p>劝告锁</p><ul><li>检查，加锁有应用程序自己控制</li></ul></li><li><p>强制锁</p><ul><li>检查，加锁由内核控制</li><li>影响[open() read() write()]等</li></ul></li><li><p>共享锁</p></li><li><p>排他锁</p></li><li><p>共享模式强制锁</p></li><li><p>租借锁</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">flock</span>&#123;<br>...<br><span class="hljs-type">short</span> l_type; <span class="hljs-comment">/* Type of lock: F_RDLCK, F_WRLCK, F_UNLCK */</span><br><span class="hljs-type">short</span> l_whence; <span class="hljs-comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR,</span><br><span class="hljs-comment">SEEK_END */</span><br><span class="hljs-type">off_t</span> l_start; <span class="hljs-comment">/* Starting offset for lock */</span><br><span class="hljs-type">off_t</span> l_len; <span class="hljs-comment">/* Number of bytes to lock */</span><br><span class="hljs-type">pid_t</span> l_pid; <span class="hljs-comment">/* PID of process blocking our lock (F_GETLK only) */</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>cmd</p><ul><li>F_GETLK：获得文件的封锁信息</li><li>F_SETLK：对文件的某个区域封锁或解除封锁</li><li>F_SETLKW：功能同F_SETLK，wait方式。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/file.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lockf</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">off_t</span> len)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="多核编程">2. 多核编程</h2><h3 id="exec">exec</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>execl</code>、<code>execlp</code>和<code>execle</code>：可变参数为逐个列举。<code>execl</code>和<code>execle</code>带有环境变量，而<code>execlp</code>不带环境变量。实际上会调用对应的v系列函数。</p></li><li><p><code>execv</code>、<code>execvp</code>和<code>execve</code>：可变参数为NULL结尾的指针数组。<code>execv</code>和<code>execvp</code>不带环境变量，而<code>execve</code>可以传递环境变量。前两者最终会调用execve函数。</p></li></ul><h3 id="fork">fork</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)<br>&#123;子进程执行的代码段；&#125;<br><span class="hljs-keyword">else</span><br>&#123;父进程执行的代码段；&#125;<br></code></pre></td></tr></table></figure><h3 id="wait-waitpid">wait &amp; waitpid</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *status)</span></span>;<br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *status, <span class="hljs-type">int</span> options)</span></span>;<br></code></pre></td></tr></table></figure><p>wait：调用wait函数的进程会被挂起，等待任意一个子进程结束，如果该子进程结束了，此函数会回收子进程的资源。</p><ul><li>如果成功，wait会返回被收集的子进程的进程ID；</li><li>如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。</li></ul><p>waitpid：回收指定进程号的子进程，可以设置是否阻塞。</p><ul><li><p>pid=0，等待任意子进程。</p></li><li><p>pid=-1，回收所有子进程。</p></li><li><p>pid&lt;-1，其绝对值为某个进程组的组id，回收该进程组的所有进程。</p></li><li><p>status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。</p></li><li><p>options：WNOHANG，非阻塞。</p></li></ul><ol type="1"><li><p>当正常返回的时候，waitpid返回收集到的子进程的进程ID；</p></li><li><p>如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0；　　</p></li><li><p>如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在；</p><p>当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD。</p></li></ol><h3 id="signal">Signal</h3><p>信号处理</p><ul><li><p>忽略信号</p></li><li><p>不能忽略的信号： SIGKILL, SIGSTOP、一些硬件异常信号</p></li><li><p>执行系统默认动作</p></li><li><p>捕捉信号</p></li></ul><p>signal函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span></span>;<br>(Returned Value: the previous handler <span class="hljs-keyword">if</span> success, SIG_ERR <span class="hljs-keyword">if</span> error)<br></code></pre></td></tr></table></figure><p>handler为用户定义的函数。</p><h4 id="kill和raise">kill和raise</h4><p>kill向进程发送信号，raise向当前进程发送信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span></span>;<br>(Returned Value: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success, <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>;<br>(Returned Value: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success, <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h4 id="alarm和pause">alarm和pause</h4><p>alarm：一定时间后发送SIGALRM信号。</p><p>pause：挂起等待信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pause</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>组合两者可以让进程等待一段时间后执行。</p><h4 id="可靠信号机制">可靠信号机制</h4><h3 id="可重入函数">可重入函数</h3><p>可以被中断的函数。</p><p>不可重入函数：</p><ul><li>系统资源</li><li>全局变量</li><li>使用静态数据结构</li><li>malloc、free</li><li>标准IO函数</li></ul><h3 id="posix-thread">POSIX Thread</h3><p>编译：gcc thread.c –o thread –lpthread</p><h4 id="创建和终止">创建和终止</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_t</span> *thread,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_attr_t</span> *attr,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> *arg)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="等待和分离">等待和分离</h4><p>Joinable Thread：可连接线程</p><ul><li>可以被其他线程等待（join）的线程。</li></ul><p>Detached Thread：分离线程</p><ul><li>启动后独立运行的线程。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;pthread.h&gt;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_join(<span class="hljs-params">pthread_t</span> <span class="hljs-params">th</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">thread_return</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_detach(<span class="hljs-params">pthread_t</span> <span class="hljs-params">th</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="线程同步">线程同步</h4><h5 id="信号量">信号量</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_init(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-params">pshared</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">value</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_wait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_post(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_destroy(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_trywait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_getvalue(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">sval</span>)</span>;<br></code></pre></td></tr></table></figure><p>生产者-消费者问题：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/wait.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;fcntl.h&gt;</span><br><span class="hljs-comment">#include &lt;semaphore.h&gt;</span><br><br><span class="hljs-comment">#define BUFFER_SIZE 10</span><br><span class="hljs-comment">#define PRODUCER_COUNT 3</span><br><span class="hljs-comment">#define CONSUMER_COUNT 2</span><br><br>sem_t empty, full, mutex;<br>int buffer[BUFFER_SIZE];<br>int <span class="hljs-keyword">in</span> = <span class="hljs-number">0</span>;<br>int out = <span class="hljs-number">0</span>;<br><br>void produce(int index) &#123;<br>    sem_wait(&amp;empty);<br>    sem_wait(&amp;mutex);<br><br>    printf(<span class="hljs-string">&quot;生产者%d生产了一个产品\n&quot;</span>, index);<br>    buffer[<span class="hljs-keyword">in</span>] = index;<br>    <span class="hljs-keyword">in</span> = (<span class="hljs-keyword">in</span> + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br><br>    sem_post(&amp;mutex);<br>    sem_post(&amp;full);<br>&#125;<br><br>void consume(int index) &#123;<br>    sem_wait(&amp;full);<br>    sem_wait(&amp;mutex);<br><br>    printf(<span class="hljs-string">&quot;消费者%d消费了一个产品\n&quot;</span>, index);<br>    buffer[out] = -<span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 或者可以用某种方式标记为已消费<br>    out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br><br>    sem_post(&amp;mutex);<br>    sem_post(&amp;empty);<br>&#125;<br><br>int main() &#123;<br>    <span class="hljs-regexp">//</span> 初始化信号量<br>    <span class="hljs-keyword">if</span> (sem_init(&amp;empty, <span class="hljs-number">1</span>, BUFFER_SIZE) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sem_init(&amp;full, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sem_init(&amp;mutex, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    pid_t pid;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; PRODUCER_COUNT; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 子进程，生产者<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                produce(i);<br>                sleep(rand() % <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 随机睡眠以模拟不同生产者生产速度<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; CONSUMER_COUNT; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 子进程，消费者<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                consume(i);<br>                sleep(rand() % <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 随机睡眠以模拟不同消费者消费速度<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 等待所有生产者和消费者结束<br>    <span class="hljs-keyword">while</span> (wait(NULL) &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-regexp">//</span> 销毁信号量<br>    sem_destroy(&amp;empty);<br>    sem_destroy(&amp;full);<br>    sem_destroy(&amp;mutex);<br><br>    <span class="hljs-keyword">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="互斥量">互斥量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex, <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *mutexattr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><br><span class="hljs-type">int</span> buffer[BUFFER_SIZE];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> out = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 互斥量初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex, empty, full;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        <span class="hljs-keyword">while</span> (in == BUFFER_SIZE) &#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>); <span class="hljs-comment">// 生产者等待</span><br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        &#125;<br><br>        <span class="hljs-comment">// 生产产品</span><br>        buffer[in] = *(<span class="hljs-type">int</span>*)arg;<br>        in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产了产品 %d\n&quot;</span>, *(<span class="hljs-type">int</span>*)arg);<br><br>        <span class="hljs-comment">// 通知消费者有新产品</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        full++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有产品</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        <span class="hljs-keyword">while</span> (out == in) &#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>); <span class="hljs-comment">// 消费者等待</span><br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        &#125;<br><br>        <span class="hljs-comment">// 消费产品</span><br>        <span class="hljs-type">int</span> product = buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费了产品 %d\n&quot;</span>, product);<br><br>        <span class="hljs-comment">// 通知生产者有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        empty++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; mutex init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;empty, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; empty init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;full, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; full init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_t</span> pid, cid;<br>    <span class="hljs-type">int</span> producer_arg = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> consumer_arg = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建生产者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, producer, &amp;producer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建消费者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;cid, <span class="hljs-literal">NULL</span>, consumer, &amp;consumer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(cid, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 销毁互斥量</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;empty);<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;full);<br></code></pre></td></tr></table></figure><h5 id="条件变量">条件变量</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_init(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>, <span class="hljs-params">pthread_condattr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond_attr</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_destory(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_wait(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>, <span class="hljs-params">pthread_mutex_t</span> <span class="hljs-params">mutex</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_signal(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-params">cond</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_broadcast(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-params">cond</span>)</span>;<br></code></pre></td></tr></table></figure><p>条件变量使用：与互斥量结合</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><br><span class="hljs-type">int</span> buffer[BUFFER_SIZE];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> out = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 互斥量初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-comment">// 条件变量初始化</span><br><span class="hljs-type">pthread_cond_t</span> empty, full;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">while</span> (in == BUFFER_SIZE) &#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;empty, &amp;mutex);<br>        &#125;<br><br>        <span class="hljs-comment">// 生产产品</span><br>        buffer[in] = *(<span class="hljs-type">int</span>*)arg;<br>        in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产了产品 %d\n&quot;</span>, *(<span class="hljs-type">int</span>*)arg);<br><br>        <span class="hljs-comment">// 通知消费者有新产品</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;full);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有产品</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">while</span> (out == in) &#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;full, &amp;mutex);<br>        &#125;<br><br>        <span class="hljs-comment">// 消费产品</span><br>        <span class="hljs-type">int</span> product = buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费了产品 %d\n&quot;</span>, product);<br><br>        <span class="hljs-comment">// 通知生产者有空余位置</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;empty);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; mutex init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化条件变量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_cond_init</span>(&amp;empty, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; empty init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_cond_init</span>(&amp;full, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; full init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_t</span> pid, cid;<br>    <span class="hljs-type">int</span> producer_arg = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> consumer_arg = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建生产者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, producer, &amp;producer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建消费者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;cid, <span class="hljs-literal">NULL</span>, consumer, &amp;consumer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(cid, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 销毁互斥量</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;empty);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;full);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程取消">线程取消</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cancel(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcancelstate(<span class="hljs-params">int</span> <span class="hljs-params">state</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldstate</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcanceltype(<span class="hljs-params">int</span> <span class="hljs-params">type</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldtype</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="线程局部存储-tls">线程局部存储 TLS</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_key_create(<span class="hljs-params">pthread_key_t</span> <span class="hljs-operator">*</span><span class="hljs-params">key</span>, <span class="hljs-params">void</span> (<span class="hljs-operator">*</span><span class="hljs-params">destructor</span>)</span>(void*));<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_key_delete(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>)</span>;<br>void *pthread<span class="hljs-constructor">_getspecific(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setspecific(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>, <span class="hljs-params">const</span> <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">value</span>)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程_2_Shell</title>
    <link href="http://example.com/2024/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E7%AB%A0%20Shell%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E7%AB%A0%20Shell%E7%BC%96%E7%A8%8B/</id>
    <published>2024-05-02T04:00:00.000Z</published>
    <updated>2024-06-21T07:23:33.201Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第2章-shell编程">第2章 Shell编程</h1><p>Shell：指令解释器和编程环境。</p><p>用户和操作系统之间的接口，作为核外程序存在。</p><p>Shell的双重角色：</p><ul><li>命令解释程序<ul><li>Linux的开机启动过程；进程树</li><li>Shell的工作步骤</li><li>打印提示符；得到命令行；解析命令；查找文件；准备参数；执行命令</li></ul></li><li>独立的程序设计语言解释器</li></ul><p>Shell列举：ash、bsh、bash、sh、csh、zsh</p><h2 id="脚本文件">脚本文件</h2><p>注释：#</p><p>退出码：</p><ul><li>0：正常返回</li><li>1~128：错误码</li><li>129+：信号量</li></ul><h3 id="执行脚本文件">执行脚本文件</h3><ol type="1"><li><p>$ sh script_file</p></li><li><p>chmod +x script_file</p><p>./script_file</p></li><li><p>source script_file或 . script_file</p></li></ol><h3 id="用户环境">用户环境</h3><ol type="1"><li>.bash_profile，.bash_logout，.bashrc<ul><li>.bash_profile：用户登录时被读取，其中命令被bash执行</li><li>.bashrc：启动一个新的shell时被读取并执行</li><li>.bash_logout：登录退出时读取执行</li></ul></li><li>Alias：alias/unalias</li><li>环境变量<ul><li>export/env/set</li></ul></li></ol><h3 id="变量">变量</h3><ul><li>用户变量</li><li>环境变量</li><li>参数变量和内部变量</li></ul><h4 id="用户变量">用户变量</h4><p>用户在shell脚本里定义的变量。</p><ul><li><p>变量的赋值与使用：var=value echo $var</p></li><li><p>read命令：read var（读取用户输入并赋值给var）</p><ul><li>-p：在提示符后添加文本</li><li>-s：不显示用户输入</li><li>-r：用户输入不能修改</li><li>-n[字符数]：指定读取字符数，例如-n1</li></ul></li><li><p>引号</p><ul><li>单引号内的所有字符保持本身字符的意思，不被bash解释</li><li>除了$、``（不是单引号）、，双引号内的所有字符将保持字符本身含义，不被bash解释</li></ul></li></ul><h4 id="环境变量">环境变量</h4><p>Shell环境提供的变量，通常使用大写字母做名称。</p><table><thead><tr class="header"><th>环境变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$HOME</td><td>当前用户登录目录</td></tr><tr class="even"><td>$PATH</td><td>以冒号分隔的用来搜索命令的目录清单</td></tr><tr class="odd"><td><span class="math inline">\(PS1 |命令行提示符，通常是”\)</span>”字符</td><td></td></tr><tr class="even"><td>$PS2</td><td>辅助提示符，用来提示后续输入，通常是”&gt;”字符</td></tr><tr class="odd"><td>$IFS</td><td>输入区分隔符。当shell读取输入数据时会把一组字符看成是单词之间的分隔符，通常是空格、制表符、换行符等。</td></tr></tbody></table><h4 id="参数变量和内部变量">参数变量和内部变量</h4><p>调用脚本程序时如果带有参数，对应的参数和额外产生的一些变量。</p><table><thead><tr class="header"><th>环境变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$#</td><td>传递到脚本程序的参数个数</td></tr><tr class="even"><td>$0</td><td>脚本程序的名字</td></tr><tr class="odd"><td>$1</td><td>脚本程序的参数</td></tr><tr class="even"><td>$*</td><td>一个全体参数组成的清单，它是一个独立的变量，各个参数之间用环境变量IFS中的第一个字符分隔开</td></tr><tr class="odd"><td><span class="math inline">\(@ |“\)</span>*”的一种变体，它不使用IFS环境变量。</td><td></td></tr></tbody></table><h3 id="条件测试">条件测试</h3><p>test expression 或 [ expression ]</p><ul><li>字符串比较</li><li>算术比较</li><li>文件相关测试</li><li>逻辑操作</li></ul><table><thead><tr class="header"><th>字符串比较</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>str1 = str2</td><td>相同则为真</td></tr><tr class="even"><td>str1!=str2</td><td>不同则为真</td></tr><tr class="odd"><td>-z str</td><td>字符串为空则结果为真</td></tr><tr class="even"><td>-n str</td><td>字符串不为空则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>算术比较</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>expr1 –eq expr2</td><td>两个表达式相等则结果为真</td></tr><tr class="even"><td>expr1 –ne expr2</td><td>两个表达式不等则结果为真</td></tr><tr class="odd"><td>expr1 –gt expr2</td><td>expr1 大于 expr2 则结果为真</td></tr><tr class="even"><td>expr1 –ge expr2</td><td>expr1 大于或等于 expr2 则结果为真</td></tr><tr class="odd"><td>expr1 –lt expr2</td><td>expr1 小于 expr2 则结果为真</td></tr><tr class="even"><td>expr1 –le expr2</td><td>expr1 小于或等于 expr2 则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>文件条件测试</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>-e file</td><td>文件存在则结果为真</td></tr><tr class="even"><td>-d file</td><td>文件是一个子目录则结果为真</td></tr><tr class="odd"><td>-f file</td><td>文件是一个普通文件则结果为真</td></tr><tr class="even"><td>-s file</td><td>文件的长度不为零则结果为真</td></tr><tr class="odd"><td>-r file</td><td>文件可读则结果为真</td></tr><tr class="even"><td>-w file</td><td>文件可写则结果为真</td></tr><tr class="odd"><td>-x file</td><td>文件可执行则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>逻辑操作</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>! expr</td><td>逻辑表达式求反</td></tr><tr class="even"><td>expr1 –a expr2</td><td>两个逻辑表达式“And”（“与”）</td></tr><tr class="odd"><td>expr1 –o expr2</td><td>两个逻辑表达式“Or”（“或”）</td></tr></tbody></table><h3 id="条件语句">条件语句</h3><h4 id="if语句">if语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ expression ]<br><span class="hljs-keyword">then</span><br>statements<br><span class="hljs-keyword">elif</span> [ expression ]<br><span class="hljs-keyword">then</span><br>statements<br><span class="hljs-keyword">elif</span> …<br><span class="hljs-keyword">else</span><br>statements<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h4 id="case语句">case语句</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">case</span> str <span class="hljs-built_in">in</span><br>str1 | <span class="hljs-type">str2</span>) statements;;<br>str3 | <span class="hljs-type">str4</span>) statements;;<br>*) statements;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="重复语句">重复语句</h3><h4 id="for语句">for语句</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">in</span> list<br><span class="hljs-keyword">do</span><br>statements<br>done<br></code></pre></td></tr></table></figure><h4 id="while语句">while语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span><br>statements<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="until语句">until语句</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">until</span> condition<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">statements</span><br>done<br></code></pre></td></tr></table></figure><h4 id="select语句">select语句</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">select</span> item in itemlist<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">statements</span><br>done<br></code></pre></td></tr></table></figure><p>生成菜单列表</p><h3 id="命令表">命令表</h3><p>命令的组合。</p><ul><li><p>分号串联：command1 ; command2 ; …</p></li><li><p>条件组合，AND和OR：</p><p><code>statement1 &amp;&amp; statement2 &amp;&amp; …</code>和<code>statement1 || statement2 || …</code></p></li></ul><h3 id="语句块">语句块</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&#123;<br>stateme<span class="hljs-symbol">nt1</span><br>stateme<span class="hljs-symbol">nt2</span><br>…<br>&#125;<br>&#123; stateme<span class="hljs-symbol">nt1</span>; stateme<span class="hljs-symbol">nt2</span> ; … ; &#125;<br></code></pre></td></tr></table></figure><h3 id="函数">函数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">func</span><span class="hljs-params">()</span></span><br>&#123;<br>statements<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量：local关键字</p><p>函数调用：func para1 para2 ...</p><p>返回值：return</p><h3 id="杂项命令">杂项命令</h3><ul><li>break：从for/while/until循环退出</li><li>continue：跳到下一个循环继续执行</li><li>exit n：以退出码”n”退出脚本运行</li><li>return：函数返回</li><li>export：将变量导出到shell，使之成为shell的环境变量</li><li>set：为shell设置参数变量</li><li>unset：从环境中删除变量或函数</li><li>trap：指定在收到操作系统信号后执行的动作</li><li>“:”(冒号命令)：空命令</li><li>“.”(句点命令)或source在当前shell中执行命令</li></ul><h3 id="捕获命令输出">捕获命令输出</h3><p><code>$(command)</code>和<code>`(command)`</code></p><h3 id="算术扩展">算术扩展</h3><p><code>$((...))</code></p><h3 id="参数扩展">参数扩展</h3><p>批处理 1_tmp, 2_tmp, …</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>i=1<br><span class="hljs-keyword">while</span> [ “<span class="hljs-variable">$i</span>” –ne 10 ]; <span class="hljs-keyword">do</span><br><span class="hljs-built_in">touch</span> “<span class="hljs-variable">$&#123;i&#125;</span>_tmp”<br>i=$((<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure><p>更复杂形式：</p><figure><img src="/image/Linux系统编程/参数.png" alt="参数扩展" /><figcaption aria-hidden="true">参数扩展</figcaption></figure><h3 id="即时文档">即时文档</h3><p>在shell脚本中向一条命令传送输入数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">cat</span> &gt;&gt; file.txt &lt;&lt; !CATINPUT!<br>Hello, this is a here document.<br>!CATINPUT!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程_1_基础</title>
    <link href="http://example.com/2024/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E7%AB%A0%20Linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E7%AB%A0%20Linux%E5%9F%BA%E7%A1%80/</id>
    <published>2024-05-01T04:00:00.000Z</published>
    <updated>2024-06-21T07:23:15.117Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第1章-linux系统基础">第1章 Linux系统基础</h1><h2 id="linux概念与使用">1. Linux概念与使用</h2><p>基于GNU通用公共协议的类Unix操作系统。</p><ul><li>开源、流行、支持大多数平台</li></ul><h3 id="gnulinux系统">GNU/Linux系统</h3><p>GNU软件/库+Linux内核</p><p>版本：Ubuntu、Debian、Mint、Red Hat、Fodore、SuSe</p><h3 id="boot-loader">Boot loader</h3><p>Boot loader加载并启动Linux内核。</p><p>常见的Boot loader：</p><ul><li>LILO：Linux Loader</li><li>GRUB：Grand Unified Boot Loader<ul><li>配置文件：<code>/boot/grub/grub.conf</code>（旧版）</li><li>不需要和LILO一样进行配置激活（自动识别加载系统内核和initrd文件）</li><li>使用grub-install安装在MBR中</li></ul></li></ul><p>GRUB引导过程：</p><ol type="1"><li>MBR上的引导程序，负责加载GRUB的第二阶段</li><li>完整的内核加载在/boot/grub目录下</li></ol><p>要能读懂GRUB配置文件</p><p>基本结构：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">default</span>=<span class="hljs-number">0</span>  # 默认启动第一个系统<br><span class="hljs-attribute">timeout</span>=<span class="hljs-number">5</span>  # 等待超时时间<span class="hljs-number">5</span>秒<br><span class="hljs-attribute">splashimage</span>=(hd0,<span class="hljs-number">0</span>)/grub/splash.xpm.gz  # 背景图片<br><span class="hljs-attribute">hiddenmenu</span>  # 隐藏菜单，若要显式，在启动时按下ESC<br><span class="hljs-attribute">title</span> Red Hat Enterprise Linux AS (<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5)  # 定义操作系统的说明信息<br>    <span class="hljs-attribute">root</span> (hd0,<span class="hljs-number">0</span>) <br>    <span class="hljs-attribute">kernel</span> /vmlinuz-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5 ro root＝/dev/sda2 rhgb quiet<br>    <span class="hljs-attribute">initrd</span> /initrd-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5.img<br></code></pre></td></tr></table></figure><p>GRUB2：<code>/boot/grub/grub.cfg</code></p><h3 id="虚拟终端">虚拟终端</h3><p>控制台模拟了一个或多个虚拟终端。</p><p>每个虚拟终端是独立的控制台，不同用户可以使用不同的虚拟终端。</p><p>切换方式：Ctrl+Alt+Fn / Alt+Fn</p><h2 id="linux基础命令">2. Linux基础命令</h2><p>命令行：$ 和 #（root）</p><p>$ command option(s) argument(s)</p><p>主要命令都需要掌握。</p><h3 id="基础命令">0. 基础命令</h3><ul><li>passwd：修改密码</li><li>mkpasswd：生成随机密码</li><li>date, cal：打印日期/日历</li><li>who, finger：查看系统上在线的用户信息</li><li>clear：清空屏幕</li><li>echo：打印信息</li><li>write, wall, talk：与其他用户信息通信。<ul><li><code>write username</code>：提示输入消息内容，然后将消息发送给<code>username</code>。</li><li><code>wall</code>：即write all，发送给所有用户</li><li><code>talk username</code>：连接目标用户，启动聊天会话</li></ul></li></ul><h3 id="目录命令">1. 目录命令</h3><ul><li><p>pwd：打印工作目录</p></li><li><p>cd</p></li><li><p>mkdir</p></li><li><p>rmdir</p></li><li><p>ls：列出目录中的内容</p><ul><li><p>-l：以长格式显示文件和目录的信息。</p><p>包括文件或目录的权限模式、所有者、群组、大小和最后修改日期。</p></li><li><p>-a：显示所有文件，包括以.开头的隐藏文件。</p></li><li><p>-R：递归列出所有子目录中的内容。</p></li></ul></li><li><p>mknod：创建字符设备或块设备<code>mknod [options] [name] [type] [major minor]</code></p><ul><li><code>[options]</code>：可选的标志，如 <code>-m</code>用来设置文件的权限模式。</li><li><code>[major minor]</code>：设备的节点号。主节点号和次节点号用于识别设备类型。对于字符设备，主节点号通常表示设备类，而次节点号表示特定的设备。</li></ul></li></ul><h3 id="文件命令">2. 文件命令</h3><ul><li><p>touch：创建新文件、更新文件修改时间</p></li><li><p>cp</p></li><li><p>mv：移动并重命名文件</p></li><li><p>ln：链接文件</p><ul><li>硬链接：<code>ln source_file link_name</code></li><li>符号链接：<code>ln -s /full/path/to/source source_directory/link_name</code></li></ul></li><li><p>rm</p></li><li><p>cat</p></li><li><p>chown：改变文件或目录的所有者。<code>chown [options] [user:group] [file...]</code></p><ul><li><p><code>[options]</code>：</p><p><code>-R</code> 用于递归改变所有子目录和文件的所有者；</p><p><code>-h</code>：对于符号链接，改变链接本身的所有者，而不是链接指向的文件。</p></li><li><p><code>[user:group]</code>：指定新的所有者和组。用户名可以单独指定，或者与组名一起指定。如果只指定用户名，则默认组为用户所属的默认组。</p></li><li><p><code>[file...]</code>：要改变所有者的文件或目录列表。</p></li></ul></li><li><p>chgrp：改变文件或目录的组所有权。<code>chgrp [options] [group] [file...]</code></p></li><li><p>more/less：分页查看文件内容</p><ul><li>more：逐页显示文件，空格下一页，<code>b</code>上一页，<code>q</code>退出</li><li>less：滚动显示文件，功能更多。<ul><li>按 <code>/</code> ，输入搜索词搜索文件内容，按 <code>n</code>查找下一个匹配项，按 <code>p</code> 查找上一个匹配项。</li></ul></li></ul></li></ul><h4 id="文件权限">文件权限</h4><p>三个访问等级：</p><ul><li>用户</li><li>群组</li><li>其他</li></ul><p>三个权限：</p><ul><li>读 r</li><li>写 w</li><li>执行 x</li></ul><p>ls -l会展示文件权限</p><p>默认文件权限</p><p>file：-rw-r--r--</p><p>Directory：drwxr-xr-x</p><p>第一个字符表示文件类型，后续9个字符分别为u、g、o的rwx。</p><p>文件类型：</p><ul><li>-：常规文件</li><li>d：目录</li><li>l：链接</li><li>c：字符设备文件</li><li>b：块设备文件</li><li>p：管道</li><li>s：套接字</li></ul><p>修改权限：<code>chmod who operator what filename</code></p><ul><li>who:<ul><li>u：文件所有者</li><li>g：群组</li><li>o：系统其他用户</li><li>a：all</li></ul></li><li>operator:<ul><li>+：添加权限</li><li>-：删除权限</li><li>=: 设置明确权限</li></ul></li><li>what: rwx</li></ul><p>将u、g、o各自的rwx权限看为一个二进制数，可以用数字为它们赋予权限。</p><ul><li><p>r=4,w=2,x=1</p></li><li><p>chmod 765 file：u=rwx,g=rw,o=rx</p></li></ul><h4 id="文件编辑">文件编辑</h4><p>vi、emacs、gedit</p><h3 id="进程">3. 进程</h3><p>进程是一个正在执行的程序实例。由执行程序、它的当前值、状态信息以及通过操作系统管理此进程执行情况的资源组成。</p><ul><li><p>ps：报告进程状态</p></li><li><p>pstree：展示进程树</p></li><li><p>jobs, fg, bg, ctrl-z：任务控制</p><ul><li><p>jobs：查看当前 shell环境中所有在后台运行的任务列表，会给出每个任务的唯一编号。</p></li><li><p>fg %1：将一个后台任务调至前台执行，用%指定任务编号。</p></li><li><p>bg %1：将一个在后台暂停的任务继续运行在后台。</p></li><li><p>Ctrl+Z：将当前前台执行的任务挂起到后台。</p></li></ul></li><li><p>kill：杀死进程<code>kill [PID]</code>、发送信号给进程<code>kill [signal] [PID]</code></p></li><li><p>nohup：无视挂起信号运行指令</p></li><li><p>nice, renice：调整进程优先级</p><p>nice介于-20～19，影响调度优先级，nice越低优先级越高</p><ul><li><p>nice：启动一个新进程，并为其设置一个nice值。</p></li><li><p>renice：改变正在运行的进程的nice值。</p></li></ul></li><li><p>top：展示占用CPU最高的进程列表</p></li></ul><h3 id="寻找帮助">4. 寻找帮助</h3><p>man、info、--help</p><h3 id="重定向">5. 重定向</h3><p>标准输入、标准输出、标准错误</p><ul><li>对应的文件描述符：0, 1, 2</li></ul><p><code>&lt;、&gt;</code>：覆盖文件</p><p><code>&gt;&gt;</code>：追加到末尾</p><p><code>2&gt;</code>：将标准错误输出到文件，而标准输出仍然会输出到命令行</p><p><code>&gt;&amp;</code>：将标准输出和错误都输出到文件</p><p><code>2&gt;&amp;1</code>：将标准错误输出重定向到标准输出，与上个选项的区别是会打印到命令行</p><h3 id="管道">6. 管道</h3><p>一个进程的输出作为另一个进程的输入。</p><p><code>命令1|命令2</code>：命令1的输出会直接传递给命令2作为输入。</p><h3 id="高级命令">7. 高级命令</h3><ul><li><p>find：查找文件。<code>find [options] [path...] [-exec [command] &#123;&#125; +]</code></p><ul><li><code>[options]</code>：find命令的行为选项，如<code>-name</code>、<code>-type</code>、<code>-mtime</code> 等。<ul><li><code>-print</code>：打印找到的文件名。</li><li><code>-delete</code>：删除找到的文件。</li></ul></li><li><code>[path...]</code>：要搜索的目录路径。如果省略，默认在当前目录搜索。</li></ul></li><li><p>sed：通过模式匹配对文本进行处理。</p></li><li><p>grep：在文本文件中搜索指定的文本字符串。<code>grep [options] [pattern] [file...]</code></p><ul><li>选项：<ul><li><code>-i</code>：忽略大小写。</li><li><code>-v</code>：反转匹配，只显示不匹配的行。</li><li><code>-c</code>：计数，只输出匹配行的数量。</li><li><code>-n</code>：显示匹配行及其行号。</li><li><code>-l</code>：只输出包含匹配字符串的文件名。</li><li><code>-L</code>：只输出不包含匹配字符串的文件名。</li><li><code>-r</code> 或 <code>-R</code>：递归搜索目录中的所有文件。</li><li><code>-E</code>：使用扩展正则表达式。</li><li><code>-o</code>：只输出匹配到的部分，而不是整行内容。</li></ul></li></ul></li></ul><p>基本正则表达式：</p><ul><li><code>.</code>：匹配任意单个字符。<ul><li>例子：<code>grep '.$' file.txt</code> 将匹配 file.txt中以任意字符结尾的行。</li></ul></li><li><code>*</code>：匹配前一个字符出现零次或多次。<ul><li>例子：<code>grep 'o*' file.txt</code> 将匹配 file.txt中包含零个或多个 “o” 的行。</li></ul></li><li><code>^</code>：匹配行的开始。<ul><li>例子：<code>grep '^A' file.txt</code> 将匹配 file.txt 中以 “A”开头的行。</li></ul></li><li><code>$</code>：匹配行的结束。<ul><li>例子：<code>grep 'B$' file.txt</code> 将匹配 file.txt 中以 “B”结尾的行。</li></ul></li><li><code>[abc]</code>：匹配方括号内的任意一个字符。<ul><li>例子：<code>grep '[abc]' file.txt</code> 将匹配 file.txt 中包含“a”、“b” 或 “c” 的行。</li></ul></li><li><code>[^abc]</code>：匹配不在方括号内的任意一个字符。<ul><li>例子：<code>grep '[^abc]' file.txt</code> 将匹配 file.txt 中不包含“a”、“b” 或 “c” 的行。</li></ul></li><li><code>\</code>：转义字符，用于匹配特殊字符。<ul><li>例子：<code>grep '\\.' file.txt</code> 将匹配 file.txt中包含一个反斜杠后跟一个点（<code>.</code>）的行。</li></ul></li><li><code>()</code>：标记子表达式的开始和结束。<ul><li>例子：<code>grep '(abc|def)' file.txt</code> 将匹配 file.txt 中包含“abc” 或 “def” 的行。</li></ul></li><li><code>|</code>：逻辑或操作符。<ul><li>例子：<code>grep 'A|B' file.txt</code> 将匹配 file.txt 中包含 “A” 或“B” 的行。</li></ul></li><li><code>\&lt;</code>：匹配单词的开始（前面必须有一个单词边界）。<ul><li>例子：<code>grep '\&lt;word' file.txt</code> 将匹配 file.txt 中以“word” 开头的行，其中 “word” 是一个单词。</li></ul></li><li><code>\&gt;</code>：匹配单词的结束（后面必须有一个单词边界）。<ul><li>例子：<code>grep '\&gt;word' file.txt</code> 将匹配 file.txt 中以“word” 结尾的行，其中 “word” 是一个单词。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_5_云数据中心</title>
    <link href="http://example.com/2024/04/05/%E4%BA%91%E8%AE%A1%E7%AE%97/5-%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/"/>
    <id>http://example.com/2024/04/05/%E4%BA%91%E8%AE%A1%E7%AE%97/5-%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/</id>
    <published>2024-04-05T04:00:00.000Z</published>
    <updated>2024-06-21T07:11:10.378Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云数据中心">5-云数据中心</h1><h2 id="基本设计">1. 基本设计</h2><p>外部：不间断的电源、足够带宽的网络</p><p>内部：散热（保证设备安全）</p><h2 id="云数据中心特征">2. 云数据中心特征</h2><h3 id="特征">2.0 特征</h3><ol type="1"><li><p>高设备利用率</p><ul><li><p>通过虚拟化整合云平台系统与数据中心硬件资源，减少物理服务器数量</p></li><li><p>优化资源利用率、简化管理，降低成本、快速响应业务需求的变化等</p></li><li><p>较大的数据中心有更低的单位运营成本：网络、存储、管理</p></li></ul></li><li><p>绿色节能</p><ul><li><p>能源</p></li><li><p>功耗：服务器、空调</p></li></ul></li><li><p>自动化管理</p><ul><li><p>人力成本是大多数管理数据中心站点最大成本因素</p></li><li><p>无人值守，远程管理</p></li><li><p>门禁、通风、温度、湿度、电力均可远程调度与控制</p></li></ul></li><li><p>高可用性</p><ul><li><p>各个部分的冗余、容错、容灾设计</p></li><li><p>扩展和升级时，保持正常运行</p></li></ul></li></ol><h3 id="绿色节能技术">2.1 绿色节能技术</h3><h4 id="耗电原因">耗电原因</h4><ul><li>技术因素<ul><li>云计算中心规模不断扩大，硬件设备数量激增，导致总体耗电量大幅上升。</li><li>为了保证高可用性和稳定性，通常采用功耗相对较高的高性能处理器、内存和存储设备。</li><li>虚拟化技术的广泛应用也带来了额外的能耗。</li></ul></li><li>商业因素<ul><li>客户需求不断增长<spanclass="math inline">\(\rightarrow\)</span>数据中心建设、扩容。</li><li>激烈的市场竞争<spanclass="math inline">\(\rightarrow\)</span>不断优化更新技术。</li></ul></li></ul><h4 id="采取措施">采取措施</h4><ol type="1"><li><p>优化技术</p><ul><li>使用更高能效设备、服务器架构和更智能的资源调度策略。</li></ul></li><li><p>节约能源</p><ul><li><p>在数据中心设计和运营中充分考虑节能因素。</p><p>例如，采用更为合理的布局和散热系统设计，减少冷却能耗；</p><p>合理安排数据中心工作时间，充分利用自然冷却等方式降低能耗。</p></li></ul></li><li><p>提升硬件使用率</p><ul><li><p>例如，推广容器化技术，实现应用打包和快速部署；</p><p>采用无服务器架构，减少闲置服务器数量等。</p></li></ul></li><li><p>可再生能源</p></li><li><p>绿色云生态系统</p><ul><li>与硬件厂商、政府部门等共同合作，构建一个绿色云生态系统。通过政策引导、技术创新和市场机制等手段，推动整个行业的绿色发展。</li></ul></li></ol><h4 id="具体节能技术">具体节能技术</h4><ul><li>配电系统：高压直流配电、市电直供配电</li><li>空调系统节能：高温回风、精确制冷、自然冷空调</li><li>集装箱数据中心节能技术<ul><li>服务器设备、网络设备、空调设备、供电设备等高密度地装入固定尺寸的集装箱中</li><li>高密度、模块化、按需快速部署、移动便捷</li></ul></li><li>管理系统节能策略和算法：供电管理</li><li>新能源应用</li></ul><h3 id="自动化管理">2.2 自动化管理</h3><p>目标：使得在规模较大的情况下，实现较少人员对数据中心的高度智能管理。</p><p>工作范围：按需分配/收回资源；自动配电、冷却、消防等。</p><p>具体内容：资源的自动化调度和对业务的灵活响应。</p><ul><li>既需要单业务自治，也需要对业务和资源进行全局控制和协调。</li></ul><h4 id="特征和内容">特征和内容</h4><ol type="1"><li><p>全面可视化：多层级运行时视图，全面掌握数据中心资产、配置和各层次依赖关系的现状</p></li><li><p>自动的控制执行：全面自动化流程</p></li><li><p>多层次的无缝集成：流畅地自动执行在不同层次和组成部分之间地各种处理流程，快速的协调数据中心内外的所有变更，实现端到端的流程管理</p></li><li><p>综合与实时的报告：提供全面综合和透视依赖关系的报告提高管理水平</p></li><li><p>全生命周期支持：自动化整个“计划—实施—检查—更正”的IT流程生命周期</p></li></ol><p>实现的三个阶段：</p><ol type="1"><li><p>IT服务操作：监控和管理IT基础设施的广义集合</p><ul><li><p>目标：生成有效的全局IT支撑架构，提高IT服务质量，对活动和过程进行协调和执行</p></li><li><p>活动和过程：事故管理、事件监控和管理、问题管理</p></li></ul></li><li><p>IT服务管理：制定设施间的交互和协作处理，确保IT服务符合标准规范</p><ul><li><p>定义：根据客户需求的层次确保IT服务质量的一系列过程</p></li><li><p>主题：服务管理、服务层管理、IT资产管理、财务管理</p></li></ul></li><li><p>数据中心自动化：维护IT环境，定制、检查和执行服务层协议</p></li></ol><p>采用数据中心自动化工具必须具备如下条件</p><ul><li>管理系统</li><li>定义过程</li><li>认知非自动化过程的成本</li><li>内部流程资源</li></ul><h3 id="容灾备份">2.3 容灾备份</h3><table><thead><tr class="header"><th><strong>对比维度</strong></th><th><strong>备份</strong></th><th><strong>容灾</strong></th></tr></thead><tbody><tr class="odd"><td>使用目的</td><td>避免数据丢失，一般通过快照、备份等技术构建数据的数据备份副本，故障时可以通过数据的历史副本恢复用户数据。</td><td>避免业务中断，一般是通过复制技术（应用层复制、主机I/O层复制、存储层复制）在异地构建业务的备用主机和数据，主站点故障时备用站点可以接管业务。</td></tr><tr class="even"><td>使用场景</td><td>针对病毒入侵、人为误删除、软硬件故障等场景，可将数据恢复到任意备份点。</td><td>针对软硬件故障以及海啸、火灾、地震等重大自然灾害，运行故障切换，尽快恢复业务。源端可用区恢复正常时，可轻松利用故障恢复能力重新切换回到源端可用区。</td></tr><tr class="odd"><td>成本</td><td>通常是生产系统的1~2%。</td><td>通常是生产系统的20%~100%（根据不同的RPO/RTO要求而定），高级别的双活容灾，要求备用站点也要部署一套和主站点相同的业务系统，基础设施成本需要翻倍计算。</td></tr></tbody></table><p>容灾备份：</p><p>异地建立、维护备份存储系统，利用地理分离保证系统和数据对灾难性事件的抵御能力。</p><ul><li>容灾系统的抵抗程度：数据级容灾和应用级容灾。</li></ul><h4 id="关键技术">关键技术</h4><p>技术核心：复制数据</p><ul><li><p>镜像：将符合指定规则的报文复制到目的端口</p></li><li><p>快照：拷贝指定数据集合，用于数据备份恢复、提供额外访问通道。</p></li><li><p>基于IP的SAN的远程数据容灾备份技术：主数据中心复制到备份数据中心。</p></li><li><p>数据库复制。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_4_网络</title>
    <link href="http://example.com/2024/04/04/%E4%BA%91%E8%AE%A1%E7%AE%97/4-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2024/04/04/%E4%BA%91%E8%AE%A1%E7%AE%97/4-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C/</id>
    <published>2024-04-04T04:00:00.000Z</published>
    <updated>2024-06-21T07:10:51.728Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算网络">4-云计算网络</h1><h2 id="基本架构">1. 基本架构</h2><p>云数据中心需要基础网络将所有设备组织在本地网络里面——基础网络架构。</p><p>传统树结构：建造方便简单，但不便于拓展与升级</p><ul><li>任意一个核心交换机故障导致上千台服务器失效</li></ul><p>架构需求：低成本、高可扩展性、低配置开销、健壮性、节能</p><h3 id="改进树结构">1.1 改进树结构</h3><h4 id="fattree">FatTree</h4><ol type="1"><li>K叉树，K个Pod(集装器)，每个Pod有K个交换机，其中K/2个为接入交换机，K/2个为汇聚交换机。</li><li>Pod中每个交换机有K个接口。<ul><li>接入交换机的K/2个接口接主机，K/2个接口接汇聚交换机；</li><li>汇聚交换机的K/2个接口接接入交换机，K/2个接核心交换机。</li></ul></li><li>有<spanclass="math inline">\((K/2)^2\)</span>个核心交换机，每个交换机K个端口接K个汇聚交换机。</li><li>一个Pod内的所有交换机相互连接：完全二分图。</li><li>一个Pod内的每个汇聚交换机与一部分核心交换机连接，但是一个Pod和每一个核心交换机都有连接。</li></ol><p>两级路由表，允许两级前缀查询：Pod间流量尽可能均匀分布于核心交换机</p><p>任意两个不同Pod主机之间存在K条路径</p><ul><li>将流量在这些路径间分散</li><li>任意给定Pod的低层和高层交换机对位于本Pod的任意子网都有终结性表项</li><li>在全负载最坏的情况下实现约87%的聚合带宽</li></ul><p>与传统层次结构相比，FatTree有如下特点：</p><ul><li>消除了树形结构上层链路对吞吐量的限制</li><li>为内部节点间通信提供多条并行链路</li><li>与现有数据中心网络使用的以太网结构和IP 配置的服务器兼容</li><li>但是布线复杂了；扩展时需要重构；受到端口数限制等。</li></ul><p>FatTree的扩展性受限于核心交换机端口数量，目前比较常用的是48端口10G核心交换机，在3层树结构中能够支持27648台主机。</p><h4 id="vl2">VL2</h4><p>若干服务器连接到机架(接入)交换机；</p><p>每台接入交换机与两台汇聚交换机连接；</p><p>每台汇聚交换机与所有核心交换机连接。</p><p>特点：</p><ul><li>扁平寻址，允许服务实例被放置到网络覆盖的任何地方</li><li>负载均衡将流量统一分配到网络路径</li><li>终端系统的地址解析拓展到巨大的服务器池</li></ul><p>核心思想：使用FatTree同样的拓扑结构建立扁平的第二层网络。</p><p>机制：</p><ul><li>IP地址仅仅作为名字使用，没有拓扑含义；将服务器的名字与其位置分开。</li><li>使用可扩展、可靠的目录系统来维持名字和位置间的映射。</li><li>当服务器发送分组时，服务器上的VL2代理开启目录系统以得到实际的目的位置，然后将分组发送到目的地。</li></ul><p>优势：VL2是目前最易用于对现有数据中心网络改造的结构；应用程序使用服务地址通信而底层网络使用位置信息地址进行转发，使得虚拟机能够在网络中任意迁移而不影响服务质量。</p><p>缺点：VL2依赖于中心化的基础设施来实现2层语义和资源整合，面临单点失效和扩展性问题。</p><h3 id="递归层次结构">1.2 递归层次结构</h3><p>每一个高层的网络拓扑，由多个低层的递归单元按照递归规律相互连接构成，同时也是更高层级网络的一个递归单元。</p><ul><li>增加服务器数量<spanclass="math inline">\(\rightarrow\)</span>提高总的递归层次<ul><li>添加服务器更加灵活，可增加的数量增大</li><li>对交换机性能要求低</li></ul></li></ul><p>递归层次结构：DCell、Ficonn、BCube、MDCube</p><h4 id="ficonn">FiConn</h4><p>服务器使用两个网卡端口：主用端口连接低层网络，备用端口连接高层网络</p><p>递归定义的结构</p><ul><li>第0层为基本构建单元，n个服务器连接一个具有n个端口的交换机</li><li>每个低层<strong>FiConn</strong>中备用端口空闲的一半服务器与其他相同层次的FiConn网络中备用端口空闲的服务器连接</li><li>k层服务器、k层端口、k层链路</li></ul><h4 id="bcube">BCube</h4><p>主要使用交换机构建层次化网络</p><p>第0层：n服务器连接1交换机</p><p>第1层：n个0层连接n个交换机</p><p>……</p><p>第k层：n个k-1层连接nk交换机</p><p>交换机n个端口，服务器k+1个端口。</p><h3 id="光交换网络">1.3 光交换网络</h3><p>使用光纤交换机调整网络拓扑。</p><h2 id="软件定义网络">2. 软件定义网络</h2><h3 id="openflow">2.1 OpenFlow</h3><p>使用集中控制器控制OpenFlow Switch的Flow Table。</p><p>Controller 会为特定的工作负载计算最佳路径，从而对 Switch的数据转发定义路径。</p><p>核心理论：控制转发分离架构、可编程性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_3_虚拟化</title>
    <link href="http://example.com/2024/04/03/%E4%BA%91%E8%AE%A1%E7%AE%97/3-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2024/04/03/%E4%BA%91%E8%AE%A1%E7%AE%97/3-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/</id>
    <published>2024-04-03T04:00:00.000Z</published>
    <updated>2024-06-21T07:10:30.083Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="虚拟化技术">3-虚拟化技术</h1><p>问题：云计算涉及到哪些虚拟化技术？需要对哪些资源做虚拟化？对应的虚拟化技术和产品是什么？</p><h2 id="什么是虚拟化">0. 什么是虚拟化</h2><p>虚拟化是云计算的核心技术。</p><p>本质：通过虚拟化层逻辑化原先的物理设备，实现软硬件解耦。</p><p>核心思想：</p><ul><li><p>利用软件或固件管理程序构成虚拟化层，把物理资源映射为虚拟资源。</p></li><li><p>在虚拟资源上可以安装和部署多个虚拟机，实现多用户共享物理资源。</p></li></ul><h2 id="服务器虚拟化">1. 服务器虚拟化</h2><p>硬件级、操作系统级、程序库API、应用程序</p><p>代表产品：</p><p>裸机虚拟化（VMware vSphere）、操作系统级虚拟化（VMwareWorkstation、Docker）</p><h3 id="硬件级虚拟化">1.1 硬件级虚拟化</h3><p>使用作为虚拟化层的软件管理客户操作系统，使其独立于主机操作系统，同时运行在同硬件上。</p><ul><li>Hypervisor、Virtual Machine Monitor（VMM）</li></ul><p>要求：高效、隔离、复制</p><p>类别：裸机虚拟化、寄居虚拟化</p><h4 id="优势">优势</h4><ol type="1"><li>封装性：虚拟机快照、克隆、挂起和恢复非常便捷</li><li>多实例：降低计算机资源损耗</li><li>隔离</li><li>硬件无关性</li><li>特权功能</li></ol><h4 id="可虚拟化架构">可虚拟化架构</h4><p>使用特权级分隔应用软件和系统软件的架构。</p><p>原因：提高虚拟机控制软件直接访问硬件的效率、低特权级的虚拟机之间更易实现资源隔离。</p><h4 id="虚拟化硬件对象">虚拟化硬件对象</h4><p>CPU、内存、I/O设备</p><h5 id="cpu虚拟化">CPU虚拟化</h5><ul><li>任意时刻一个物理CPU只能运行一个虚拟CPU</li><li>每个客户操作系统可以使用一个或多个虚拟CPU</li><li>各个操作系统之间虚拟CPU运行相互隔离，互不影响</li></ul><p>调度：VMM决定哪个虚拟CPU在哪个物理CPU上运行，保证隔离、公平和性能</p><p>执行：虚拟CPU保证虚拟机的指令正确运行。</p><ul><li>实现技术：模拟执行、监控执行</li></ul><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：解释、扫描、翻译</li><li>基于硬件辅助的虚拟化：硬件针对虚拟化作出支持</li><li>修改操作系统的类虚拟化：修改客户机操作系统，配合VMM进行虚拟化</li></ol><h5 id="内存虚拟化">内存虚拟化</h5><p>把物理内存统一管理，包装成多个虚拟的物理内存提供给虚拟机使用。</p><p>每个虚拟机拥有各自独立的内存空间。</p><p>VMM的工作：</p><ol type="1"><li>维护客户机物理地址和宿主机器的机器地址之间的映射</li><li>截获虚拟机对客户机物理地址的访问，并根据所记录的映射关系，转换成机器地址</li></ol><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：影子页表，直接把客户机虚拟地址翻译为物理地址</li><li>基于硬件辅助的虚拟化：硬件辅助地址转换</li><li>修改操作系统的类虚拟化：客户机直接使用VMM的机器地址到物理地址的翻译表</li></ol><h5 id="io虚拟化">I/O虚拟化</h5><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：VMM进行设备模拟并处理所有设备请求与响应</li><li>基于硬件辅助的虚拟化：DMA地址重映射</li><li>修改操作系统的类虚拟化：修改客户机操作系统，客户机直接与物理设备交互</li></ol><h3 id="操作系统级虚拟化">1.2 操作系统级虚拟化</h3><p>在主机操作系统中插入一个虚拟化层。</p><p>在同一个操作系统内核内，运行多个虚拟机；虚拟机可以访问内核。</p><p>虚拟机/容器</p><p>容器的优缺点：</p><ul><li>启动/停止开销最小，资源需求低，可扩展性强</li><li>可同步虚拟机与宿主操作系统环境状态的变化</li><li>允许虚拟机中进程访问尽可能多的主机资源</li><li>同一个容器中的操作系统级虚拟机必须使用相同的客户操作系统</li><li>资源隔离性较差</li></ul><h2 id="云数据中心虚拟化">2. 云数据中心虚拟化</h2><p>为什么要虚拟化？</p><ul><li>一台物理设备一个用户 vs.一台物理设备多个用户：提升资源共享与复用的效率，降低成本</li><li>固定大小与位置的存储空间 vs.灵活扩展和空间分布的空间：提升可扩展性，提升存储资源使用效率</li><li>为了实现服务器、存储虚拟化，要求网络也要能够方便、灵活地调整：随着虚拟机的迁移一起迁移</li></ul><h3 id="服务器虚拟化-1">服务器虚拟化</h3><p>将一个或多个物理服务器虚拟成多个逻辑上的服务器。</p><p>虚拟机、容器。</p><h3 id="存储虚拟化">存储虚拟化</h3><p>把分布的异构存储设备统一为一个或几个大的存储池。</p><p>存储虚拟化将系统中分散且异构的存储资源整合起来，形成一个统一连续编址的逻辑存储空间。</p><h3 id="网络虚拟化">网络虚拟化</h3><p>在底层物理网络和网络用户之间增加一个抽象层。</p><p>云数据中心对网络的需求</p><ul><li>提高数据传输效率：应对数据同步、备份、虚拟机迁移等的大流量</li><li>提高管理效率：采用统一的交换网络减少布线、维护和扩容的成本</li></ul><p>网络虚拟化技术：</p><ul><li><p>核心层网络虚拟化</p></li><li><p>虚拟机网络虚拟化</p></li><li><p>接入层网络虚拟化</p></li></ul><h2 id="虚拟机迁移">3. 虚拟机迁移</h2><h3 id="需求">需求</h3><ol type="1"><li><p>负载平衡需要</p></li><li><p>物理服务器定期升级的需要</p></li></ol><p>关注重点：实时迁移</p><ul><li>保持虚拟机运行的同时，将其从一个计算机迁移到另一个计算机，并在目的计算机恢复运行</li></ul><h3 id="迁移内容">迁移内容</h3><ul><li>内存迁移：最困难</li><li>网络迁移：迁移网络设备、协议状态和配置</li><li>存储设备迁移：使用NAS作为存储设备共享数据</li></ul><p>分类：</p><ul><li>物理机到虚拟机 P2V</li><li>虚拟机到虚拟机 V2V</li><li>虚拟机到物理机 V2P</li></ul><h3 id="内存迁移方案">内存迁移方案</h3><table><thead><tr class="header"><th>迁移方案</th><th>具体描述</th><th>优势与劣势</th></tr></thead><tbody><tr class="odd"><td>Stop and Copy</td><td>A停机，将对应内存全部复制到B，启动B</td><td>方法简单，总迁移时间最短，但停机时间无法接受</td></tr><tr class="even"><td>Stop and Copy和Pull阶段结合</td><td>A停机，将部分内存复制到B，启动B，B运行中遇到缺失内存，再到A内存中复制</td><td>停机时间很短，总迁移时间很长。Pull阶段复制造成的性能下降，用户体验差</td></tr><tr class="odd"><td>Push和Stop and Copy阶段结合</td><td>A不停机，保持对外服务，将变化的内存迭代地复制到B，直到最后剩余很少要复制的再停止A，复制最后变动到B，启动B</td><td>平衡了停机时间和总迁移时间之间的矛盾。需要有一种算法能够测定工作集，以避免反复重传。可能会占用大量的网络带宽，对其他服务造成影响</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_2_架构</title>
    <link href="http://example.com/2024/04/02/%E4%BA%91%E8%AE%A1%E7%AE%97/2-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2024/04/02/%E4%BA%91%E8%AE%A1%E7%AE%97/2-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/</id>
    <published>2024-04-02T04:00:00.000Z</published>
    <updated>2024-06-21T07:26:02.071Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算架构">2-云计算架构</h1><h2 id="计算架构的演化">1. 计算架构的演化</h2><h3 id="发展历程">1.1 发展历程</h3><ol type="1"><li>中央集权架构：所有计算、计算资源、业务逻辑都集中于一台主机</li><li>客户机/服务机架构（C/S架构）<ul><li>客户端：承载少量计算任务和所有IO任务</li><li>服务器：承载主要计算任务</li><li>优点：充分利用客户端计算能力；关注点分离，简化软件复杂度、编程模式</li><li>缺点：持久链接，系统伸缩能力受限；客户端开发维护成本高；平台相关，升级换代麻烦</li></ul></li><li>中间层架构：将业务逻辑和数据服务分别放在两个服务器上（还是C/S架构）<ul><li>客户机到中间件为无状态的非持久链接：提升架构弹性</li></ul></li><li>浏览器/服务器架构（B/S架构）<ul><li>对客户机、中间层架构的扩展——客户端开发、维护成本降低，升级改动小</li><li>客户端：负载进一步缩减，仅显示和运行基于浏览器的脚本程序</li><li>服务器：Web服务器层屏蔽各中间件的差异，提供通用的用户访问界面</li><li>扩展性高：对客户机性能无要求</li><li>对网络性能要求高</li></ul></li><li>C/S和B/S混合架构<ul><li>没有一种架构能够适用于所有场景</li><li>有些服务需要持久的链接（内部用户）</li><li>有些仅通过非持久链接即可（外部用户）</li></ul></li><li>面向服务的架构（SOA）</li><li>微服务架构：在SOA思想上对系统业务做彻底的组件化、服务化。</li></ol><h3 id="面向服务的架构soa">1.2 面向服务的架构（SOA）</h3><p>通过定义良好的接口，联系应用程序的不同服务的组件模型。</p><p>接口：中立定义，独立于硬件平台、操作系统和编程语言。</p><ul><li><p>服务交互方式统一、通用。</p></li><li><p>服务只做本职工作，暴露接口。</p></li><li><p>通过统一的界面协调多个服务：控制复杂性，更容易管理。</p></li></ul><p>SOA的目标：系统更有弹性，更灵活、更快地响应不断改变的企业业务需求，解决软件重用问题。</p><p>具体通过：</p><ul><li>简单的服务间接口</li><li>粗粒度：调用者和服务层只需一次交互</li><li>松耦合：服务间相对独立无依赖</li><li>位置透明</li><li>协议无关</li></ul><p>SOA架构角色：</p><ul><li>服务请求者</li><li>服务提供者</li><li>服务注册中心</li></ul><p>操作：</p><ul><li>发布</li><li>查询</li><li>绑定和调用</li></ul><h2 id="云计算架构二维视角">2. 云计算架构二维视角</h2><p>基础架构 + 应用程序（后端+前端）</p><h3 id="基础架构">2.1 基础架构</h3><p>虚拟化层</p><ul><li><p>将硬件转换为统一的IT资源（可灵活拆分、统一计量、统一管理、软件定义的）</p></li><li><p>可以在不同的抽象层实现：应用层、操作系统层、体系结构层、硬件层等</p></li></ul><p>Web服务层</p><ul><li><p>将云资源提供给客户的一种最方便的方式，解决大部分客户无法直接使用虚拟机的问题；</p></li><li><p>支持面广、对客户端要求低，只需要浏览器就可以访问。</p></li></ul><p>服务总线层</p><ul><li>中间件层，封装计算服务、数据存储、消息传递</li><li>分离用户与虚拟化层、连接用户与Web服务层。</li></ul><p>客户机用户界面</p><ul><li><p>Web门户，将各种服务混搭集成在一个页面。</p></li><li><p>基于Ajax，Javascript，趋势是使用功能完善的组件</p><ul><li>如JavaBeans/Applets，Silvedight/.NET等</li><li>可下载和安装在客户机上</li></ul></li></ul><p>###　2.2 云应用程序结构</p><p>传统操作系统上的应用程序：进程、线程、服务、shell（应用程序的控制接口）</p><ul><li>进程就是最终产品，每一个进程可运行多个指令序列（线程），一个线程对应一种服务。</li></ul><p>云环境中的应用程序：应用程序、应用实例、服务、云命令行界面（控制端）</p><ul><li><p>应用程序由多个同时运行的实例支撑</p></li><li><p>不同的应用实例运行在不同的服务器上，每一个应用实例提供一种或多种服务</p></li><li><p>服务间相互独立</p></li></ul><h2 id="云计算逻辑架构">3. 云计算逻辑架构</h2><h3 id="云体">3.1 云体</h3><p>云计算的物质基础，使用的资源集合，构成云计算的软硬件环境。</p><ul><li><p>例如网络、服务器、存储器、交换机等。</p><p>广义的云体包括数据中心机器辅助设施如电力、空调、机架、冷却等系统。</p></li></ul><p>目前，云体就是数据中心。</p><p>云计算的横向架构。</p><p>传统系统环境：进程/线程/内存管理 + 文件系统 + 进程间通信/网络。</p><p>云运行时环境：计算资源+持久存储+通信</p><h4 id="云数据中心">云数据中心</h4><p>数据集中存储、计算、交换的中心。</p><p>传统数据中心的问题</p><ul><li>机器过多、利用率过低</li><li>应用迁移太困难</li><li>存储需求增长太快</li></ul><p>云数据中心：重视虚拟化，以提高资源利用率</p><p>软件定义数据中心：</p><ul><li>软件定义计算：计算节点虚拟化。</li><li>软件定义存储：分离管理接口与数据读写。管理接口统一，数据读写可以兼容各种方式。</li><li>软件定义网络：数据平面（数据转发）和控制平面（转发表的设置等）分离；集中控制，分布式转发。</li></ul><h3 id="云栈">3.2 云栈</h3><p>又称云平台，是在云上建造的运行环境。</p><ul><li><p>支持应用程序的发布、运行、监控、调度、伸缩，</p><p>并为应用程序提供辅助服务机制，如访问控制、权限管理等。</p></li></ul><h4 id="云栈的三层模式">云栈的三层模式</h4><ol type="1"><li>基础设施即服务层：硬件+虚拟化</li><li>平台即服务层：应用程序的运行环境</li><li>软件即服务层：Web应用服务</li></ol><h4 id="云计算技术架构">云计算技术架构</h4><p>SOA构建层+管理中间件层+资源池层+物理资源层</p><p>管理中间件层和资源池层是云计算技术的最关键部分。</p><h4 id="iaas实现机制">IaaS实现机制</h4><ol type="1"><li>配置工具：在分配的节点上准备任务运行环境。</li><li>系统管理模块：管理和分配所有可用的资源，其核心是负载均衡。</li><li>服务目录：用户可以访问的服务清单。</li><li>用户交互接口：Web用户访问接口。</li><li>监视统计模块：监视节点运行状态，统计节点使用情况。</li></ol><h3 id="云计算">3.3 云计算</h3><p>利用云体和云平台所进行的计算或处理。</p><p>无论在哪个层面开展，只要符合“按量计费、资源可伸缩”就是云计算。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_1_概念</title>
    <link href="http://example.com/2024/04/01/%E4%BA%91%E8%AE%A1%E7%AE%97/1-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2024/04/01/%E4%BA%91%E8%AE%A1%E7%AE%97/1-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E5%BF%B5/</id>
    <published>2024-04-01T04:00:00.000Z</published>
    <updated>2024-06-21T07:25:56.523Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算概念">1-云计算概念</h1><p>大规模分布式计算模式，通过一系列技术实现按需交付。</p><h2 id="计算模式的发展历程">1. 计算模式的发展历程</h2><p>主机系统与集中计算<spanclass="math inline">\(\rightarrow\)</span>集群计算<spanclass="math inline">\(\rightarrow\)</span>个人计算机与桌面计算<spanclass="math inline">\(\rightarrow\)</span>分布式计算<spanclass="math inline">\(\rightarrow\)</span>网格计算<spanclass="math inline">\(\rightarrow\)</span>​云计算</p><ul><li><strong>效用计算</strong>：将IT资源包装成可以度量的服务提供给用户。</li><li><strong>服务计算</strong>（软件即服务SaaS）：将应用程序作为服务提供。</li></ul><p>云计算：效用计算+服务计算</p><h3 id="对计算的追求">对计算的追求</h3><p>自动化、高性能、易使用</p><h3 id="云计算持续优化的动力">云计算持续优化的动力</h3><ol type="1"><li>节能</li><li>降低成本</li><li>提升资产安全</li><li>提升信息系统容灾备份能力</li></ol><h2 id="云计算的特征与分类">2. 云计算的特征与分类</h2><h3 id="特征">2.1 特征</h3><ul><li><p>物理特征：大规模</p></li><li><p>技术特征：虚拟化</p></li><li><p>商业特征：按需服务</p></li><li><p>使用特征：通用、高可伸缩</p></li><li><p>目标：高可靠</p></li></ul><h3 id="云部署模型">2.2 云部署模型</h3><p>公有云：由第三方云提供者拥有的可公共访问的云环境</p><p>私有云：由一家组织单独拥有，利用云计算技术来访问组织内部的IT资源</p><p>混合云：由两种或者更多不同云部署模型组成的云环境</p><h3 id="云服务模型">2.3 云服务模型</h3><ul><li>软件作为服务：Software as a Service，SaaS</li><li>平台作为服务：PaaS</li><li>基础设施作为服务：IaaS</li></ul><h4 id="iaas">IaaS</h4><p>通过虚拟机方式对外提供计算、存储和网络能力</p><ul><li>虚拟机安装操作系统，享有公网IP，使用公网访问虚拟机</li><li>额外租用存储设备挂载到虚拟机</li><li>多个虚拟机之间通过公用网络、私有网络进行通信</li></ul><p>类似租用独立的计算机，用户自行解决多台机器之间的协同问题</p><p>优势</p><ul><li>允许用户动态申请和释放资源</li><li>按使用量计费</li><li>更高的资源使用效率（节能环保）</li></ul><h4 id="paas">PaaS</h4><p>提供用户应用程序的开发和运行环境，包括应用编程接口和运行平台等，支持应用从创建到运行整个生命周期需要的各种软硬件资源和工具。</p><ul><li>经过封装的IT能力，或逻辑资源：数据库、文件系统和应用运行环境</li><li>主要面向软件开发者（包括应用服务上）</li></ul><p>PaaS自身负责资源的动态扩展和容错管理，用户无需考虑节点间的配合问题。</p><p>用户自主权降低，需按照给定的编程环境和编程模型构建应用。</p><h4 id="saas">SaaS</h4><p>通过标准的Web浏览器或软件客户端访问云上的应用。</p><h3 id="相关技术">2.4 相关技术</h3><p>虚拟化技术、容器技术、数据加密、分布式计算与分布式存储等。</p><h4 id="分布式计算">分布式计算</h4><p>多个通过网络互联的计算机相互之间传递数据，实现信息共享，协作共同完成处理任务。</p><p>优势：</p><ul><li>资源共享</li><li>多设备负载均衡</li><li>将程序放在最适合的计算机上运行</li></ul><h2 id="云计算三元认知">3. 云计算三元认知</h2><h3 id="商业模式">3.1 商业模式</h3><p>一种全新的商业模式、服务类型。</p><ul><li>在软件服务基础上提供平台和基础设施服务</li><li>具体实现：云平台，包括计算范式和实现方式</li></ul><h3 id="计算范式">3.2 计算范式</h3><p>理论实现，针对商业模式的架构设计。</p><ul><li>云体逻辑结构：具体落地的云平台逻辑结构。<ul><li>物理结构：云数据中心</li><li>计算+存储+通信</li></ul></li><li>云栈逻辑结构：面向服务的云平台逻辑结构。<ul><li>物理结构：管理系统的结构</li><li>基础设施即服务，平台即服务，软件即服务</li></ul></li></ul><h3 id="实现方式">3.3 实现方式</h3><p>数据中心+云平台管理系统</p><ul><li>软件定义数据中心：软件定义计算，软件定义存储，软件定义网络，软件定义安全。</li></ul><h2 id="云计算的开源方法论">4. 云计算的开源方法论</h2><h3 id="什么是开源">4.1 什么是开源</h3><p>开源是一种方法论、一种构造大规模复杂软件的协作方式。</p><p>开源软件：</p><p>一种版权持有人为任何人和任何目的提供学习、修改和分发权力，并公布源代码的计算机软件。</p><ol type="1"><li><p>许可证不应限制任何个人或团体将包含该开源软件的广义作品进行销售或赠予</p></li><li><p>开源软件的程序必须包含源代码，必须允许发布源代码及以后的程序</p></li><li><p>开源软件许可证必须允许修改和派生作品，并允许使用原有软件的许可条款发布他们</p></li></ol><p>开源不一定自由，开源不一定免费；自由不一定免费；免费不一定开源，不一定自由。</p><h3 id="开源的价值与意义">4.2 开源的价值与意义</h3><ol type="1"><li>开源促进国家信息技术创新，带动经济发展</li><li>软件厂商依托开源提升研发能力</li><li>用户使用开源技术改变信息化路线</li><li>企业自主开源，引领技术发展路径</li></ol><h2 id="云计算技术的挑战与未来">5. 云计算技术的挑战与未来</h2><h3 id="难点">5.1 难点</h3><ol type="1"><li><p>数据中心安全控制</p></li><li><p>构建高度同构化的虚拟资源</p></li><li><p>高可用性的实现——资源管理</p></li><li><p>容错的实现——任务管理</p><p>当集群中的服务出现故障时，服务器集群上的程序执行不会被中端或挂起。</p></li><li><p>节能（负载均衡）——任务管理</p><p>任务调度；虚拟机调度。</p></li><li><p>云安全与隐私保护——安全管理</p><p>基础设施安全，平台安全，软件安全；数据完整性和隐私保护等。</p></li></ol><p><span class="math inline">\(集群可用性=\frac{MTTF(两个相邻故障之间的系统平均正常运行时间)}{MTTF+MTTR(发生故障后修复及还原工作状态的平均时间)}\)</span></p><h3 id="风险与挑战">5.2 风险与挑战</h3><ol type="1"><li><p>增加了安全漏洞</p><ul><li>远程使用IT资源需要云用户将信任边界扩展到外部的云，建立这样的安全架构同时又不引入安全漏洞是非常困难的</li><li>重叠的信任边界和不断增加的数据曝光为恶意的云用户提供了更多的攻击IT资源、窃取或破坏企业数据的机会</li></ul></li><li><p>降低了运营管理控制能力</p><ul><li>云用户对云资源的管理控制低于对企业内部IT资源的管理控制<ul><li>云提供者可能不遵守它发布的云服务保证</li><li>云用户和云提供者之间较长的地理距离可能需要更多的网络跳数，会带来延迟波动和带宽受限</li></ul></li></ul></li><li><p>云提供者之间有限的可移植性</p><ul><li>由于缺乏行业标准，不同的云提供者提供的服务存在较大差异</li></ul></li><li><p>法规和法律问题</p><ul><li><p>第三方云提供者通常选择造价较低、方便的地理位置建立数据中心，而云用户通常不会意识到所使用IT资源和自身数据所存放的位置</p></li><li><p>某些云用户可能会遇到严重的法律问题</p><p>例如：英国法律规定，英国公民的个人数据只能留在英国境内</p></li><li><p>潜在的数据获得和公开</p><p>例如：某些国家的法律规定，某些类型的数据必须向某些政府机构或数据主体公开</p></li></ul></li></ol><h3 id="缺陷与未来">5.3 缺陷与未来</h3><ul><li>从平台角度看——没有统一的标准</li><li>从计算角度看——针对松耦合的数据处理</li><li>从数据角度看——管理和分析商业数据</li><li>从资源集成角度看——必须集中到云中</li><li>从信息安全角度看——暴露、丢失的风险</li></ul><p>这也恰是网格的优势。</p><p>未来：云格计算</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
</feed>
