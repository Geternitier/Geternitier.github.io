<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Geternitier的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-21T07:24:02.689Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Geternitier</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统编程_4_内核驱动</title>
    <link href="http://example.com/2024/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E7%AB%A0%20%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"/>
    <id>http://example.com/2024/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E7%AB%A0%20%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/</id>
    <published>2024-05-04T04:00:00.000Z</published>
    <updated>2024-06-21T07:24:02.689Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第4章-内核驱动">第4章 内核驱动</h1><h2 id="什么是内核">0. 什么是内核？</h2><p>操作系统是一系列程序的集合，其中最重要的部分构成了内核。</p><p>单内核/微内核</p><ul><li>单内核是一个很大的进程，内部可以分为若干模块，运行时是一个独立的二进制文件，模块间通讯通过直接调用函数实现</li><li>微内核中大部分内核作为独立的进程在特权下运行，通过消息传递进行通讯</li></ul><p>Linux内核的能力</p><ul><li>内存管理，文件系统，进程管理，多线程支持，抢占式，多处理支持</li></ul><p>Linux内核区别于其他UNIX商业内核的优点</p><ul><li>单内核，模块支持</li><li>免费/开源</li><li>支持多种CPU，硬件支持能力非常强大</li><li>Linux开发者都是非常出色的程序员</li><li>通过学习Linux内核的源码可以了解现代操作系统的实现原理</li></ul><h3 id="配置内核">配置内核</h3><p>下载源码、解压、make clean、<strong>make menuconfig</strong></p><figure><img src="/image/Linux系统编程/menu.png" alt="menu" /><figcaption aria-hidden="true">menu</figcaption></figure><p>编译内核：</p><ul><li>make</li><li>make zImage、make bzImage：生成压缩内核镜像</li><li>make modules：编译模块</li></ul><p>make install：将编译好的内核copy到/boot</p><h2 id="驱动">1. 驱动</h2><p>许多常见驱动的源代码集成在内核源码里，也有第三方开发的驱动，可以单独编译成模块.ko。编译需要内核头文件的支持。</p><p>驱动运行在内核态。</p><h3 id="加载模块">加载模块</h3><p>底层命令：</p><p>insmod：<code>insmod [options] module_file</code></p><ul><li><code>-f</code>: 强制加载模块，即使模块已被其他进程使用。</li><li><code>-o</code>: 指定模块的参数。</li><li><code>-v</code>: 显示详细信息。</li></ul><p>rmmod：<code>rmmod [options] module_name</code></p><ul><li><code>-f</code>: 强制卸载模块，即使模块已被其他进程使用。</li><li><code>-s</code>: 模块卸载后，不更新/proc/modules文件。</li><li><code>-w</code>: 在卸载模块之前，等待其关闭所有文件描述符。</li></ul><p>高层命令：</p><p>modprobe：<code>modprobe [options] module_name</code></p><ul><li><code>-a</code>: 自动加载所有依赖的模块。</li><li><code>-c</code>: 从 /etc/modprobe.conf 中读取配置。</li><li><code>-d</code>: 检测模块依赖，但不加载它们。</li><li><code>-e</code>: 禁止使用某些内核特性（如 SMP）。</li><li><code>-k</code>: 保留内核符号表。</li><li><code>-l</code>: 列出可以加载的模块，而不实际加载它们。</li><li><code>-n</code>: 禁止自动插入已指定名字的模块。</li><li><code>-p</code>: 使用预设的模块参数。</li><li><code>-r</code>: 删除模块及其依赖的模块。</li><li><code>-s</code>: 使模块静默加载，不输出信息。</li><li><code>-v</code>: 输出更多的信息。</li></ul><p>模块依赖</p><p>自动按需加载/卸载</p><p>moddep：列出指定内核模块所依赖的其他模块</p><p>lsmod：列出当前内核加载的所有模块及其各种信息</p><p>modinfo：显示关于内核模块的详细信息</p><h3 id="模块编写">模块编写</h3><p>不能使用c库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/moduleparam.h&gt;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> test;<br><span class="hljs-built_in">module_param</span>(test, <span class="hljs-type">int</span>, <span class="hljs-number">0644</span>);<span class="hljs-comment">//module_param(变量名称，类型, 访问许可掩码)</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">hello_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(KERN_INFO “Hello world test=%d \n” , test);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">hello_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;Goodbye world\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-built_in">MODULE_DESCRIPTION</span>(<span class="hljs-string">&quot;Test&quot;</span>);<br><span class="hljs-built_in">MODULE_AUTHOR</span>(<span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-built_in">module_init</span>(hello_init);<br><span class="hljs-built_in">module_exit</span>(hello_exit);<br></code></pre></td></tr></table></figure><h4 id="导出符号">导出符号</h4><p>如果一个模块需要向其他模块导出符号（方法或全局变量），需要使用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">EXPORT_SYMBOL(<span class="hljs-params">name</span>)</span>;<br><span class="hljs-constructor">EXPORT_SYMBOL_GPL(<span class="hljs-params">name</span>)</span>;<br></code></pre></td></tr></table></figure><p>符号必须在模块文件的全局部分导出。</p><p>/proc/kallsyms 可以显示所有导出的符号。</p><h3 id="字符设备">字符设备</h3><h4 id="设备号">设备号</h4><p>一个字符设备或者块设备都有一个主设备号和次设备号。</p><ul><li>主设备号和次设备号统称为设备号。<ul><li>主设备号用来表示一个特定的驱动程序。</li><li>次设备号用来表示使用该驱动程序的各设备。</li></ul></li></ul><h4 id="cdev">cdev</h4><p>linux内核中使用cdev结构体来描述字符设备。该结构体是所有字符设备的抽象，其包含了大量字符设备所共有的特性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> cdev *my_cdev = cdev<span class="hljs-constructor">_alloc()</span>;<br>my_cdev-&gt;ops = &amp;my_fops;<br>void cdev<span class="hljs-constructor">_init(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">cdev</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file_operations</span> <span class="hljs-operator">*</span><span class="hljs-params">fops</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="初始化加载过程">初始化加载过程</h4><ol type="1"><li>申请设备号</li><li>定义文件操作结构体 file_operations</li><li>创建并初始化定义结构体 cdev</li><li>将cdev注册到系统，并和对应的设备号绑定</li><li>在/dev文件系统中用mknod创建设备文件，并将该文件绑定到设备号上</li></ol><p>申请释放设备号：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">first</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>;<br><span class="hljs-built_in">int</span> alloc<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">firstminor</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>;<br>void unregister<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">first</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span>;<br></code></pre></td></tr></table></figure><p>设备注册与释放</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> cdev<span class="hljs-constructor">_add(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">dev_t</span> <span class="hljs-params">num</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span>;<br>void cdev<span class="hljs-constructor">_del(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程_3_编程</title>
    <link href="http://example.com/2024/05/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0%20Linux%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/05/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0%20Linux%E7%BC%96%E7%A8%8B/</id>
    <published>2024-05-03T04:00:00.000Z</published>
    <updated>2024-06-21T07:23:49.037Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第3章-linux编程">第3章 Linux编程</h1><h2 id="编程前的准备">0. 编程前的准备</h2><h3 id="编译命令">0.1 编译命令</h3><p>gcc -c（编译）</p><p>gcc（链接 或者 编译 + 链接）</p><p>g++（C++对应的命令，其实就是换了前端）</p><p>gcc [options] [filename]</p><p>基础可选项:</p><ul><li>-E: 只对源程序进行预处理(调用cpp预处理器)</li><li>-S: 只对源程序进行预处理、编译</li><li>-c: 执行预处理、编译、汇编而不链接</li><li>-o output_file: 指定输出文件名</li><li>-g: 产生调试工具必需的符号信息</li><li>-O/On: 在程序编译、链接过程中进行优化处理</li><li>-Wall: 显示所有的警告信息</li><li>-Idir: 指定额外的头文件搜索路径</li><li>-Ldir: 指定额外的库文件搜索路径</li><li>-lname: 链接时搜索指定的库文件</li><li>-DMACRO[=DEFN]: 定义MACRO宏</li></ul><h3 id="make">0.2 make</h3><p>make [-f Makefile] [option] [target]</p><p>makefile描述模块间的依赖关系，make命令根据makefile对程序进行管理和维护；make判断被维护文件的时序关系。</p><h4 id="make执行顺序">make执行顺序</h4><ol type="1"><li>make会在当前目录下找名字叫“Makefile” 或“makefile” 的文件。</li><li>查找文件中的第一个目标文件（target），举例中的hello</li><li>如果hello文件不存在，或是hello所依赖的文件修改时间要比hello新，就会执行后面所定义的命令来生成hello文件。</li><li>如果hello所依赖的.o文件不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（类似一个堆栈的过程）</li><li>make根据.o文件的规则生成 .o 文件，然后再用 .o文件生成hello文件。</li></ol><h4 id="makefile规则结构">Makefile规则结构</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">target <span class="hljs-string">...</span> : prerequisites <span class="hljs-string">...</span><br><span class="hljs-keyword">command</span>```<br></code></pre></td></tr></table></figure><ul><li>target是一个目标文件，可以是Object File，也可以是执行文件</li><li>prerequisites是要生成target所需要的文件或是目标</li><li>command是make需要执行的命令。（可以是任意的Shell命令）</li></ul><p>例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hello : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span><br>gcc -o hello <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span><br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs<span class="hljs-selector-class">.h</span><br>cc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br><span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.c</span> defs<span class="hljs-selector-class">.h</span> command<span class="hljs-selector-class">.h</span><br>cc -c <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.c</span><br>clean :<br>rm edit <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span>.o<br></code></pre></td></tr></table></figure><p>伪目标：clean</p><p>取名不能和文件名重名，可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”。</p><ul><li><p>一般没有依赖的文件，但也可以为伪目标指定所依赖的文件。</p></li><li><p>伪目标同样可以作为“默认目标”，只要将其放在第一个。</p></li></ul><h4 id="预定义变量">预定义变量</h4><ul><li>$&lt; 第一个依赖文件的名称</li><li>$?所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚</li><li>$+所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件</li><li>$^ 所有的依赖文件，以空格分开，不包含重复的依赖文件</li><li>$* 不包括扩展名的目标文件名称</li><li>$@ 目标的完整名称</li><li>$% 如果目标是归档成员，则该变量表示目标的归档成员名称</li></ul><h4 id="多目标扩展">多目标扩展</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">targets</span> <span class="hljs-attr">...</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">target-pattern</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">prereq-patterns</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">commands</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = foo.o bar.o<br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br><span class="hljs-variable">$(objects)</span>: %.o: %.c<br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><ul><li>目标从$object中获取</li><li>“%.o”表明要所有以“.o”结尾的目标，即“foo.obar.o”，就是变量$object集合的模式</li><li>依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是依赖的目标就是“foo.c bar.c”</li></ul><h4 id="函数">函数</h4><p>调用语法：</p><ul><li><p><code>$(&lt;function&gt; &lt;arguments&gt;)</code></p></li><li><p><code>$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</code></p></li><li><p>字符串处理函数</p><ul><li><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></li><li><code>$(strip &lt;string&gt;)</code></li></ul></li><li><p>文件名操作函数</p><ul><li><code>$(dir &lt;names...&gt;)</code></li><li><code>$(basename &lt;names...&gt;)</code></li></ul></li><li><p>foreach函数：<code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></p></li><li><p>if函数：<code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code></p></li><li><p>call函数：<code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code></p></li></ul><h2 id="文件系统">1. 文件系统</h2><p>文件：可以被读写的对象。</p><ul><li>文件的属性包含访问权限、文件类型。</li></ul><p>文件系统：文件及其属性的集合。</p><h3 id="文件类型和结构">1.1 文件类型和结构</h3><p>文件类型：</p><ul><li>-：常规文件</li><li>d：目录</li><li>l：链接</li><li>c：字符设备文件</li><li>b：块设备文件</li><li>p：管道</li><li>s：套接字</li></ul><p>文件结构：字节流</p><h3 id="vfsvirtual-file-system-switch">1.2 VFS：Virtual File SystemSwitch</h3><p>用户程序系统调用的统一接口，连接Ext2、FAT等多种不同的文件系统。</p><p>虚拟、只存在于内存。</p><p>组件：</p><ul><li>超级块：文件系统的元数据，它包含了文件系统的全局信息，如块大小、inode和数据块的数量、分配策略等。</li><li>i-node：文件的元数据，如文件的大小、创建时间、最后访问时间、最后修改时间、文件权限等，但不包括文件名和文件数据本身。</li><li>文件：打开的文件，包含了读写文件的当前位置、文件的状态等。</li><li>dentry：文件系统中的一个目录入口，即一个路径名与一个i-node的映射。</li></ul><h3 id="硬链接和符号链接">1.3 硬链接和符号链接</h3><p>硬链接：</p><ul><li>不同的文件名对应同一个inode</li><li>不能跨越文件系统</li><li>对应系统调用link</li></ul><p>符号链接</p><ul><li>存储被链接文件的文件名(而不是inode)实现链接</li><li>可跨越文件系统</li><li>对应系统调用symlink</li></ul><h3 id="系统调用和库函数">1.4 系统调用和库函数</h3><p>都是C函数。</p><p>系统调用：Linux内核的对外接口；用户程序和内核之间唯一的接口。</p><p>库函数：依赖于系统调用，提供较复杂功能。</p><h4 id="基础io系统调用">基础I/O系统调用</h4><ul><li>文件描述符：非负整数<ul><li>STDIN_FILENO (0)、STDOUT_FILENO (1)、STDERR_FILENO (2)</li></ul></li><li>基础I/O函数<ul><li>open/creat、close、read、write、lseek</li><li>dup/dup2</li><li>fcntl</li><li>ioctl</li></ul></li></ul><h5 id="opencreat">open/creat</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br>(Return: a <span class="hljs-keyword">new</span> file descriptor <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>flags：文件访问模式。</p><ul><li>O_RDONLY：只读</li><li>O_WRONLY：只写</li><li>O_RDWR：读写</li><li>O_APPEND：追加</li><li>O_TRUNC：如果文件存在，截断到0字节</li><li>O_CREAT：文件不存在则创建</li><li>O_EXCL：与 <code>O_CREAT</code>标志结合使用。如果文件已存在则报错。</li></ul><p>mode：八进制数，文件权限。</p><figure><img src="/image/Linux系统编程/权限.png" alt="权限" /><figcaption aria-hidden="true">权限</figcaption></figure><p>umask：一个环境变量，决定了文件创建时的权限掩码。</p><ul><li>mode &amp; ~umask，得到最终创建的文件权限。</li></ul><h5 id="close">close</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h5 id="readwrite">read/write</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br>(返回值: 读到的字节数，若已到文件尾为<span class="hljs-number">0</span>，若出错为<span class="hljs-number">-1</span>)<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br>(返回值: 若成功为已写的字节数，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h5 id="lseek">lseek</h5><p>改变文件读写位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br>(Return: the resulting offset location <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>whence（出发点）：</p><ul><li>SEEK_SET</li><li>SEEK_CUR</li><li>SEEK_END</li></ul><h5 id="dupdup2">dup/dup2</h5><p>复制文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span></span>;<br>(Return: the <span class="hljs-keyword">new</span> file descriptor <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h5 id="fcntl">fcntl</h5><p>管理文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">long</span> arg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> flock *lock)</span></span>;<br>(返回值: 若成功则依赖于cmd，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><p>cmd：</p><ul><li>F_DUPFD：复制文件描述符</li><li>F_GETFD/F_SETFD：获取设置文件描述符控制标志</li><li>F_GETFL/F_SETFL：获取设置文件描述符状态标志</li><li>F_GETOWN/F_SETOWN：获取设置I/O可用性标志</li><li>F_GETLK/F_SETLK/F_SETLKW：获取设置文件锁</li></ul><h5 id="ioctl">ioctl</h5><p>控制设备。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> request, ...)</span></span>;<br></code></pre></td></tr></table></figure><p>重定向用到了哪些系统调用？</p><h4 id="标准io库">标准I/O库</h4><p>主要考察缓冲。</p><p>文件流</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs julia">FILE* fp;<br>// <span class="hljs-literal">stdin</span> <span class="hljs-literal">stdout</span> <span class="hljs-literal">stderr</span><br></code></pre></td></tr></table></figure><p>三种缓冲：</p><ul><li>块缓冲</li><li>线性缓冲</li><li>无缓冲</li></ul><p>setbuf、setvbuf</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setvbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> mode, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>mode：_IOFBF（满缓冲）、_IOLBF（行缓冲）、_IONBF（无缓冲）</p><p>流式I/O函数：</p><ul><li><p>open/close</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fclose</span><span class="hljs-params">(FILE *stream)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>mode：r w a r+(读写) w+(读写，无则新建，有则清空)a+(读与追加，无则新建)</p></li><li><p>read/write</p><ul><li><p>每次一个字符的I/O</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getc</span>(<span class="hljs-params">FILE *fp</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fgetc</span>(<span class="hljs-params">FILE *fp</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getchar</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span>;<br>（Result: Reads the next character <span class="hljs-keyword">from</span> a stream <span class="hljs-keyword">and</span> returns it <span class="hljs-keyword">as</span> an unsigned <span class="hljs-built_in">char</span> cast to an <span class="hljs-built_in">int</span>, <span class="hljs-keyword">or</span> EOF <span class="hljs-keyword">on</span> end of file <span class="hljs-keyword">or</span> error.）<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">ungetc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> c, FILE *stream</span>)</span>; <span class="hljs-comment">// 将字符插回流中</span><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> putc(<span class="hljs-built_in">int</span> c, <span class="hljs-keyword">FILE</span> *fp);<br><span class="hljs-built_in">int</span> fputc(<span class="hljs-built_in">int</span> c, <span class="hljs-keyword">FILE</span> *fp);<br><span class="hljs-built_in">int</span> putchar(<span class="hljs-built_in">int</span> c);<br>(<span class="hljs-keyword">Return</span>: the <span class="hljs-keyword">character</span> <span class="hljs-keyword">if</span> success; -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure></li><li><p>每次一行的I/O</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span>; <span class="hljs-comment">//not recommended.</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>直接I/O(二进制I/O)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span></span>;<br>(Return: the number of a items successfully read <span class="hljs-keyword">or</span> written.)<br></code></pre></td></tr></table></figure></li><li><p>格式化I/O</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">scanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sscanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>reposition</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">ftell</span><span class="hljs-params">(FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rewind</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fgetpos</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">fpos_t</span> *pos)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fsetpos</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">fpos_t</span> *pos)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>flush</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fflush</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>流与文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fileno</span><span class="hljs-params">(FILE *fp)</span></span>;<br><span class="hljs-function">FILE *<span class="hljs-title">fdopen</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>临时文件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">char *<span class="hljs-built_in">tmpnam</span>(char *s);<br>(返回值: 指向唯一路径名的指针)<br>FILE *<span class="hljs-built_in">tmpfile</span>(void);<br>(返回值: 若成功为文件指针，若出错为NULL)<br></code></pre></td></tr></table></figure></li></ul><h4 id="高级系统调用">高级系统调用</h4><p>stat、fstat：返回文件状态信息，存储在buf中</p><p>lstat：获取符号链接本身的状态信息，存储在buf中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> filedes, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> &#123;<br><span class="hljs-type">mode_t</span> st_mode; <span class="hljs-comment">/*file type &amp; mode*/</span><br><span class="hljs-type">ino_t</span> st_ino; <span class="hljs-comment">/*inode number (serial number)*/</span><br><span class="hljs-type">dev_t</span> st_rdev; <span class="hljs-comment">/*device number (file system)*/</span><br><span class="hljs-type">nlink_t</span> st_nlink; <span class="hljs-comment">/*link count*/</span><br><span class="hljs-type">uid_t</span> st_uid; <span class="hljs-comment">/*user ID of owner*/</span><br><span class="hljs-type">gid_t</span> st_gid; <span class="hljs-comment">/*group ID of owner*/</span><br><span class="hljs-type">off_t</span> st_size; <span class="hljs-comment">/*size of file, in bytes*/</span><br><span class="hljs-type">time_t</span> st_atime; <span class="hljs-comment">/*time of last access*/</span><br><span class="hljs-type">time_t</span> st_mtime; <span class="hljs-comment">/*time of last modification*/</span><br><span class="hljs-type">time_t</span> st_ctime; <span class="hljs-comment">/*time of last file status change*/</span><br><span class="hljs-type">long</span> st_blksize; <span class="hljs-comment">/*Optimal block size for I/O*/</span><br><span class="hljs-type">long</span> st_blocks; <span class="hljs-comment">/*number 512-byte blocks allocated*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>测试文件类型：sys/stat.h</p><ul><li>S_ISREG()</li><li>S_ISDIR()</li><li>S_ISCHAR()</li><li>S_ISBLK()</li><li>S_ISFIFO()</li><li>S_ISLNK()</li><li>S_ISSOCK()</li></ul><p>文件权限</p><ul><li><p>rwx</p></li><li><p>SUID：需要有效uid</p></li><li><p>SGID：需要有效gid</p></li><li><p>Sticky bit：只有owner</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchmod</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">mode_t</span> mode)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchown</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lchown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">mode_t</span> <span class="hljs-title">umask</span><span class="hljs-params">(<span class="hljs-type">mode_t</span> mask)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">symlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">readlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> bufsiz)</span></span>;<br>(Return: the count of characters placed in the buffer <span class="hljs-keyword">if</span> success;<span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>目录</p><ul><li>mkdir/rmdir</li><li>chdir/fchdir, getcwd</li><li>读取目录：DIR数据结构<ul><li>opendir/closedir</li><li>readdir</li><li>telldir</li><li>seekdir</li></ul></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rmdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchdir</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dir)</span></span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *<span class="hljs-built_in">readdir</span>(DIR *dir);<br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">telldir</span><span class="hljs-params">(DIR *dir)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seekdir</span><span class="hljs-params">(DIR *dir, <span class="hljs-type">off_t</span> offset)</span></span>;<br></code></pre></td></tr></table></figure><p>文件锁 important</p><ul><li><p>记录锁</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fcntl</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> fd, <span class="hljs-built_in">int</span> cmd, <span class="hljs-keyword">struct</span> flock *<span class="hljs-keyword">lock</span></span>)</span>;<br>(返回值: 若成功则依赖于cmd，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure></li><li><p>劝告锁</p><ul><li>检查，加锁有应用程序自己控制</li></ul></li><li><p>强制锁</p><ul><li>检查，加锁由内核控制</li><li>影响[open() read() write()]等</li></ul></li><li><p>共享锁</p></li><li><p>排他锁</p></li><li><p>共享模式强制锁</p></li><li><p>租借锁</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">flock</span>&#123;<br>...<br><span class="hljs-type">short</span> l_type; <span class="hljs-comment">/* Type of lock: F_RDLCK, F_WRLCK, F_UNLCK */</span><br><span class="hljs-type">short</span> l_whence; <span class="hljs-comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR,</span><br><span class="hljs-comment">SEEK_END */</span><br><span class="hljs-type">off_t</span> l_start; <span class="hljs-comment">/* Starting offset for lock */</span><br><span class="hljs-type">off_t</span> l_len; <span class="hljs-comment">/* Number of bytes to lock */</span><br><span class="hljs-type">pid_t</span> l_pid; <span class="hljs-comment">/* PID of process blocking our lock (F_GETLK only) */</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>cmd</p><ul><li>F_GETLK：获得文件的封锁信息</li><li>F_SETLK：对文件的某个区域封锁或解除封锁</li><li>F_SETLKW：功能同F_SETLK，wait方式。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/file.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lockf</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">off_t</span> len)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="多核编程">2. 多核编程</h2><h3 id="exec">exec</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>execl</code>、<code>execlp</code>和<code>execle</code>：可变参数为逐个列举。<code>execl</code>和<code>execle</code>带有环境变量，而<code>execlp</code>不带环境变量。实际上会调用对应的v系列函数。</p></li><li><p><code>execv</code>、<code>execvp</code>和<code>execve</code>：可变参数为NULL结尾的指针数组。<code>execv</code>和<code>execvp</code>不带环境变量，而<code>execve</code>可以传递环境变量。前两者最终会调用execve函数。</p></li></ul><h3 id="fork">fork</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)<br>&#123;子进程执行的代码段；&#125;<br><span class="hljs-keyword">else</span><br>&#123;父进程执行的代码段；&#125;<br></code></pre></td></tr></table></figure><h3 id="wait-waitpid">wait &amp; waitpid</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *status)</span></span>;<br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *status, <span class="hljs-type">int</span> options)</span></span>;<br></code></pre></td></tr></table></figure><p>wait：调用wait函数的进程会被挂起，等待任意一个子进程结束，如果该子进程结束了，此函数会回收子进程的资源。</p><ul><li>如果成功，wait会返回被收集的子进程的进程ID；</li><li>如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。</li></ul><p>waitpid：回收指定进程号的子进程，可以设置是否阻塞。</p><ul><li><p>pid=0，等待任意子进程。</p></li><li><p>pid=-1，回收所有子进程。</p></li><li><p>pid&lt;-1，其绝对值为某个进程组的组id，回收该进程组的所有进程。</p></li><li><p>status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。</p></li><li><p>options：WNOHANG，非阻塞。</p></li></ul><ol type="1"><li><p>当正常返回的时候，waitpid返回收集到的子进程的进程ID；</p></li><li><p>如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0；　　</p></li><li><p>如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在；</p><p>当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD。</p></li></ol><h3 id="signal">Signal</h3><p>信号处理</p><ul><li><p>忽略信号</p></li><li><p>不能忽略的信号： SIGKILL, SIGSTOP、一些硬件异常信号</p></li><li><p>执行系统默认动作</p></li><li><p>捕捉信号</p></li></ul><p>signal函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span></span>;<br>(Returned Value: the previous handler <span class="hljs-keyword">if</span> success, SIG_ERR <span class="hljs-keyword">if</span> error)<br></code></pre></td></tr></table></figure><p>handler为用户定义的函数。</p><h4 id="kill和raise">kill和raise</h4><p>kill向进程发送信号，raise向当前进程发送信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span></span>;<br>(Returned Value: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success, <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>;<br>(Returned Value: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success, <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h4 id="alarm和pause">alarm和pause</h4><p>alarm：一定时间后发送SIGALRM信号。</p><p>pause：挂起等待信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pause</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>组合两者可以让进程等待一段时间后执行。</p><h4 id="可靠信号机制">可靠信号机制</h4><h3 id="可重入函数">可重入函数</h3><p>可以被中断的函数。</p><p>不可重入函数：</p><ul><li>系统资源</li><li>全局变量</li><li>使用静态数据结构</li><li>malloc、free</li><li>标准IO函数</li></ul><h3 id="posix-thread">POSIX Thread</h3><p>编译：gcc thread.c –o thread –lpthread</p><h4 id="创建和终止">创建和终止</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_t</span> *thread,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_attr_t</span> *attr,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> *arg)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="等待和分离">等待和分离</h4><p>Joinable Thread：可连接线程</p><ul><li>可以被其他线程等待（join）的线程。</li></ul><p>Detached Thread：分离线程</p><ul><li>启动后独立运行的线程。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;pthread.h&gt;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_join(<span class="hljs-params">pthread_t</span> <span class="hljs-params">th</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">thread_return</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_detach(<span class="hljs-params">pthread_t</span> <span class="hljs-params">th</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="线程同步">线程同步</h4><h5 id="信号量">信号量</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_init(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-params">pshared</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">value</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_wait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_post(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_destroy(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_trywait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_getvalue(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">sval</span>)</span>;<br></code></pre></td></tr></table></figure><p>生产者-消费者问题：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/wait.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;fcntl.h&gt;</span><br><span class="hljs-comment">#include &lt;semaphore.h&gt;</span><br><br><span class="hljs-comment">#define BUFFER_SIZE 10</span><br><span class="hljs-comment">#define PRODUCER_COUNT 3</span><br><span class="hljs-comment">#define CONSUMER_COUNT 2</span><br><br>sem_t empty, full, mutex;<br>int buffer[BUFFER_SIZE];<br>int <span class="hljs-keyword">in</span> = <span class="hljs-number">0</span>;<br>int out = <span class="hljs-number">0</span>;<br><br>void produce(int index) &#123;<br>    sem_wait(&amp;empty);<br>    sem_wait(&amp;mutex);<br><br>    printf(<span class="hljs-string">&quot;生产者%d生产了一个产品\n&quot;</span>, index);<br>    buffer[<span class="hljs-keyword">in</span>] = index;<br>    <span class="hljs-keyword">in</span> = (<span class="hljs-keyword">in</span> + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br><br>    sem_post(&amp;mutex);<br>    sem_post(&amp;full);<br>&#125;<br><br>void consume(int index) &#123;<br>    sem_wait(&amp;full);<br>    sem_wait(&amp;mutex);<br><br>    printf(<span class="hljs-string">&quot;消费者%d消费了一个产品\n&quot;</span>, index);<br>    buffer[out] = -<span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 或者可以用某种方式标记为已消费<br>    out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br><br>    sem_post(&amp;mutex);<br>    sem_post(&amp;empty);<br>&#125;<br><br>int main() &#123;<br>    <span class="hljs-regexp">//</span> 初始化信号量<br>    <span class="hljs-keyword">if</span> (sem_init(&amp;empty, <span class="hljs-number">1</span>, BUFFER_SIZE) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sem_init(&amp;full, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sem_init(&amp;mutex, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    pid_t pid;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; PRODUCER_COUNT; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 子进程，生产者<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                produce(i);<br>                sleep(rand() % <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 随机睡眠以模拟不同生产者生产速度<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; CONSUMER_COUNT; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 子进程，消费者<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                consume(i);<br>                sleep(rand() % <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 随机睡眠以模拟不同消费者消费速度<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 等待所有生产者和消费者结束<br>    <span class="hljs-keyword">while</span> (wait(NULL) &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-regexp">//</span> 销毁信号量<br>    sem_destroy(&amp;empty);<br>    sem_destroy(&amp;full);<br>    sem_destroy(&amp;mutex);<br><br>    <span class="hljs-keyword">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="互斥量">互斥量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex, <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *mutexattr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><br><span class="hljs-type">int</span> buffer[BUFFER_SIZE];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> out = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 互斥量初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex, empty, full;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        <span class="hljs-keyword">while</span> (in == BUFFER_SIZE) &#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>); <span class="hljs-comment">// 生产者等待</span><br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        &#125;<br><br>        <span class="hljs-comment">// 生产产品</span><br>        buffer[in] = *(<span class="hljs-type">int</span>*)arg;<br>        in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产了产品 %d\n&quot;</span>, *(<span class="hljs-type">int</span>*)arg);<br><br>        <span class="hljs-comment">// 通知消费者有新产品</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        full++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有产品</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        <span class="hljs-keyword">while</span> (out == in) &#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>); <span class="hljs-comment">// 消费者等待</span><br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        &#125;<br><br>        <span class="hljs-comment">// 消费产品</span><br>        <span class="hljs-type">int</span> product = buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费了产品 %d\n&quot;</span>, product);<br><br>        <span class="hljs-comment">// 通知生产者有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        empty++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; mutex init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;empty, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; empty init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;full, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; full init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_t</span> pid, cid;<br>    <span class="hljs-type">int</span> producer_arg = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> consumer_arg = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建生产者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, producer, &amp;producer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建消费者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;cid, <span class="hljs-literal">NULL</span>, consumer, &amp;consumer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(cid, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 销毁互斥量</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;empty);<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;full);<br></code></pre></td></tr></table></figure><h5 id="条件变量">条件变量</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_init(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>, <span class="hljs-params">pthread_condattr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond_attr</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_destory(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_wait(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>, <span class="hljs-params">pthread_mutex_t</span> <span class="hljs-params">mutex</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_signal(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-params">cond</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_broadcast(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-params">cond</span>)</span>;<br></code></pre></td></tr></table></figure><p>条件变量使用：与互斥量结合</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><br><span class="hljs-type">int</span> buffer[BUFFER_SIZE];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> out = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 互斥量初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-comment">// 条件变量初始化</span><br><span class="hljs-type">pthread_cond_t</span> empty, full;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">while</span> (in == BUFFER_SIZE) &#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;empty, &amp;mutex);<br>        &#125;<br><br>        <span class="hljs-comment">// 生产产品</span><br>        buffer[in] = *(<span class="hljs-type">int</span>*)arg;<br>        in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产了产品 %d\n&quot;</span>, *(<span class="hljs-type">int</span>*)arg);<br><br>        <span class="hljs-comment">// 通知消费者有新产品</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;full);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有产品</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">while</span> (out == in) &#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;full, &amp;mutex);<br>        &#125;<br><br>        <span class="hljs-comment">// 消费产品</span><br>        <span class="hljs-type">int</span> product = buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费了产品 %d\n&quot;</span>, product);<br><br>        <span class="hljs-comment">// 通知生产者有空余位置</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;empty);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; mutex init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化条件变量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_cond_init</span>(&amp;empty, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; empty init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_cond_init</span>(&amp;full, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; full init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_t</span> pid, cid;<br>    <span class="hljs-type">int</span> producer_arg = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> consumer_arg = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建生产者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, producer, &amp;producer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建消费者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;cid, <span class="hljs-literal">NULL</span>, consumer, &amp;consumer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(cid, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 销毁互斥量</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;empty);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;full);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程取消">线程取消</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cancel(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcancelstate(<span class="hljs-params">int</span> <span class="hljs-params">state</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldstate</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcanceltype(<span class="hljs-params">int</span> <span class="hljs-params">type</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldtype</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="线程局部存储-tls">线程局部存储 TLS</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_key_create(<span class="hljs-params">pthread_key_t</span> <span class="hljs-operator">*</span><span class="hljs-params">key</span>, <span class="hljs-params">void</span> (<span class="hljs-operator">*</span><span class="hljs-params">destructor</span>)</span>(void*));<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_key_delete(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>)</span>;<br>void *pthread<span class="hljs-constructor">_getspecific(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setspecific(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>, <span class="hljs-params">const</span> <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">value</span>)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程_2_Shell</title>
    <link href="http://example.com/2024/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E7%AB%A0%20Shell%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E7%AB%A0%20Shell%E7%BC%96%E7%A8%8B/</id>
    <published>2024-05-02T04:00:00.000Z</published>
    <updated>2024-06-21T07:23:33.201Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第2章-shell编程">第2章 Shell编程</h1><p>Shell：指令解释器和编程环境。</p><p>用户和操作系统之间的接口，作为核外程序存在。</p><p>Shell的双重角色：</p><ul><li>命令解释程序<ul><li>Linux的开机启动过程；进程树</li><li>Shell的工作步骤</li><li>打印提示符；得到命令行；解析命令；查找文件；准备参数；执行命令</li></ul></li><li>独立的程序设计语言解释器</li></ul><p>Shell列举：ash、bsh、bash、sh、csh、zsh</p><h2 id="脚本文件">脚本文件</h2><p>注释：#</p><p>退出码：</p><ul><li>0：正常返回</li><li>1~128：错误码</li><li>129+：信号量</li></ul><h3 id="执行脚本文件">执行脚本文件</h3><ol type="1"><li><p>$ sh script_file</p></li><li><p>chmod +x script_file</p><p>./script_file</p></li><li><p>source script_file或 . script_file</p></li></ol><h3 id="用户环境">用户环境</h3><ol type="1"><li>.bash_profile，.bash_logout，.bashrc<ul><li>.bash_profile：用户登录时被读取，其中命令被bash执行</li><li>.bashrc：启动一个新的shell时被读取并执行</li><li>.bash_logout：登录退出时读取执行</li></ul></li><li>Alias：alias/unalias</li><li>环境变量<ul><li>export/env/set</li></ul></li></ol><h3 id="变量">变量</h3><ul><li>用户变量</li><li>环境变量</li><li>参数变量和内部变量</li></ul><h4 id="用户变量">用户变量</h4><p>用户在shell脚本里定义的变量。</p><ul><li><p>变量的赋值与使用：var=value echo $var</p></li><li><p>read命令：read var（读取用户输入并赋值给var）</p><ul><li>-p：在提示符后添加文本</li><li>-s：不显示用户输入</li><li>-r：用户输入不能修改</li><li>-n[字符数]：指定读取字符数，例如-n1</li></ul></li><li><p>引号</p><ul><li>单引号内的所有字符保持本身字符的意思，不被bash解释</li><li>除了$、``（不是单引号）、，双引号内的所有字符将保持字符本身含义，不被bash解释</li></ul></li></ul><h4 id="环境变量">环境变量</h4><p>Shell环境提供的变量，通常使用大写字母做名称。</p><table><thead><tr class="header"><th>环境变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$HOME</td><td>当前用户登录目录</td></tr><tr class="even"><td>$PATH</td><td>以冒号分隔的用来搜索命令的目录清单</td></tr><tr class="odd"><td><span class="math inline">\(PS1 |命令行提示符，通常是”\)</span>”字符</td><td></td></tr><tr class="even"><td>$PS2</td><td>辅助提示符，用来提示后续输入，通常是”&gt;”字符</td></tr><tr class="odd"><td>$IFS</td><td>输入区分隔符。当shell读取输入数据时会把一组字符看成是单词之间的分隔符，通常是空格、制表符、换行符等。</td></tr></tbody></table><h4 id="参数变量和内部变量">参数变量和内部变量</h4><p>调用脚本程序时如果带有参数，对应的参数和额外产生的一些变量。</p><table><thead><tr class="header"><th>环境变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$#</td><td>传递到脚本程序的参数个数</td></tr><tr class="even"><td>$0</td><td>脚本程序的名字</td></tr><tr class="odd"><td>$1</td><td>脚本程序的参数</td></tr><tr class="even"><td>$*</td><td>一个全体参数组成的清单，它是一个独立的变量，各个参数之间用环境变量IFS中的第一个字符分隔开</td></tr><tr class="odd"><td><span class="math inline">\(@ |“\)</span>*”的一种变体，它不使用IFS环境变量。</td><td></td></tr></tbody></table><h3 id="条件测试">条件测试</h3><p>test expression 或 [ expression ]</p><ul><li>字符串比较</li><li>算术比较</li><li>文件相关测试</li><li>逻辑操作</li></ul><table><thead><tr class="header"><th>字符串比较</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>str1 = str2</td><td>相同则为真</td></tr><tr class="even"><td>str1!=str2</td><td>不同则为真</td></tr><tr class="odd"><td>-z str</td><td>字符串为空则结果为真</td></tr><tr class="even"><td>-n str</td><td>字符串不为空则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>算术比较</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>expr1 –eq expr2</td><td>两个表达式相等则结果为真</td></tr><tr class="even"><td>expr1 –ne expr2</td><td>两个表达式不等则结果为真</td></tr><tr class="odd"><td>expr1 –gt expr2</td><td>expr1 大于 expr2 则结果为真</td></tr><tr class="even"><td>expr1 –ge expr2</td><td>expr1 大于或等于 expr2 则结果为真</td></tr><tr class="odd"><td>expr1 –lt expr2</td><td>expr1 小于 expr2 则结果为真</td></tr><tr class="even"><td>expr1 –le expr2</td><td>expr1 小于或等于 expr2 则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>文件条件测试</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>-e file</td><td>文件存在则结果为真</td></tr><tr class="even"><td>-d file</td><td>文件是一个子目录则结果为真</td></tr><tr class="odd"><td>-f file</td><td>文件是一个普通文件则结果为真</td></tr><tr class="even"><td>-s file</td><td>文件的长度不为零则结果为真</td></tr><tr class="odd"><td>-r file</td><td>文件可读则结果为真</td></tr><tr class="even"><td>-w file</td><td>文件可写则结果为真</td></tr><tr class="odd"><td>-x file</td><td>文件可执行则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>逻辑操作</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>! expr</td><td>逻辑表达式求反</td></tr><tr class="even"><td>expr1 –a expr2</td><td>两个逻辑表达式“And”（“与”）</td></tr><tr class="odd"><td>expr1 –o expr2</td><td>两个逻辑表达式“Or”（“或”）</td></tr></tbody></table><h3 id="条件语句">条件语句</h3><h4 id="if语句">if语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ expression ]<br><span class="hljs-keyword">then</span><br>statements<br><span class="hljs-keyword">elif</span> [ expression ]<br><span class="hljs-keyword">then</span><br>statements<br><span class="hljs-keyword">elif</span> …<br><span class="hljs-keyword">else</span><br>statements<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h4 id="case语句">case语句</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">case</span> str <span class="hljs-built_in">in</span><br>str1 | <span class="hljs-type">str2</span>) statements;;<br>str3 | <span class="hljs-type">str4</span>) statements;;<br>*) statements;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="重复语句">重复语句</h3><h4 id="for语句">for语句</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">in</span> list<br><span class="hljs-keyword">do</span><br>statements<br>done<br></code></pre></td></tr></table></figure><h4 id="while语句">while语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span><br>statements<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="until语句">until语句</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">until</span> condition<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">statements</span><br>done<br></code></pre></td></tr></table></figure><h4 id="select语句">select语句</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">select</span> item in itemlist<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">statements</span><br>done<br></code></pre></td></tr></table></figure><p>生成菜单列表</p><h3 id="命令表">命令表</h3><p>命令的组合。</p><ul><li><p>分号串联：command1 ; command2 ; …</p></li><li><p>条件组合，AND和OR：</p><p><code>statement1 &amp;&amp; statement2 &amp;&amp; …</code>和<code>statement1 || statement2 || …</code></p></li></ul><h3 id="语句块">语句块</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&#123;<br>stateme<span class="hljs-symbol">nt1</span><br>stateme<span class="hljs-symbol">nt2</span><br>…<br>&#125;<br>&#123; stateme<span class="hljs-symbol">nt1</span>; stateme<span class="hljs-symbol">nt2</span> ; … ; &#125;<br></code></pre></td></tr></table></figure><h3 id="函数">函数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">func</span><span class="hljs-params">()</span></span><br>&#123;<br>statements<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量：local关键字</p><p>函数调用：func para1 para2 ...</p><p>返回值：return</p><h3 id="杂项命令">杂项命令</h3><ul><li>break：从for/while/until循环退出</li><li>continue：跳到下一个循环继续执行</li><li>exit n：以退出码”n”退出脚本运行</li><li>return：函数返回</li><li>export：将变量导出到shell，使之成为shell的环境变量</li><li>set：为shell设置参数变量</li><li>unset：从环境中删除变量或函数</li><li>trap：指定在收到操作系统信号后执行的动作</li><li>“:”(冒号命令)：空命令</li><li>“.”(句点命令)或source在当前shell中执行命令</li></ul><h3 id="捕获命令输出">捕获命令输出</h3><p><code>$(command)</code>和<code>`(command)`</code></p><h3 id="算术扩展">算术扩展</h3><p><code>$((...))</code></p><h3 id="参数扩展">参数扩展</h3><p>批处理 1_tmp, 2_tmp, …</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>i=1<br><span class="hljs-keyword">while</span> [ “<span class="hljs-variable">$i</span>” –ne 10 ]; <span class="hljs-keyword">do</span><br><span class="hljs-built_in">touch</span> “<span class="hljs-variable">$&#123;i&#125;</span>_tmp”<br>i=$((<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure><p>更复杂形式：</p><figure><img src="/image/Linux系统编程/参数.png" alt="参数扩展" /><figcaption aria-hidden="true">参数扩展</figcaption></figure><h3 id="即时文档">即时文档</h3><p>在shell脚本中向一条命令传送输入数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">cat</span> &gt;&gt; file.txt &lt;&lt; !CATINPUT!<br>Hello, this is a here document.<br>!CATINPUT!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux系统编程_1_基础</title>
    <link href="http://example.com/2024/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E7%AB%A0%20Linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E7%AB%A0%20Linux%E5%9F%BA%E7%A1%80/</id>
    <published>2024-05-01T04:00:00.000Z</published>
    <updated>2024-06-21T07:23:15.117Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第1章-linux系统基础">第1章 Linux系统基础</h1><h2 id="linux概念与使用">1. Linux概念与使用</h2><p>基于GNU通用公共协议的类Unix操作系统。</p><ul><li>开源、流行、支持大多数平台</li></ul><h3 id="gnulinux系统">GNU/Linux系统</h3><p>GNU软件/库+Linux内核</p><p>版本：Ubuntu、Debian、Mint、Red Hat、Fodore、SuSe</p><h3 id="boot-loader">Boot loader</h3><p>Boot loader加载并启动Linux内核。</p><p>常见的Boot loader：</p><ul><li>LILO：Linux Loader</li><li>GRUB：Grand Unified Boot Loader<ul><li>配置文件：<code>/boot/grub/grub.conf</code>（旧版）</li><li>不需要和LILO一样进行配置激活（自动识别加载系统内核和initrd文件）</li><li>使用grub-install安装在MBR中</li></ul></li></ul><p>GRUB引导过程：</p><ol type="1"><li>MBR上的引导程序，负责加载GRUB的第二阶段</li><li>完整的内核加载在/boot/grub目录下</li></ol><p>要能读懂GRUB配置文件</p><p>基本结构：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">default</span>=<span class="hljs-number">0</span>  # 默认启动第一个系统<br><span class="hljs-attribute">timeout</span>=<span class="hljs-number">5</span>  # 等待超时时间<span class="hljs-number">5</span>秒<br><span class="hljs-attribute">splashimage</span>=(hd0,<span class="hljs-number">0</span>)/grub/splash.xpm.gz  # 背景图片<br><span class="hljs-attribute">hiddenmenu</span>  # 隐藏菜单，若要显式，在启动时按下ESC<br><span class="hljs-attribute">title</span> Red Hat Enterprise Linux AS (<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5)  # 定义操作系统的说明信息<br>    <span class="hljs-attribute">root</span> (hd0,<span class="hljs-number">0</span>) <br>    <span class="hljs-attribute">kernel</span> /vmlinuz-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5 ro root＝/dev/sda2 rhgb quiet<br>    <span class="hljs-attribute">initrd</span> /initrd-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5.img<br></code></pre></td></tr></table></figure><p>GRUB2：<code>/boot/grub/grub.cfg</code></p><h3 id="虚拟终端">虚拟终端</h3><p>控制台模拟了一个或多个虚拟终端。</p><p>每个虚拟终端是独立的控制台，不同用户可以使用不同的虚拟终端。</p><p>切换方式：Ctrl+Alt+Fn / Alt+Fn</p><h2 id="linux基础命令">2. Linux基础命令</h2><p>命令行：$ 和 #（root）</p><p>$ command option(s) argument(s)</p><p>主要命令都需要掌握。</p><h3 id="基础命令">0. 基础命令</h3><ul><li>passwd：修改密码</li><li>mkpasswd：生成随机密码</li><li>date, cal：打印日期/日历</li><li>who, finger：查看系统上在线的用户信息</li><li>clear：清空屏幕</li><li>echo：打印信息</li><li>write, wall, talk：与其他用户信息通信。<ul><li><code>write username</code>：提示输入消息内容，然后将消息发送给<code>username</code>。</li><li><code>wall</code>：即write all，发送给所有用户</li><li><code>talk username</code>：连接目标用户，启动聊天会话</li></ul></li></ul><h3 id="目录命令">1. 目录命令</h3><ul><li><p>pwd：打印工作目录</p></li><li><p>cd</p></li><li><p>mkdir</p></li><li><p>rmdir</p></li><li><p>ls：列出目录中的内容</p><ul><li><p>-l：以长格式显示文件和目录的信息。</p><p>包括文件或目录的权限模式、所有者、群组、大小和最后修改日期。</p></li><li><p>-a：显示所有文件，包括以.开头的隐藏文件。</p></li><li><p>-R：递归列出所有子目录中的内容。</p></li></ul></li><li><p>mknod：创建字符设备或块设备<code>mknod [options] [name] [type] [major minor]</code></p><ul><li><code>[options]</code>：可选的标志，如 <code>-m</code>用来设置文件的权限模式。</li><li><code>[major minor]</code>：设备的节点号。主节点号和次节点号用于识别设备类型。对于字符设备，主节点号通常表示设备类，而次节点号表示特定的设备。</li></ul></li></ul><h3 id="文件命令">2. 文件命令</h3><ul><li><p>touch：创建新文件、更新文件修改时间</p></li><li><p>cp</p></li><li><p>mv：移动并重命名文件</p></li><li><p>ln：链接文件</p><ul><li>硬链接：<code>ln source_file link_name</code></li><li>符号链接：<code>ln -s /full/path/to/source source_directory/link_name</code></li></ul></li><li><p>rm</p></li><li><p>cat</p></li><li><p>chown：改变文件或目录的所有者。<code>chown [options] [user:group] [file...]</code></p><ul><li><p><code>[options]</code>：</p><p><code>-R</code> 用于递归改变所有子目录和文件的所有者；</p><p><code>-h</code>：对于符号链接，改变链接本身的所有者，而不是链接指向的文件。</p></li><li><p><code>[user:group]</code>：指定新的所有者和组。用户名可以单独指定，或者与组名一起指定。如果只指定用户名，则默认组为用户所属的默认组。</p></li><li><p><code>[file...]</code>：要改变所有者的文件或目录列表。</p></li></ul></li><li><p>chgrp：改变文件或目录的组所有权。<code>chgrp [options] [group] [file...]</code></p></li><li><p>more/less：分页查看文件内容</p><ul><li>more：逐页显示文件，空格下一页，<code>b</code>上一页，<code>q</code>退出</li><li>less：滚动显示文件，功能更多。<ul><li>按 <code>/</code> ，输入搜索词搜索文件内容，按 <code>n</code>查找下一个匹配项，按 <code>p</code> 查找上一个匹配项。</li></ul></li></ul></li></ul><h4 id="文件权限">文件权限</h4><p>三个访问等级：</p><ul><li>用户</li><li>群组</li><li>其他</li></ul><p>三个权限：</p><ul><li>读 r</li><li>写 w</li><li>执行 x</li></ul><p>ls -l会展示文件权限</p><p>默认文件权限</p><p>file：-rw-r--r--</p><p>Directory：drwxr-xr-x</p><p>第一个字符表示文件类型，后续9个字符分别为u、g、o的rwx。</p><p>文件类型：</p><ul><li>-：常规文件</li><li>d：目录</li><li>l：链接</li><li>c：字符设备文件</li><li>b：块设备文件</li><li>p：管道</li><li>s：套接字</li></ul><p>修改权限：<code>chmod who operator what filename</code></p><ul><li>who:<ul><li>u：文件所有者</li><li>g：群组</li><li>o：系统其他用户</li><li>a：all</li></ul></li><li>operator:<ul><li>+：添加权限</li><li>-：删除权限</li><li>=: 设置明确权限</li></ul></li><li>what: rwx</li></ul><p>将u、g、o各自的rwx权限看为一个二进制数，可以用数字为它们赋予权限。</p><ul><li><p>r=4,w=2,x=1</p></li><li><p>chmod 765 file：u=rwx,g=rw,o=rx</p></li></ul><h4 id="文件编辑">文件编辑</h4><p>vi、emacs、gedit</p><h3 id="进程">3. 进程</h3><p>进程是一个正在执行的程序实例。由执行程序、它的当前值、状态信息以及通过操作系统管理此进程执行情况的资源组成。</p><ul><li><p>ps：报告进程状态</p></li><li><p>pstree：展示进程树</p></li><li><p>jobs, fg, bg, ctrl-z：任务控制</p><ul><li><p>jobs：查看当前 shell环境中所有在后台运行的任务列表，会给出每个任务的唯一编号。</p></li><li><p>fg %1：将一个后台任务调至前台执行，用%指定任务编号。</p></li><li><p>bg %1：将一个在后台暂停的任务继续运行在后台。</p></li><li><p>Ctrl+Z：将当前前台执行的任务挂起到后台。</p></li></ul></li><li><p>kill：杀死进程<code>kill [PID]</code>、发送信号给进程<code>kill [signal] [PID]</code></p></li><li><p>nohup：无视挂起信号运行指令</p></li><li><p>nice, renice：调整进程优先级</p><p>nice介于-20～19，影响调度优先级，nice越低优先级越高</p><ul><li><p>nice：启动一个新进程，并为其设置一个nice值。</p></li><li><p>renice：改变正在运行的进程的nice值。</p></li></ul></li><li><p>top：展示占用CPU最高的进程列表</p></li></ul><h3 id="寻找帮助">4. 寻找帮助</h3><p>man、info、--help</p><h3 id="重定向">5. 重定向</h3><p>标准输入、标准输出、标准错误</p><ul><li>对应的文件描述符：0, 1, 2</li></ul><p><code>&lt;、&gt;</code>：覆盖文件</p><p><code>&gt;&gt;</code>：追加到末尾</p><p><code>2&gt;</code>：将标准错误输出到文件，而标准输出仍然会输出到命令行</p><p><code>&gt;&amp;</code>：将标准输出和错误都输出到文件</p><p><code>2&gt;&amp;1</code>：将标准错误输出重定向到标准输出，与上个选项的区别是会打印到命令行</p><h3 id="管道">6. 管道</h3><p>一个进程的输出作为另一个进程的输入。</p><p><code>命令1|命令2</code>：命令1的输出会直接传递给命令2作为输入。</p><h3 id="高级命令">7. 高级命令</h3><ul><li><p>find：查找文件。<code>find [options] [path...] [-exec [command] &#123;&#125; +]</code></p><ul><li><code>[options]</code>：find命令的行为选项，如<code>-name</code>、<code>-type</code>、<code>-mtime</code> 等。<ul><li><code>-print</code>：打印找到的文件名。</li><li><code>-delete</code>：删除找到的文件。</li></ul></li><li><code>[path...]</code>：要搜索的目录路径。如果省略，默认在当前目录搜索。</li></ul></li><li><p>sed：通过模式匹配对文本进行处理。</p></li><li><p>grep：在文本文件中搜索指定的文本字符串。<code>grep [options] [pattern] [file...]</code></p><ul><li>选项：<ul><li><code>-i</code>：忽略大小写。</li><li><code>-v</code>：反转匹配，只显示不匹配的行。</li><li><code>-c</code>：计数，只输出匹配行的数量。</li><li><code>-n</code>：显示匹配行及其行号。</li><li><code>-l</code>：只输出包含匹配字符串的文件名。</li><li><code>-L</code>：只输出不包含匹配字符串的文件名。</li><li><code>-r</code> 或 <code>-R</code>：递归搜索目录中的所有文件。</li><li><code>-E</code>：使用扩展正则表达式。</li><li><code>-o</code>：只输出匹配到的部分，而不是整行内容。</li></ul></li></ul></li></ul><p>基本正则表达式：</p><ul><li><code>.</code>：匹配任意单个字符。<ul><li>例子：<code>grep '.$' file.txt</code> 将匹配 file.txt中以任意字符结尾的行。</li></ul></li><li><code>*</code>：匹配前一个字符出现零次或多次。<ul><li>例子：<code>grep 'o*' file.txt</code> 将匹配 file.txt中包含零个或多个 “o” 的行。</li></ul></li><li><code>^</code>：匹配行的开始。<ul><li>例子：<code>grep '^A' file.txt</code> 将匹配 file.txt 中以 “A”开头的行。</li></ul></li><li><code>$</code>：匹配行的结束。<ul><li>例子：<code>grep 'B$' file.txt</code> 将匹配 file.txt 中以 “B”结尾的行。</li></ul></li><li><code>[abc]</code>：匹配方括号内的任意一个字符。<ul><li>例子：<code>grep '[abc]' file.txt</code> 将匹配 file.txt 中包含“a”、“b” 或 “c” 的行。</li></ul></li><li><code>[^abc]</code>：匹配不在方括号内的任意一个字符。<ul><li>例子：<code>grep '[^abc]' file.txt</code> 将匹配 file.txt 中不包含“a”、“b” 或 “c” 的行。</li></ul></li><li><code>\</code>：转义字符，用于匹配特殊字符。<ul><li>例子：<code>grep '\\.' file.txt</code> 将匹配 file.txt中包含一个反斜杠后跟一个点（<code>.</code>）的行。</li></ul></li><li><code>()</code>：标记子表达式的开始和结束。<ul><li>例子：<code>grep '(abc|def)' file.txt</code> 将匹配 file.txt 中包含“abc” 或 “def” 的行。</li></ul></li><li><code>|</code>：逻辑或操作符。<ul><li>例子：<code>grep 'A|B' file.txt</code> 将匹配 file.txt 中包含 “A” 或“B” 的行。</li></ul></li><li><code>\&lt;</code>：匹配单词的开始（前面必须有一个单词边界）。<ul><li>例子：<code>grep '\&lt;word' file.txt</code> 将匹配 file.txt 中以“word” 开头的行，其中 “word” 是一个单词。</li></ul></li><li><code>\&gt;</code>：匹配单词的结束（后面必须有一个单词边界）。<ul><li>例子：<code>grep '\&gt;word' file.txt</code> 将匹配 file.txt 中以“word” 结尾的行，其中 “word” 是一个单词。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux系统编程" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_5_云数据中心</title>
    <link href="http://example.com/2024/04/05/%E4%BA%91%E8%AE%A1%E7%AE%97/5-%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/"/>
    <id>http://example.com/2024/04/05/%E4%BA%91%E8%AE%A1%E7%AE%97/5-%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/</id>
    <published>2024-04-05T04:00:00.000Z</published>
    <updated>2024-06-21T07:11:10.378Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云数据中心">5-云数据中心</h1><h2 id="基本设计">1. 基本设计</h2><p>外部：不间断的电源、足够带宽的网络</p><p>内部：散热（保证设备安全）</p><h2 id="云数据中心特征">2. 云数据中心特征</h2><h3 id="特征">2.0 特征</h3><ol type="1"><li><p>高设备利用率</p><ul><li><p>通过虚拟化整合云平台系统与数据中心硬件资源，减少物理服务器数量</p></li><li><p>优化资源利用率、简化管理，降低成本、快速响应业务需求的变化等</p></li><li><p>较大的数据中心有更低的单位运营成本：网络、存储、管理</p></li></ul></li><li><p>绿色节能</p><ul><li><p>能源</p></li><li><p>功耗：服务器、空调</p></li></ul></li><li><p>自动化管理</p><ul><li><p>人力成本是大多数管理数据中心站点最大成本因素</p></li><li><p>无人值守，远程管理</p></li><li><p>门禁、通风、温度、湿度、电力均可远程调度与控制</p></li></ul></li><li><p>高可用性</p><ul><li><p>各个部分的冗余、容错、容灾设计</p></li><li><p>扩展和升级时，保持正常运行</p></li></ul></li></ol><h3 id="绿色节能技术">2.1 绿色节能技术</h3><h4 id="耗电原因">耗电原因</h4><ul><li>技术因素<ul><li>云计算中心规模不断扩大，硬件设备数量激增，导致总体耗电量大幅上升。</li><li>为了保证高可用性和稳定性，通常采用功耗相对较高的高性能处理器、内存和存储设备。</li><li>虚拟化技术的广泛应用也带来了额外的能耗。</li></ul></li><li>商业因素<ul><li>客户需求不断增长<spanclass="math inline">\(\rightarrow\)</span>数据中心建设、扩容。</li><li>激烈的市场竞争<spanclass="math inline">\(\rightarrow\)</span>不断优化更新技术。</li></ul></li></ul><h4 id="采取措施">采取措施</h4><ol type="1"><li><p>优化技术</p><ul><li>使用更高能效设备、服务器架构和更智能的资源调度策略。</li></ul></li><li><p>节约能源</p><ul><li><p>在数据中心设计和运营中充分考虑节能因素。</p><p>例如，采用更为合理的布局和散热系统设计，减少冷却能耗；</p><p>合理安排数据中心工作时间，充分利用自然冷却等方式降低能耗。</p></li></ul></li><li><p>提升硬件使用率</p><ul><li><p>例如，推广容器化技术，实现应用打包和快速部署；</p><p>采用无服务器架构，减少闲置服务器数量等。</p></li></ul></li><li><p>可再生能源</p></li><li><p>绿色云生态系统</p><ul><li>与硬件厂商、政府部门等共同合作，构建一个绿色云生态系统。通过政策引导、技术创新和市场机制等手段，推动整个行业的绿色发展。</li></ul></li></ol><h4 id="具体节能技术">具体节能技术</h4><ul><li>配电系统：高压直流配电、市电直供配电</li><li>空调系统节能：高温回风、精确制冷、自然冷空调</li><li>集装箱数据中心节能技术<ul><li>服务器设备、网络设备、空调设备、供电设备等高密度地装入固定尺寸的集装箱中</li><li>高密度、模块化、按需快速部署、移动便捷</li></ul></li><li>管理系统节能策略和算法：供电管理</li><li>新能源应用</li></ul><h3 id="自动化管理">2.2 自动化管理</h3><p>目标：使得在规模较大的情况下，实现较少人员对数据中心的高度智能管理。</p><p>工作范围：按需分配/收回资源；自动配电、冷却、消防等。</p><p>具体内容：资源的自动化调度和对业务的灵活响应。</p><ul><li>既需要单业务自治，也需要对业务和资源进行全局控制和协调。</li></ul><h4 id="特征和内容">特征和内容</h4><ol type="1"><li><p>全面可视化：多层级运行时视图，全面掌握数据中心资产、配置和各层次依赖关系的现状</p></li><li><p>自动的控制执行：全面自动化流程</p></li><li><p>多层次的无缝集成：流畅地自动执行在不同层次和组成部分之间地各种处理流程，快速的协调数据中心内外的所有变更，实现端到端的流程管理</p></li><li><p>综合与实时的报告：提供全面综合和透视依赖关系的报告提高管理水平</p></li><li><p>全生命周期支持：自动化整个“计划—实施—检查—更正”的IT流程生命周期</p></li></ol><p>实现的三个阶段：</p><ol type="1"><li><p>IT服务操作：监控和管理IT基础设施的广义集合</p><ul><li><p>目标：生成有效的全局IT支撑架构，提高IT服务质量，对活动和过程进行协调和执行</p></li><li><p>活动和过程：事故管理、事件监控和管理、问题管理</p></li></ul></li><li><p>IT服务管理：制定设施间的交互和协作处理，确保IT服务符合标准规范</p><ul><li><p>定义：根据客户需求的层次确保IT服务质量的一系列过程</p></li><li><p>主题：服务管理、服务层管理、IT资产管理、财务管理</p></li></ul></li><li><p>数据中心自动化：维护IT环境，定制、检查和执行服务层协议</p></li></ol><p>采用数据中心自动化工具必须具备如下条件</p><ul><li>管理系统</li><li>定义过程</li><li>认知非自动化过程的成本</li><li>内部流程资源</li></ul><h3 id="容灾备份">2.3 容灾备份</h3><table><thead><tr class="header"><th><strong>对比维度</strong></th><th><strong>备份</strong></th><th><strong>容灾</strong></th></tr></thead><tbody><tr class="odd"><td>使用目的</td><td>避免数据丢失，一般通过快照、备份等技术构建数据的数据备份副本，故障时可以通过数据的历史副本恢复用户数据。</td><td>避免业务中断，一般是通过复制技术（应用层复制、主机I/O层复制、存储层复制）在异地构建业务的备用主机和数据，主站点故障时备用站点可以接管业务。</td></tr><tr class="even"><td>使用场景</td><td>针对病毒入侵、人为误删除、软硬件故障等场景，可将数据恢复到任意备份点。</td><td>针对软硬件故障以及海啸、火灾、地震等重大自然灾害，运行故障切换，尽快恢复业务。源端可用区恢复正常时，可轻松利用故障恢复能力重新切换回到源端可用区。</td></tr><tr class="odd"><td>成本</td><td>通常是生产系统的1~2%。</td><td>通常是生产系统的20%~100%（根据不同的RPO/RTO要求而定），高级别的双活容灾，要求备用站点也要部署一套和主站点相同的业务系统，基础设施成本需要翻倍计算。</td></tr></tbody></table><p>容灾备份：</p><p>异地建立、维护备份存储系统，利用地理分离保证系统和数据对灾难性事件的抵御能力。</p><ul><li>容灾系统的抵抗程度：数据级容灾和应用级容灾。</li></ul><h4 id="关键技术">关键技术</h4><p>技术核心：复制数据</p><ul><li><p>镜像：将符合指定规则的报文复制到目的端口</p></li><li><p>快照：拷贝指定数据集合，用于数据备份恢复、提供额外访问通道。</p></li><li><p>基于IP的SAN的远程数据容灾备份技术：主数据中心复制到备份数据中心。</p></li><li><p>数据库复制。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_4_网络</title>
    <link href="http://example.com/2024/04/04/%E4%BA%91%E8%AE%A1%E7%AE%97/4-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2024/04/04/%E4%BA%91%E8%AE%A1%E7%AE%97/4-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C/</id>
    <published>2024-04-04T04:00:00.000Z</published>
    <updated>2024-06-21T07:10:51.728Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算网络">4-云计算网络</h1><h2 id="基本架构">1. 基本架构</h2><p>云数据中心需要基础网络将所有设备组织在本地网络里面——基础网络架构。</p><p>传统树结构：建造方便简单，但不便于拓展与升级</p><ul><li>任意一个核心交换机故障导致上千台服务器失效</li></ul><p>架构需求：低成本、高可扩展性、低配置开销、健壮性、节能</p><h3 id="改进树结构">1.1 改进树结构</h3><h4 id="fattree">FatTree</h4><ol type="1"><li>K叉树，K个Pod(集装器)，每个Pod有K个交换机，其中K/2个为接入交换机，K/2个为汇聚交换机。</li><li>Pod中每个交换机有K个接口。<ul><li>接入交换机的K/2个接口接主机，K/2个接口接汇聚交换机；</li><li>汇聚交换机的K/2个接口接接入交换机，K/2个接核心交换机。</li></ul></li><li>有<spanclass="math inline">\((K/2)^2\)</span>个核心交换机，每个交换机K个端口接K个汇聚交换机。</li><li>一个Pod内的所有交换机相互连接：完全二分图。</li><li>一个Pod内的每个汇聚交换机与一部分核心交换机连接，但是一个Pod和每一个核心交换机都有连接。</li></ol><p>两级路由表，允许两级前缀查询：Pod间流量尽可能均匀分布于核心交换机</p><p>任意两个不同Pod主机之间存在K条路径</p><ul><li>将流量在这些路径间分散</li><li>任意给定Pod的低层和高层交换机对位于本Pod的任意子网都有终结性表项</li><li>在全负载最坏的情况下实现约87%的聚合带宽</li></ul><p>与传统层次结构相比，FatTree有如下特点：</p><ul><li>消除了树形结构上层链路对吞吐量的限制</li><li>为内部节点间通信提供多条并行链路</li><li>与现有数据中心网络使用的以太网结构和IP 配置的服务器兼容</li><li>但是布线复杂了；扩展时需要重构；受到端口数限制等。</li></ul><p>FatTree的扩展性受限于核心交换机端口数量，目前比较常用的是48端口10G核心交换机，在3层树结构中能够支持27648台主机。</p><h4 id="vl2">VL2</h4><p>若干服务器连接到机架(接入)交换机；</p><p>每台接入交换机与两台汇聚交换机连接；</p><p>每台汇聚交换机与所有核心交换机连接。</p><p>特点：</p><ul><li>扁平寻址，允许服务实例被放置到网络覆盖的任何地方</li><li>负载均衡将流量统一分配到网络路径</li><li>终端系统的地址解析拓展到巨大的服务器池</li></ul><p>核心思想：使用FatTree同样的拓扑结构建立扁平的第二层网络。</p><p>机制：</p><ul><li>IP地址仅仅作为名字使用，没有拓扑含义；将服务器的名字与其位置分开。</li><li>使用可扩展、可靠的目录系统来维持名字和位置间的映射。</li><li>当服务器发送分组时，服务器上的VL2代理开启目录系统以得到实际的目的位置，然后将分组发送到目的地。</li></ul><p>优势：VL2是目前最易用于对现有数据中心网络改造的结构；应用程序使用服务地址通信而底层网络使用位置信息地址进行转发，使得虚拟机能够在网络中任意迁移而不影响服务质量。</p><p>缺点：VL2依赖于中心化的基础设施来实现2层语义和资源整合，面临单点失效和扩展性问题。</p><h3 id="递归层次结构">1.2 递归层次结构</h3><p>每一个高层的网络拓扑，由多个低层的递归单元按照递归规律相互连接构成，同时也是更高层级网络的一个递归单元。</p><ul><li>增加服务器数量<spanclass="math inline">\(\rightarrow\)</span>提高总的递归层次<ul><li>添加服务器更加灵活，可增加的数量增大</li><li>对交换机性能要求低</li></ul></li></ul><p>递归层次结构：DCell、Ficonn、BCube、MDCube</p><h4 id="ficonn">FiConn</h4><p>服务器使用两个网卡端口：主用端口连接低层网络，备用端口连接高层网络</p><p>递归定义的结构</p><ul><li>第0层为基本构建单元，n个服务器连接一个具有n个端口的交换机</li><li>每个低层<strong>FiConn</strong>中备用端口空闲的一半服务器与其他相同层次的FiConn网络中备用端口空闲的服务器连接</li><li>k层服务器、k层端口、k层链路</li></ul><h4 id="bcube">BCube</h4><p>主要使用交换机构建层次化网络</p><p>第0层：n服务器连接1交换机</p><p>第1层：n个0层连接n个交换机</p><p>……</p><p>第k层：n个k-1层连接nk交换机</p><p>交换机n个端口，服务器k+1个端口。</p><h3 id="光交换网络">1.3 光交换网络</h3><p>使用光纤交换机调整网络拓扑。</p><h2 id="软件定义网络">2. 软件定义网络</h2><h3 id="openflow">2.1 OpenFlow</h3><p>使用集中控制器控制OpenFlow Switch的Flow Table。</p><p>Controller 会为特定的工作负载计算最佳路径，从而对 Switch的数据转发定义路径。</p><p>核心理论：控制转发分离架构、可编程性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>云计算_3_虚拟化</title>
    <link href="http://example.com/2024/04/03/%E4%BA%91%E8%AE%A1%E7%AE%97/3-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2024/04/03/%E4%BA%91%E8%AE%A1%E7%AE%97/3-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/</id>
    <published>2024-04-03T04:00:00.000Z</published>
    <updated>2024-06-21T07:10:30.083Z</updated>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="虚拟化技术">3-虚拟化技术</h1><p>问题：云计算涉及到哪些虚拟化技术？需要对哪些资源做虚拟化？对应的虚拟化技术和产品是什么？</p><h2 id="什么是虚拟化">0. 什么是虚拟化</h2><p>虚拟化是云计算的核心技术。</p><p>本质：通过虚拟化层逻辑化原先的物理设备，实现软硬件解耦。</p><p>核心思想：</p><ul><li><p>利用软件或固件管理程序构成虚拟化层，把物理资源映射为虚拟资源。</p></li><li><p>在虚拟资源上可以安装和部署多个虚拟机，实现多用户共享物理资源。</p></li></ul><h2 id="服务器虚拟化">1. 服务器虚拟化</h2><p>硬件级、操作系统级、程序库API、应用程序</p><p>代表产品：</p><p>裸机虚拟化（VMware vSphere）、操作系统级虚拟化（VMwareWorkstation、Docker）</p><h3 id="硬件级虚拟化">1.1 硬件级虚拟化</h3><p>使用作为虚拟化层的软件管理客户操作系统，使其独立于主机操作系统，同时运行在同硬件上。</p><ul><li>Hypervisor、Virtual Machine Monitor（VMM）</li></ul><p>要求：高效、隔离、复制</p><p>类别：裸机虚拟化、寄居虚拟化</p><h4 id="优势">优势</h4><ol type="1"><li>封装性：虚拟机快照、克隆、挂起和恢复非常便捷</li><li>多实例：降低计算机资源损耗</li><li>隔离</li><li>硬件无关性</li><li>特权功能</li></ol><h4 id="可虚拟化架构">可虚拟化架构</h4><p>使用特权级分隔应用软件和系统软件的架构。</p><p>原因：提高虚拟机控制软件直接访问硬件的效率、低特权级的虚拟机之间更易实现资源隔离。</p><h4 id="虚拟化硬件对象">虚拟化硬件对象</h4><p>CPU、内存、I/O设备</p><h5 id="cpu虚拟化">CPU虚拟化</h5><ul><li>任意时刻一个物理CPU只能运行一个虚拟CPU</li><li>每个客户操作系统可以使用一个或多个虚拟CPU</li><li>各个操作系统之间虚拟CPU运行相互隔离，互不影响</li></ul><p>调度：VMM决定哪个虚拟CPU在哪个物理CPU上运行，保证隔离、公平和性能</p><p>执行：虚拟CPU保证虚拟机的指令正确运行。</p><ul><li>实现技术：模拟执行、监控执行</li></ul><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：解释、扫描、翻译</li><li>基于硬件辅助的虚拟化：硬件针对虚拟化作出支持</li><li>修改操作系统的类虚拟化：修改客户机操作系统，配合VMM进行虚拟化</li></ol><h5 id="内存虚拟化">内存虚拟化</h5><p>把物理内存统一管理，包装成多个虚拟的物理内存提供给虚拟机使用。</p><p>每个虚拟机拥有各自独立的内存空间。</p><p>VMM的工作：</p><ol type="1"><li>维护客户机物理地址和宿主机器的机器地址之间的映射</li><li>截获虚拟机对客户机物理地址的访问，并根据所记录的映射关系，转换成机器地址</li></ol><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：影子页表，直接把客户机虚拟地址翻译为物理地址</li><li>基于硬件辅助的虚拟化：硬件辅助地址转换</li><li>修改操作系统的类虚拟化：客户机直接使用VMM的机器地址到物理地址的翻译表</li></ol><h5 id="io虚拟化">I/O虚拟化</h5><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：VMM进行设备模拟并处理所有设备请求与响应</li><li>基于硬件辅助的虚拟化：DMA地址重映射</li><li>修改操作系统的类虚拟化：修改客户机操作系统，客户机直接与物理设备交互</li></ol><h3 id="操作系统级虚拟化">1.2 操作系统级虚拟化</h3><p>在主机操作系统中插入一个虚拟化层。</p><p>在同一个操作系统内核内，运行多个虚拟机；虚拟机可以访问内核。</p><p>虚拟机/容器</p><p>容器的优缺点：</p><ul><li>启动/停止开销最小，资源需求低，可扩展性强</li><li>可同步虚拟机与宿主操作系统环境状态的变化</li><li>允许虚拟机中进程访问尽可能多的主机资源</li><li>同一个容器中的操作系统级虚拟机必须使用相同的客户操作系统</li><li>资源隔离性较差</li></ul><h2 id="云数据中心虚拟化">2. 云数据中心虚拟化</h2><p>为什么要虚拟化？</p><ul><li>一台物理设备一个用户 vs.一台物理设备多个用户：提升资源共享与复用的效率，降低成本</li><li>固定大小与位置的存储空间 vs.灵活扩展和空间分布的空间：提升可扩展性，提升存储资源使用效率</li><li>为了实现服务器、存储虚拟化，要求网络也要能够方便、灵活地调整：随着虚拟机的迁移一起迁移</li></ul><h3 id="服务器虚拟化-1">服务器虚拟化</h3><p>将一个或多个物理服务器虚拟成多个逻辑上的服务器。</p><p>虚拟机、容器。</p><h3 id="存储虚拟化">存储虚拟化</h3><p>把分布的异构存储设备统一为一个或几个大的存储池。</p><p>存储虚拟化将系统中分散且异构的存储资源整合起来，形成一个统一连续编址的逻辑存储空间。</p><h3 id="网络虚拟化">网络虚拟化</h3><p>在底层物理网络和网络用户之间增加一个抽象层。</p><p>云数据中心对网络的需求</p><ul><li>提高数据传输效率：应对数据同步、备份、虚拟机迁移等的大流量</li><li>提高管理效率：采用统一的交换网络减少布线、维护和扩容的成本</li></ul><p>网络虚拟化技术：</p><ul><li><p>核心层网络虚拟化</p></li><li><p>虚拟机网络虚拟化</p></li><li><p>接入层网络虚拟化</p></li></ul><h2 id="虚拟机迁移">3. 虚拟机迁移</h2><h3 id="需求">需求</h3><ol type="1"><li><p>负载平衡需要</p></li><li><p>物理服务器定期升级的需要</p></li></ol><p>关注重点：实时迁移</p><ul><li>保持虚拟机运行的同时，将其从一个计算机迁移到另一个计算机，并在目的计算机恢复运行</li></ul><h3 id="迁移内容">迁移内容</h3><ul><li>内存迁移：最困难</li><li>网络迁移：迁移网络设备、协议状态和配置</li><li>存储设备迁移：使用NAS作为存储设备共享数据</li></ul><p>分类：</p><ul><li>物理机到虚拟机 P2V</li><li>虚拟机到虚拟机 V2V</li><li>虚拟机到物理机 V2P</li></ul><h3 id="内存迁移方案">内存迁移方案</h3><table><thead><tr class="header"><th>迁移方案</th><th>具体描述</th><th>优势与劣势</th></tr></thead><tbody><tr class="odd"><td>Stop and Copy</td><td>A停机，将对应内存全部复制到B，启动B</td><td>方法简单，总迁移时间最短，但停机时间无法接受</td></tr><tr class="even"><td>Stop and Copy和Pull阶段结合</td><td>A停机，将部分内存复制到B，启动B，B运行中遇到缺失内存，再到A内存中复制</td><td>停机时间很短，总迁移时间很长。Pull阶段复制造成的性能下降，用户体验差</td></tr><tr class="odd"><td>Push和Stop and Copy阶段结合</td><td>A不停机，保持对外服务，将变化的内存迭代地复制到B，直到最后剩余很少要复制的再停止A，复制最后变动到B，启动B</td><td>平衡了停机时间和总迁移时间之间的矛盾。需要有一种算法能够测定工作集，以避免反复重传。可能会占用大量的网络带宽，对其他服务造成影响</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞萤扑火，向死而生。&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="http://example.com/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_03_树学习</title>
    <link href="http://example.com/2023/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_%E6%A0%91%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-10-10T14:00:00.000Z</published>
    <updated>2023-11-02T12:04:30.865Z</updated>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="树学习">树学习</h1><p>20230926</p><p>18:30-21:30</p><p>20231010</p><p>18:30-21:30</p><h2 id="符号学习">符号学习</h2><p>推理的角度：</p><ul><li>演绎推理：<span class="math inline">\(P\rightarrowQ\)</span>，P为真则Q为真</li><li>反绎推理：<span class="math inline">\(P\rightarrowQ\)</span>，Q为真则P为真</li><li>归纳推理：P为真，Q未必为真</li></ul><p>符号（概念）学习是一类归纳推理。</p><h3 id="概念学习">概念学习</h3><p>给定样例集合，以及每个样例是否属于某个概念，自动地推断出该概念的一般定义。</p><h4 id="概念学习任务">概念学习任务</h4><ul><li>实例集合X</li><li>目标概念c：定义在实例集X上的布尔函数<spanclass="math inline">\(c:X\rightarrow\{0,1\}\)</span></li><li>训练样例：正例<spanclass="math inline">\((c(x)=1)\)</span>，反例<spanclass="math inline">\((c(x)=0)\)</span></li><li>假设集H：每个假设h表示X上定义的布尔函数<spanclass="math inline">\(h:X\rightarrow\{0,1\}\)</span></li></ul><p>概念学习：寻找一个假设h，使对于X中的所有x，<spanclass="math inline">\(h(x)=c(x)\)</span></p><p>归纳学习假设：任一假设如果在足够大的训练样例集合中能很好地逼近目标概念函数，它也能在未见实例中很好地逼近目标概念。</p><h4 id="作为搜索的概念学习">作为搜索的概念学习</h4><p>当假设的表示确定后，也就确定了概念学习算法所有假设的空间。</p><p>搜索的目标是为了寻找最好的拟合训练样例的假设。</p><p>搜索的操作：</p><ul><li>用逻辑变量替换常量</li><li>合取表达式去掉部分条件</li><li>对表达式增加析取项</li><li>用属性的超类来替换属性</li></ul><h4 id="假设的一般到特殊序">假设的一般到特殊序</h4><ul><li><p>更泛化</p><p><span class="math inline">\(令h_j和h_k是定义在X上的布尔函数，h_j\ge_gh_k即h_j更泛化于h_k\)</span></p><p><span class="math inline">\(当且仅当(\forall x\inX)[(h_k(x)=1)\rightarrow (h_j(x)=1)]\)</span></p></li><li><p>严格泛化：记为<spanclass="math inline">\(h_j\gt_gh_k\)</span></p></li><li><p>更特化：记为<spanclass="math inline">\(h_j\ge_sh_k\)</span></p></li></ul><h3 id="寻找极大特殊假设find-s">寻找极大特殊假设，Find-S</h3><ol type="1"><li><p>将h初始化为H中最特殊的假设</p></li><li><p>对每个正例x：</p><p>对h的每个属性约束，如果x满足，不处理；</p><p>否则将该约束替换为x满足的另一个最一般的约束</p></li><li><p>输出假设h</p></li></ol><p>对以属性合取式表示的假设空间，输出与正例一致的最特殊的假设。</p><h3id="列表消除算法list-then-eliminate">列表消除算法，List-Then-Eliminate</h3><ol type="1"><li>变型空间Version Space：假设空间H中所有假设的列表</li><li>对每个样例<spanclass="math inline">\(&lt;x,c(x)&gt;\)</span>，从变型空间中移除<spanclass="math inline">\(h(x)\neq c(x)\)</span>的假设h</li><li>输出变型空间中的假设列表</li></ol><p>要列出所有假设，在实际中往往不可能。</p><h2 id="变型空间">变型空间</h2><p>一致：一个假设h与训练样例集合D一致，当且仅当<spanclass="math inline">\(Consistent(h,D)\equiv(\forall&lt;x,c(x)&gt;\inD)\quad h(x)=c(x)\)</span>。</p><p>变型空间（Version Space）：</p><p>关于假设空间H和训练样例集合D的变型空间，是H中与训练样例D一致的所有假设构成的子集。<spanclass="math inline">\(VS_{H,D}\equiv\{h\inH|Consistent(h,D)\}\)</span></p><ul><li><p>极大泛化：H中和D一致的极大一般成员的集合</p><p><span class="math inline">\(G\equiv\{g\inH|Consistent(g,D)\and(\neg\exist g&#39;\in H[(g&#39;\gt_g g)\andConsistent(g&#39;,D)])\}\)</span></p></li><li><p>极大特化：H中和D一致的极大特殊成员的集合</p><p><span class="math inline">\(S\equiv\{s\inH|Consistent(s,D)\and(\neg\exist s&#39;\in H[(s\gt_s s&#39;)\andConsistent(s&#39;,D)])\}\)</span></p></li></ul><h3 id="表示定理">表示定理</h3><p>令X为任意的实例集合，H为X上定义的布尔函数集合。令<spanclass="math inline">\(c:X\rightarrow[0,1]\)</span>为X上定义的任一目标概念，并令D为任意训练样例的集合<spanclass="math inline">\(\{&lt;x,c(x)&gt;\}\)</span>。对所有的X，H，c，D以及良好定义的S和G：<spanclass="math inline">\(VS_{H,D}\equiv\{h\in H|(\exist s\in S)(\exist g\inG)[g\gt_g h\gt_s s]\}\)</span></p><ul><li>其中G为极大泛化集合，S为极大特化集合。</li></ul><h3 id="正例和反例的作用">正例和反例的作用</h3><p>正例用于S泛化，搜索S集合；反例用于G特化，缩小G集合。</p><p>反例对于超泛化具有抑制作用。</p><h3 id="候选消除算法">候选消除算法</h3><p>将G集合初始化为H中最一般的假设：<spanclass="math inline">\(G_0=\{&lt;?,...,?&gt;\}\)</span></p><p>将S集合初始化为H中最特殊的假设：<spanclass="math inline">\(S_0=\{&lt;\empty,...,\empty&gt;\}\)</span></p><p>对每个训练样例d，</p><ul><li><p>如果d是正例：</p><ul><li><p>从G中移去所有与d不一致的假设</p></li><li><p>对S中每一个与d不一致的假设s：</p><ul><li><p>从S中移除s</p></li><li><p>把s的所有极小泛化假设h加入到S中</p><p>h满足与D一致，而且G中某个成员比h更一般</p></li><li><p>从S中移去所有比S中另一假设更一般的假设</p></li></ul></li></ul></li><li><p>如果d是反例：</p><ul><li><p>从S中移去所有和d不一致的假设</p></li><li><p>对G中每一个与d不一致的假设g：</p><ul><li><p>从G中移除g</p></li><li><p>把g的所有极小特化假设h加入到G中</p><p>h满足与D一致，而且S中某个成员比h更特殊</p></li><li><p>从G中移去所有比G中另一假设更特殊的假设</p></li></ul></li></ul></li></ul><h3 id="归纳偏置">归纳偏置</h3><p>归纳推理的根本问题：</p><ul><li>目标概念假设不在假设空间怎么办？</li><li>能设计包含所有假设的空间吗？</li><li>假设空间大小对未见实例的泛化能力有什么影响？</li><li>假设空间大小对所需训练样例数量有什么影响？</li></ul><p>假设空间往往是合取的有偏表示，而真实空间是析取的无偏表示。</p><p>无偏学习的无用性：</p><p>无偏学习需要X中所有实例进行训练，无法进行泛化，变型空间和候选消除算法失效。</p><p>因此，归纳学习必须给定某种形式的预先假定，即归纳偏置。</p><ul><li><p>核心：学习器从训练样例中泛化并推断新实例分类过程中所采用的策略</p></li><li><p>精确定义：</p><ul><li><p>给定任意训练数据<spanclass="math inline">\(D_c=\{x,c(x)\}\)</span>，目标概念c，学习算法L</p></li><li><p>推断新实例性<span class="math inline">\(x_i\)</span></p></li><li><p>归纳推理过程为：</p><p><span class="math inline">\((D_c\and x_i)\rightarrowL(x_i,D_c)\)</span></p><p><span class="math inline">\((B\and D_c\and x_i)\vdashL(x_i,D_c)\)</span></p></li></ul><p>学习器的归纳偏置为附加的前提集合B，通过B，则归纳推理可由演绎推理派生</p></li></ul><h4 id="有偏性">有偏性</h4><ul><li>无归纳偏置</li><li><span class="math inline">\(c\in H\)</span></li><li><span class="math inline">\(c\inH\)</span>且任何实例，除非可由其他先验推出，否则为反例</li></ul><p>有偏性越强，则学习器的归纳能力越强。</p><p>有偏程度不同的三种归纳学习算法：</p><ul><li>机械式学习器</li><li>候选消除算法</li><li>Find-S</li></ul><h2 id="决策树学习">决策树学习</h2><ul><li><p>实例：“属性-值”对表示，应用最广的归纳推理算法之一</p></li><li><p>目标函数具有离散的输出值</p></li><li><p>很好的健壮性（样例可以包含错误，也可以处理缺少属性值的实例）</p></li><li><p>能够学习析取表达式</p></li></ul><p>决策树学习算法：</p><ul><li>ID3、Assistant、C4.5</li><li>搜索一个完整表示的假设空间，表示为多个if-then规则</li></ul><p>归纳偏置：优先选择较小的树</p><h3 id="算法框架">算法框架</h3><p>问题设置：</p><ul><li>可能的实例集X</li><li>未知的目标函数<span class="math inline">\(f:X\rightarrowY\)</span></li><li>假设函数集<span class="math inline">\(H=\{h|h:X\rightarrowY\}\)</span></li></ul><p>输入：未知目标函数f的训练样例<spanclass="math inline">\(\{&lt;x_i,y_i&gt;\}\)</span></p><p>输出：最佳近似f的假设<span class="math inline">\(h\in H\)</span></p><p>算法框架：</p><ol type="1"><li>处理基本情况</li><li>寻找最好的分类属性A</li><li>用A建立一个节点划分样例</li><li>递归处理每一个划分作为其子节点/子树</li></ol><h3 id="假设空间搜索">假设空间搜索</h3><p>搜索的假设空间就是可能的决策树的集合。</p><p>从一个假设空间中搜索一个正确拟合训练样例的假设。</p><p>从简单到复杂的爬山算法遍历假设空间。从空的树开始，然后逐步考虑更加复杂的假设。引导爬山搜索的评估函数是信息增益度量。</p><h3 id="如何选择最佳属性">如何选择最佳属性</h3><p>衡量给定的属性区分训练样例的能力：信息增益</p><p>信息的度量：熵，刻画了样例集合的纯度。</p><ul><li><p>目标属性为布尔值的样例集S的熵：</p><p><spanclass="math inline">\(Entropy(S)=-p_+log_2p_+-p_-log_2p_-\)</span></p><p>其中，<span class="math inline">\(p_+\)</span>为正例的概率，<spanclass="math inline">\(p_-\)</span>为反例的概率。</p></li><li><p>熵的一般定义：</p><p><spanclass="math inline">\(Entropy(S)=\Sigma_{i=1}^c(-p_ilog_2p_i)\)</span></p></li></ul><p>信息增益：使用属性分割样例，导致期望熵降低</p><p><span class="math inline">\(Gain(S,A)=Entropy(S)-\Sigma_{v\inValues(A)}\frac{|S_v|}{S}Entropy(S_v)\)</span></p><ul><li><p>其中<spanclass="math inline">\(Values(A)\)</span>是属性A所有可能值的集合</p></li><li><p><spanclass="math inline">\(S_v\)</span>是S中属性A的值为v的子集，即<spanclass="math inline">\(S_v=\{s\in S|A(s)=v\}\)</span></p></li><li><p>第二项是用A分类S后熵的期望值</p></li></ul><h3 id="用于学习布尔函数的id3算法">用于学习布尔函数的ID3算法</h3><p><span class="math inline">\(ID3(Examples,Attributes)\)</span></p><ol type="1"><li><p>创建树的Root结点</p></li><li><p>如果Examples的目标属性均为正，则返回label=+的单结点树Root</p></li><li><p>如果Examples的目标属性均为反，那么返回label=-的单结点树Root</p></li><li><p>如果Attributes为空，那么返回单结点树Root，label设置为Examples中最普遍的目标属性值</p></li><li><p>否则</p><ul><li><p><span class="math inline">\(A\leftarrowAttributes中分类Examples能力最好的属性\)</span></p></li><li><p><span class="math inline">\(Root的决策属性\leftarrowA\)</span></p></li><li><p><span class="math inline">\(对于A的每个可能值v_i\)</span></p><ul><li><p><spanclass="math inline">\(令Examples_{v_i}为Examples中满足A属性值为v_i的子集\)</span></p></li><li><p><span class="math inline">\(如果Examples_{v_i}为空\)</span></p><ul><li><p><spanclass="math inline">\(在这个分支下加一个叶子结点，\)</span></p><p><spanclass="math inline">\(结点的label设置为Examples中最普遍的目标属性值\)</span></p></li></ul></li><li><p><spanclass="math inline">\(否则，在这个分支下加一个子树ID3(Examples_{v_i},Attributes-\{A\})\)</span></p></li></ul></li></ul></li><li><p>结束，返回树Root</p></li></ol><h4 id="id3算法特点">ID3算法特点</h4><p>假设空间：包含所有的决策树</p><p>遍历过程：仅维持单一的当前假设</p><ul><li>变型空间候选消除算法维持满足训练样例的所有假设</li></ul><p>不进行回溯，局部最优</p><p>基于统计，对错误样例不敏感，不适用于增量处理。</p><p>改进算法：C4.5等。</p><h3 id="决策树学习中的归纳偏置">决策树学习中的归纳偏置</h3><p><span class="math display">\[ 搜索策略决定了归纳偏置\begin{cases}近似：优先选择较短的树\\ 有限选择信息增益高的属性更接近根结点的树\end{cases}\]</span></p><h3 id="奥卡姆剃刀原理">奥卡姆剃刀原理</h3><p>如果对于同一现象有两种不同的假说，应该采取比较简单的那一种。</p><ul><li>不是简单的选择最简化的假设，而是推理所依据的是使可证伪的假设的数目更少。</li></ul><h2 id="其他树算法">其他树算法</h2><h3 id="c4.5算法">C4.5算法</h3><p>属性选择指标：</p><p>信息增益率：信息增益/该属性的熵</p><ul><li>信息增益准则对可取值数目较多的属性有所偏好</li><li>避免对取值数目较少的属性有所偏好，采用以下启发式：<ul><li>先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的</li></ul></li></ul><h3 id="cart算法">CART算法</h3><h4 id="属性选择指标分类">属性选择指标（分类）</h4><p>信息增益和增益率准则均需要计算对数。</p><p>基尼指数：模型的纯度，越小纯度越高。</p><ul><li><p>K个分类：<spanclass="math inline">\(Gini(p)=\Sigma_{k=1}^K(1-p_k)p_k=1-\Sigma_{k=1}^Kp_k^2\)</span></p></li><li><p>数据集D：<spanclass="math inline">\(Gini(D)=1-\Sigma_{k=1}^K(\frac{C_k}{D})^2\)</span></p></li><li><p>属性A对数据集的划分：<spanclass="math inline">\(Gini(D,A)=\frac{|D_1|}{D}Gini(D_1)+\frac{|D_2|}{D}Gini(D_2)\)</span></p></li><li><p>基尼指数和熵是正相关的，均可用来表示一个集合的混乱程度，并作为叶子结点的损失</p></li></ul><h4 id="属性选择指标回归">属性选择指标（回归）</h4><p>采用方差和度量。</p><p>度量目标是对于划分特征A，对应划分点s两边的数据集<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>，求出使<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>各自集合的均方差最小，同时<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>的均方差之和最小。</p><p><span class="math inline">\(min_{A,s}[min_{c_1}\Sigma_{x_i\inD_1(A,s)}(y_i-c_i)^2+min_{c_2}\Sigma_{x_i\inD_2(A,s)}(y_i-c_2)^2]\)</span></p><p>回归树输出不是类别，采用叶子结点的均值或者中位数来预测输出结果。</p><h4 id="连续值处理">连续值处理</h4><p>连续特征离散化：</p><ul><li>C4.5基于信息增益率离散化，CART基于基尼系数离散化</li><li>m个样本的连续特征A有m个，从小到大排列<spanclass="math inline">\(a_1,...,a_m\)</span>，则CART取相邻两样本值的平均数做划分点，一共取m-1个，其中第i个划分点<spanclass="math inline">\(T_i\)</span>表示为：<spanclass="math inline">\(T_i= (a_i+a_{i+1})/2\)</span>。<ol type="1"><li>分别计算以这m-1个点作为二元分类点时的基尼系数。</li><li>选择基尼系数最小的点为该连续特征的二元离散分类点。</li><li>如取到的基尼系数最小的点为<spanclass="math inline">\(a_t\)</span>，则小于<spanclass="math inline">\(a_t\)</span>的值为类别1；大于<spanclass="math inline">\(a_t\)</span>的值为类别2，这样就做到了连续特征的离散化。</li></ol></li></ul><h4 id="离散值处理">离散值处理</h4><p>CART分类树算法：对离散值的处理，采用不停地二分离散特征。</p><ul><li><p>多叉树：在ID3、C4.5，特征A被选中，如果它有3个取值<spanclass="math inline">\(A_1,A_2,A_3\)</span>，则建立三叉子树</p></li><li><p>二叉树：</p><ul><li>CART将特征A分成<span class="math inline">\(\{A_1\}\)</span>和<spanclass="math inline">\(\{A_2,A_3\}\)</span>、<spanclass="math inline">\(\{A_2\}\)</span>和<spanclass="math inline">\(\{A_1,A_3\}\)</span>、<spanclass="math inline">\(\{A_3\}\)</span>和<spanclass="math inline">\(\{A_1,A_2\}\)</span>三种情况，找到基尼系数最小的组合，比如<spanclass="math inline">\(\{A_2\}\)</span>和<spanclass="math inline">\(\{A_1,A_3\}\)</span>，然后建立二叉树节点。</li><li>由于并没有把特征A的取值完全分开，后面还有机会对子节点继续选择特征A划分<spanclass="math inline">\(A_1\)</span>和<spanclass="math inline">\(A_3\)</span>。</li></ul></li></ul><h4 id="剪枝处理">剪枝处理</h4><p>后剪枝：从完全生长的决策树的底端剪去一些子树，使决策树变小，从而增强泛化能力。</p><ul><li>首先从生成算法产生的决策树<spanclass="math inline">\(T_0\)</span>底端开始不断剪枝，直到<spanclass="math inline">\(T_0\)</span>的根节点，形成一个子序列<spanclass="math inline">\(T_0,...,T_n\)</span></li><li>然后通过交叉验证在独立的验证集上对子树序列进行测试，从中选择最优子树。</li></ul><p>最小化子树的损失函数：<spanclass="math inline">\(C_a(T)=C(T)+a|T|\)</span></p><ul><li>T为任意子树，C(T)为对数据的预测误差（如基尼系数），|T|为子树叶结点个数。超参<spanclass="math inline">\(a\ge0\)</span>，权衡训练数据的拟合程度与模型的复杂度。</li><li>a比较大，则最优子树<span class="math inline">\(T_a\)</span>偏小</li><li>a比较小，则最优子树<span class="math inline">\(T_a\)</span>偏大</li><li>a=0，则最优子树等于未剪枝的<spanclass="math inline">\(T_0\)</span></li><li>a趋近于∞，则最优子树为根结点树</li></ul><h2 id="树学习算法优缺点">树学习算法优缺点</h2><h3 id="优点">优点</h3><ul><li><p>简单直观，可解释性强。</p></li><li><p>基本不需要预处理，也不需要提前归一化和处理缺失值。既可以处理离散值也可以处理连续值。不过很多算法只是专注于离散值或者连续值。</p></li><li><p>可以处理多维度输出的分类问题。</p></li><li><p>使用决策树预测的代价为<spanclass="math inline">\(O(log_2m)\)</span>，m为样本数。</p></li><li><p>可以交叉验证的剪枝来选择模型，从而提高泛化能力。</p></li><li><p>对于异常点的容错能力好，健壮性高。</p></li></ul><h3 id="缺点">缺点</h3><ul><li><p>树算法非常容易过拟合，导致泛化能力不强（设置节点最少样本树、限制树深度）</p></li><li><p>样本的一点变动会导致树结构的剧烈改变（集成学习）</p></li><li><p>寻找最优决策树是NP难题，通过启发式方法容易陷入局部最优（集成学习）</p></li><li><p>比较复杂的关系，决策树很难学习（使用其他学习方法）</p></li><li><p>如果某些特征的样本比例过大，生成决策树比较容易偏向于这些特征（调节样本权重）</p></li></ul><h3 id="延伸">延伸</h3><ul><li><p>BAIR博客地址：https://bair.berkeley.edu/blog/2020/04/23/decisions/</p></li><li><p>论文地址：https://arxiv.org/abs/2004.00221</p></li><li><p>开源项目地址：https://github.com/alvinwan/neu</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;两岸猿声啼不住，轻舟已过万重山。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_02_无监督学习</title>
    <link href="http://example.com/2023/09/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/09/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-09-17T14:00:00.000Z</published>
    <updated>2023-11-02T12:02:56.540Z</updated>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="无监督学习">无监督学习</h1><p>20230912</p><p>20:10-21:10</p><p>20230917</p><p>18:30-21:10</p><p>聚类算法 Clustering Algorithm</p><p>聚类的“好坏”不存在绝对标准。</p><h2 id="大纲">大纲</h2><ul><li>相关概念</li><li>距离度量</li><li>聚类准则</li><li>聚类方法</li><li>聚类评价</li></ul><h2 id="相关概念">相关概念</h2><p>聚类：数据对象的集合</p><ul><li>在同一个类里，数据对象是相似的</li><li>不同类的数据对象是不相似的</li></ul><p>聚类算法：根据给定的相似性评判标准，将一个数据集合划分为几个聚类。</p><ul><li><p>数学形式化：</p><p>样本集合：<span class="math inline">\(D=\{x_1,x_2,...,x_m\},x_i\inR^d\)</span></p><p>聚类成k个簇：<span class="math inline">\(\{C_l|l=1,2,...,k\}\)</span></p></li><li><p>好的聚类算法：聚类内部高相似，聚类之间低相似。</p></li></ul><p>聚类的依据：将整个数据集中每个样本的特征向量看成是分布在特征空间中的一些点，点与点之间的距离即可作为相似性度量依据。</p><p>聚类方法目的：寻找数据中潜在的自然分组结构、感兴趣的关系。</p><p>聚类方法的有效性和数据分布形式有很大关系。</p><h2 id="距离度量">距离度量</h2><p>目的：度量同类样本间的相似性或不同样本间的差异性</p><h3 id="度量函数和度量空间">度量函数和度量空间</h3><h3 id="常用度量函数">常用度量函数</h3><p>闵可夫斯基距离</p><h2 id="聚类准则">聚类准则</h2><h3 id="类的定义">类的定义</h3><h3 id="试探方法">试探方法</h3><p>凭直观感觉或方法，针对实际问题定义一种距离度量的阈值，然后按最近邻规则制定某些样本属于一个聚类类别。</p><h3 id="聚类准则函数方法">聚类准则函数方法</h3><h2 id="聚类方法">聚类方法</h2><ul><li>基于试探的聚类搜索算法</li><li>系统聚类法</li><li>动态聚类法</li></ul><h3 id="基于试探的聚类搜索算法">基于试探的聚类搜索算法</h3><h4 id="按最近邻规则的简单试探法">按最近邻规则的简单试探法</h4><p>选用不同的阈值和起始点来试探。</p><p>依赖于以下因素：</p><ul><li>第一个聚类中心的位置</li><li>待分类样本的排序次序</li><li>距离阈值T的大小</li><li>样本分布的几何性质</li></ul><h4 id="最大最小距离算法">最大最小距离算法</h4><p>基本思想：以试探类间欧式距离为最大作为预选出聚类中心的条件。</p><ol type="1"><li>任选一个样本作为第一个聚类中心</li><li>选距离其最远的样本为第二个聚类中心</li><li>逐个计算各样本与两个聚类中心间距离，并选取其中较小值</li><li>在所有较小值中选出最大距离，若该最大值达到一定阈值，则选取相应样本点为迪桑聚类中心</li><li>重复3、4步，若无新聚类中心，进入下一步</li><li>不同样本按最近距离分到最近的聚类中心</li><li>最后，在每一类中计算各样本均值以得到更具代表性的聚类中心。</li></ol><h3 id="系统聚类法">系统聚类法</h3><p>基本思想：</p><p>将数据样本按距离准则逐步分类，类别有多到少，直到获得合适的分类要求为止。</p><h4 id="距离准则函数">距离准则函数</h4><ul><li>最短距离（两个集合所有距离最小值）</li><li>最长距离（两个集合所有距离最大值）</li><li>类平均距离（两个集合所有距离平均值）</li></ul><h3 id="动态聚类法">动态聚类法</h3><p>基本思想：</p><p>首先选择若干个样本点作为聚类中心，再按某种聚类准则使样本点向各中心聚集，从而得到初始聚类；然后判断初始分类是否合理，若不合理，则修改聚类，如此反复，直至合理。</p><p>代表算法：K-means算法和ISODATA算法（迭代自组织数据分析算法）</p><h4 id="k-means算法">K-means算法</h4><ol type="1"><li>选择一个聚类数量k</li><li>初始化聚类中心<ul><li>随机选择k个样本点，设置这些样本点为中心</li></ul></li><li>对每个样本点，计算样本点到k个聚类中心的距离，将样本点分距离它最近的聚类中心所属的聚类</li><li>重新计算聚类中心，聚类中心为属于这一聚类的所有样本的均值</li><li>如果没有发生样本所属的聚类改变的情况则退出，否则，返回第三步重复</li></ol><p>K-means算法的结果影响因素：</p><ul><li>所选聚类数目</li><li>聚类中心的初始分布</li><li>样本分布的几何性质</li></ul><p>在实际应用中，需要试探不同的K值和选择不同的聚类中心的起始值。</p><p>如果数据样本可以形成若干个相距较远的孤立区域分布，一般都能得到较好的收敛效果。</p><ul><li>K-means算法比较适合于分类数目已知的情况。</li></ul><h5 id="k-means">K-means++</h5><p>基本思想：K个初始聚类中心相互之间应该分得越开越好</p><ol type="1"><li>从数据集中随机选取一个样本作为初始聚类中心</li><li>首先计算每个样本与当前已有聚类中心之间的最短距离（即与最近的一个聚类中心的距离），用D(x)表示；接着计算每个样本被选为下一个聚类中心的概率<spanclass="math inline">\(\frac{D(x)^2}{\Sigma_{x\inX}D(x)^2}\)</span>，最后，按轮盘法选择下一个聚类中心</li><li>重复第2步选择出共K个聚类中心</li><li>K-means中第3步至第5步</li></ol><h4 id="迭代自组织数据分析算法-isodata">迭代自组织数据分析算法ISODATA</h4><p>基本步骤与思路：</p><ol type="1"><li>选择某些初始值，可选不同的参数，也可在迭代过程中人为修改，以将N个样本按指标分配到各个聚类中心去</li><li>计算各类中诸样本的距离指标函数</li><li>按给定的要求，将前一次获得的聚类集合进行分裂和合并处理，从而获得新的聚类中心</li><li>重新进行迭代运算，计算各项指标，判断聚类结果是否符合要求。经过多次迭代后，若结果收敛，则运算结束。</li></ol><p>具体过程（运行中能够根据各个类别的实际情况进行分裂和合并来调整聚类中心数）：</p><ol type="1"><li>从数据集中随机选取<spanclass="math inline">\(K_0\)</span>个样本作为聚类中心<spanclass="math inline">\(C=\{c_1,...,c_{K_0}\}\)</span></li><li>针对数据集中每个样本<spanclass="math inline">\(x_i\)</span>，计算它到<spanclass="math inline">\(K_0\)</span>个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中</li><li>判断上述每个类中的元素数目是否小于<spanclass="math inline">\(N_{min}\)</span>。如果小于<spanclass="math inline">\(N_{min}\)</span>则需要丢弃该类，令<spanclass="math inline">\(K=K-1\)</span>，并将该类中的样本重新分配给剩下类中距离最小的类</li><li>针对每个类别<spanclass="math inline">\(c_i\)</span>，重新计算它的聚类中心$c_i=_{xc_i}x</li><li>如果当前<spanclass="math inline">\(K\le\frac{K_0}{2}\)</span>，说明当前类别太少，前往分裂</li><li>如果当前<span class="math inline">\(K\ge2K_0\)</span>，说明当前类别太多，前往合并</li><li>如果达到最大迭代次数则终止，否则返回第2步继续执行</li></ol><p>合并</p><ol type="1"><li><p>计算当前所有类别聚类中心两两之间的距离，用矩阵D表示，其中<spanclass="math inline">\(D(i,i)=0\)</span></p></li><li><p>对于<span class="math inline">\(D(i,j)\lt d_{min}(i\neqj)\)</span>的两个类别需要进行合并操作，变成一个新的类，该类的聚类中心位置为<spanclass="math inline">\(m_{new}=\frac{1}{n_i+n_j}(n_im_i+n_jm_j)\)</span></p><p>上述<span class="math inline">\(n_i\)</span>和<spanclass="math inline">\(n_j\)</span>表示这两个类别中样本的个数，新的聚类中心可以看作对这两个类别进行加权求和。如果其中一个类所包含的样本个数较多，所合成的新类就会更加偏向它。</p></li></ol><ul><li><spanclass="math inline">\(d_{min}\)</span>：两个类别对应聚类中心之间所允许最小距<spanclass="math inline">\(d_{min}\)</span>，是否进行合并的阈值</li></ul><p>分裂</p><ol type="1"><li><p>计算每个类别下所有样本在每个维度下的方差</p></li><li><p>针对每个类别的所有方差挑选出最大的方差<spanclass="math inline">\(\sigma_{max}\)</span></p></li><li><p>如果某个类别的<span class="math inline">\(\sigma_{max}\gtSigma\)</span>并且该类别所包含的样本数量<spanclass="math inline">\(n_i\ge2n_{min}\)</span>，则可以进行分裂操作4，否则退出</p></li><li><p>将满足步骤3中的类分裂成两个子类别并令<spanclass="math inline">\(K=K+1\)</span></p><p><spanclass="math inline">\(m_i^{(+)}=m_i+\sigma_{max},m_i^{-}=m_i-\sigma_{max}\)</span></p></li></ol><ul><li>最大方差Sigma</li></ul><h4 id="两个算法的比较">两个算法的比较</h4><ul><li>K-means算法通常适合于类别数目已知的聚类，而ISODATA算法则更加灵活</li><li>从算法角度看，两者相似，聚类中心都是通过样本均值的迭代计算决定</li><li>ISODATA算法加入了一些试探步骤，并且可以结合人机交互的结构，使其能利用中间结果所取得的经验更好地进行分类</li><li>ISODATA原理直观，但需要更多参数，并且某些参数很难确定，因此ISODATA算法实际过程中并没有很受欢迎</li></ul><h2 id="聚类评价">聚类评价</h2><p>几个评价指标：</p><ul><li>聚类中心之间的距离</li><li>聚类域中的样本数目</li><li>聚类域内样本的距离方差</li></ul><p>聚类目前还没有一种通用的准则，往往需要根据实际应用来选择合适的方法。</p><h3 id="常用评价指标标签未知">常用评价指标（标签未知）</h3><h4 id="紧密度compactnesscp">紧密度（Compactness，CP）</h4><p><spanclass="math inline">\(\overline{CP}=\frac{1}{K}\Sigma_{k=1}^K\overline{CP_k}\)</span></p><p>缺点：没有考虑类间聚类效果。</p><h4 id="间隔度separationsp">间隔度（Separation，SP）</h4><p><spanclass="math inline">\(\overline{SP}=\frac{2}{k^2-k}\Sigma_{i=1}^k\Sigma_{j=i+1}^k||w_i-w_j||_2\)</span></p><p><span class="math inline">\(w_i\)</span>表示第i簇的中心，<spanclass="math inline">\(w_j\)</span>表示第j簇的中心，<spanclass="math inline">\(\overline{SP}\)</span>值越大类间越分散。</p><p>缺点：没有考虑类内聚类效果</p><h4 id="davies-bouldin-indexdbi分类适确性指标">Davies-BouldinIndex(DBI)，分类适确性指标</h4><p><span class="math inline">\(DB=\frac{1}{k}\Sigma_{i=1}^kmax_{j\neqi}(\frac{\overline{C_i}+\overline{C_j}}{||w_i-w_j||_2})\)</span></p><p><spanclass="math inline">\(\overline{C_i}\)</span>表示第i簇的紧密度，<spanclass="math inline">\(w_i\)</span>表示第i簇的中心。</p><p>DB越小，表示类内越紧凑，类间越分散，</p><p>缺点：使用欧式距离，对于环状分布聚类评价很差</p><h4 id="dunn-validity-indexdvi邓恩指数">Dunn ValidityIndex(DVI)，邓恩指数</h4><p>缺点：对离散点的聚类评价高，对环状分布评价效果差</p><h3 id="常用评价指标标签已知">常用评价指标（标签已知）</h3><ul><li>Cluster Accuracy，CA，聚类准确率</li><li>Rand Index，RI，兰德指数</li><li>Adjusted Rand Index，ARI，调整兰德指数</li><li>Mutual Information，MI，互信息</li><li>Normalized Mutual Information，NMI，归一化互信息</li></ul><h2 id="前沿进展">前沿进展</h2><p>监督深度学习：</p><ol type="1"><li>收集大量具有差异性的样本</li><li>对数据进行清洗和精细标注</li><li>采用多块显卡长时间训练</li></ol><p>监督深度学习的困境：</p><ul><li>数据体量大</li><li>数据标注时间长</li><li>数据标注代价高</li></ul><p>现实中，获取原始未标注数据较容易，而典型的监督学习技术不能利用这些数据；</p><p>监督信号有时候会使得深度模型有偏。</p><h3 id="自监督学习">自监督学习</h3><p>无监督学习的一种形式，其中数据没有提供（人类标注的）监督信息。</p><ul><li>通常需要定义一个前置任务让网络学习我们关心的事情。</li><li>对于大部分前置任务，我们需要保留一部分数据，让网络学会预测。</li><li>从前置任务学习到的特征会被用到不同的下游任务（通常包含标注）</li></ul><p>自监督预训练：</p><ul><li>无标注数据</li><li>前置任务预训练</li></ul><p>下游任务迁移：</p><ul><li>有标签数据</li><li>训练测试数据集可不同</li><li>多种下游任务测试</li></ul><h4 id="自监督学习分类">自监督学习分类</h4><ul><li>前置任务学习</li><li>对比学习</li><li>非对比学习</li></ul><h4 id="前置任务学习">前置任务学习</h4><ul><li><p>生成式方法——图像着色</p></li><li><p>生成式方法——图像修复</p></li><li><p>判别式方法——图像拼图</p></li></ul><h4 id="对比学习">对比学习</h4><h4 id="非对比学习">非对比学习</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;两岸猿声啼不住，轻舟已过万重山。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习_01_概率与学习-KNN</title>
    <link href="http://example.com/2023/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%A6%82%E7%8E%87%E4%B8%8E%E5%AD%A6%E4%B9%A0-KNN/"/>
    <id>http://example.com/2023/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%A6%82%E7%8E%87%E4%B8%8E%E5%AD%A6%E4%B9%A0-KNN/</id>
    <published>2023-09-12T13:00:00.000Z</published>
    <updated>2023-09-19T06:13:57.608Z</updated>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="概率与学习-knn">概率与学习-KNN</h1><p>20230912</p><p>18:30-20:10</p><h2 id="大纲">大纲</h2><ol type="1"><li>回顾</li><li>k-近邻分类器</li><li>最近邻分类器</li><li>k-近邻回归</li><li>降低近邻计算</li><li>扩展阅读</li></ol><h2 id="回顾">回顾</h2><p>统计学角度：机器学习的目的是得到映射 <spanclass="math display">\[x\rightarrow y\]</span></p><p>对不同类型的数据用手工/自动的方式进行特征工程，得到特征向量。</p><p>分类问题</p><ul><li>训练集：<spanclass="math display">\[D_{train}=\{(x_1,y_1),(x_2,y_2),...,(x_n,y_n)\}\]</span></li><li>训练样本：<span class="math display">\[x_i\in X\in R^d\]</span></li><li>样本标签：<span class="math display">\[y_i\inY=\{1,2,...,C\}\]</span></li><li>测试集：<spanclass="math display">\[D_test=\{\bar{x}_1,\bar{x}_2...\bar{x}_m\}\]</span></li></ul><p>回归问题</p><ul><li>训练集：<spanclass="math display">\[D_{train}=\{(x_1,y_1),(x_2,y_2),...,(x_n,y_n)\}\]</span></li><li>训练样本：<span class="math display">\[x_i\in X\in R^d\]</span></li><li>样本标签：<span class="math display">\[y_i\in R\]</span></li><li>测试集：<spanclass="math display">\[D_test=\{\bar{x}_1,\bar{x}_2...\bar{x}_m\}\]</span></li></ul><p>距离度量</p><ul><li>欧式距离</li><li>余弦相似性</li><li>曼哈顿距离</li><li>切比雪夫距离</li><li>马氏距离</li></ul><h2 id="k-近邻分类器">k-近邻分类器</h2><p>k-Nearest Neighbor Classfier, k-NN</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择k个最近（距离最小/相似度最大）的训练样本</li><li>采用投票法，将近邻中样本数最多的类别标签分配给<spanclass="math inline">\(\bar{x}\)</span></li></ul><p>k的取值的影响</p><ul><li>k一般取奇数值，避免平局</li><li>k取不同的值，分类结果可能不同</li><li>k值较小时，对噪声敏感，整体模型变得复杂，容易过拟合</li><li>k值较大时，对噪声不敏感，整体模型变得简单，容易欠拟合</li></ul><h2 id="最近邻分类器">最近邻分类器</h2><p>1-Nearest Neighbor Classfier, 1-NN</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择最近（距离最小/相似度最大）的训练样本<spanclass="math inline">\(i^*=argmax d(\bar{x},x_i)\)</span></li><li>采用投票法，将<spanclass="math inline">\(x_{i^*}\)</span>的类别标签分配给<spanclass="math inline">\(\bar{x}\)</span></li></ul><p>泛化错误率</p><ul><li>最近邻分类器的泛化错误率（测试样本x，其最近邻为z）<ul><li><span class="math inline">\(P(error)=1-\Sigma_{c\iny}P(c|x)P(c|z)\)</span></li></ul></li><li>贝叶斯最优分类器的结果：<spanclass="math inline">\(2\times(1-P(c^*|x))\)</span></li></ul><p>最近邻分类器虽然简单，但泛化错误率不超过贝叶斯分类器的两倍。</p><h2 id="k-近邻回归">k-近邻回归</h2><p>k-Nearest Neighbor Regression</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择k个最近（距离最小/相似度最大）的训练样本</li><li>将距离值的倒数作为权重，将k个近邻的标签值加权平均，作为<spanclass="math inline">\(\bar{x}\)</span>的预测值</li></ul><p>近邻平滑：核平滑法（kernel smoother）</p><ul><li>二次核</li><li>次方核</li><li>高斯核</li></ul><h2 id="讨论">讨论</h2><ul><li><p>k-NN是典型的“懒惰学习”。</p><p>训练阶段仅仅是把样本保存起来，训练时间开销为零，待收到测试样本后再进行处理。</p></li><li><p>SVM、CNN等是“急切学习”。</p><p>在训练阶段就对样本进行学习处理的方法，这类方法尝试在训练期间构造一个通用的与输入无关的目标函数。</p></li></ul><p>k-近邻分类器的优缺点</p><ul><li>优点<ul><li>精度高</li><li>对异常值不敏感</li><li>无数据输入假定</li></ul></li><li>缺点<ul><li>计算复杂度高</li><li>空间复杂度高</li></ul></li></ul><p>时间复杂度</p><ul><li>假设<spanclass="math inline">\(d(x_i,x_j)\)</span>是欧式距离，时间复杂度为<spanclass="math inline">\(O(d)\)</span></li><li>训练阶段：0</li><li>测试阶段：<span class="math inline">\(O(nd+nlogk)\)</span><ul><li>从n个数中选择k个最小的，时间复杂度为<spanclass="math inline">\(nlogk\)</span></li></ul></li><li>空间复杂度是？</li></ul><h2 id="降低计算">降低计算</h2><ul><li>特征维度2-5：维诺图</li><li>特征维度6-30：KD-Tree</li><li>特征高维：<ul><li>降维算法，如主成分分析（Principle Component Analysis）PCA</li><li>近似最近邻（approximate nearest neighbor, ANN）</li><li>哈希（hashing）</li></ul></li></ul><h3 id="维诺图">维诺图</h3><p>根据一组给定的目标，将一个平面划分成靠近每一个目标的多个区块。</p><ul><li><p>维诺图由一系列维诺单元组成，每个维诺单元是一个凸多面体</p><ul><li><p>假设X是一个点集，包含K个基点<spanclass="math inline">\((P_k)_{k\in K}\)</span>，那么维诺单元<spanclass="math inline">\(R_k\)</span>定义为：</p><p><span class="math inline">\(R_k=\{x\in X|d(x,P_k)\le d(x,P_j),\forallj\neq k\}\)</span></p></li></ul></li><li><p>查询或测试：给定一个查询<span class="math inline">\(q\inR^d\)</span>，找到<span class="math inline">\(P_k\inX\)</span>，使得<span class="math inline">\(q\in R_k\)</span></p></li><li><p>时间复杂度：</p><ul><li>2维数据：<spanclass="math inline">\(O(nlogn)\)</span>用来计算维诺图；</li><li>d维数据：使用二叉空间分割树进行点的定位，但是时间估计困难，难以量化</li></ul></li><li><p>适用范围：1-NN</p></li><li><p>适合特征维度：2～3维，可能4～5维</p></li></ul><h3 id="kd树">KD树</h3><p>KD树是一种对K维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。</p><p>KD树是二叉树，表示对K维空间的一个划分，构造KD树相当于不断用垂直于坐标轴的超平面将K维空间切分，构成一系列K维超矩形区域。KD树的每个结点对应于一个K维超矩形区域。</p><p>构造流程：</p><ol type="1"><li>确定split域。计算每个特征维度的方差，选定方差最大维度为split域。</li><li>确定Node-data域。</li><li>对剩下的数据点进行划分，确定左右子空间。</li><li>递归。在每个子空间继续进行空间划分，直到空间中只包含一个数据点。</li></ol><p>KD树搜索</p><ol type="1"><li>二叉搜索</li><li>回溯分析</li><li>返回最近邻</li></ol><p>时间复杂度</p><ul><li><p>寻找最近邻的时间复杂度为<spanclass="math inline">\(O(logn)\)</span></p></li><li><p>找到中位数的算法时间复杂度为<spanclass="math inline">\(O(n)\)</span></p></li><li><p>KD树搜索时间复杂度为<spanclass="math inline">\(O(nlogn)\)</span></p></li></ul><h3 id="降维">降维</h3><p>核心思想：通过某种数学变换将原始高维属性空间转变为一个低维子空间，来缓解维数灾难问题。</p><ul><li>多维缩放</li><li>主成分分析</li><li>局部线性潜入</li><li>ISOMAP</li></ul><h3 id="近似最近邻">近似最近邻</h3><p>核心思想：搜索可能是最近邻的数据项而不再只限于返回最可能的数据项，在牺牲可接受范围内的精度的情况下提高检索效率。</p><ul><li>不要求一定是距离最短的k个</li><li>如第k个最近邻，其距离为<spanclass="math inline">\(d_k\)</span>，则ANN要求其选取的所有k个样例的距离<spanclass="math inline">\(\hat{d}\le(1+\varepsilon)d_k\)</span></li><li>可以将k-NN搜索速度提高几个数量级</li></ul><p>FLANN：https://github.com/mariusmuja/flann</p><h3 id="哈希">哈希</h3><p>核心思想：利用哈希函数把任意长度的输入映射为固定长度的输出</p><h2 id="扩展阅读">扩展阅读</h2><h3 id="概率化k-nn">概率化k-NN</h3><p>通过定义似然函数来构造概率化的k-NN。</p><p>https://www.cc.gatech.edu/~afb/classes/CS7616-Spring2014/slides/CS7616-13a-PKNN.pdf</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;两岸猿声啼不住，轻舟已过万重山。&lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌入式_6_软件系统</title>
    <link href="http://example.com/2023/09/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/6_%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/09/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/6_%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-09-06T04:00:00.000Z</published>
    <updated>2023-11-10T06:37:48.454Z</updated>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第六章-嵌入式软件系统">第六章 嵌入式软件系统</h1><h2 id="概述">1. 概述</h2><h3 id="嵌入式软件与桌面软件的对比">嵌入式软件与桌面软件的对比</h3><p>内存：有限</p><p>CPU：往往只是恰好满足要求</p><p>操作系统：Windows、Linux、RTOS、专有操作系统、裸机</p><p>实时行为：可预测、实时性</p><p>开发流程：资源少，交叉开发；代码需要在特定环境下运行</p><p>执行流程：多数嵌入式设备自开启起就会持续运行某个程序至系统关机</p><ul><li>该程序可能存储在ROM，也可能是从非易失性存储器转移到RAM中执行。</li></ul><p>每个嵌入式设备都不同：</p><ul><li>技术层面：不同的CPU架构、内存、外设、应用程序和操作系统。</li><li>商业运作层面的，比如手机开发、生产的商业模式就和核磁共振扫描仪完全不同。</li></ul><p>软件组件：适合嵌入式环境的库；与硬件交互的接口；网络支持；数据存储；GUI</p><h3 id="软硬件权衡">软硬件权衡</h3><p>软件主导硬件，有关硬件的决策会对软件产生影响。</p><p>软硬件可能是不同团队进行开发。</p><ul><li>微处理器的选择：可能影响软件效率</li><li>内存大小和组合</li><li>包含的外设</li></ul><h3 id="调试">调试</h3><p>在线仿真器ICE（In-Circuit Emulator）</p><ul><li><p>模拟CPU的功能，可以完全仿真芯片的行为</p></li><li><p>价格昂贵，难以普及，没有广泛使用</p></li></ul><p>监控调试器</p><ul><li><p>需要通信通道</p></li><li><p>因为占用系统资源的问题，在一些严格的场合下不适合使用</p></li></ul><p>片上调试</p><ul><li><p>例如，JTAG是边界扫描测试的一个标准协议，SWD（Serial WireDebug）仿真器</p></li><li><p>价格便宜，易于实现</p></li><li><p>广泛使用</p></li></ul><h3 id="自检">自检</h3><p>输入/输出电路</p><p>板载开关：用于配置或模式选择</p><p>状态显示：字符或LED（3种状态：开、关、闪烁）</p><h3 id="软件系统层次结构">软件系统层次结构</h3><figure><img src="/image/嵌入式系统概论/软件系统层次结构.png"alt="软件系统层次结构" /><figcaption aria-hidden="true">软件系统层次结构</figcaption></figure><h3 id="可视化程序模型">可视化程序模型</h3><p>将实时应用视为单个/多个执行线程</p><h4 id="单线程程序模型">单线程程序模型</h4><p>优点：</p><ul><li><p>编程和再编程非常快速简单</p></li><li><p>改变系统响应特性的同时，往模型上添加新功能插件也相当容易</p></li></ul><p>缺点：</p><ul><li><p>在于应用领域的限制</p></li><li><p>难以做到安全地再编程</p></li><li><p>很难应用到不同行为或不同环境的运行系统中去</p></li></ul><h4 id="多线程程序模型">多线程程序模型</h4><p>优点：</p><ul><li><p>允许将系统工作划分为几个逻辑阶段，然后编写相互独立的程序来处理各自的工作</p></li><li><p>所有处理过程并行</p></li><li><p>如果有更高吞吐量的需求，工程师可以在任务中引入新的通信和协作模型</p></li></ul><p>缺点：可能引入资源竞争</p><h4 id="建立模型的好处">建立模型的好处</h4><p>辅助测试和完善最终系统。</p><p>模型利用它所知的系统属性来描述整个系统，并能够被用于对系统特性的进一步研究。</p><p>使用程序模型开发软件和硬件，便于将整个实时系统全盘考虑。</p><p>模型使得工程师能够预测程序的运行，从而满足系统的性能需求和功能需求。</p><h4 id="模型之间的差异">模型之间的差异</h4><p>一些模型易于编写，但调试不易；一些模型难于编写，但调试容易。</p><p>一些模型使得程序运行得更快，但需要付出更多内存资源消耗的代价。</p><p>模型准确性与鲁棒性。</p><h2 id="设计模式">2. 设计模式</h2><h3 id="嵌入式软件架构模式">嵌入式软件架构模式</h3><p>分为业务逻辑与实时依赖硬件的逻辑，抽象层将所需操作的高级请求转换为低级命令。<imgsrc="/image/嵌入式系统概论/嵌入式软件架构.png"alt="嵌入式软件架构" /></p><p>对于基于微控制器的系统来说，最常用的架构模式有：</p><ul><li>非结构化单体架构</li><li>分层架构</li><li>事件驱动架构</li><li>微服务架构</li></ul><h4 id="非结构化单体架构">非结构化单体架构</h4><p>应用和与之相连的多个模块，模块之间也可以相互连接</p><ul><li>容易构建，难以维持规模和移植</li><li>与应用层的应用程序紧密耦合</li></ul><h4 id="分层架构">分层架构</h4><p>将应用程序的逻辑划分为若干独立的层，仅通过定义良好的抽象层进行交互。</p><ul><li><p>试图通过将应用程序分解为独立的层来改善非结构化单体架构的高耦合性。</p></li><li><p>最常用。</p></li><li><p>例：应用层、中间件层、操作系统层、驱动层、硬件层</p></li></ul><h4 id="事件驱动架构">事件驱动架构</h4><p>利用中断来立即响应事件。</p><ul><li>事件驱动的体系结构通常使用消息队列、信号量和事件标志来表示系统中发生了事件。</li><li>对于实时嵌入式应用程序和与能耗相关的应用程序非常有意义。</li><li>优点：可扩展、软件模块高内聚、低耦合。</li><li>缺点：无论何时需要做任何事，都有额外的开销和复杂性。</li></ul><h4 id="微服务架构">微服务架构</h4><p>将应用程序构建为为业务领域开发的小型自治服务的集合。</p><ul><li><p>微服务本质上是低耦合的，这使得它易于维护、可测试，可以快速扩展或移植。</p></li><li><p>微服务是围绕系统的业务逻辑组织的。</p><ul><li>业务逻辑：系统行为的业务规则和用例。</li></ul></li><li><p>缺点：</p><ul><li>在架构上，增加设计的复杂性；</li><li>由于具有其他体系结构中可能不需要的通信特性，它们可能会增加额外的开销和内存需求；</li><li>架构的分散性也意味着实时的、确定性的行为可能更具挑战性，实时和响应可能有额外的抖动；</li><li>可能会增加开发时间和预算。</li></ul></li></ul><h4 id="微内核架构microkernel-architecture">微内核架构，MicrokernelArchitecture</h4><p>也称插件化(Plug-in)架构，是一种面向功能拆分的可扩展架构。</p><ul><li>包含核心系统和插件模块。</li><li>具备模块化解耦、弹性部署的能力以及安全稳定的特性，非常符合物联网的发展。</li><li>进程间通信性能相对较低。</li></ul><h3 id="管理外设数据">管理外设数据</h3><p>轮询、中断、直接存储器访问（DMA）</p><h4 id="外设轮询">外设轮询</h4><p>让应用程序定期轮询外设，查看是否有任何数据可供管理和处理。</p><ul><li>优先级：无，按顺序运行</li><li>响应时间：所有任务的总和</li><li>变化的影响：修改任务的执行时间或添加任务会影响所有其他任务</li><li>优点：简单，没有共享数据问题</li><li>缺点：浪费处理周期；在处理外设时可能会有很多抖动和延迟</li></ul><h4 id="有限状态机">有限状态机</h4><p>只执行当前状态，每个状态决定下一个状态（非顺序执行）。</p><ul><li>优先级：每个状态决定下一个状态的优先级</li><li>响应时间：所有任务的总和</li><li>变化的影响：修改任务的执行时间或添加任务会影响所有其他任务</li><li>同样没有共享数据问题</li></ul><h4 id="中断设计模式">中断设计模式</h4><p>中断应用程序的正常流程，以允许中断处理程序运行代码来处理系统中发生的事件。</p><p>当设计ISR时，我们希望中断尽可能快地运行（最小化中断）。</p><ul><li><p>避免内存分配操作，如声明非静态变量、操作堆栈或使用动态内存</p></li><li><p>尽量减少函数调用，以避免时钟周期开销、不可重入函数或阻塞函数的问题</p></li></ul><h5 id="带有中断的轮询">带有中断的轮询</h5><ul><li><p>优先级：中断优先于主循环，中断的优先级</p></li><li><p>反应时间：所有任务的总和或中断执行时间</p></li><li><p>变更的影响：对中断服务例程的影响较小。与主循环的轮询相同。</p></li><li><p>共享数据：必须处理与中断服务例程共享的数据</p></li><li><p>优势：</p><ul><li><p>不需要浪费CPU周期来检查数据是否准备好</p></li><li><p>获取数据的延迟是确定的</p></li><li><p>抖动被最小化</p></li></ul></li><li><p>缺点：</p><ul><li>中断的设置可能比较复杂</li><li>必须小心不要使用频繁触发的中断</li><li>当使用中断来接收数据时，开发人员必须仔细管理他们在ISR中所做的工作。开发人员经常需要使用ISR来处理所需的即时操作，然后将处理和非紧急的工作卸载给应用程序，从而增加了软件设计的复杂性。</li></ul></li></ul><h5id="数据获取存储相关的中断设计模式">数据获取/存储相关的中断设计模式</h5><ul><li>线性数据存储</li><li>双缓冲区</li><li>环形/循环缓冲区</li><li>带有信号量的循环缓冲区</li><li>带有事件标志的循环缓冲区</li><li>消息队列</li></ul><p>线性数据存储：</p><ul><li><p>中断服务程序可以直接访问共享内存位置</p></li><li><p>线性数据存储可能是危险的：</p><ul><li>线性数据存储是经常遇到竞态条件的地方</li><li>用于存储应用程序和ISR之间的数据的共享变量也需要声明为volatile，以防止编译器优化</li></ul></li><li><p>数据存储必须由互斥锁保护，以防止竞态条件</p></li></ul><p>双缓冲区：可以缓解数据存储的一些竞态条件问题。</p><p>环形缓冲区：</p><p>环形缓冲区（Circular Buffer），也被称为循环缓冲区（CyclicBuffer）或者环形队列（RingBuffer），是一种数据结构类型，它在内存中形成一个环形的存储空间。</p><ul><li><p>特点：终点和起点相连形成一个环状结构。</p></li><li><p>在处理流数据和实现数据缓存等场景中具有广泛的应用。</p></li><li><p>在中断中接收到的实时数据可以从外设中移除并存储在循环缓冲区中。因此，中断可以尽可能快地运行，同时允许应用程序代码自行处理循环缓冲区。使用循环缓冲区有助于确保数据不丢失，中断速度快，合理地处理数据。</p></li></ul><p>带有通知的循环缓冲区：</p><ul><li>应用程序需要轮询缓冲区以查看是否有新的可用数据。<ul><li>信号量和事件标志</li></ul></li><li>在大多数实时操作系统中，使用事件标志比使用信号量更有效。</li></ul><p>消息队列：</p><ul><li><p>类似于使用带有信号量的线性缓冲区。</p></li><li><p>通常需要更多的RAM、ROM和处理能力。</p></li></ul><h4 id="dma">DMA</h4><p>无需CPU的交互情况下在RAM和外设之间以及内部传输数据。</p><ul><li><p>RAM到RAM</p></li><li><p>外设到RAM</p></li><li><p>外设到外设</p></li></ul><p>DMA控制器可以显著提高外设和应用程序之间的数据吞吐量。此外，可以利用DMA控制器减轻CPU运行ISR来传输数据的负担，并最大限度地减少浪费的计算周期。</p><h3 id="实时嵌入式软件常用设计模式">实时嵌入式软件常用设计模式</h3><p>单核</p><p>多核</p><p>发布和订阅模型</p><p>RTOS模式</p><p>处理中断和低功耗设计</p><h4 id="多核架构">多核架构</h4><p>同构多核，对称多核处理具有相同处理器架构的两个核。</p><p>异构多核架构，每个处理核心都有不同的底层架构。</p><h4 id="发布和订阅模型">发布和订阅模型</h4><p>在物联网领域广泛使用，ROS也使用。</p><ul><li>在许多情况下，物联网设备将启动电源，连接到云，然后订阅它想要接收的消息主题。该设备甚至还可以发布特定的主题。</li></ul><p>缺点：会导致应用程序占用更大的内存。</p><h4 id="rtos应用程序设计模式">RTOS应用程序设计模式</h4><p>资源同步：对共享资源的访问是否安全</p><ul><li>确保需要访问资源的多个任务或中断协调进行，避免竞争条件和内存损坏。</li><li>可以通过三种方式处理资源同步：中断锁、抢占锁和互斥锁。<ul><li>中断锁：禁用中断以在任务和中断之间提供资源同步</li><li>抢占锁：在临界区期间临时禁用RTOS内核抢占调度程序</li><li>互斥锁：通过创建一个对象来保护临界区，该对象的状态可以被检查，以确定是否可以安全访问共享资源，其唯一目的是为共享资源提供互斥</li><li>中断锁禁用系统中断，可能导致问题；抢占锁不禁用系统中断，但禁止内核抢占；互斥锁两者都不禁用。</li></ul></li></ul><p>活动同步：决定执行是否已达到特定状态</p><ul><li><p>单向同步（任务对任务）：使用二值信号量或事件标志来同步任务。</p></li><li><p>单向同步（中断到任务）：ISR给出信号量或事件标志后，继续执行直到完成为止。</p></li><li><p>双向同步：两个任务在它们之间的两个方向上进行协调。</p></li></ul><h4 id="广播设计模式">广播设计模式</h4><p>允许多个任务阻塞，直到给定信号量、出现事件标志，甚至将消息放入消息队列。</p><p>任务或ISR可以提供由多个任务使用的二值信号量广播。广播可能无法在所有实时操作系统中实现，必须检查RTOS是否支持。</p><ul><li>如果不支持广播，则可以创建由任务或中断给出的多个信号量。从设计的角度来看，使用多个信号量并不优雅，从实现的角度来看也不高效，但有时在软件中就是这样。</li></ul><h4 id="低功耗应用程序设计模式">低功耗应用程序设计模式</h4><p>关于低功耗设计模式，主要模式是尽可能地保持设备关闭。</p><ul><li>事件驱动中，事件之间没有实际工作要做时，应该将微控制器置于适当的低功耗状态，并关闭任何非必要的电子设备</li><li>除非发生唤醒事件，否则系统处于低功耗状态</li><li>实际工作完成后，系统恢复到低功耗状态</li></ul><p>建议：使用内置tickless模式的RTOS，或者扩展系统tick以使微控制器休眠更长时间</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;眼花耳热后，意气素霓生。&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式系统概论" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌入式_5_I/O与总线</title>
    <link href="http://example.com/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/5_IO%E4%B8%8E%E6%80%BB%E7%BA%BF/"/>
    <id>http://example.com/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/5_IO%E4%B8%8E%E6%80%BB%E7%BA%BF/</id>
    <published>2023-09-05T04:00:00.000Z</published>
    <updated>2023-11-09T13:50:09.284Z</updated>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第五章-io与总线">第五章 I/O与总线</h1><h2 id="设备分类">1. 设备分类</h2><h3 id="按从属分类">按从属分类</h3><p>系统设备：操作系统启动时已注册的标准设备</p><ul><li>操作系统中有设备驱动程序和管理程序，例如闪存，触摸面板</li></ul><p>用户设备：操作系统启动时未注册的非标准设备</p><ul><li>设备驱动程序由用户提供，例如SD卡、U盘</li></ul><h3 id="按使用分类">按使用分类</h3><p>专用设备：同一时间只能被一个进程使用。</p><p>共享设备：可被多个进程同时寻址。</p><p>虚拟设备：通过虚拟技术将一台独占设备虚拟成多台逻辑设备供多个用户进程同时使用。</p><h3 id="按特征分类">按特征分类</h3><p>存储设备</p><p>输入/输出设备</p><ul><li>通常由机械部件和电子部件组成，电子部分称为设备控制器或适配器</li></ul><h3 id="按信息传输单元分类">按信息传输单元分类</h3><p>块设备：以块为单位组织和交换数据，是结构化设备，例如硬盘。</p><p>字符设备：以字符为单位组织和交换数据，是非结构化设备，例如串口、打印机。</p><ul><li>基本特征是传输速率低且不可寻址，执行输入/输出操作时经常使用中断。</li></ul><h2 id="输入输出">2. 输入/输出</h2><p>输入/输出接口需要多个寄存器：</p><ul><li>数据寄存器</li><li>控制寄存器</li><li>状态寄存器</li></ul><h3 id="可编程io">可编程I/O</h3><p>通信过程中选择控制寄存器或数据缓冲区的三种方法：</p><ul><li><p>独立I/O端口</p></li><li><p>内存映射I/O</p></li><li><p>混合解决方案，混合模型包括内存映射I/O数据缓冲区和用于控制寄存器的独立I/O端口</p></li></ul><p>Intel x86提供了in、out指令，大多数其他cpu使用内存映射I/O。</p><h4 id="独立io端口">独立I/O端口</h4><p>优点：</p><ul><li>I/O独立编址，不占用内存</li><li>使用I/O指令，程序清晰，很容易看出是I/O操作还是存储器操作</li><li>译码电路比较简单（I/O端口的地址空间较小，所用地址线较少）</li></ul><p>缺点：只能用专门I/O指令，访问端口办法少</p><h4 id="内存映射io">内存映射I/O</h4><p>优点：</p><ul><li><p>在内存映射I/O模式中，设备控制寄存器只是内存中的变量，可以像其他变量一样在C语言中寻址。因此，I/O设备驱动程序可以完全用C语言编写。</p></li><li><p>在这种模式下，不需要特殊的保护机制来阻止用户进程执行I/O操作。</p></li></ul><p>缺点：</p><ul><li><p>目前大多数嵌入式处理器都支持内存缓存。缓存设备控制寄存器会导致灾难。为了防止这种情况，必须为硬件提供选择性禁用缓存的功能，这将增加嵌入式系统中硬件和软件的复杂性。</p></li><li><p>如果只有一个地址空间，所有内存模块和所有I/O设备必须检查所有内存引用，以决定响应哪一个，这将严重影响系统性能。</p></li></ul><h3 id="忙等io">忙等I/O</h3><p>使用指令测试设备忙闲。</p><p>缺点：低效</p><ul><li>CPU在测试设备时不能做其他工作</li><li>很难同时进行输入/输出</li></ul><h3 id="中断io">中断I/O</h3><p>中断允许设备改变CPU中的控制流，调用子例程来处理设备。</p><ul><li>行为：基于子程序调用机制，强制下一条指令为预定义地址的子程序调用</li></ul><h4 id="中断的物理接口">中断的物理接口</h4><ul><li>CPU与设备通过CPU总线连接</li><li>CPU与设备握手</li><li>设备发出中断请求</li><li>CPU在能够处理中断时确认中断</li></ul><h4 id="优先级与向量">优先级与向量</h4><p>优先级：决定哪些中断首先得到CPU</p><ul><li>屏蔽：在挂起的中断完成之前，不会识别低于当前优先级的中断。</li><li>不可屏蔽中断NMI，最高优先级，不会被屏蔽，通常用于断电。</li></ul><p>向量：决定每种类型的中断调用什么代码</p><ul><li>中断向量表</li></ul><h4 id="中断序列">中断序列</h4><ol type="1"><li>CPU确认请求</li><li>设备发送向量</li><li>CPU调用中断处理程序</li><li>软件处理请求</li><li>CPU恢复前台程序状态</li></ol><h4 id="中断开销">中断开销</h4><p>中断处理程序执行时间</p><p>中断机制开销</p><p>寄存器保存/恢复</p><p>流水线相关的开销</p><p>缓存相关的开销</p><h4 id="中断设计">中断设计</h4><p>中断服务处理，Interrupt Service Routines，ISR</p><p>基本原则是保持处理程序简短（时间上）。</p><ul><li>避免循环和冗长复杂的指令。</li><li>尽快重新启用中断，先做硬件关键和不可重入的事情，然后执行中断启用指令。</li><li>预计花费时间和复杂度。</li></ul><p>C语言和汇编语言：</p><ul><li>汇编语言的花费时间易于估计，C语言难以估计</li><li>但是尽量使用C语言</li></ul><h4 id="调试intinta周期">调试INT/INTA周期</h4><ol type="1"><li><p>设备硬件产生中断脉冲</p></li><li><p>中断控制器(如果有的话)以优先级处理多个同时发生的请求，并向处理器发出单个中断</p></li><li><p>CPU响应一个中断确认周期</p></li><li><p>控制器在总线上发出一个中断向量</p></li><li><p>CPU读取向量并计算向量所指向的内存中的地址，然后获取这个值</p></li></ol><h4 id="查找丢失的中断">查找丢失的中断</h4><p>可以使用单个上行/下行计数器构建一个小电路，该计数器对每个中断进行计数，并减少每个中断确认的计数。如果计数器总是显示0或1的值，则一切正常。</p><p>一个经验法则将帮助最小化丢失的中断：在最早的安全点重新启用ISR中的中断。</p><h4 id="避免nmi">避免NMI</h4><p>NMI（不可屏蔽的中断）用于电源故障、系统关闭和即将发生的灾难，定时器或UART中断不是。</p><p>NMI甚至会破坏编码良好的中断处理程序，因为大多数isr在服务硬件的前几行代码中都是不可重入的。NMI也会阻碍堆栈管理工作。</p><p>NMI与大多数工具的混合效果很差。调试任何ISR-NMI或其他方式都是令人恼火的。很少有工具能很好地在ISR内单步执行和设置断点。</p><h4 id="断点问题">断点问题</h4><p>虽然断点确实是很棒的调试辅助工具，但是对于嵌入式代码是具有不确定性的。</p><p>使用实时trace，这是所有仿真器和一些智能逻辑分析仪都具有的功能。</p><h4 id="可重入">可重入</h4><p>例程必须满足以下条件才能重入:</p><ul><li><p>以原子方式使用所有共享变量，除非将每个共享变量分配给函数的特定实例</p></li><li><p>不调用不可重入的函数</p></li><li><p>不以非原子的方式使用硬件</p></li></ul><p>原子指不能被中断的操作。</p><p>消除不可重入代码的办法：</p><ul><li><p>避免共享变量。</p><p>全局变量是没完没了的调试问题和代码失败的根源。使用自动变量或动态分配内存。</p></li><li><p>在不可重入代码期间禁用中断。</p></li><li><p>信号量。</p></li></ul><h4 id="竞态条件">竞态条件</h4><p>设备或系统出现不恰当的执行时序，而得到不正确的结果。</p><p>参考计算机操作系统：进程的同步和互斥问题。</p><h2 id="总线">2. 总线</h2><p>总线是计算机各种功能部件之间传送信息的公共通信干线。</p><ul><li>一组传送线路 + 相关通信协议</li></ul><h3 id="总线协议">总线协议</h3><p>总线协议决定设备如何通信。</p><ul><li>协议由状态机指定，协议中的每个参与者都有一个状态机。</li><li>总线上的设备经历一系列的状态。</li><li>可包含异步逻辑行为。</li></ul><h3 id="系统总线配置">系统总线配置</h3><p>多总线允许并行：一个总线连接慢速设备，另一个独立总线连接高速设备。</p><p>桥连接两个总线。</p><p>常用总线：</p><figure><img src="/image/嵌入式系统概论/常用总线.png" alt="常用总线" /><figcaption aria-hidden="true">常用总线</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;眼花耳热后，意气素霓生。&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式系统概论" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌入式_4_存储器架构</title>
    <link href="http://example.com/2023/09/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/4_%E5%AD%98%E5%82%A8%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2023/09/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/4_%E5%AD%98%E5%82%A8%E5%99%A8%E6%9E%B6%E6%9E%84/</id>
    <published>2023-09-04T04:00:00.000Z</published>
    <updated>2023-11-09T12:48:10.006Z</updated>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第四章-存储器架构">第四章 存储器架构</h1><h2 id="存储系统">1. 存储系统</h2><h3 id="存储系统-1">存储系统</h3><p>对许多应用来说，存储系统对整个系统性能的影响比对数据流水线的影响更大。</p><p>复杂性：在同一个嵌入式系统中，通常需要组合各种存储技术</p><ul><li>至少需要一些非易失性存储和一些易失性存储</li></ul><p>层次结构往往是必须的。</p><p>处理器架构的地址空间被分解成若干子空间来提供不同类型的存储器访问。</p><h3 id="易失性存储器">易失性存储器</h3><p>断电时内容消失的存储器。</p><p>随机存取存储器，RAM</p><ul><li>静态RAM，SRAM：速度快，面积大</li><li>动态RAM，DRAM：保持数据的时间很短，需要定期刷新；比SRAM更不稳定</li></ul><p>大多数嵌入式系统都包括一个SRAM，许多ES也会包括DRAM。</p><ul><li>只利用SRAM不能提供足够大的存储容量</li></ul><p>影响程序执行时间的因素</p><ul><li><p>被访问的存储器地址是映射到SRAM还是DRAM</p></li><li><p>DRAM可能在忙于刷新时被请求访问，因此DRAM刷新周期会引起访问时间的变化</p></li><li><p>访问历史也会影响存取时间</p></li></ul><h3 id="非易失性存储器">非易失性存储器</h3><p>不需要持续供电来保留存储在计算设备中的数据或程序代码。</p><ul><li><p>只读存储器ROM，或掩模ROM（MashROM）：内容在芯片工厂就已经固定</p></li><li><p>电可擦除可编程ROM，EEPROM</p></li><li><p>快闪存储器（Flash）</p></li><li><p>磁盘存储器</p></li></ul><h3 id="固件">固件</h3><p>固件（firmware）一般存储于设备中的电可擦除只读存储器或FLASH芯片中，一般可由用户通过特定的刷新程序进行升级。</p><p>可固化（ROMable）：可被编程到ROM芯片中的机器语言。作为“只读”芯片不能更新，可固化程序必须使用RAM或磁盘来保存变化的数据。</p><ul><li><p>代码将从ROM正确执行：不需要复制到RAM，但是RAM可能更快</p></li><li><p>代码和数据不能混用，除了常量数据</p></li></ul><h3 id="flash">Flash</h3><p>读取快于一般ROM，慢于RAM。</p><p>写入时间大大超过读取时间，且写入次数有限。</p><ul><li><p>SLC：速度快，存储密度低，稳定性好，成本高，约10万次擦写寿命，多用于高端企业级产品</p></li><li><p>MLC：速度一般，成本一般，约3000—10000次擦写寿命，应用于中高端SSD</p></li><li><p>TLC：速度慢，成本最低，约1000次擦写寿命</p></li></ul><p>类型：</p><ul><li><p>NOR：块擦除；擦除和写入时间较长，但能够像RAM那样访问</p></li><li><p>NAND：以块为单位；擦除和写入速度比较快；按页读取</p></li></ul><figure><img src="/image/嵌入式系统概论/Flash.png" alt="Flash" /><figcaption aria-hidden="true">Flash</figcaption></figure><h2 id="存储器层次结构">2. 存储器层次结构</h2><p>精确的分层机构取决于技术参数，也取决于应用领域</p><ul><li><p>处理器寄存器</p></li><li><p>工作存储器（或主存储器、主存）：实现了处理器存储地址所涵盖的存储器。通常，其容量在几MB到几GB之间，并且是易失的</p></li><li><p>缓冲存储器:高速缓存、地址转换高速缓存（TLB）以及暂存存储器（SPM）。</p></li><li><p>flash、磁盘等非易失性存储，也可基于互联网的存储器解决方案（如云）。</p></li></ul><h3 id="cache">Cache</h3><p>高速缓存的架构对应用程序的执行时间具有很大影响。</p><ul><li>潜在地提高了存储系统的能效。</li><li>设计时预测缓存是否命中很困难，这对实时性能的精确预测也是负担。</li><li>多级Cache</li></ul><h3 id="暂存存储器">暂存存储器</h3><p>SPM，也叫紧耦合内存TCM。</p><ul><li>SPM和主存统一编址，每当某个简单的地址解码器给出一个SPM地址范围内的地址时，SPM就被访问。</li><li>SPM通常和处理器集成在一个芯片上。</li><li>功耗低、速度快。</li></ul><h3 id="存储器访问时间难以预测">存储器访问时间难以预测</h3><p>虚拟存储器：使各种存储技术看起来是一个连续的地址空间</p><p>地址转换：把地址空间的逻辑地址转换成一种存储技术上的物理地址</p><ul><li>转换通常是由转换后备缓冲器（Translation LookasideBuffer，TLB）协助完成</li></ul><p>很难预测或理解访问存储器的时间需要多久，因而嵌入式系统设计人员通常比一般程序员需要更深入地理解存储器系统</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;眼花耳热后，意气素霓生。&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式系统概论" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌入式_3_微处理器</title>
    <link href="http://example.com/2023/09/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/3_%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://example.com/2023/09/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/3_%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2023-09-03T04:00:00.000Z</published>
    <updated>2023-11-09T12:34:32.031Z</updated>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第三章-嵌入式微处理器">第三章 嵌入式微处理器</h1><p>Embedded Microprocessor</p><h2 id="嵌入式系统硬件">1. 嵌入式系统硬件</h2><p>包含CPU、总线、存储器、输入/输出设备</p><p>常见微处理器：</p><ul><li>ARM</li><li>MIPS</li><li>PowerPC</li><li>X86</li></ul><h3 id="冯诺伊曼结构">冯诺伊曼结构</h3><ul><li>将程序指令存储器和数据存储器合并在一起的存储器结构</li><li>程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同</li><li>CPU寄存器: 程序计数器(PC)，指令寄存器(IR)，通用寄存器等。</li></ul><h3 id="哈佛结构">哈佛结构</h3><p>明显的特点：</p><ul><li><p>使用两个独立的存储器模块，分别存储指令和数据</p><p>每个存储模块都不允许指令和数据并存</p></li><li><p>使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，这两条总线之间毫无关联</p></li></ul><p>改进的哈佛结构，其结构特点为：</p><ul><li>使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存;</li><li>具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块(程序存储模块和数据存储模块)，公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输</li><li>两条总线由程序存储器和数据存储器分时共用</li></ul><p>大多数数字信号处理器（DSP）使用哈佛架构来处理流数据：</p><ul><li>更大的内存带宽</li><li>更可预测的带宽</li></ul><h3 id="risc和cisc">RISC和CISC</h3><ul><li>复杂指令集计算机，Complex instruction set computer，CISC<ul><li>多种寻址模式</li></ul></li><li>精简指令集计算机，Reduced instruction set computer，RISC<ul><li>流水线指令</li><li>访存指令只有load/store</li></ul></li></ul><h4 id="risc-v">RISC-V</h4><ul><li>简单、完全开源并且免费</li><li>将基准指令和扩展指令分开，可以通过扩展指令做定制化的模块和扩展<ul><li>RISC-V的基准指令集确定后将不会变化，这是RISC-V稳定性的重要保障</li></ul></li></ul><h4 id="设计系统芯片需要考虑">设计系统芯片需要考虑</h4><ul><li>成本</li><li>生态系统</li><li>碎片化风险</li><li>安全性</li><li>设计保证</li></ul><h3 id="编程模型">编程模型</h3><p>在程序中可以用道德寄存器集合。</p><ul><li>有些寄存器不可见</li></ul><h2 id="嵌入式微处理器分类">2. 嵌入式微处理器分类</h2><p>按位数可分为4、8、16等；</p><p>按功能可分为4种：</p><ul><li>嵌入式微处理单元（MPU）：类似CPU</li><li>嵌入式微控制器（MCU）：包含MPU与存储器、I/O接口和基本控制器</li><li>嵌入式DSP处理器：特殊设计系统和算法，用于信号处理</li><li>嵌入式SoC：集成MPU、存储器、外设控制器、通信功能等<ul><li>MCU通常不支持操作系统，裸机运行程序，快速响应实时任务和控制系统</li><li>SoC适合运行操作系统，性能和可靠性强，往往用于更高端的设备</li></ul></li></ul><h3 id="嵌入式微处理单元mpu">嵌入式微处理单元（MPU）</h3><p>嵌入式微处理器就是和通用计算机的处理器对应的CPU。</p><ul><li><p>功能和微处理器基本一样，具有32位以上，性能较高。</p></li><li><p>体积小、功耗少、成本低、可靠性高，有的可提供工业级应用。</p></li></ul><p>流行的嵌入式微处理器：ARM：Cortex-A系列、Power、MIPS</p><figure><img src="/image/嵌入式系统概论/框图.png" alt="框图" /><figcaption aria-hidden="true">框图</figcaption></figure><h3 id="嵌入式微控制器mcu">嵌入式微控制器（MCU）</h3><p>嵌入式微控制器就是将整个计算机系统的主要硬件集成到一块芯片中，芯片内部集成ROM/EPROM，RAM，总线，总线逻辑，定时/计数器，Watchdog，I/O，串行口等各种必要功能和外设。</p><ul><li>特点：<ul><li>一个系列的微控制器具有多种衍生产品</li><li>单片化，体积大大减小，功耗和成本降低，可靠性提高</li><li>是目前嵌入式工业的主流，约占嵌入式系统50%的份额</li></ul></li></ul><p>流行的嵌入式微控制器：</p><ul><li><p>通用系列：8051，Coldfire的MC683xx（32位），Cortex-M0/3/4/7/M33/M35P</p></li><li><p>半通用系列:支持I2C,CAN BUS及众多专用MCU和兼容系列</p></li></ul><h3 id="嵌入式dsp">嵌入式DSP</h3><p>嵌入式DSP是专门用于信号处理方面的处理器，其在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令执行速度。</p><p>应用领域：数字滤波、频谱分析、FFT</p><p>流行的嵌入式DSP：</p><ul><li>德州仪器（TI），c6000 与 c5000</li><li>模拟器件公司（ADI）</li><li>摩托罗拉（Motorola）公司</li></ul><h3 id="嵌入式soc">嵌入式SoC</h3><p>嵌入式SoC是追求产品系统最大包容的集成器件。绝大多数系统构件都在一个系统芯片内部。</p><p>SoC芯片可以有效地降低电子/信息系统产品开发成本，缩短开发周期，提高产品竞争力。</p><p>特点：</p><ul><li>结构简洁</li><li>体积小、功耗小</li><li>可靠性高</li><li>设计生产效率高</li></ul><p>流行的SoC：高通骁龙（Snapdragon）、海思</p><h3 id="现场可编程门阵列fpga">现场可编程门阵列，FPGA</h3><p>具有可编程特性的集成电路。</p><ul><li>赛灵思、阿尔特拉（被英特尔收购）</li></ul><h4 id="dsp和fpga">DSP和FPGA</h4><figure><img src="/image/嵌入式系统概论/DSP与FPGA.png" alt="DSP与FPGA" /><figcaption aria-hidden="true">DSP与FPGA</figcaption></figure><h2 id="嵌入式微处理器的特点">嵌入式微处理器的特点</h2><p>基础是通用微处理器；与通用微处理器的区别：</p><ul><li>体积小、重量轻、可靠性高、功耗低</li><li>成本低：片上存储、引脚与封装、代码密度</li><li>工作温度、抗电磁干扰、可靠性等方面增强</li></ul><h2 id="arm">ARM</h2><h3 id="arm公司">ARM公司</h3><p>成立于1990年11月，从Acorn电脑公司剥离出来。</p><ul><li><p>设计ARM系列的RISC处理器内核。</p></li><li><p>授权ARM核心设计的半导体合作 伙伴制造和销售给他们的客户。</p></li><li><p>同时开发技术以协助ARM架构的设计。</p><ul><li>软件工具、电路板、调试硬件、应用软件、总线架构、外围设备等。</li></ul></li></ul><h3 id="arm处理器的主要应用领域">ARM处理器的主要应用领域</h3><ul><li><p>消费类电子产品：</p><p>ARM技术在目前流行的数字音频播放器、数字机顶盒和游戏机中得到了广泛采用</p></li><li><p>无线通讯领域：</p><p>目前大部分无线通讯设备采用了ARM技术，ARM以其高性价比和低成本，在该领域的地位日益巩固</p></li><li><p>网络应用：</p><p>随着宽带技术的推广，采用ARM技术的ADSL芯片正逐步获得竞争优势，此外，ARM在语音及视频处理上进行了优化，并获得广泛支持，这也对DSP的应用领域提出了挑战</p></li><li><p>工业控制领域：</p><p>基于ARM核的微控制器芯片不但占据了高端微控制器的大部分市场份额，同时也逐渐向低端微控制器应用领域扩展，Cortex-M系列就是ARM公司推出的典型低功耗、高性价比32位工控微控制器，向传统的8位/16位微控制器提出了挑战</p></li><li><p>成像和安全产品：</p><p>现在流行的数码相机和打印机中绝大部分采用ARM技术，手机中的32位SIM智能卡也采用了ARM技术</p></li></ul><h3 id="arm处理器分类">ARM处理器分类</h3><p>结构体系版本（Architecture）</p><ul><li>ARM v4T</li><li>ARM v5TE</li><li>ARM v6</li><li>ARM Cortex（v7 ，v8）</li></ul><p>按应用特征分类</p><ul><li><p>应用处理器，Application Processor</p></li><li><p>实时控制处理器，Real-time Controller</p></li><li><p>微控制器，Micro-controller</p></li><li><p>SecurCore</p></li></ul><h3 id="arm架构">ARM架构</h3><p>典型的RISC：</p><ul><li>丰富的寄存器</li><li>加载/存储体系结构</li><li>简单寻址模式</li><li>统一和固定长度的指令字段</li></ul><p>增强功能：</p><ul><li>每条指令控制ALU和移位器</li><li>自动递增和自动递减寻址模式</li><li>多个加载/存储</li><li>条件执行</li></ul><p>特点：</p><ul><li>高性能</li><li>低代码</li><li>低功耗</li><li>低硅面积</li></ul><h3 id="流水线">流水线</h3><p>提高速度：大多数指令在一个周期内执行。</p><p>版本：</p><ul><li><p>3级（ARM7TDMI及更早版本）</p></li><li><p>5级（ARMS, ARM9TDMI）</p></li><li><p>6级（ARM10TDMI）</p></li></ul><p>流水线清空，导致执行速度变慢。</p><ul><li>分支指令</li></ul><p>分支预测技术</p><ul><li>静态</li><li>动态</li></ul><h3 id="meltdown-spectre">Meltdown &amp; Spectre</h3><p>近20年的Intel，AMD，Qualcomm厂家和其它ARM的处理器受到影响。</p><p>因为此次CPU漏洞特殊性，包括Linux，Windows，OSX等的操作系统平台参与了修复。</p><p>Firefox，Chrome，Edge等浏览器也发布了相关的安全公告和缓解方案。</p><h2 id="选择微处理器">选择微处理器</h2><h3 id="准则">准则</h3><ul><li>高效、经济<ul><li>速度、尺寸、功耗、易于升级、单位成本</li></ul></li><li>软件开发工具可用性<ul><li>汇编器、C编译器、仿真器</li></ul></li><li>广泛的可用性和可靠的微控制器来源</li></ul><h3 id="步骤">步骤</h3><ol type="1"><li>列出所需的硬件接口</li><li>检查软件架构</li><li>选择体系结构</li><li>确定内存要求</li><li>搜索微控制器</li><li>检查零件可用性</li><li>选择开发工具包</li><li>研究编译器和工具</li><li>开始尝试</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;眼花耳热后，意气素霓生。&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式系统概论" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌入式_2_设计方法</title>
    <link href="http://example.com/2023/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/2_%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2023/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/2_%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</id>
    <published>2023-09-02T04:00:00.000Z</published>
    <updated>2023-11-09T12:32:03.085Z</updated>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第二章-嵌入式系统设计方法">第二章 嵌入式系统设计方法</h1><h2 id="嵌入式系统设计面临的挑战">1. 嵌入式系统设计面临的挑战</h2><ul><li>硬件需求</li><li>多项功能在时间上的协调一致性、时限要求</li><li>系统功耗</li><li>系统可升级性</li><li>系统可靠性</li></ul><h3 id="设计者要求">设计者要求</h3><ul><li>懂得系统架构</li><li>了解硬件细节</li><li>软件设计满足<ul><li>实时要求</li><li>低功耗</li><li>代码量小</li></ul></li><li>了解领域知识</li></ul><h3 id="设计目标">设计目标</h3><ul><li>成本</li><li>性能</li><li>功耗</li><li>尺寸</li><li>可伸缩性和可重用性</li><li>容错</li><li>……</li></ul><h2 id="嵌入式系统的设计过程">2. 嵌入式系统的设计过程</h2><ul><li><p>问题：功能、性能要求、价格、开发周期等约束</p></li><li><p>设计：选择、折衷、分析比较、计算、评价</p></li></ul><h3 id="简化的设计流">简化的设计流</h3><figure><img src="/image/嵌入式系统概论/简化的设计流.png" alt="简化的设计流" /><figcaption aria-hidden="true">简化的设计流</figcaption></figure><h3id="嵌入式系统的设计过程的基本流程">嵌入式系统的设计过程的基本流程</h3><figure><img src="/image/嵌入式系统概论/基本流程.png" alt="基本流程" /><figcaption aria-hidden="true">基本流程</figcaption></figure><h3 id="v模型的设计流">V模型的设计流</h3><figure><img src="/image/嵌入式系统概论/V模型.png" alt="V模型" /><figcaption aria-hidden="true">V模型</figcaption></figure><h2 id="嵌入式系统设计方法学">3. 嵌入式系统设计方法学</h2><h3 id="体系结构设计">体系结构设计</h3><ul><li>满足规格说明的主要组件<ul><li>硬件：中央处理器、外围设备等</li><li>软件：必要的程序及其运行</li></ul></li><li>功能性和非功能性需求</li></ul><h4 id="硬件和软件组件设计">硬件和软件组件设计</h4><ul><li>开始编码前，必须花时间构建系统</li><li>有些组件是现成的，可以根据现有设计进行修改，还有一些必须从头开始设计</li></ul><h4 id="软硬件的划分">软硬件的划分</h4><p>嵌入式系统的设计涉及硬件与软件部件，设计中必须决定什么功能由硬件实现，什么功能由软件实现。</p><ul><li>硬件和软件具有双重性，这是划分决策的前提</li><li>软硬件变动对系统决策有影响</li><li>划分选择需考虑多种因素</li></ul><h5 id="通常由软件实现的部分">通常由软件实现的部分</h5><ul><li>操作系统功能<ul><li>任务调度</li><li>资源管理</li><li>设备驱动</li></ul></li><li>协议栈<ul><li>TCP/IP</li></ul></li><li>应用软件框架</li><li>除了基本系统、物理接口、基本逻辑电路，许多由硬件实现的功能都可以由软件实现</li></ul><h5 id="双重性部分">双重性部分</h5><ul><li>算法<ul><li>加密/解密</li><li>编码/解码</li><li>压缩/解压</li><li>等等</li></ul></li><li>数学运算<ul><li>浮点运算、FFT、等等</li></ul></li></ul><h4 id="软硬件技术对系统结构影响">软硬件技术对系统结构影响</h4><ul><li>硬软件设计的趋势——融合、渗透<ul><li>硬件设计的软件化：VHDL、Verilog、HANDEL-C</li><li>软件实现的硬件化：各种算法的ASIC</li></ul></li><li>对系统设计的影响——协同设计<ul><li>增加灵活性</li><li>增加了风险</li></ul></li></ul><h3 id="嵌入式系统设计方法的演变">嵌入式系统设计方法的演变</h3><ol type="1"><li>以PCB、CAD和在线仿真器为主要工具</li><li>EDA和EOS为开发平台</li><li>以IP内核库为设计基础，用软硬件协同设计技术的系统级设计方法</li></ol><h4 id="传统嵌入式系统设计过程">传统嵌入式系统设计过程</h4><ul><li>系统在一开始就被划分为软件和硬件两大部分</li><li>软件和硬件独立进行开发设计</li><li>硬件优先</li></ul><p>问题：</p><ul><li>软硬件间交互受很大限制<ul><li>凭经验划分软硬件</li><li>软硬件之间的相互性能影响很难评估</li></ul></li><li>系统集成相对滞后，NRE较大</li></ul><p>导致：</p><ul><li>设计质量差</li><li>设计修改难</li><li>研制周期不能有效保障</li></ul><h4 id="软硬件协同设计hwsw-co-design">软硬件协同设计HW/SW Co-design</h4><p>协同设计是指通过并行设计利用硬件和软件的协同作用来实现系统级目标。</p><p>协同设计试图通过提供分析方法来增加嵌入式系统设计的可预测性，这些分析方法告诉设计师一个系统是否满足其性能、功率和尺寸目标，并提供综合方法让设计师快速评估许多潜在的设计方法。</p><ul><li>它从90年代早期的一个新兴的学科变成了如今的主流技术。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;眼花耳热后，意气素霓生。&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式系统概论" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌入式_1_引言</title>
    <link href="http://example.com/2023/09/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/1_%E5%BC%95%E8%A8%80/"/>
    <id>http://example.com/2023/09/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/1_%E5%BC%95%E8%A8%80/</id>
    <published>2023-09-01T04:00:00.000Z</published>
    <updated>2023-11-09T12:27:15.525Z</updated>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第一章-引言">第一章 引言</h1><h3 id="几个术语">几个术语</h3><ul><li><p>泛在计算：任何时间、任何地点的计算</p></li><li><p>不可见计算机：计算机被集成到物件中</p></li><li><p>普适计算：计算设备对日常生活的渗透</p></li><li><p>环境智能：生活环境中的计算机技术</p></li></ul><h2 id="嵌入式系统的定义">1. 嵌入式系统的定义</h2><h3 id="嵌入式系统">嵌入式系统</h3><p>以应用为中心，以计算机技术为基础，软硬件可裁减，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统。</p><ul><li><p>嵌入式系统（Emedded System）实际上是嵌入式计算机系统。</p></li><li><p>嵌入式系统就是一个具有特定功能或用途的隐藏在设备中的计算机软硬件集合体。</p></li><li><p>嵌入式系统三要素</p><ul><li>嵌入性：嵌入到对象体系中，有对象环境要求</li><li>专用性：软硬件按对象要求设计、裁减</li><li>计算机：实现对象的智能化功能</li></ul></li></ul><h3 id="信息物理系统">信息物理系统</h3><p>Cyber-Physical System（CPS），是计算进程和物理进程的集成。</p><ul><li><p>强调嵌入式系统和物理学的深度融合</p></li><li><p>深度融合了各类信息技术：传感器、嵌入式计算、云计算、网络通信</p><p>使各种信息化能力高度协同和自治</p></li><li><p>信息化能力：</p><p>3C：计算-Computer、通信-Communication、控制-Control</p></li></ul><h3 id="无线感知网络">无线感知网络</h3><p>Wireless sensornetwork/WSN，是由许多在空间中分布的自动装置组成的一种无线通信计算机网络，这些装置使用传感器协作地监控不同位置的物理或环境状况。</p><h3 id="物联网">物联网</h3><p>Internet ofThings（IoT），通过射频识别（RFID），红外感应器，全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物品与互联网相连接，进行信息交换和通信，以实现智能化识别、定位、跟踪、监控和管理的一种网络概念。</p><ul><li>面向生产的物联网技术开发被称为“工业4.0”。</li></ul><h3 id="发展历程">发展历程</h3><p>1960-1970：出现和兴起</p><p>1971-1989：走向繁荣，软硬件日益完善</p><p>1990-现在：走向纵深</p><h2 id="嵌入式系统的组成">2. 嵌入式系统的组成</h2><p>嵌入式系统一般由嵌入式硬件和软件组成：应用软件+中间件+运行内核+驱动+系统硬件</p><ul><li>硬件以微处理器为核心，集成存储器和系统专用的输入/输出设备</li><li>软件包括初始化代码及驱动、嵌入式操作系统和应用程序等</li></ul><h2 id="嵌入式系统的特点">3. 嵌入式系统的特点</h2><p>形式多样、面向特定应用</p><p>得到多种类型的处理器和处理器体系结构的支持</p><p>通常及其关注成本</p><p>实时性、可靠性</p><p>一般使用适应多种处理器、可剪裁、轻量型、实时可靠、可固化的嵌入式操作系统</p><p>需要专门工具和特殊方法进行开发</p><h2 id="嵌入式系统的分类">4. 嵌入式系统的分类</h2><p>处理器位数：8位、16位、32位、64位</p><p>应用：移动互联网、工业控制、可穿戴设备等</p><p>速度：</p><ul><li>强实时系统：响应时间毫秒或微秒级</li><li>一般实时系统：几秒级</li><li>弱实时系统：数十秒或更长</li></ul><p>确定性：</p><ul><li>硬实时系统：对系统响应时间有严格要求</li><li>软实时系统：系统响应时间不满足，不会导致系统出现致命错误或崩溃</li></ul><p>软件复杂程度：循环轮询、有限状态机、前后台、单/多处理器多任务系统</p><h2 id="嵌入式系统的发展趋势">5. 嵌入式系统的发展趋势</h2><p>嵌入式人工智能</p><p>嵌入式安全性</p><p>高计算需求和复杂性</p><p>软硬件协同设计</p><p>更高集成度</p><p>云计算</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;眼花耳热后，意气素霓生。&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式系统概论" scheme="http://example.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>数理逻辑_0_集合基础</title>
    <link href="http://example.com/2023/08/01/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/0_%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/08/01/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/0_%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/</id>
    <published>2023-08-01T04:00:00.000Z</published>
    <updated>2023-11-13T08:12:09.991Z</updated>
    
    <content type="html"><![CDATA[<p>飞流直下三千尺，疑是银河落九天。</p><span id="more"></span><h1 id="第零章-集合基础">第零章 集合基础</h1><h2 id="集合论符号">集合论符号</h2><ul><li>“$$”用于表示一个证明的结束。</li><li>“如果···那么···”，即“蕴含”，缩写为“<spanclass="math inline">\(···\Longrightarrow···\)</span>”；“逆蕴含”则为"<spanclass="math inline">\(···\Longleftarrow···\)</span>"。</li><li>“当且仅当”缩写为“<spanclass="math inline">\(iff\)</span>”或符号“<spanclass="math inline">\(\Longleftrightarrow\)</span>”</li><li>“因为”缩写为“<spanclass="math inline">\(\because\)</span>”，因此缩写为“<spanclass="math inline">\(\therefore\)</span>”</li><li>“<span class="math inline">\(x\neq y\)</span>”是“<spanclass="math inline">\(x=y\)</span>”的否定，“<spanclass="math inline">\(x\notin y\)</span>”是“<spanclass="math inline">\(x\in y\)</span>”的否定，类似符号可推广</li></ul><p>集合是指一些对象的全体，这些对象称为集合的元素或成员。</p><ul><li><p><span class="math inline">\(t\in A\)</span>表示t是A的元素，<spanclass="math inline">\(x=y\)</span>表示x和y是同一个元素</p></li><li><p>如果A和B是两个集合，且对于任意元素t都有</p><p><span class="math inline">\(t\in A\quad iff\quad t\in B\)</span></p><p>那么<span class="math inline">\(A=B\)</span>。</p></li></ul><p>集合论的基本思想：集合是由其元素所确定的。</p><p>对于集合A，<spanclass="math inline">\(A;t\)</span>表示一个新的集合，其元素包括A的元素和元素t（可能是新的），即：</p><p><span class="math inline">\(A;t=A\cup \{t\}\)</span></p><p>集合的表示方法：</p><ul><li>列举法，也称为外延表示方法。</li><li>内涵表示方法，即这个集合由具有某些性质P的对象构成</li></ul><p>如果集合A的所有元素都是集合B的元素，我们称A是B的子集，记作<spanclass="math inline">\(A\subseteq B\)</span>。</p><ul><li>任何集合都是其自身的子集，空集是每个集合的子集</li></ul><h2 id="集合">集合</h2><p>对象是人们感觉和思维中确定的某些事物。我们总是使用对象的名来谈论它。</p><ul><li>对象的名称也可以作为对象，这时候我们通常加引号用以区别</li></ul><h3 id="集合的定义">集合的定义</h3><p>康托尔的集合定义：具有某种性质的、确定的、互异的对象所组成的整体。</p><ul><li>确定性：对于任意集合A和任意元素a，a是否是A的元素是客观确定的</li><li>互异性：一个集合中任意两个对象是不相等的</li></ul><p>罗素悖论集合论：不能用更简单的数学概念来给集合下一个确定的定义</p><ul><li>集合的概念是不能定义的</li><li>康托尔的集合定义只是对集合的一个描述</li></ul><p>罗素悖论：<span class="math inline">\(A=\{A:A\notinA\}\)</span>，可以推导出<span class="math inline">\(A\inA\)</span>当且仅当<span class="math inline">\(A\notin A\)</span>。</p><p>这说明弗雷格根据康托尔的表述引入的概括原则（对任意确定的性质P，所有基于性质P的对象组成的群体就是集合）是有问题的。</p><h3 id="公理化">公理化</h3><h4 id="外延公理-extensionality">外延公理 Extensionality</h4><p>如果X和Y有相同元素，则<spanclass="math inline">\(X=Y\)</span>。即</p><p><span class="math inline">\(A=B\quad iff\quad \forall x(x\in A\quadiff\quad x\in B)\)</span></p><h4 id="空集公理">空集公理</h4><p>存在一个集合，它不含任何元素，除此之外的其他集合都称为非空的。</p><p>空集是每个集合的子集。</p><h4 id="分离公理-separation">分离公理 Separation</h4><p>如果<spanclass="math inline">\(\varphi\)</span>是一性质，则对于任意集合A和参数p，存在一个集合<spanclass="math inline">\(B=\{u\in X:\varphi (u,p)\}\)</span>，它包含所有具有这个性质的A中的元素u。</p><ul><li>由外延公理，分离公理中的集合B是唯一确定的。</li></ul><p>Paring无序对公理：对任意a，b，存在一个集合<spanclass="math inline">\(\{a,b\}\)</span>，恰好含有元素a，b。</p><h2 id="关系">关系</h2><h3 id="幂集交集并集">幂集、交集、并集</h3><ul><li><p>集合A的幂集<span class="math inline">\(\RhoA\)</span>的元素是A的所有子集，即：</p><p><span class="math inline">\(\Rho A=\{x|x\subseteq A\}\)</span></p></li><li><p>集合A与B的并集<span class="math inline">\(A\cupB\)</span>是属于A或属于B的元素的集合</p></li><li><p>集合A与B的交集是所有A与B共有的元素的集合</p><ul><li>A与B不相交，当且仅当二者的交集为空集</li></ul></li></ul><p>对于非空集合A，其元素也是集合，有</p><ul><li><span class="math inline">\(\bigcupA=\{x|x属于A的某个元素\}\)</span></li><li><span class="math inline">\(\bigcapA=\{x|x属于A的每个元素\}\)</span></li></ul><h3 id="有序对">有序对</h3><h4 id="有序对的定义">有序对的定义</h4><p>元素x和y的有序对<spanclass="math inline">\(&lt;x,y&gt;\)</span>定义如下：</p><p><span class="math inline">\(&lt;x,y&gt;=&lt;u,v&gt;\quad iff\quadx=u且y=v\)</span></p><p>所有具有上述性质的定义都可以作为有序对的定义。</p><p>其中，一个标准的定义是<spanclass="math inline">\(&lt;x,y&gt;=\{\{x\},\{x,y\} \}\)</span></p><p>有序三元组可以定义为<spanclass="math inline">\(&lt;x,y,z&gt;=&lt;&lt;x,y&gt;,z&gt;\)</span></p><p>更一般地，对于<spanclass="math inline">\(n&gt;1\)</span>可以如下递归地定义n元组：</p><p><spanclass="math inline">\(&lt;x_1,x_2,...,x_{n+1}&gt;=&lt;&lt;x_1,x_2,...,x_n&gt;,x_{n+1}&gt;\)</span></p><p>为方便起见，对于<spanclass="math inline">\(n=1\)</span>，我们定义<spanclass="math inline">\(&lt;x&gt;=x\)</span>；这样上式对于<spanclass="math inline">\(n=1\)</span>也是成立的。</p><h4 id="有限序列">有限序列</h4><p>称S是A中元素的有限序列（有限串）当且仅当对某个正整数n，<spanclass="math inline">\(S=&lt;x_1,...,x_n&gt;\)</span>，其中每个<spanclass="math inline">\(x_i\in A\)</span>。</p><p>S的子段指一个有限序列<spanclass="math inline">\(&lt;x_k,x_{k+1},...,x_{m-1},x_m&gt;,1\leq k\leqm\leq n\)</span></p><ul><li>这个子段是初始段当且仅当<spanclass="math inline">\(k=1\)</span></li><li>这个子段是真子段当且仅当该子段与S不同</li></ul><p>如果<spanclass="math inline">\(&lt;x_1,...,x_n&gt;=&lt;y_1,...,y_n&gt;\)</span>，易证<spanclass="math inline">\(x_i=y_i,1\leq i\leq n\)</span></p><p>如果<spanclass="math inline">\(&lt;x_1,...,x_m&gt;=&lt;y_1,...y_n&gt;\)</span>，未必有<spanclass="math inline">\(m=n\)</span>，因为每个有序三元组也是一个有序对。</p><ul><li>只有当某个<span class="math inline">\(x_i\)</span>本身是<spanclass="math inline">\(y_i\)</span>的一个有限序列，或某个<spanclass="math inline">\(y_i\)</span>本身是<spanclass="math inline">\(x_i\)</span>的一个有限序列时，m和n才不相等。</li></ul><p>引理：如果<spanclass="math inline">\(&lt;x_1,...,x_m&gt;=&lt;y_1,...,y_m,...,y_{m+k}&gt;\)</span>，那么<spanclass="math inline">\(x_1=&lt;y_1,...,y_{k+1}&gt;\)</span></p><h4 id="笛卡尔积">笛卡尔积</h4><p>笛卡尔积<span class="math inline">\(A\times B\)</span>是所有序对<spanclass="math inline">\(&lt;x,y&gt;\)</span>的集合，其中<spanclass="math inline">\(x\in A,y\in B\)</span>，即<spanclass="math inline">\(A\times B=\{&lt;x,y&gt;|x\in A,y\in B\}\)</span></p><p><spanclass="math inline">\(A^n\)</span>表示A中元素构成的所有的n元组组成的集合，比如<spanclass="math inline">\(A^3=(A\times A)\times A\)</span></p><h3 id="关系-1">关系</h3><p>关系是有序对的集合。</p><ul><li>关系R的定义域记为dom R，是所有满足<spanclass="math inline">\(&lt;x,y&gt;\in R\)</span>的元素x的集合</li><li>关系R的值域记作ran R，是所有满足<spanclass="math inline">\(&lt;x,y&gt;\in R\)</span>的元素y的集合</li><li>dom R和ran R并称为R的域，记作fld R</li></ul><p>A上的n元关系是<span class="math inline">\(A_n\)</span>的子集，若<spanclass="math inline">\(n&gt;1\)</span>，它就是一个关系；<spanclass="math inline">\(n=1\)</span>，A上的一元关系只是A的一个子集。</p><ul><li><p>A上的一个特殊的二元关系是恒等关系<spanclass="math inline">\(\{&lt;x,x&gt;|x\in A \}\)</span></p></li><li><p>对于A上的二元关系R和A的一个子集B，R对B的限制指交集<spanclass="math inline">\(R\cap B^n\)</span></p></li></ul><p>对于关系R，定义：</p><ul><li><p>R在A上是自反的，当且仅当对A中每个x都有<spanclass="math inline">\(&lt;x,x&gt;\in R\)</span></p></li><li><p>R是对称的，当且仅当如果<span class="math inline">\(&lt;x,y&gt;\inR\)</span>，则<span class="math inline">\(&lt;y,x&gt;\inR\)</span></p></li><li><p>R是传递的，当且仅当如果<span class="math inline">\(&lt;x,y&gt;\inR,&lt;y,z&gt;\in R\)</span>，则<spanclass="math inline">\(&lt;x,z&gt;\in R\)</span></p></li></ul><p>R在A上满足三分律，当且仅当对A中任意的x和y，如下三种可能有且仅有一种成立：</p><ul><li><span class="math inline">\(&lt;x,y&gt;\in R\)</span></li><li><span class="math inline">\(x=y\)</span></li><li><span class="math inline">\(&lt;y,z&gt;\in R\)</span></li></ul><p>关系R是A上的一个等价关系当且仅当R是A上自反、对称和传递的一个二元关系；</p><p>关系R是A上的一个序关系当且仅当R是传递的且在A上满足三分律。</p><ul><li><p>对于A上的等价关系R盒<span class="math inline">\(x\inA\)</span>，定义x的等价类为<spanclass="math inline">\(\{y|&lt;x,y&gt;\in R\}\)</span></p><p>等价类划分了A，每个等价类都是A的子集，A的每个元素恰好只属于一个等价类。</p></li></ul><p>关系R的逆关系记为<spanclass="math inline">\(R^{-1}\)</span>，定义为<spanclass="math inline">\(R^{-1}=\{&lt;x,y&gt;|&lt;y,x&gt;\inR\}\)</span></p><h3 id="函数">函数</h3><p>一个具有单值性质的关系F，对于定义域domF中的每一个x，都有唯一的y满足<span class="math inline">\(&lt;x,y&gt;\inF\)</span>。通常，这个唯一的y称F在x上的值F(x)。</p><p>我们称F将定义域A映射到值域B，F是一个函数。</p><ul><li><p>F是一个一一映射当且仅当对于B中的每个y，存在唯一的x使得<spanclass="math inline">\(&lt;x,y&gt;\in F\)</span></p></li><li><p>如果<span class="math inline">\(&lt;x,y&gt;\)</span>在定义域domF中，则记<spanclass="math inline">\(F(x,y)=F(&lt;x,y&gt;)\)</span></p></li><li><p>这个记法可以推广到n元</p></li></ul><p>A上的n元运算是一个将<spanclass="math inline">\(A^n\)</span>映射到A中的函数。</p><h3 id="偏序关系">偏序关系</h3><p>序的一般理论：</p><p>设A为一个集合，R是A上的二元关系，称R为A上的偏序关系，如果满足如下条件：</p><ul><li><p>R具有自反性</p></li><li><p>R具有反对称性，且对任意<span class="math inline">\(x,y\inR\)</span>，如果<span class="math inline">\(xRy\)</span>且<spanclass="math inline">\(yRx\)</span>，则<spanclass="math inline">\(x=y\)</span></p></li><li><p>R具有传递性</p></li></ul><p>设A为一个集合，R是A上的二元关系，称R为A上的严格偏序关系，如果满足如下条件：</p><ul><li><p>R具有禁自反性，即任意x属于A都有非<spanclass="math inline">\(R(x,x)\)</span></p></li><li><p>R具有禁对称性，且对任意<span class="math inline">\(x,y\inA\)</span>，如果<span class="math inline">\(R(x,y)\)</span>，则非<spanclass="math inline">\(R(y,x)\)</span></p></li><li><p>R具有传递性</p></li></ul><p>自然数集N上面的小于关系就是严格的偏序关系。</p><p>极小元的定义：</p><p>如果<spanclass="math inline">\((A,\leq)\)</span>是偏序集，B包含于A，b属于B，称b为B的关于<spanclass="math inline">\(\leq\)</span>关系的极小元，如果不存在x属于B，使得<spanclass="math inline">\(x\neq b\)</span>且<spanclass="math inline">\(x\leq b\)</span>。</p><h3 id="良序关系">良序关系</h3><p>线序的定义：</p><p>如果<spanclass="math inline">\((A,\leq)\)</span>是偏序集，A中任意两个元素x，y都在偏序关系<spanclass="math inline">\(\leq\)</span>下可以比较，即要么<spanclass="math inline">\(x\leq y\)</span>，要么<spanclass="math inline">\(y\leq x\)</span>，则称<spanclass="math inline">\(\leq\)</span>关系是线序关系或全序关系。相应地称<spanclass="math inline">\((A,\leq)\)</span>为线序集或全序集。</p><p>如果<span class="math inline">\(\leq\)</span>为A上的线序，则称<spanclass="math inline">\(&lt;\)</span>为A上的严格线序。</p><p>良序的定义：</p><p>设<spanclass="math inline">\((A,\le)\)</span>是线序集，如果A的任意非空子集都有<spanclass="math inline">\(\le-\)</span>极小元，则称<spanclass="math inline">\((A,\le)\)</span>为良序集，且称<spanclass="math inline">\(\le\)</span>为A上的良序，或称A被<spanclass="math inline">\(\le\)</span>良序。</p><p>如果<spanclass="math inline">\(\le\)</span>是R上的良序，有时也称<spanclass="math inline">\(&lt;\)</span>是A上的良序。</p><ul><li>有穷的线序集都是良序集。</li><li>在定义中如果只要求偏序而不是线序，就称为良基偏序。</li></ul><h4 id="良序问题">良序问题</h4><p>是否对任意的集合A，都存在A上的良序关系？</p><p>良序原则：任意的集合都可以被良序</p><ul><li>良序原则和Zorn引理等价</li></ul><h3 id="乘积公理">乘积公理</h3><p>对任意集族<span class="math inline">\((X_i)_{i\inI}\)</span>，如果I为非空集合，且对任意<span class="math inline">\(i\inI\)</span>，集合<span class="math inline">\(X_i\)</span>非空，则<spanclass="math inline">\(\prod_{i\in I}X_i\)</span>非空。</p><h3 id="选择公理">选择公理</h3><p>对任意非空集合X，如果X中的元素均为非空集合，则存在映射f使得<spanclass="math inline">\(dom(f)=X\)</span>，且<spanclass="math inline">\(\forall x\in X\)</span>都有<spanclass="math inline">\(f(x)\in x\)</span>（称f为X上的选择函数）。</p><h3 id="可数">可数</h3><p>集合A是可数的，当且仅当存在某个函数将A一对一映射到自然数N中。</p><ul><li>设A是一个可数集，则所有由A的元素构成的有限序列的集合也可数</li></ul><h2 id="有穷与无穷集合">有穷与无穷集合</h2><h3 id="自然数的定义">自然数的定义</h3><p>集合的后继：</p><p>设A为任意的集合，我们称集合<span class="math inline">\(A\cup\{A\}\)</span>为A的后继集合，简称A的后继，记作<spanclass="math inline">\(A^+\)</span>，而A为<spanclass="math inline">\(A^+\)</span>的前趋。</p><p>自然数的定义：</p><ol type="1"><li><span class="math inline">\(0=\empty\)</span></li><li><span class="math inline">\(1=0^+=\{0\}\)</span></li><li><span class="math inline">\(2=1^+=\{0,1\}\)</span></li><li>假设我们已经定义了<spanclass="math inline">\(n=\{0,1,...,n-1\}\)</span>，则定义<spanclass="math inline">\(n+1=n^+=n\cup\{n\}=\{0,1,...,n-1,n\}\)</span></li><li>每个自然数都是从0开始经过有穷步后继运算的结果</li></ol><h3 id="无穷公理">无穷公理</h3><p>所有自然数组成的集合的整体是集合，记为<spanclass="math inline">\(\omega\)</span>。</p><h3 id="佐恩引理或极大原则">佐恩引理或极大原则</h3><p>设A是一个集合，且满足对于任意的链<spanclass="math inline">\(C\subseteq A\)</span>，有集合<spanclass="math inline">\(\bigcupC\)</span>在A中，那么A中存在极大元m，即m不是A中其他任意元素的子集。</p><ul><li>我们说一组集合C是一个链，当且仅当对于C中任意元素x和y，要么<spanclass="math inline">\(x\subseteq y\)</span>要么<spanclass="math inline">\(y\subseteq x\)</span></li></ul><h3 id="数学归纳法">数学归纳法</h3><p>集合形式的数学归纳法：</p><p>设S为一个集合，如果S满足如下两个条件：</p><ul><li><span class="math inline">\(0\in S\)</span></li><li>对任何自然数n，如果<span class="math inline">\(n\inS\)</span>，则<span class="math inline">\(n+1\in S\)</span></li></ul><p>则<span class="math inline">\(\omega \subseteqS\)</span>，即每个自然数对属于S。</p><h4 id="正则公理">正则公理</h4><p>每个非空集合A中总存在元素x使得<span class="math inline">\(x\capA=\empty\)</span>（此时称x为A的<span class="math inline">\(\in-\)</span>极小元）。</p><p>正则公理的蕴含：</p><ul><li><p>不存在集合<span class="math inline">\(x\in x\)</span></p></li><li><p>不存在集合x,y使得<span class="math inline">\(x\iny\)</span>且<span class="math inline">\(y\inx\)</span>。一般地，不存在集合<spanclass="math inline">\(x_1,...,x_n\)</span>使得<spanclass="math inline">\(x_1\in x_2,...,x_{n-1}\in x_n,x_n\inx_1\)</span>。</p><p>不存在集合<span class="math inline">\(\{x_n|n\in \omega使得每个n\in\omega 都有x_{n+1}\in x_n\}\)</span></p></li></ul><p>集合形式的数学归纳法证明：暂略，20230912，P30</p><p>性质形式的数学归纳原理：</p><p>设R是性质，如果有</p><ol type="1"><li>R(0)成立，且</li><li>对任意自然数n，若R(n)成立，R(n+1)也成立</li></ol><p>则对任意自然数n都有R(n)成立。</p><h4 id="传递集合">传递集合</h4><p>设A是一个集合，如果A的任意元素都是A的子集，则称A是传递集合。</p><ul><li><p>A为传递集合，则<span class="math inline">\(\forall x\in A,y\inx,y\in A\)</span>。</p></li><li><p>每个自然数都是传递集合</p></li><li><p><spanclass="math inline">\(\omega\)</span>是传递集合，即对任意自然数n都有n是<spanclass="math inline">\(\omega\)</span>的传递集合</p></li><li><p>引理：<span class="math inline">\(\forall n,m\in N,如果n\subseteqm,有n=m或者n\in m\)</span></p></li></ul><p>$<span class="math inline">\(-三歧性：\)</span>x,yA有xy或x=y或yx$</p><ul><li><span class="math inline">\(\omega\)</span>具有三歧性</li></ul><p>任意自然数n、m，定义</p><ul><li><span class="math inline">\(m&lt;n当且仅当m\in n\)</span></li><li><span class="math inline">\(m\le n当且仅当m&lt;n或m=n\)</span></li></ul><h3 id="有穷集合和无穷集合">有穷集合和无穷集合</h3><h4 id="等势集合">等势集合</h4><p>设A、B为两个集合，如果存在A到B上的双射，则称A与B等势，或称A与B对等，记为<spanclass="math inline">\(A～B\)</span></p><ul><li>直观上，A与B等势，则A和B有同样多的元素。</li></ul><p>等势关系是等价关系，即</p><ul><li><span class="math inline">\(\forall A,A～A\)</span></li><li><span class="math inline">\(\forallA,B,如果A～B,则B～A\)</span></li><li><span class="math inline">\(\forallA,B,C,如果A～B,B～C,则A～C\)</span></li></ul><h4 id="康托尔伯恩斯坦定理">康托尔伯恩斯坦定理</h4><p>设A、B为两个集合，假设<span class="math inline">\(A\preceq B,B\preceqA\)</span>，则<span class="math inline">\(A～B\)</span></p><h4 id="有穷集合">有穷集合</h4><p>和某个自然数等势的集合为有穷集合，否则为无穷集合。</p><ul><li><p>每个自然数都是有穷集合</p></li><li><p>引理：假设A是有穷集合，x不属于A，则<spanclass="math inline">\(A\cup \{x\}\)</span>是有穷集合</p></li><li><p>引理：集合A是有穷集合，当且仅当存在自然数n，使得<spanclass="math inline">\(A\preceq n\)</span></p></li><li><p>对任意的自然数n，n的每个真子集都不与n等势</p><ul><li>抽屉原理：集合A为有穷集合，当且仅当它不与它的任何真子集等势</li></ul></li></ul><h4 id="可数集合">可数集合</h4><p>若集合<span class="math inline">\(A\preceq\omega\)</span>，即存在A到<spanclass="math inline">\(\omega\)</span>的单射，则称A可数</p><ul><li>若<spanclass="math inline">\(A～\omega\)</span>，则称A为可数的无穷集合</li><li>定理：可数多个可数集合的并集可数</li></ul><h4 id="无穷集合">无穷集合</h4><p>每一个无穷集合都有无数无穷子集。</p><ul><li>如果A是无穷集合，则<span class="math inline">\(\omega\preceqA\)</span></li><li>A是无穷集合当且仅当它与自身的一个真子集等势</li><li>引理：假设A是非空集合且<span class="math inline">\(\bigcupA=A\)</span>，则A是无穷集合</li></ul><h4 id="不可数集合">不可数集合</h4><p>不是可数集合的无穷集合为不可数元集合。</p><ul><li><p>康托尔定理：<span class="math inline">\(\forall A,A\prec\Rho(A)\)</span></p></li><li><p>区间(0,1)不可数</p></li><li><p>连通性假设：<span class="math inline">\(\forall A,\omega\preceqA且A\preceq R，则要么A～\omega，要么A～R。\)</span></p><p><span class="math inline">\(换言之，不存在集合A使得\omega\preceqA且A\preceq R。\)</span></p></li></ul><h4 id="序数">序数</h4><p>每一个良序集合都与一个自然数序同构。</p><ul><li>设<spanclass="math inline">\((A,\le_A)\)</span>为一个良序集，A有穷，则存在一个自然数n，使得<spanclass="math inline">\((A,\le_A)\)</span>与<spanclass="math inline">\((n,\le)\)</span>序同构</li></ul><p>具有三歧性的传递集合叫做序数</p><ul><li>0是序数</li><li>每个自然数都是序数</li><li><span class="math inline">\(\omega\)</span>是序数</li></ul><p>引理：如果<span class="math inline">\(\alpha\)</span>是序数，<spanclass="math inline">\(\alpha^+\)</span>也是序数；序数的每个元素也是序数。</p><p>对于自然数n，归纳定义<spanclass="math inline">\(\omega+n\)</span>：</p><ol type="1"><li><span class="math inline">\(\omega+0=\omega\)</span></li><li><span class="math inline">\(\omega+(n+1)=(\omega+n)^+\)</span></li></ol><p>对任意自然数有<spanclass="math inline">\(\omega+n\)</span>为序数。</p><p>定理：对任意两个序数<spanclass="math inline">\(\alpha、\beta\)</span>都有<spanclass="math inline">\(\alpha\in\beta\)</span>，或者<spanclass="math inline">\(\alpha=\beta\)</span>，或者<spanclass="math inline">\(\beta\in\alpha\)</span>。</p><ul><li>证明：0912 P42</li></ul><p>用<span class="math inline">\(O_n\)</span>表示所有序数的类。</p><ul><li><p><span class="math inline">\(O_n\)</span>不是集合，否则<spanclass="math inline">\(O_n是序数，O_N\subseteqO_n\)</span>，与正则公理矛盾。</p></li><li><p>任何序数在属于关系上是良序集，我们用&lt;表示序数的属于关系</p></li></ul><p>定理：假设S中每个元素都是序数，那么<spanclass="math inline">\(\bigcup S\)</span>也是序数。</p><ul><li><span class="math inline">\(\omega\)</span>是序数</li><li>设<spanclass="math inline">\(S_0=\{\omega,\omega+1,...,\omega+n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega+\omega\)</span>或<spanclass="math inline">\(\omega·2\)</span><ul><li>类似地，可以定义<spanclass="math inline">\(\omega·3,...,\omega·n,...\)</span></li></ul></li><li>设<spanclass="math inline">\(S_1=\{\omega,\omega·2,...,\omega·n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega·\omega\)</span>或<spanclass="math inline">\(\omega^2\)</span><ul><li>类似地，可以定义<spanclass="math inline">\(\omega^3,...,\omega^n,...\)</span></li></ul></li><li>设<spanclass="math inline">\(S_2=\{\omega,\omega^2,...,\omega^n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega^\omega\)</span></li></ul><p>上述<span class="math inline">\(\omega^n\)</span>和<spanclass="math inline">\(\omega^\omega\)</span>为序数算数，不是笛卡尔积。</p><p>替换公理：设<spanclass="math inline">\(P(x,y)\)</span>为类关系，A是一个集合，如果<spanclass="math inline">\(\forall x\in A\)</span>，有唯一<spanclass="math inline">\(y_x\)</span>，使得<spanclass="math inline">\(P(x,y_x)\)</span>成立，则<spanclass="math inline">\(\{y_x|x\in A\}\)</span>是集合。</p><h4 id="超穷归纳法">超穷归纳法</h4><p>设<span class="math inline">\(\alpha\)</span>为序数</p><ul><li>如果存在序数<span class="math inline">\(\beta\)</span>使得<spanclass="math inline">\(\alpha=\beta^+\)</span>，则称<spanclass="math inline">\(\alpha\)</span>为后继序数</li><li>不是后继序数的非零序数称为极限序数</li></ul><p>设<span class="math inline">\(\alpha\neq 0\)</span>为序数，则</p><ul><li><spanclass="math inline">\(\alpha\)</span>为极限序数当且仅当对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都有<spanclass="math inline">\(\beta^+\lt\alpha\)</span></li><li><span class="math inline">\(\alpha\)</span>是极限序数当且仅当<spanclass="math inline">\(\alpha\)</span>中无最大元，即对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都存在<spanclass="math inline">\(\gamma\lt\alpha\)</span>，使得<spanclass="math inline">\(\beta\lt\gamma\)</span></li></ul><p>超穷归纳法原理：</p><p>设<span class="math inline">\(R(x)\)</span>为一个性质</p><ol type="1"><li><p>假设<span class="math inline">\(R(0)\)</span>成立</p></li><li><p>对任意的序数<spanclass="math inline">\(\alpha\)</span>，如果<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\alpha+1)\)</span>也成立</p></li><li><p>对于任意的极限序数<spanclass="math inline">\(\lambda\)</span>，如果对每一<spanclass="math inline">\(\alpha\lt\lambda\)</span>都有<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\lambda)\)</span>成立</p><p>那么对于任意的序数<spanclass="math inline">\(\alpha\)</span>都有<spanclass="math inline">\(R(\alpha)\)</span>成立</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞流直下三千尺，疑是银河落九天。&lt;/p&gt;</summary>
    
    
    
    <category term="数理逻辑" scheme="http://example.com/categories/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/"/>
    
    
  </entry>
  
  <entry>
    <title>毛概-期末复习</title>
    <link href="http://example.com/2023/06/15/%E6%AF%9B%E6%A6%82%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2023/06/15/%E6%AF%9B%E6%A6%82%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</id>
    <published>2023-06-15T04:00:00.000Z</published>
    <updated>2024-06-21T07:25:11.308Z</updated>
    
    <content type="html"><![CDATA[<h1id="毛泽东思想和中国特色社会主义理论体系概论-期末复习">毛泽东思想和中国特色社会主义理论体系概论期末复习</h1><span id="more"></span><p>任课教师：武海宝</p><h3 id="科学社会主义">科学社会主义</h3><ul><li>科学社会主义确认金融资本是现代社会各种病症的根源。</li><li>共产主义不是对财产的否定，而是对社会财产的私人垄断的否定。</li></ul><p>伦理社会主义：</p><p>伦理社会主义是在自然经济时代发展起来的，它强调人与人之间的和谐，与宗教、大同理想、家族文化等各种形态相结合，以一种改良的身份去批评资本主义，但它无法改变资本主义的基本逻辑</p><h2 id="新民主主义革命">新民主主义革命</h2><h3 id="中国社会主义革命道路探索">中国社会主义革命道路探索</h3><h4 id="中国的两步走">中国的两步走</h4><p>中国革命必须分为两个步骤。第一步，改变这个殖民地、半殖民地、半封建的社会形态，使之变成一个独立的民主主义的社会，第二部，使这个革命向前发展，建立一个社会主义的社会。——毛泽东《新民主主义论》</p><h4 id="三湾改编">三湾改编</h4><p>1927年9月至10月，毛泽东在江西省永新县三湾村领导了三湾改编。</p><p>毛泽东创造性地确立了支部建在连上、官兵平等等一系列治军方略。三湾改编是中国共产党建设新型人民军队最早的一次成功探索和实践。</p><p>意义：</p><ul><li>从政治上和组织上保证了党对军队的绝对领导，是我党建设新型人民军队最早的一次成功探索和实践，标志着毛泽东建设人民军队思想的开始形成</li><li>初步解决了如何把以农民和旧军人为主要成分的革命军队建设成为一支无产阶级新型人民军队的问题，奠定了政治强军的基础</li><li>实现民主主义，对团结广大士兵群众、瓦解敌军起到巨大作用</li></ul><h4 id="新民主主义革命的基本纲领">新民主主义革命的基本纲领</h4><ul><li>没收封建地主阶级的土地归农民所有；没收官僚资本主义的垄断资本归国家所有；保护民族工商业</li><li>建立无产阶级领导下的一切反帝反封建的人民联合专政的民主共和国，这就是新民主主义的共和国</li><li>实行人民大众的反帝反封建的文化，即民族的、科学的、大众的文化</li></ul><h4 id="新旧民主主义革命的异同">新旧民主主义革命的异同</h4><ul><li>相同点：<ul><li>社会性质：都发生在半殖民地半封建社会</li><li>革命任务：都是反对外国资本主义侵略和本国封建统治</li><li>革命性质：都属于资产阶级民主革命的范畴</li></ul></li><li>不同点：<ul><li>领导力量：旧民主主义革命的领导是资产阶级，新民主主义革命的领导是无产阶级</li><li>指导思想：旧民主主义革命是资产阶级的平等、自由思想和民族观念，新民主主义革命是马克思主义</li><li>革命前途：旧民主主义革命是建立资产阶级民主共和国，新民主主义革命在完成民主革命任务后，还要进入社会主义社会</li><li>革命发展和群众发动的深度、广度：旧民主主义革命的纲领不彻底，群众发动不充分，土地问题不能彻底解决；新民主主义革命提出了彻底的革命纲领，广泛发动群众，解决了民主革命的中心问题，即土地问题</li><li>结果不同：旧民主主义革命有胜利的一面，但最终果实被窃取，革命任务没有完成，社会性质没有改变，在这一意义讲是最终遭到了失败；新民主主义革命的胜利成为了社会主义的必要准备，社会主义是新民主主义革命的必然结果</li><li>旧民主主义革命属于世界资产阶级革命的一部分，新民主主义革命属于无产阶级世界革命的一部分</li></ul></li></ul><h3 id="新民主主义社会">新民主主义社会</h3><ul><li>政治上，新民主主义的国家实行工人阶级领导的、工农联盟为基础的、团结各民主阶级和国内各民族的人民民主专政。</li><li>经济上：</li></ul><table><thead><tr class="header"><th>成分</th><th>来源</th><th>性质</th><th>地位</th></tr></thead><tbody><tr class="odd"><td>国营经济</td><td>没收官僚资本</td><td>社会主义</td><td>领导地位</td></tr><tr class="even"><td>合作社经济</td><td>个体向社会主义集体经济过渡</td><td>半社会主义</td><td></td></tr><tr class="odd"><td>个体经济</td><td>个体农业、手工业</td><td>个体经济</td><td>绝对优势</td></tr><tr class="even"><td>私人资本主义经济</td><td>民族资本主义</td><td>资本主义</td><td></td></tr><tr class="odd"><td>国家资本主义经济</td><td>私人资本主义经济向社会主义国营经济过渡</td><td>半社会主义</td><td></td></tr></tbody></table><p>新民主主义社会，是指在新民主主义革命胜利的基础上，建立起来的既不是资产阶级共和国也不是无产阶级共和国的的各个革命阶级联合专政的共和国，是落后国家进行革命的特有社会形态。</p><ul><li>性质：过渡性社会形态，隶属于社会主义体系</li><li>特点：既有社会主义因素，也有资本主义因素</li><li>从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期</li><li>过渡时期的时间，中央领导估计大约需要10年、15年或者更久</li></ul><h4 id="过渡时期总路线">过渡时期总路线</h4><p>从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造。</p><h4id="中国社会主义改造道路三大改造">中国社会主义改造道路：三大改造</h4><ul><li>农业合作化，将小农经济改造为农业集体主义经济</li><li>手工业社会主义改造，通过合作化道路，把个体手工业转变为社会主义劳动群众集体所有制经济</li><li>资本主义工商业社会主义改造，通过国家资本主义的形式，采取和平赎买的政策，将民族资本主义经济改造成社会主义公有制企业，而且将所有制改造与人的改造相结合，努力使剥削者成为自食其力的劳动者</li></ul><p>社会主义改造时期，把实现国家的工业化作为党在过渡时期总路线的主体，受苏联的影响，一度过多强调重工业和基础设施的发展，促使党思考如何走中国工业化道路的问题。</p><h4 id="中国工业化道路的目标和方针">中国工业化道路的目标和方针</h4><ul><li>总方针：以农业为基础，以工业为主导，以农、轻、重为序发展国民经济</li><li>农业为重工业提供积累资金和原料，同时提供市场</li><li>目标：逐步建立独立的比较完整的基础工业体系和国防工业体系</li></ul><h3 id="中国无产阶级的主要优点">中国无产阶级的主要优点</h3><ol type="1"><li>革命性强。深受帝国主义、封建主义、资本主义的三重压迫，具有强烈的反抗意识</li><li>和广大农民有着天然联系，容易和农民结成亲密的联盟</li><li>集中在沿海、沿江大中城市，便于组织</li></ol><p>新民主主义革命的动力：农民</p><h2 id="改革开放">改革开放</h2><h3 id="家庭联产承包责任制和土地流转">家庭联产承包责任制和土地流转</h3><p>家庭联产承包责任制和统分结合的双层经营体制：</p><p>所有权、承包权和经营权三权分置，经营权流转的格局。农业用地在土地承包期限内，可以通过转包、转让、入股、合作、租赁、互换等方式出让经营权。</p><h3id="中国社会主义农业改革和发展的两个飞跃">中国社会主义农业改革和发展的两个飞跃</h3><p>两个飞跃是邓小平晚年关于我国农业改革和发展的重要思考</p><ol type="1"><li>废除人民公社，实行家庭联产承保责任制</li><li>适应科学生产、生产社会化的需要，再度发展集体经济</li></ol><h3id="中国特色社会主义市场经济制度的体制优势">中国特色社会主义市场经济制度的体制优势</h3><ul><li>从落后国家率先取得胜利的社会主义，还不能一下子排除掉资本。中国从新民主主义社会到改革开放，基本探索出一个相对稳定的制度形式，也就是公有制主导下的市场经济</li><li>以公有制为主体的社会主义市场经济制度既能充分利用市场、充分利用一般职能资本的积极作用来推动社会发展，又能避免金融资本的剥削性、寄生性、投机性积累及其所导致的一系列问题，创造了一条不同于西方的现代化道路</li></ul><h2 id="社会主义">社会主义</h2><h3 id="社会主义的本质">社会主义的本质</h3><ul><li>解放和发展生产力——基本经济制度的内在属性</li><li>消灭剥削，消除两极分化——基本经济制度的内在张力</li><li>最终达到共同富裕</li></ul><h3 id="三个代表">三个代表</h3><p>三个代表是建党理论。</p><p>中国共产党始终代表</p><ul><li>中国先进生产力的发展要求</li><li>中国先进文化的前进方向</li><li>中国最广大人民的根本利益</li></ul><h3 id="科学发展观">科学发展观</h3><ul><li>第一要义是发展</li><li>核心是以人为本</li><li>基本要求是全面协调可持续发展</li><li>根本方法是统筹兼顾</li></ul><h3 id="十个坚持">十个坚持</h3><ul><li>坚持党的领导</li><li>坚持人民至上</li><li>坚持理论创新</li><li>坚持独立自主</li><li>坚持中国道路</li><li>坚持胸怀天下</li><li>坚持开拓创新</li><li>坚持敢于斗争</li><li>坚持统一战线</li><li>坚持自我革命</li></ul><h2 id="使命型政党">使命型政党</h2><h3 id="理论渊源">理论渊源</h3><p>⻢克思：过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的，为绝大多数人谋利益的独立的运动。在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。</p><h3 id="人民利益的统一性完整性">人民利益的统一性、完整性</h3><ul><li>区别公意和众意：<ul><li>卢梭在《社会契约论》中说：“公意和众意之间经常有着很大的差别。公意总是着眼于公共利益，而众意则着眼于私利，它只是个体意志的总和。”</li></ul></li></ul><h3 id="中国共产党是使命型政党">中国共产党是使命型政党</h3><ul><li>把国家从金融资本、金融寡头的工具变成社会利益的集中代表，这是社会主义国家的国体概念。作为社会联合所有制的代理人来执行职能的国家，这是一种和新自由主义消极国家不一样的积极国家，这种积极国家又要依赖一个先锋队、依赖一个使命型政党。</li><li>这种政党不同于⻄方那样一种选举型政党。选举型政党容易分裂人⺠的意志，而人⺠意志的分裂有利于金融寡头对经济、政治的支配。</li><li>共产党作为先锋队的组织，作为人⺠意志的集中表现，作为一个没有自己特殊私利的政党，共产党的合法性依据先进的纲领、依据人⺠⺠主、依据自我革命。社会主义政权的一系列的组织形式不同于⻄方三权分立的政治制度。</li></ul><h4id="使命型政党和西方选举型政党的区别">使命型政党和西方选举型政党的区别</h4><ul><li>基于全心全意为人民服务的马克思主义政党；建立在人性恶和权力恶的双重不信任文化基础上的政党</li><li>作为整体的部分而服务于本体的政党；割裂于整体而利用本体牟利的政党</li></ul><h2 id="我国的政治制度">我国的政治制度</h2><h4 id="人民民主专政国体">人民民主专政——国体</h4><p>中国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家。</p><p>人民民主专政是中国的国家根本性质</p><p>只有人民民主专政才能终结国外列强操控的军阀割据。</p><p>军阀割据的社会根源：</p><ul><li>中国社会的半封建性，中国具有分散性的封建地主经济的必然产物</li><li>中国社会的半殖民性，帝国主义分而治之的侵略政策必然导致军阀割据</li></ul><h4 id="人民代表大会制度政体">人民代表大会制度——政体</h4><ul><li>人民通过人民代表大会有效行使国家权力</li><li>全国人民代表大会是最高国家权力机关，地方人民代表大会是地方国家权力机关</li><li>各级国家行政机关、监察机关、审判机关、检察机关都由人民代表大会产生，对人大负责，受人大监督。人民代表大会有立法权、监督权、决定权、任免权</li><li>人大代表来自人民，横向上，来自各地区、各民族、各方面、各阶层；纵向上，全国、省、市、县、乡五级都有人民代表大会，具有广泛代表性</li></ul><h4id="中国共产党领导的多党合作和政治协商制度">中国共产党领导的多党合作和政治协商制度</h4><p>中国共产党是执政党，八个民主党派是接受中国共产党领导、同中国共产党亲密合作的参政党。</p><ul><li>在中国，没有反对党，也没有在野党。中国既不是一党专政，也不是多党竞争、轮流执政，而是“共产党领导、多党派合作，共产党执政、多党派参政”。</li></ul><h4 id="民主实践选举民主">民主实践：选举民主</h4><ul><li><p>人⺠通过选举、投票行使权利，选出代表自己意愿的人来掌握并行使权力，是中国⺠主的一种主要形式，是人⺠实现当家作主的主要体现。</p></li><li><p>中国的选举是广泛的，有国家机构选举、村(居)委会选举、企事业单位职工代表大会选举等，涵盖了国家政治生活和社会生活的各个方面。</p></li><li><p>中国的选举是平等的，人⺠的选举权和被选举权得到充分保障，一人一票、票票等值</p></li><li><p>中国的选举是真实的，不受金钱操控，选⺠按照自己的意愿选出自己信任的人。</p></li><li><p>国家机构选举：从全国人大到乡级人大，五级人⺠代表大会代表均由⺠主选举产生，每届任期5年。选⺠直接选举产生县乡两级人大代表，县级以上人大代表由下一级人大选举产生。各级国家机关领导人员均由同级人大选举产生或者决定任命。</p></li><li><p>基层选举：村(居)⺠委员会选举和企事业单位职工代表大会选举。村(居)⺠依法定期选举产生村(居)⺠委员会成员。在企事业单位中，职工代表大会是职工当家作主、行使⺠主管理权力的机构。</p></li></ul><h4 id="民主实践协商民主">民主实践：协商民主</h4><ul><li><p>人⺠在通过选举、投票行使权利的同时，在重大决策前和决策过程中进行充分协商，尽可能就共同性问题取得一致意⻅。协商⺠主是中国⺠主独特的、独有的、独到的⺠主形式。</p></li><li><p>协商⺠主形式:提案、会议、座谈、论证、听证、评估、咨询、网络、⺠意调查等多种途径和方式，在决策之前和决策实施之中开展广泛协商。</p></li></ul><p>缺乏协商民主：英国脱欧</p><p>票决至上：一人一票是民主的一种形式，但绝非其唯一和全部</p><h4 id="政党和民主">政党和民主</h4><ul><li>中国共产党的领导，是中国发展全过程人⺠⺠主的根本保证。</li><li>把中国14亿多人⺠的意愿表达好、实现好，必须有坚强有力的统一领导。</li><li>中国共产党始终坚持以人⺠为中心、坚持人⺠主体地位，真正为人⺠执政、靠人⺠执政；充分发挥总揽全局、协调各方的领导核心作用。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1
id=&quot;毛泽东思想和中国特色社会主义理论体系概论-期末复习&quot;&gt;毛泽东思想和中国特色社会主义理论体系概论
期末复习&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>编译原理-目标代码生成</title>
    <link href="http://example.com/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
    <id>http://example.com/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</id>
    <published>2023-06-04T04:00:00.000Z</published>
    <updated>2023-06-24T05:24:36.365Z</updated>
    
    <content type="html"><![CDATA[<p>子不语</p><span id="more"></span><h1 id="目标代码生成">目标代码生成</h1><h2 id="risc-v">RISC-V</h2><h3 id="寄存器">寄存器</h3><ul><li><p>zero：存放常数0，不允许修改</p></li><li><p>ra：存放返回地址</p></li><li><p>t0~t6：保存临时变量</p></li><li><p>pc：保存下一条指令的地址</p></li></ul><h3 id="指令">指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">t0</span>, <span class="hljs-number">20</span><span class="hljs-comment"># li: load immediate</span><br>li <span class="hljs-built_in">t1</span>, <span class="hljs-number">22</span><br><span class="hljs-keyword">add </span><span class="hljs-built_in">t2</span>, <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">t1</span><br></code></pre></td></tr></table></figure><p>li指令是一条伪指令，最终会翻译为addi t0, zero, 20的形式</p><ul><li>负数则为addi t0, zero, -20</li><li>没有subi指令</li></ul><h3 id="系统调用">系统调用</h3><ol type="1"><li>把服务号写入a7寄存器</li><li>把参数写入a0、a1、a2、a3、fa0、...</li><li><code>ecall</code></li><li>从结果寄存器中获得返回值</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">1</span><span class="hljs-comment"># service 1 is print integer</span><br><span class="hljs-keyword">add </span><span class="hljs-built_in">a0</span>, <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">zero</span><span class="hljs-comment"># load desired int into a0</span><br>ecall<br></code></pre></td></tr></table></figure><h3 id="代码段">代码段</h3><ul><li><p>.开始的指令是写给汇编器的指令</p></li><li><p>.data存储全局变量</p><ul><li><code>g: .word 0</code></li><li><code>msg: .string "sss"</code>以\0结尾的string</li><li><code>msg: .ascii "sds"</code>的string不以\0结尾</li></ul></li><li><p>.text存储运行代码</p><ul><li><code>la t0, g      # la: load address</code></li><li><code>lw t0, 0(t0) # lw: load word</code></li><li><code>sw t6, 0(t0) #sw: store word</code></li></ul></li></ul><p>默认在程序开始添加.text</p><ul><li>打印字符串：</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">4</span><br>la <span class="hljs-built_in">a0</span>, msg<br>ecall<br></code></pre></td></tr></table></figure><ul><li>mv</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">1</span><br>mv <span class="hljs-built_in">a0</span>, <span class="hljs-built_in">t6</span> <span class="hljs-comment">#add a0, t6, zero</span><br>ecall<br></code></pre></td></tr></table></figure><ul><li>数组：偏移地址</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br><span class="hljs-symbol">numbers:</span> <span class="hljs-meta">.word</span> -<span class="hljs-number">30</span>, <span class="hljs-number">30</span>, -<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span><br><br><span class="hljs-meta">.text</span><br>la <span class="hljs-built_in">t0</span>, numbers<br><span class="hljs-keyword">lw </span><span class="hljs-built_in">t1</span>, <span class="hljs-number">12</span>(<span class="hljs-built_in">t0</span>)<span class="hljs-comment"># 偏移12个字节，到20</span><br><span class="hljs-keyword">addi </span><span class="hljs-built_in">t1</span>, <span class="hljs-built_in">t1</span>, <span class="hljs-number">90</span><br><span class="hljs-keyword">sw </span><span class="hljs-built_in">t1</span>, <span class="hljs-number">12</span>(<span class="hljs-built_in">t0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;子不语&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>编译原理-语法分析</title>
    <link href="http://example.com/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2023-06-03T04:00:00.000Z</published>
    <updated>2023-06-24T01:03:49.860Z</updated>
    
    <content type="html"><![CDATA[<p>子不语</p><span id="more"></span><h1 id="语法分析">语法分析</h1><p>文法：一组描述良构程序语法结构的精确的规则</p><ul><li>文法给出了一个程序设计语言的精确易懂的语法规约</li><li>对于某些类型的文法，我们可以自动地构造出高效的语法分析器，它能够确定一个源程序的语法结构。同时，语法分析器的构造过程可以揭示出语法的二义性，还能发现一些容易在语法的初始设计阶段被忽略的问题</li><li>一个正确设计的文法给出了一个语言的结构，该结构有助于把源程序翻译成正确的目标代码，也有助于检测错误</li><li>一个文法支持逐步加入可以完成新任务的新语言构造从而迭代地演化和开发语言。如果对语言的实现遵循语言的文法结构，那么在实现中加入这些新构造的工作就变得更容易</li></ul><h2 id="一引论">一、引论</h2><h3 id="语法分析器的作用">语法分析器的作用</h3><p>语法分析器从词法分析器获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成，能够以易于理解的方式报告语法错误，并且能够从常见的错误中恢复并继续处理程序的其余部分。</p><ul><li><p>对于良构的程序，语法分析器构造出一棵语法分析树，并把它传递给编译器的其他部分进一步处理。</p></li><li><p>处理文法的语法分析器大体上可分为三种类型：</p><ul><li>通用的：效率较低不能用于编译器产品</li><li>自顶向下的：从语法分析树的顶部开始向底部构造语法分析树</li><li>自底向上的：从叶结点开始逐步向根结点构造<ul><li>语法分析器的输入总是按从左到右的方式被扫描，每次扫描一个符号</li></ul></li></ul></li></ul><h3 id="语法错误的处理">语法错误的处理</h3><p>错误的不同层次：</p><ul><li>词法错误</li><li>语法错误</li><li>语义错误</li><li>逻辑错误</li></ul><p>可行前缀特性：</p><p>一旦发现输入的某个前缀不能够通过添加一些符号而形成这个语言的串，就可以立即检测到语法错误。</p><p>错误恢复的一般策略：恐慌模式和短语层次恢复</p><ul><li>恐慌模式恢复<ul><li>一旦发现错误就不断丢弃输入中的符号，知道找到同步词法单元集合中的某个元素<ul><li>同步词法单元通常是界限符，如分号和右大括号</li><li>跳过大量输入，但简单且能保证不会进入无限循环</li></ul></li></ul></li><li>短语层次的恢复<ul><li>将余下输入的某个前缀替换为另一个串，使之可以继续分析<ul><li>必须小心选择替换方法以免无限循环</li></ul></li></ul></li><li>错误产生式<ul><li>预测常见错误，在文法中加入错误产生式</li></ul></li><li>全局纠正<ul><li>通过最小的改动序列将错误输入串转换为语法正确的串<ul><li>开销大，仅具理论价值</li></ul></li></ul></li></ul><h2 id="二上下文无关文法">二、上下文无关文法</h2><h3 id="上下文无关文法的定义">上下文无关文法的定义</h3><p>上下文无关文法（Context-free grammar，CFG）</p><p>一个上下文无关文法由终结符号，非终结符号，一个开始符号和一组产生式组成。</p><ul><li><p>终结符号是组成串的基本符号</p></li><li><p>非终结符号是表示串的集合的语法变量</p></li><li><p>一个文法中，某个非终结符号被指定为开始符号</p></li><li><p>一个文法的产生式描述了将终结符号和非终结符号组合成串的方法，其组成元素：</p><ul><li>一个被称为产生式头或左部的非终结符号，这个产生式定义了这个头所代表的串集合的一部分</li><li>符号<spanclass="math inline">\(\rightarrow\)</span>。有时也使用::=来替代箭头</li><li>一个由零个或多个终结符号与非终结符号组成的产生式体或右部</li></ul></li></ul><p>语义：上下文无关文法G定义了一个语义L(G)</p><p>约定：</p><ul><li>常用开始符号S</li><li>常用表达式、项和因子的非终结符号E、T、F</li><li>一般第一个产生式的头为开始符号</li></ul><h3 id="推导">推导</h3><p>将某个产生式的左边替换成它的右边。</p><ul><li><p>每一步推导需要选择替换哪个非终结符号，以及使用哪个产生式</p></li><li><p>一次推导：<spanclass="math inline">\(\Longrightarrow\)</span></p></li><li><p>一次或多次推导：<spanclass="math inline">\(\Longrightarrow^+\)</span></p></li><li><p>零次或多次推导：<spanclass="math inline">\(\Longrightarrow^*\)</span></p></li></ul><p>如果<span class="math inline">\(S\Longrightarrow^*\alpha\)</span>，其中S为文法G的开始符号，称<spanclass="math inline">\(\alpha\)</span>为G的一个句型。</p><ul><li>文法G的一个句子是不包含非终结符号的句型</li><li>文法生成的语言是它的所有句子的集合，称为上下文无关语言</li><li>两个生成相同语言的文法是等价的</li></ul><p>最左推导：总是选择每个句型的最左非终结符号</p><p>最右推导：总是选择每个句型的最右边的非终结符号</p><p>正则表达式的表达能力严格弱于上下文无关文法。</p><p>正则表达式转上下文无关文法：</p><ol type="1"><li>转NFA或DFA</li><li>自动机每个状态转为上下文无关文法的一个非终结符号</li><li>逐步转换</li></ol><h4 id="二义性">二义性</h4><p>如果一个文法可以为某个句子生成多棵语法分析树，那么它就是二义性的。</p><p>消除二义性</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">stmt</span>: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span><br>| <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span> <span class="hljs-keyword">else</span> <span class="hljs-type">stmt</span><br>| other<br></code></pre></td></tr></table></figure><p>修改规则：每个else和最近的尚未匹配的then匹配</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">stmt</span>: matched_stmt<br>| open_stmt<br>matched_stmt: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> thrn matched_stmt <span class="hljs-keyword">else</span> matched_stmt<br>| other<br>open_stmt: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span><br> | <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then matched_stmt <span class="hljs-keyword">else</span> open_stmt<br></code></pre></td></tr></table></figure><h4 id="左递归">左递归</h4><p>如果一个文法中有一个非终结符号使得对某个串<spanclass="math inline">\(\alpha\)</span>存在一个推导<spanclass="math inline">\(A\Longrightarrow^+A\alpha\)</span>，那么这个文法就是左递归的。</p><ul><li>自顶向下语法分析不能处理左递归文法</li></ul><p>消除直接左递归：</p><ol type="1"><li>将A的全部产生式分组：<span class="math inline">\(A\rightarrowA\alpha_1|A\alpha_2|...|A\alpha_m|\beta_1|\beta_2|...|\beta_n\)</span>，其中<spanclass="math inline">\(\beta_i\)</span>都不以A开始</li><li>将A的产生式替换为<ul><li><span class="math inline">\(A\rightarrow\beta_1A^{&#39;}|\beta_2A^{&#39;}|...|\beta_nA^{&#39;}\)</span></li><li><span class="math inline">\(A^{&#39;}\rightarrow\alpha_1A^{&#39;}|\alpha_2A^{&#39;}|...|\alpha_nA^{&#39;}|\epsilon\)</span></li></ul></li></ol><p>消除间接左递归：先化为直接左递归，再使用上述方法</p><ul><li>该方法下的文法不能存在环和<spanclass="math inline">\(\epsilon\)</span>产生式</li></ul><h4 id="提取左公因子">提取左公因子</h4><p>对于每个非终结符号A，找出它的两个或多个选项之间的最长公共前缀<spanclass="math inline">\(\alpha\)</span>，若<spanclass="math inline">\(\alpha \neq\epsilon\)</span>，即存在一个非平凡的公共前缀，将所有<spanclass="math inline">\(A\rightarrow\alpha\beta_1|\alpha\beta_2|...|\alpha\beta_n|\gamma\)</span>替换为</p><ul><li><span class="math inline">\(A\rightarrow \alphaA^{&#39;}|\gamma\)</span></li><li><span class="math inline">\(A^{&#39;}\rightarrow\beta_1|\beta_2|...|\beta_n\)</span></li></ul><p>其中<span class="math inline">\(\gamma\)</span>为A所有不以<spanclass="math inline">\(\alpha\)</span>开始的产生式体。</p><ul><li>不断应用上述转换，直到每个非终结符号的任意两个产生式体没有公共前缀为止</li></ul><h3 id="自顶向下的语法分析">自顶向下的语法分析</h3><p>为输入串构造语法分析树，从语法分析树的根结点开始，按照先根次序创建这棵语法分析树的各个结点。可以被看作寻找输入串的最左推导的过程。</p><ul><li>根结点是文法的起始符号S</li><li>每个中间结点表示对某个非终结符应用某个产生式进行推导</li><li>叶结点为词法单元流，仅包括终结符号和特殊的文件结束符$（EOF）</li></ul><p>对于有些文法，可以构造出向前看k个输入符号的预测分析器，这类文法称为LL(k)文法。</p><h4 id="递归下降">递归下降</h4><p>为每一个非终结符写一个递归函数，内部按需调用其他非终结符对应的递归函数进行下降。</p><h4 id="预测分析表">预测分析表</h4><p>指明每个非终结符在面对不同的词法单元或文件结束符时，该选择哪个产生式或报错。</p><p>首行为各个终结符和$，首列为各个非终结符。</p><h5 id="first和follow集合">FIRST和FOLLOW集合</h5><p><span class="math inline">\(First(\alpha)\)</span>是可以从<spanclass="math inline">\(\alpha\)</span>推导得到的句型的<strong>首终结符号</strong>的集合。</p><p><span class="math inline">\(First(\alpha)=\{t\inT\cup\{\epsilon\}|\alpha\Longrightarrow^*t\beta\or\alpha\Longrightarrow^*\epsilon \}\)</span></p><p>如果非终结符A的所有产生式对应的FIRST集合不相交，那么只需查看当前词法单元即可确定选择的产生式。</p><ul><li>单个符号X的<span class="math inline">\(First(X)\)</span>的计算<ul><li>先判断是否是终结符，若是，则<spanclass="math inline">\(First(X)\)</span>即其自身</li><li>否则，判断X的每一条产生式，且需要判断X可否推导出空串</li></ul></li><li>符号串<span class="math inline">\(\alpha\)</span>的<spanclass="math inline">\(First(\alpha)\)</span>的计算，<spanclass="math inline">\(\alpha=X\beta\)</span><ul><li>若<span class="math inline">\(\epsilon\notin L(X)\)</span>，即<spanclass="math inline">\(First(X)\)</span></li><li>若<span class="math inline">\(\epsilon\in L(X)\)</span>，为<spanclass="math inline">\((First(X)\setminus\{\epsilon\})\cupFirst(\beta)\)</span></li><li>如果<span class="math inline">\(\epsilon\in\alpha\)</span>，将<spanclass="math inline">\(\epsilon\)</span>加入<spanclass="math inline">\(First(\alpha)\)</span></li></ul></li></ul><p><spanclass="math inline">\(Follow(A)\)</span>是可能在某些句型中<strong>紧跟在A右边的终结符</strong>的集合。</p><p>对于任意的产生式左部非终结符<span class="math inline">\(A\inN\)</span>：</p><p><span class="math inline">\(Follow(A)=\{t\in T\cup\{\$\}|\exists.S\Longrightarrow^*s=^\triangle At\gamma\}\)</span></p><p>考虑产生式<span class="math inline">\(A\rightarrow\alpha\)</span>，如果从<spanclass="math inline">\(\alpha\)</span>可以推导出空串，则只有当当前词法单元属于<spanclass="math inline">\(Follow(A)\)</span>，才可以选择该产生式。</p><ul><li>非终结符X的<span class="math inline">\(Follow(X)\)</span>的计算<ul><li>若X是开始符号，则<span class="math inline">\(\$\)</span>也在<spanclass="math inline">\(Follow(X)\)</span>中<ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cup\{\$\}\)</span></li></ul></li><li>若X是某产生式右部最后一个符号，即<spanclass="math inline">\(A\rightarrow \alpha X\)</span><ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cupFollow(A)\)</span></li></ul></li><li>若X是某产生式右部中间的一个符号，即<spanclass="math inline">\(A\rightarrow \alpha X\beta\)</span><ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cup(First(\beta)\setminus\{\epsilon\})\)</span></li><li>若<span class="math inline">\(\epsilon\inFirst(\beta)\)</span>，<span class="math inline">\(Follow(X)\leftarrowFollow(X)\cup Follow(A)\)</span></li></ul></li></ul></li></ul><p>根据First和Follow集合计算确定给定文法G的预测分析表：</p><p>对应每条产生式<spanclass="math inline">\(A\rightarrow\alpha\)</span>与终结符t，如果</p><ul><li><span class="math inline">\(t\in First(\alpha)\)</span></li><li><span class="math inline">\(\epsilon\in First(\alpha)\and t\inFollow(A)\)</span></li></ul><p>则在表格[A,t]中填入<spanclass="math inline">\(A\rightarrow\alpha\)</span></p><h4 id="ll1文法">LL(1)文法</h4><ul><li><p>从左向右读入词法单元</p></li><li><p>在推导的每一步，LL(1)总是选择最左边的非终结符进行展开</p></li><li><p>如果文法G的预测分析表是无冲突的，则G是LL(1)文法。</p><ul><li>对于当前选择的非终结符，仅根据输入中当前的词法单元即可确定需要哪条产生式</li></ul></li></ul><p>非递归的预测分析算法：使用栈保存终结符和非终结符</p><h3 id="adaptive-ll算法">Adaptive LL(*)算法</h3><p>Adaptive LL(*)算法，简称ALLStar算法。</p><h4 id="优先级上升算法">优先级上升算法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;)&#x27;</span><br>| INT<br>| ID<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>: (<br><span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-built_in">expr</span>[0] <span class="hljs-string">&#x27;)&#x27;</span><br>| INT<br>| ID<br>)<br>(&#123;5 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-built_in">expr</span>[6]<br>| &#123;4 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[5]<br>)*<br>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;!&#x27;</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| ID<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>:(ID<br>| <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span>[4]<br>)<br>(&#123;3 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;!&#x27;</span><br>| &#123;2 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>)*<br>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: &lt;assoc = right&gt; <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| INT<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>:( INT )<br>(&#123;3 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>|&#123;2 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>)*<br>;<br></code></pre></td></tr></table></figure><p>总结：</p><p>按原产生式排序优先级；</p><p>左结合运算符右操作符优先级上升，右结合运算符右操作符优先级不变。</p><h4 id="antlr4的错误报告与恢复">ANTLR4的错误报告与恢复</h4><p>共四类词法、语法错误</p><ul><li>词法错误：LexerNoViableAltException</li><li>语法错误<ul><li>NoViableAltException：非终结符的可选分支均不可行</li><li>InputMismatchException：可选分支不匹配</li><li>FailedPerdicateException</li></ul></li></ul><h3 id="自底向上的语法分析">自底向上的语法分析</h3><p>自底向上的、不断归约的、基于句柄识别自动机的、适用于LR文法的LR语法分析器。</p><h4 id="自底向上构建语法分析树">自底向上构建语法分析树</h4><ul><li>根结点是文法起始符号S</li><li>叶结点是词法单元流，仅包含终结符号与特殊文件结束符$</li><li>每个中间非终结符结点表示使用它的某条产生式进行归约</li></ul><h4 id="lr语法分析器">LR语法分析器</h4><ul><li>从左向右扫描输入</li><li>构建反向最右推导</li></ul><p>LR语法分析器的状态：</p><p>在任意时刻，语法分析树的上边缘和剩余的输入构成当前句型。</p><ul><li>LR语法分析器使用栈存储语法分析树的上边缘，它包含了语法分析器目前所知的所有信息。</li></ul><p>栈上操作：</p><ul><li>移入输入符号</li><li>按产生式归约</li></ul><h4 id="lr分析表">LR分析表</h4><p>在当前状态（编号）下，面对当前文法符号时，该采取什么动作</p><ul><li><p>第一列为状态，用数字编号</p></li><li><p>其后的一组列为ACTION列，其首行为文法符号，余行指明动作</p></li><li><p>再之后的一组列为GOTO列，其首行为归约的文法符号，余行指明转换到的状态</p></li><li><p><spanclass="math inline">\(s_n\)</span>：移入输入符号，并进入状态n</p></li><li><p><spanclass="math inline">\(r_k\)</span>：使用k号产生式进行归约</p></li><li><p><span class="math inline">\(g_n\)</span>：转换到状态n</p></li><li><p><span class="math inline">\(acc\)</span>：成功接受，结束</p></li><li><p>空白：错误</p></li></ul><p>示例（SLR(1)分析表）：</p><figure><img src="/image/编译原理/LR分析表.png" alt="LR分析表" /><figcaption aria-hidden="true">LR分析表</figcaption></figure><p>栈中存储语法分析器的状态（编号），编码了语法分析树的上边缘。</p><p>如何构造LR分析表？</p><h5 id="句柄">句柄</h5><p>在输入串的反向最右推导中，如果下一步是逆用产生式<spanclass="math inline">\(A\rightarrow \alpha\)</span>，则称<spanclass="math inline">\(\alpha\)</span>为当前句型的句柄。</p><ul><li>LR语法分析器的关键就是高效寻找每个归约步骤所使用的句柄。</li></ul><p>存在一种LR语法分析方法，保证句柄总是出现在栈顶。</p><h5 id="lr0句柄识别有穷自动机">LR(0)句柄识别有穷自动机</h5><p>LR(0)项：文法G的一个LR(0)项是G的某个产生式加上一个位于体部的点。</p><ul><li>项指明了语法分析器已经观察到了某个产生式的某个前缀</li><li>例：<span class="math inline">\(A\rightarrow XYZ\)</span>的项<ul><li><span class="math inline">\(A\rightarrow ·XYZ\)</span></li><li><span class="math inline">\(A\rightarrow X·YZ\)</span></li><li><span class="math inline">\(A\rightarrow XY·Z\)</span></li><li><span class="math inline">\(A\rightarrow XYZ·\)</span></li></ul></li><li>项集：若干项构成的集合，可以表示句柄识别自动机的一个状态</li><li>项集族：若干项集的集合，可以表示句柄识别自动机的状态集</li></ul><p>增广文法：文法G的增广文法G‘为在G中加入产生式<spanclass="math inline">\(S&#39;\rightarrow S\)</span>的文法。</p><p>状态的划分：“点”的位置</p><ul><li><p>点指明了栈顶，左边是栈中内容，右边是期望看到的文法符号。</p></li><li><p>以<span class="math inline">\(E&#39;\rightarrow·E\)</span>为初始状态，推导点右边的内容。</p></li><li><p>逐步推导接受文法符号后的内容。</p></li></ul><p>示例：</p><figure><img src="/image/编译原理/LR0句柄识别自动机.png"alt="LR0句柄识别自动机" /><figcaption aria-hidden="true">LR0句柄识别自动机</figcaption></figure><p><span class="math inline">\(J=GOTO(I,X)=CLOSURE({[A\rightarrow\alphaX·\beta]|[A\rightarrow\alpha·X\beta]\in I})\)</span></p><p>接受状态：<span class="math inline">\(F=\{I\in C|\exist[A\rightarrow\alpha·]\in I \}\)</span></p><p>GOTO函数拆分成ACTION表（针对终结符）和GOTO表（针对非终结符）。</p><p>上图转化为的表：</p><figure><img src="/image/编译原理/LR0分析表.png" alt="LR0分析表" /><figcaption aria-hidden="true">LR0分析表</figcaption></figure><p>LR(0)分析表构造规则</p><ul><li><p><span class="math inline">\(GOTO(I_i,a)=I_j\and a\inT\Longrightarrow ACTION[i,a]\leftarrow sj\)</span></p></li><li><p><span class="math inline">\(GOTO(I_i,A)=I_j\and A\inN\Longrightarrow GOTO[i,A]\leftarrow gj\)</span></p></li><li><p><span class="math inline">\([k: A\rightarrow\alpha·]\in I_i\andA\neq S&#39;\Longrightarrow\forall t\inT\cup\{\$\}.ACTION[i,t]=rk\)</span></p></li><li><p><span class="math inline">\([S&#39;\rightarrow S·]\inI_i\Longrightarrow ACTION[i,\$]\leftarrow acc\)</span></p></li></ul><p>改进第三规则即为SLR(1)分析表：</p><p><span class="math inline">\([k: A\rightarrow\alpha·]\in I_i\and A\neqS&#39;\Longrightarrow\forall t\in Follow(A).ACTION[i,t]=rk\)</span></p><p>LR(0)文法</p><p>如果文法G的LR(0)分析表是无冲突的，则G是LR(0)文法。</p><ul><li>LR(0)分析表每一行选用的归约产生式是相同的。</li></ul><p>SLR(1)文法</p><p>如果文法G的SLR(1)分析表无冲突，则G是SLR(1)文法。</p><p>两类可能的冲突：移入/归约冲突、归约/归约冲突</p><h2 id="三属性文法">三、属性文法</h2><p>属性文法：为上下文无关文法赋予语义</p><p>在语义分析过程中实现属性文法，语义动作嵌入的位置决定了何时执行该动作。</p><p>基本思想：一个动作在它左边的所有文法符号都处理过之后立即执行</p><h3 id="语法制导定义">语法制导定义</h3><p>Syntax-Directed Definition，SDD</p><p>一个上下文无关文法和属性及规则的结合。</p><ul><li>每个文法符号都可以关联多个属性</li><li>每个产生式都可以关联一组规则</li></ul><p>SDD唯一确定了语法分析树上每个非终结符节点的属性；</p><p>SDD没有规定以什么方式、什么顺序计算这些属性值。</p><h4 id="综合属性">综合属性</h4><p>结点N的综合属性只能通过N的子结点或N本身的属性进行定义。</p><h4 id="s属性定义">S属性定义：</h4><p>如果一个SDD的每个属性都是综合属性，则它是S属性定义。</p><p>依赖图用于确定一棵给定的语法分析树中各个属性实例之间的依赖关系。</p><p>S 属性定义的依赖图刻画了属性实例之间自底向上的信息流动。</p><h4 id="继承属性">继承属性</h4><p>结点N上的继承属性只能通过N的父结点、N本身和N的兄弟结点上的属性来定义。</p><p>继承属性<spanclass="math inline">\(T^{&#39;}.inh\)</span>用于在表达式中从左到右传递中间计算结果</p><table><thead><tr class="header"><th>产生式</th><th>语法规则</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(T\rightarrow FT^{&#39;}\)</span></td><td><span class="math inline">\(T^{&#39;}.inh=F.val\)</span>；<spanclass="math inline">\(T.val=T^{&#39;}.syn\)</span>；</td></tr><tr class="even"><td><span class="math inline">\(T^{&#39;}\rightarrow*FT_1^{&#39;}\)</span></td><td><span class="math inline">\(T^{&#39;}_1.inh=T^{&#39;}.inh\timesF.val\)</span>；<spanclass="math inline">\(T^{&#39;}.syn=T^{&#39;}_1.syn\)</span>；</td></tr><tr class="odd"><td><span class="math inline">\(T^{&#39;}\rightarrow\epsilon\)</span></td><td><spanclass="math inline">\(T^{&#39;}.syn=T^{&#39;}.inh\)</span>；</td></tr><tr class="even"><td><span class="math inline">\(F\rightarrow digit\)</span></td><td><span class="math inline">\(F.val=digit.lexval\)</span>；</td></tr></tbody></table><p>综合属性<spanclass="math inline">\(T^{&#39;}.syn\)</span>则用以计算最终结果。</p><h4 id="l属性定义">L属性定义</h4><p>如果一个SDD的每个属性要么是综合属性，要么是继承属性，则它是L属性定义。</p><ul><li><p>继承属性规则需满足限制：</p><p>对于<span class="math inline">\(A\rightarrowX_1X_2...X_n\)</span>及其对应规则定义的<spanclass="math inline">\(X_i.a\)</span>，这个规则只能使用</p><ul><li>和产生式头A关联的继承属性</li><li>位于<spanclass="math inline">\(X_i\)</span>左边的文法符号的相关的综合属性或继承属性</li><li>和这个<spanclass="math inline">\(X_i\)</span>的实例本身相关的继承属性或综合属性，但是在这个<spanclass="math inline">\(X_i\)</span>的全部属性组成的依赖图中不存在环</li></ul></li></ul><p>数组类型文法：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">T:</span> BC<br><span class="hljs-symbol">B:</span> INT<br><span class="hljs-symbol">C:</span> <span class="hljs-string">&#x27;[&#x27;</span> INT <span class="hljs-string">&#x27;]&#x27;</span> C<br></code></pre></td></tr></table></figure><p>有符号二进制数文法</p><table><thead><tr class="header"><th>产生式</th><th>属性规则</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(Number\rightarrow SignList\)</span></td><td><spanclass="math inline">\(List.pos=0;\)</span>$if(Sign.neg){Number.val=-List.val;}<span class="math display">\[else\{Number.val=List.val;\}$ || $Sign\rightarrow +$           |$Sign.neg=false;$                                            || $Sign\rightarrow -$           |$Sign.neg=true;$                                             || $List\rightarrow Bit$         | $Bit.pos =List.pos;\]</span>List.val=Bit.val;$</td></tr><tr class="even"><td><span class="math inline">\(List\rightarrow List_1Bit\)</span></td><td><span class="math inline">\(List_1.pos=List.pos+1;\)</span><spanclass="math inline">\(Bit.pos=List.pos;\)</span><spanclass="math inline">\(List.val=List_1.val+Bit.val;\)</span></td></tr><tr class="odd"><td><span class="math inline">\(Bit\rightarrow 0\)</span></td><td><span class="math inline">\(Bit.val=0;\)</span></td></tr><tr class="even"><td><span class="math inline">\(Bit\rightarrow 1\)</span></td><td><span class="math inline">\(Bit.val=1;\)</span></td></tr></tbody></table><h4 id="后缀表示">后缀表示</h4><p>递归定义：</p><ul><li>如果E是一个常量或变量，则E的后缀表示是E本身</li><li>如果E是形如<span class="math inline">\(E_1 opE_2\)</span>的表达式，则E的后缀表示是<spanclass="math inline">\(E_1&#39;E_2&#39;op\)</span>，这里的<spanclass="math inline">\(E_1&#39;\)</span>和<spanclass="math inline">\(E_2&#39;\)</span>是<spanclass="math inline">\(E_1\)</span>和<spanclass="math inline">\(E_2\)</span>的后缀表达式</li><li>如果E是形如<spanclass="math inline">\((E_1)\)</span>的表达式，则E的后缀表示是<spanclass="math inline">\(E_1\)</span>的后缀表示</li></ul><h3 id="语法制导的翻译方案">语法制导的翻译方案</h3><p>Syntax-Directed translation，SDT</p><p>在其产生式体中嵌入语义动作的上下文无关文法。</p><ul><li>用大括号包括规则，写在产生式之后。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;子不语&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
</feed>
