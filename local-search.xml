<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++数据结构</title>
    <link href="/2025/02/01/C++/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2025/02/01/C++/C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>路就在你的脚下，只要你想走。</p><span id="more"></span><h1 id="c数据结构">C++数据结构</h1><p>以下内容自动<code>using namespace std;</code></p><h2 id="内存">1. 内存</h2><p>C++将内存视为一段连续单元，每个单元的大小为1字节且都有一个地址。通过其地址访问内存中的一个字节是一个<spanclass="math inline">\(\Omicron(1)\)</span>常量时间操作。</p><p>然而，具体的计算机并非这样简单，现代CPU往往有多个核心，每个核心既有独属于自己的缓存，也有公用的缓存。</p><ul><li><p>以我当前使用的Macbook Pro 2021为例：可以用sysctl -ahw查看（下述KB均指1024B）</p><p>M1芯片包含4个Firestrom高性能核心和4个Icestrom低性能核心</p><ul><li>每个Firestrom核心都有自己的192KB指令L1缓存和128KB数据L1缓存</li><li>4个Firestrom核心共用12MB的L2缓存</li><li>每个Icestrom核心都有自己的128KB指令L1缓存和64KB数据L1缓存</li><li>4个Icestrom核心共用4MB的L2缓存</li><li>每个缓存行的大小为128B，页大小16KB</li><li>内存16GB</li></ul></li><li><p>一些数据：</p><ul><li>L1缓存：1ns</li><li>L2缓存：5ns</li><li>内存：100ns</li><li>硬盘：15ms</li></ul></li><li><p>举个例子，下述代码的运行时间为0.66s，但是把循环中赋值处的i和j互换，时间就为2.1s。这是因为访问顺序改变使得缓存miss的次数增加了。这就是计算机中的空间局部性。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> cacheSize = <span class="hljs-number">65536</span>;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> k = cacheSize / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">array</span>(k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k));<br>    <span class="hljs-keyword">auto</span> start = chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-keyword">auto</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j) &#123;<br>            array[i][j] = counter++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> end = chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    chrono::duration&lt;<span class="hljs-type">double</span>&gt; t = end - start;<br>    cout &lt;&lt; t &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="标准库容器">2. 标准库容器</h2><p>C++容器是一系列数据结构，封装了元素内存管理的细节，分为3类：序列容器、关联容器和容器适配器。</p><h3 id="序列容器">序列容器</h3><p>标准库序列容器包含<code>array</code>、<code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>。此外也有处理字符的<code>basic_string</code>。</p><p>选择容器的思考：元素数量、使用方式（增删改查）、数据处理位置、元素排列顺序。</p><h4 id="array">array</h4><p><code>array</code>使用栈而不是堆来管理元素，实际上是原本C数组的一个替代。</p><ul><li><code>auto a = array&lt;int, k&gt;&#123;&#125;;</code></li><li>它使用类型和大小作为模板参数，这避免了C数组的数组衰变现象。<ul><li>数组衰变：当C数组作为参数传递给函数时，由于传递的是首地址指针，会丢失其大小信息。</li><li>也可以用视图来解决数组衰变的问题。</li></ul></li></ul><h4 id="vector">vector</h4><p><code>vector</code>中的元素在堆内存中连续排列，因此可以用常数时间访问其中的任何元素。</p><p><code>vector</code>具有大小和容量两个属性，大小指其中元素的个数，容量指实际具有的空间可以容纳的元素个数。<code>vector</code>有三种改变容量的方式：</p><ol type="1"><li>使用<code>push_back</code>向<code>vector</code>中添加元素时，若不超出容量，就会直接添加；否则会申请一个新的空间，然后把所有元素移动到新空间。<ul><li>当我们用指针指向<code>vector</code>中的元素时，如果<code>vector</code>申请新的空间，那么原指针指向的位置就会无效，这种情况称为野指针，因此不要用指针指向<code>vector</code>中的元素。</li><li><code>vector</code>在移动其中的元素时，如果该元素对象具有<code>noexcept</code>的移动构造函数，那么会使用移动构造，否则会使用复制构造。实际上，它使用<code>move_if_noexcept</code>。</li><li>使用<code>emplace_back</code>可以直接在<code>vector</code>中创建对象，而不是先创建再复制或移动到<code>vector</code>中。</li></ul></li><li>调用<code>reserve</code>，设定容量。</li><li>调用<code>resize</code>，且设定的大小大于当前容量。</li><li>调用<code>shrink_to_fit</code>，将容量削减为当前大小。</li></ol><p>换言之，容量也就意味着<code>vector</code>的内存空间，不改变容量，也不会改变<code>vector</code>的内存空间地址。</p><ul><li><code>clear</code>清空<code>vector</code>，但不改变容量。</li><li><code>erase</code>和<code>erase_if</code>删除指定元素和元素集合，但不改变容量，也就是说，删除后<code>vector</code>进行了元素的移动。</li></ul><h4 id="deque">deque</h4><p>在<code>vector</code>的开头添加或删除元素的时间复杂度为<spanclass="math inline">\(\Omicron(n)\)</span>，在结尾有时候也不是<spanclass="math inline">\(\Omicron(1)\)</span>，<code>deque</code>，也就是双端队列就是用于解决开头和结尾添加或删除的问题。</p><p><code>deque</code>表现为一组固定大小的数组，因而可以以常数时间进行随机访问。然而它的所有元素并不是连续存储的。因而可以实现在开头和结尾以常数时间添加和删除元素。</p><p>随机位置插入和删除的复杂度为<spanclass="math inline">\(\Omicron(n)\)</span>。</p><h4 id="list">list</h4><p><code>list</code>是一个双向链表，而<code>forward_list</code>是一个单向链表。<code>list</code>因为具有后指针，会占用更多内存。</p><h4 id="basic_string">basic_string</h4><p><code>string</code>是<code>basic_string&lt;char&gt;</code>的一个<code>typedef</code>。</p><p><code>basic_string</code>使用<strong>小对象优化</strong>，如果字符串的大小很小，就不会分配动态内存。</p><h3 id="关联容器">关联容器</h3><p>关联容器根据元素本身特性放置元素。分为有序关联容器和无序关联容器：</p><ul><li>有序关联容器使用自平衡二叉搜索树来存储元素，要求元素按小于进行排序。<ul><li>增删改查的复杂度为<span class="math inline">\(\Omicron(\logn)\)</span>。</li><li><code>set</code>、<code>map</code>、<code>multiset</code>、<code>multimap</code></li></ul></li><li>无序关联容器使用哈希表来存储元素，要求元素按==进行比较，并且可以计算哈希值。<ul><li>增删改查的复杂度为<spanclass="math inline">\(\Omicron(1)\)</span>。</li><li><code>unordered_set</code>、<code>unordered_map</code>、<code>unordered_multiset</code>、<code>unordered_multimap</code></li></ul></li></ul><p>C++20后，可以使用<code>contains</code>函数来确认关联容器是否包含特定元素，不用使用<code>count</code>或<code>find</code>来确定。</p><h3 id="容器适配器">容器适配器</h3><p><code>stack</code>、<code>queue</code>和<code>priority_queue</code>是标准库中的三种容器适配器，它们代表可以由底层序列容器实现的抽象数据类型。</p><h3 id="视图">视图</h3><p>C++17引入了<code>string_view</code>和<code>span</code>，它们不是容器，而是连续元素的视图。</p><p><code>string_view</code>使用指针和大小避免了复制，它的<code>substr</code>操作是常数复杂度，而<code>string</code>则需要申请空间并逐个赋值，是线性复杂度。</p><p><code>span</code>是对于数组的视图，同样使用指针和大小避免复制。将函数参数设置为<code>span</code>而传入C数组，可以避免数组衰减。</p><h2 id="标准库算法">3. 标准库算法</h2><p>C++20引入了<code>&lt;ranges&gt;</code>，同时也改变了<code>&lt;algorithm&gt;</code>。过去我们使用算法都基于迭代器，例如<code>sort(a.begin(),a.end())</code>，现在可以直接使用<code>ranges::sort(a)</code>（并且这个函数在algorithm库中），对于其他算法也是如此。</p><h3 id="算法概览">算法概览</h3><ol type="1"><li><p>遍历：</p><ul><li><p><code>for_each</code>，对序列的每个元素调用一次参数中的函数，并且忽略函数返回值。</p></li><li><p><code>transform</code>，对序列的每个元素调用一次参数中的函数，将函数返回值保存在第二个参数序列中。</p></li><li><p><code>generate</code>，对序列的每个元素调用一次参数中的函数，将函数返回值保存在该当前元素中。</p></li></ul></li><li><p>排序：<code>sort</code></p><ul><li>使用<code>is_sorted</code>确定集合是排序的。</li></ul></li><li><p>查找：</p><ul><li>线性：<code>find</code></li><li>二分：<ul><li><code>binary_search</code></li><li><code>equal_range</code>：参数的范围，返回一个<code>pair</code></li><li><code>upper_bound</code>：参数最后一个位置的迭代器</li><li><code>lower_bound</code>：参数第一个位置的迭代器</li></ul></li></ul></li><li><p>条件测试：接受一个范围和一个判断函数</p><ul><li><code>all_of</code></li><li><code>any_of</code></li><li><code>none_of</code></li></ul></li><li><p>计算元素数量：<code>count</code>。</p></li><li><p>最小、最大：<code>min</code>、<code>max</code>；<code>min_element</code>、<code>max_element</code>。</p></li><li><p>夹逼：<code>clamp</code>，保证一个值在某个范围中。</p></li><li><p>交换：<code>swap</code></p></li><li><p>反转序列：<code>reverse</code></p></li><li><p>旋转序列：<code>rotate</code>，<code>rotate(vec.begin(), vec.begin() + n, vec.end());</code></p></li></ol><h3 id="算法特性">算法特性</h3><ol type="1"><li>不会改变容器大小</li><li>默认使用==和&lt;运算符</li><li>复杂性保证：既不分配内存，也不具有高于<spanclass="math inline">\(\Omicron(n\log n)\)</span>的时间复杂度。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C++学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++并发</title>
    <link href="/2025/01/01/C++/C++%E5%B9%B6%E5%8F%91/"/>
    <url>/2025/01/01/C++/C++%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>路就在你的脚下，只要你想走。</p><span id="more"></span><h1 id="c并发">C++并发</h1><p>C++11首次引入了并发支持，并在后续得到扩展。同时我们也可以使用pthreads、openMP等库进行实现。</p><h3 id="硬件线程和软件线程">硬件线程和软件线程</h3><p>通常，CPU的一个核可以运行一个硬件线程，使用超线程技术，可以使一个核同时运行多个硬件线程。</p><ul><li>单核单线程处理器使用时间片机制来进行多线程支持，在多核处理器中，这项机制依旧有效。</li><li>使用<code>std::thread::hardware_concurrency()</code>获取硬件线程数。</li></ul><p>操作系统则提供软件线程，由操作系统来管理软件线程在硬件线程上时间片的分配。</p><ul><li>硬件线程数是固定的，由硬件决定，而软件线程是程序创建的，由操作系统调度到硬件线程上执行。</li></ul><h2 id="thread库">thread库</h2><h3 id="thread">thread</h3><p>C++程序至少包含一个线程，在main函数中，它会在主线程上执行。</p><ul><li>获取线程标识符：<code>std::this_thread::get_id()</code>。</li><li>使当前线程休眠：<code>std::this_thread::sleep_for()</code>。</li></ul><p>使用<code>std::thread</code>类创建线程，传递一个可调用对象（函数、lambda或函数对象）及其参数。</p><ul><li>函数对象是实现了operator()的对象。</li></ul><p>线程属于当前局部块，也会随之块的结束被销毁，如果它既没有被<code>join</code>也没有被<code>detach</code>，那么它会被<code>terminate</code>。因此需要使用<code>join</code>等待线程结束，或<code>detach</code>分离该线程。</p><p>可以使用<code>thread::joinable</code>属性来查看<code>thread</code>的状态。</p><ul><li>返回<code>false</code>的情况：默认构造、已经<code>detach</code>或<code>join</code>、被移动（运行线程被移动到另一个<code>thread</code>）</li></ul><h3 id="jthread">jthread</h3><p>C++20引入了<code>jthread</code>，它和<code>thread</code>非常相似。但当在非可连接状态销毁时，它的析构函数会自动调用<code>request_stop</code>并在销毁时<code>join</code>。</p><p><code>request_stop</code>对应停止令牌<code>stop_token</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(std::stop_token stoken)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (!stoken.<span class="hljs-built_in">stop_requested</span>()) &#123; <br>    std::cout &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::seconds&#123;<span class="hljs-number">1</span>&#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程安全">线程安全</h3><p>多线程访问某个类、方法、对象时，该类、方法、对象始终能表现出正确的行为，那么称其是线程安全的。例如，多线程买票中，把同一个位置的票卖给了两个人，或者票数卖到负数，这就是线程不安全。</p><p>线程安全，不代表行为符合预期。例如cout是线程安全的，但是在多线程输出的时候，可能出现交错输出的情况，这并不是我们想要的。</p><p>其中关键在于，线程安全，意味着原子性（操作不会被中断）、可见性（操作的修改对其他线程立即可见）、有序性（操作执行有特定顺序）。在cout的例子中，&lt;&lt;的操作是原子的，但是多线程不同&lt;&lt;的调用顺序可能不符合预期。</p><h3 id="互斥量和锁">互斥量和锁</h3><p><code>mutex</code>是用来表征对象独占的原语和C++对象。</p><ol type="1"><li><p>基本用法（不推荐）：访问前调用<code>mutex::lock</code>，访问结束后，调用<code>mutex::unlock</code>。</p><ul><li><p>调用<code>lock</code>时，线程尝试获取<code>mutex</code>的锁，如果当时<code>mutex</code>无锁就对其上锁并执行后续访问操作，如果有锁就等待<code>mutex</code>被解锁。</p></li><li><p>问题：同一线程对<code>mutex</code>反复加锁会导致死锁。</p></li><li><p><code>try_lock</code>尝试加锁，失败返回<code>false</code>，成功则加锁并返回<code>true</code>。</p></li></ul></li><li><p><code>lock_guard</code>：构造时加锁，析构时解锁，适用于简单作用域内锁管理。</p></li><li><p><code>unique_lock</code>：构造时加锁，析构时解锁，除此外还封装了手动控制锁的功能。</p><ul><li>在构造时可以选择是否立即锁定互斥量（第二个参数传入<code>defer_lock</code>）。</li><li>支持<code>lock</code>、<code>unlock</code>和<code>try_lock</code>。</li><li>可以使用移动赋值/构造转移所有权。</li><li>可以搭配<code>condition_variable</code>实现条件变量，后文详述。</li></ul></li><li><p><code>scoped_lock</code>，C++17，构造时加锁，析构时解锁，可以同时锁定多个互斥量，避免死锁。</p></li></ol><p><code>mutex</code> Plus</p><ol type="1"><li><code>recursive_mutex</code>，允许同一线程对互斥量多次加锁，但必须保证加锁和解锁次数相等。</li><li><code>timed_mutex</code><ul><li><code>try_lock_for</code>在指定时间内尝试加锁，超时放弃。</li><li><code>try_lock_until</code>在指定的时间点前尝试加锁，超时放弃。</li></ul></li><li><code>recursive_timed_mutex</code>，懂得都懂。</li><li><code>shared_mutex</code>，适用于读多写少的场景。<ul><li>使用<code>share_lock</code>加共享锁，允许读但不允许写。</li><li>使用<code>unique_lock</code>加独占锁，其他线程既不允许读也不允许写。</li></ul></li></ol><h3 id="死锁">死锁</h3><p>多个线程同时持有锁，并互相请求所持有的锁，形成循环等待，这就是死锁问题。</p><ul><li>教科书级的四个死锁条件：资源互斥使用、进程占有资源且等待、资源不被剥夺、循环等待链。</li><li>对应的死锁防止方法：资源共享、静态分配资源、剥夺式调度资源、层次化资源分配。</li><li>死锁避免：银行家算法，计算整体资源分配是否会产生死锁。</li></ul><p>C++可以使用<code>lock</code>函数和<code>scoped_lock</code>类同时获取多个锁，来应付这个问题。</p><h3 id="条件变量">条件变量</h3><p><code>condition_variable</code>通常与<code>unique_mutex</code>搭配。</p><p>用法：<code>wait</code>或<code>wait_for</code>阻塞调用线程，同时释放锁，直到另一个线程在该条件变量上执行<code>notify_one</code>或<code>notify_all</code>。如果<code>notify</code>时没有线程在等待，消息会直接丢失。</p><p>代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mutex m;<br>condition_variable cv;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">unique_lock <span class="hljs-title">l</span><span class="hljs-params">(m)</span></span>;<br>cv.<span class="hljs-built_in">wait</span>(l, []()&#123; <span class="hljs-keyword">return</span> flag; &#125;);<br>cout &lt;&lt; this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">turnFlag</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">unique_lock <span class="hljs-title">l</span><span class="hljs-params">(m)</span></span>;<br>flag = <span class="hljs-literal">true</span>;<br>cv.<span class="hljs-built_in">notify_all</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="future库">future库</h2><p>为了在线程间传递数据的同时避免使用全局变量和锁，C++引入了<code>future</code>库。</p><ol type="1"><li><p><code>promise&lt;T&gt;</code>用于存储一个类型为<code>T</code>的值，通过<code>get_future</code>关联到<code>future</code>，并通过<code>set_value</code>或<code>set_exception</code>设置结果。一个<code>promise</code>只能关联一个<code>future</code>。</p><ul><li><code>set_value_at_thread_exit</code>和<code>set_exception_at_thread_exit</code>设置值，并在线程退出时设置值为ready。</li><li><code>future f = p.get_future();</code></li></ul></li><li><p><code>future&lt;T&gt;</code>用于获取<code>promise</code>设置的值，调用<code>get</code>会阻塞到结果可用，只能调用一次。</p><ul><li><code>wait</code>等待结果。</li><li><code>wait_for</code>、<code>wait_until</code>等待，并在计时结束后返回<code>future_status</code><ul><li>包含ready（可用）、timeout（不可用）、deferred（被延迟）三种状态</li></ul></li><li><code>share</code>返回一个<code>shared_future</code>，可以多次获取其中值。</li></ul></li><li><p>当我们只需要获取函数的返回值，可以使用<code>packaged_task</code>或<code>async</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> task = std::packaged_task&lt;<span class="hljs-keyword">decltype</span>(g)&gt;&#123;g&#125;; <br><span class="hljs-keyword">auto</span> f = task.<span class="hljs-built_in">get_future</span>(); <br>std::thread&#123;std::<span class="hljs-built_in">move</span>(task)&#125;.<span class="hljs-built_in">detach</span>();<br></code></pre></td></tr></table></figure><p>然而，<code>packaged_task</code>仍然需要我们对线程进行管理。</p><p><code>future f = async(g);</code>会自动执行函数g的线程并返回结果，无需手动控制。</p></li></ol><h2 id="atomic库">atomic库</h2><p>使用<code>atomic&lt;T&gt;</code>模板封装对象，可以在不显式使用互斥量和锁的情况下解决数据竞争问题。</p><ul><li>原子变量可能会使用锁，这取决于变量的类型和平台，如果不使用，称为无锁（lockfree）。<ul><li>运行时，调用该原子变量的<code>is_lock_free</code>函数可以查看是否无锁。</li><li>编译时，调用该原子变量的<code>is_always_lock_free</code>可以检查是否无锁。</li><li>现代平台上，<code>T</code>符合本机的字长，通常都是无锁的。</li><li>无锁比有锁具有更高的性能。</li></ul></li><li>自定义类型要想封装在模板中，就必须是平凡可复制的，也就是不包含虚函数和指向动态内存的指针。</li></ul><p><code>atomic_flag</code>始终是无锁的，可以用作保护临界区。</p><p>C++20引入了原子变量和原子标志的等待和通知功能，类似条件变量。</p><p><code>shared_ptr</code>的引用计数是原子的，但指向的共享对象并不是线程安全的。可以使用<code>atomic&lt;T&gt;</code>保护<code>shared_ptr</code>，这是一个违反了平凡可复制规则的例外，但无疑是有意义的。</p><p><code>atomic</code>的一个缺点是无法封装引用，这在函数调用中不太方便。C++20引入了<code>atomic_ref</code>用来封装引用。</p><h2 id="其他同步量">其他同步量</h2><ol type="1"><li><code>latch</code>，可以视为递减计数器，传递一个int进行初始化。<ul><li>线程调用<code>latch.count_down</code>递减计数器，但不等待。</li><li>线程调用<code>latch.wait</code>等待<code>latch</code>归零。</li><li>合并上述两个操作便是<code>latch.arrive_and_wait</code>。</li></ul></li><li><code>barrier</code>，类似<code>latch</code>，但可以额外传入一个函数作为参数，归零后执行该函数。</li><li><code>counting_semaphore</code>，信号量。<code>acquire</code>对应P操作，<code>release</code>对应V操作。</li></ol><h2 id="指令顺序">指令顺序</h2><p>编译器在优化的过程中会在不影响执行结果的前提下重新排序指令，以达到更好的性能，然而，编译器的优化在面临多线程和共享数据时，会带来难以理解的错误。</p><p>C++内存栅栏：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">std::atomic<span class="hljs-constructor">_thread_fence(<span class="hljs-params">std</span>::<span class="hljs-params">memory_order_release</span>)</span>;<span class="hljs-comment">//写入栅栏</span><br>std::atomic<span class="hljs-constructor">_thread_fence(<span class="hljs-params">std</span>::<span class="hljs-params">memory_order_acquire</span>)</span>;<span class="hljs-comment">//读取栅栏</span><br></code></pre></td></tr></table></figure><p>x86架构采用较强的内存一致性模型，较少需要手动使用内存栅栏。ARM架构采用较弱的内存一致性模型，允许广泛的指令重排，因此需要频繁使用内存栅栏：</p><ul><li>StoreStore重排：后续的写操作可能在之前的写操作完成前就执行。</li><li>LoadLoad重排：后续的读操作可能在之前的读操作完成前就执行。</li></ul><p>事实上，使用互斥锁和原子变量的时候，就会隐式地在临界区创建内存栅栏，不允许重新排序指令。</p>]]></content>
    
    
    <categories>
      
      <category>C++学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>习概_内外条件</title>
    <link href="/2024/09/04/%E4%B9%A0%E6%A6%82/%E5%86%85%E5%A4%96%E6%9D%A1%E4%BB%B6/"/>
    <url>/2024/09/04/%E4%B9%A0%E6%A6%82/%E5%86%85%E5%A4%96%E6%9D%A1%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1 id="内外条件">内外条件</h1><h2 id="国家安全">13. 国家安全</h2><ol type="1"><li><p>国家安全是民族复兴的根基，社会稳定是国家强盛的前提。</p><ul><li>国家安全是中国式现代化行稳致远的重要基础。</li></ul></li><li><p>总体国家安全观是新时代国家安全工作的基本遵循：</p><ul><li>以人民安全为宗旨。</li><li>以政治安全为根本。</li><li>以经济安全为基础。</li><li>以军事、科技、文化、社会安全为保障。</li><li>以促进国家安全为依托。</li></ul></li><li><p>发展和安全的关系：</p><ul><li>发展解决的是动力问题，安全解决的是保障问题。</li><li>发展具有基础性、根本性，是解决安全问题的总钥匙，发展就是最大的安全。</li><li>安全是发展的条件和保障。</li></ul></li><li><p>如何维护政治安全：三个毫不动摇</p><ul><li>毫不动摇坚持党的领导和执政地位。</li><li>毫不动摇坚持和完善中国特色社会主义制度。</li><li>毫不动摇坚持马克思主义在意识形态领域的指导地位。</li></ul><p>政治安全与人民安全、国家利益至上是有机统一的：</p><ul><li>政治安全是维护人民安全和国家利益的根本保证。</li><li>人民安全居于中心地位，国家安全归根结底是保障人民利益。</li><li>国家利益至上是实现政治安全和人民安全的要求和原则。</li></ul></li><li><p>维护重点领域国家安全：国土、经济、社会、网络、人工智能、数据、生物和公共卫生、外部。</p><ul><li>国土安全是立国之基。</li><li>经济安全是国家安全的基础。</li></ul></li><li><p>如何推进国家安全体系和能力现代化：</p><ul><li>健全完善国家安全体系。</li><li>增强维护国家安全能力。</li></ul></li><li><p>如何提高防范化解重大风险能力：</p><ul><li>坚持底线思维和极限思维。</li><li>力争把风险化解在源头。</li><li>运用制度威力应对风险挑战的冲击。</li></ul></li></ol><h2 id="国防">14. 国防</h2><ol type="1"><li>国防和军队建设是捍卫国家主权、安全、发展利益的坚强后盾。<ul><li>强国必须强军，军强才能国安。</li><li>军事实力任何时候都是硬核实力。</li><li>霸权主义、强权政治、冷战思维对世界和平与发展构成巨大威胁。</li></ul></li><li>人民军队使命任务：<ul><li>为巩固中国共产党领导和我国社会主义制度提供战略支撑。</li><li>为捍卫国家主权、统一和领土完整提供战略支撑。</li><li>为维护我国海外利益提供战略支撑。</li><li>为促进世界和平与发展提供战略支撑。</li></ul></li><li>强军目标的科学内涵：<ul><li>听党指挥是灵魂，决定军队建设的政治方向。</li><li>能打胜仗是核心，反映军队的根本职能和军队建设的根本指向。<ul><li>人民军队必须牢固树立战斗力这个唯一的根本的标准，坚持一切建设和工作向能打胜仗聚焦。</li></ul></li><li>作风优良是保证，关系军队的性质、宗旨、本色。</li></ul></li><li>全面推进国防和军队现代化的战略安排：<ul><li>2027年实现建军一百年奋斗目标。</li><li>到2035年基本实现国防和军队现代化。<ul><li>这一步的关键是实现军事理论现代化、军队组织形态现代化、军事人员现代化、武器装备现代化。</li></ul></li><li>到21世纪中叶把人民军队全面建成世界一流军队。</li></ul></li><li>坚持党对人民军队的绝对领导：<ul><li>党对人民军队的绝对领导是建军之本，强军之魂。</li><li>坚持党对人民军队的绝对领导必须有一整套制度作保证：<ul><li>军队最高领导权和指挥权属于党中央、中央军委。</li><li>党委制、政治委员制、政治机关制、支部建在连上。</li></ul></li><li>军委主席负责制在党建设军队的一整套制度体系中处于最高层次、居于统领地位。</li></ul></li><li>坚持政治建军、改革强军、科技强军、人才强军、依法治国：<ul><li>政治建军是人民军队的立军之本。</li><li>改革是决定人民军队发展壮大、制胜未来的关键一招。</li><li>科技是核心战斗力，是军事发展中最活跃、最具革命性的因素。</li><li>强军之道，要在得人。</li><li>依法治军是我们党建军治军基本方式。</li></ul></li><li>练兵备战：<ul><li>牢固树立战斗力这个唯一的根本的标准。</li><li>深入推进实战化军事训练，</li><li>创新军事战略指导。</li><li>大力培育“一不怕苦，二不怕死”的战斗精神。</li></ul></li><li>巩固提高一体化国家战略体系和能力：<ul><li>关键是要在一体化上下功夫。</li><li>军政军民团结是重要政治保障。</li></ul></li></ol><h2 id="国家统一">15. 国家统一</h2><ol type="1"><li><p>“一国两制”是一项基本国策，指在统一的国家内，国家主体实行社会主义制度，个别地区依法实行资本主义制度。</p><ul><li>一国两制是中国共产党领导人民实现祖国和平统一的伟大构想。<ul><li>针对台湾问题提出，先用于香港、澳门问题。</li></ul></li><li>一国两制为国际社会提供了新思路新方案。</li></ul><p>一国两制的根本宗旨是维护国家主权、安全、发展利益。</p><ul><li>全面管治权和高度自治权统一。</li><li>坚持爱国者治港、爱国者治澳、依法治港治澳。</li></ul><p>一国两制的提出首先是为了实现和维护国家统一，任何危害国家主权安全、挑战中央权力和香港特别行政区基本法权威、利用香港对内地进行渗透破坏的活动，都是对底线的触碰，决不允许。</p></li><li><p>实现祖国完全统一是由中华民族伟大复兴的时和势决定的。</p><ul><li><p>中华文明具有突出的统一性，国家统一永远是中国核心利益的核心。</p></li><li><p>台独分裂是祖国统一的最大障碍。</p></li></ul></li><li><p>牢牢把握两岸关系主导权和主动权：</p><ul><li>和平统一、一国两制是最佳方式。</li><li>促进两岸经济文化交流合作，深化各领域融合发展。</li><li>决不承诺放弃使用武力。</li></ul></li></ol><h2 id="外交">16. 外交</h2><ol type="1"><li><p>百年未有之大变局：</p><ul><li>国际力量对比深刻变化。</li><li>新一轮科技革命和产业变革深入发展。</li><li>国际体系和国际秩序深度调整。</li></ul></li><li><p>中国特色大国外交：</p><ul><li>建立在正确历史观、大局观、角色观基础上。</li><li>牢牢把握服务民族复兴、促进人类进步这条主线。</li><li>坚持正确的原则要求。<ul><li>党的领导。</li><li>中国特色社会主义为根本。</li><li>相互尊重、合作共赢为基础。</li><li>公平公正为理念。</li><li>国家核心利益为底线。</li></ul></li></ul></li><li><p>中国外交的宗旨：外交为民。</p><p>周边居于外交全局的首要位置。</p></li><li><p>和平发展道路：</p><ul><li>为什么走和平发展道路：<ul><li>由中国共产党性质宗旨和我国社会主义制度决定。</li><li>基于中国历史文化传统作出的必然选择。</li><li>符合历史潮流、顺应时代大势。</li></ul></li><li>走和平发展道路的政治主张：<ul><li>独立自主的和平外交政策。</li><li>既要通过维护世界和平发展自己，又要通过自身发展维护世界和平。</li></ul></li></ul></li><li><p>推动构建人类命运共同体，是当代中国共产党人回答和解决关乎人类前途命运的时代之问的中国方案，是应对人类共同挑战、建设更加繁荣美好世界的人间正道，也是新时代对外工作的总目标。</p><p>构建人类命运共同体，就是要携手世界各国人民共同建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界。</p></li><li><p>和平、发展、公平、正义、民主、自由，是全人类的共同价值，也是联合国的崇高目标。</p><ul><li>全人类共同价值与西方普世价值存在区别。</li><li>发展是人类社会永恒的主题。</li><li>安全是发展的前提，是人类最基本最普遍的愿望。</li><li>文明多样性是世界的基本特征，也是人类进步的源泉。</li></ul></li><li><p>要秉持共商共建共享的全球治理观，坚持真正的多边主义，推动全球治理体系朝着更加公平合理的方向发展，积极做全球治理变革进程的参与者、推动者、引领者。</p></li><li><p>一带一路倡议的初心，是以互联互通为主线，同各国加强政策沟通、设施联通、贸易畅通、资金融通、民心相通，为世界经济增长注入新动能，为全球发展开辟新空间，为国际经济合作打造新平台。</p></li></ol><h2 id="治党">17. 治党</h2><ol type="1"><li><p>全面从严治党是党永葆生机活力、走好新的赶考之路的必由之路，是新时代党的建设的鲜明主题。</p><ul><li>加强党的自身建设是新形势下推进伟大事业、进行伟大斗争、实现伟大梦想的必然要求。</li><li>加强党的自身建设是把党锻造成为坚强有力的马克思主义执政党的迫切需要。</li></ul><p>全面从严治党的核心是加强党的领导，基础在全面，关键在严，要害在治。</p><p>全面从严治党的重要经验：六个统一</p><ul><li>坚持思想建党和制度治党相统一。</li><li>坚持使命引领和问题导向相统一。</li><li>坚持抓“关键少数”和管“绝大多数”相统一。</li><li>坚持行使权力和担当责任相统一。</li><li>坚持严格管理和关心信任相统一。</li><li>坚持党内监督和群众监督相统一。</li></ul></li><li><p>党的建设：</p><ul><li>政治建设在首位，首要任务是保证全党服从中央，维护党中央权威和集中统一领导。</li><li>思想建设是基础性建设。</li><li>组织建设：严密党的组织体系是重点；建设高素质专业化干部队伍是关键。</li></ul><p>加强纪律建设是全面从严治党的治本之策。</p><p>制度建设：党内法规是全面从严治党的重要制度支撑；重点解决有规不依、落实不力的问题。</p></li><li><p>腐败是危害党的生命力和战斗力的最大毒瘤，对党的执政基础破坏力最大、杀伤力也最大，是党长期执政面临的最大威胁。反腐败是最彻底的自我革命。</p></li><li><p>勇于自我革命是中国共产党区别于其他政党的显著标志。</p><ul><li>勇于自我革命的重要途径：自我净化、自我完善、自我革新、自我提高。</li></ul><p>中国共产党的百年奋斗史就是一部伟大自我革命和伟大社会革命相互促进的历史。</p><p>以伟大自我革命引领伟大社会革命是新时代中国特色社会主义发展的显著特点。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>习近平新时代中国特色社会主义理论概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>习概_布局安排</title>
    <link href="/2024/09/03/%E4%B9%A0%E6%A6%82/%E5%B8%83%E5%B1%80%E5%AE%89%E6%8E%92/"/>
    <url>/2024/09/03/%E4%B9%A0%E6%A6%82/%E5%B8%83%E5%B1%80%E5%AE%89%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1 id="布局安排">布局安排</h1><h2 id="经济">6. 经济</h2><p>新发展理念、新发展格局、社会主义基本经济制度、现代化经济体系、乡村振兴</p><h3 id="新发展理念">新发展理念</h3><ol type="1"><li><p>我国经济进入新发展阶段：</p><ul><li>“三期叠加”：我国当前经济发展正处于增长速度换挡期、结构调整阵痛期、前期刺激政策消化期叠加的阶段，进入了新常态。</li><li>我国经济已由高速增产阶段转向高质量发展阶段。</li></ul></li><li><p>新发展理念：创新、协调、绿色、开放、共享。</p><ul><li><p>创新是引领发展的第一动力。</p></li><li><p>协调是持续健康发展的内在要求。</p></li><li><p>绿色是永续发展的必要条件和人民对美好生活追求的重要体现。</p></li><li><p>开放是国家繁荣发展的必要之路。</p></li><li><p>共享是中国特色社会主义的本质要求。</p></li><li><p>怎样贯彻新发展理念：从根本宗旨上、问题导向上、忧患意识上把握新发展理念。</p></li></ul></li><li><p>高质量发展是体现新发展理念的发展。</p><ul><li>高质量发展是全面建设社会主义现代化国家的首要要求，是遵循经济规律发展的必然要求。</li><li>高质量发展的含义：<ul><li>能够很好满足人民日益增长的美好生活需要的发展。</li><li>体现新发展理念的发展。</li><li>从有没有转向好不好的发展。</li></ul></li><li>高质量发展的重大战略意义：<ul><li>为全面建设社会主义现代化国家提供更为坚实的物质基础。</li><li>是不断满足人民对美好生活需要的重要保证。</li><li>是维护国家长治久安的必然要求。</li></ul></li><li>高质量发展的战略导向：<ul><li>一方面，要更好统筹质的有效提升和量的合理增长。</li><li>另一方面，要保持经济社会发展稳定性坚持稳中求进工作总基调。</li></ul></li><li>高质量发展的历史性成就：我国进入创新型国家行列。</li></ul></li><li><p>高质量发展的相关论点：</p><ul><li>加快实现高水平科技自立自强，是推动高质量发展的必由之路。</li><li>加快构建新发展格局，是推动高质量发展的战略基点。</li><li>农业强国是社会主义现代化强国的根基，推进农业现代化是高质量发展的必然要求。</li><li>人民幸福安康市推动高质量发展的最终目的。</li></ul></li><li><p>发展新质生产力是推动高质量发展的内在要求和重要着力点。</p></li><li><p>新发展格局：以国内大循环为主体、国内国际双循环相互促进。</p><ul><li><p>原因：</p><ul><li><p>国际政治经济形势剧变下，必须进一步把发展立足点放在国内，更多依靠国内市场实现经济发展。</p></li><li><p>党提出构建新发展格局，是对我国客观经济规律和发展趋势的自觉把握。</p></li></ul></li><li><p>新发展格局是开放的国内国际双循环，不是国内单循环，更不是各地小循环。</p></li><li><p>如何构建新发展格局：</p><ul><li><p>具备强大的国内经济循环体系和稳固的基本盘。</p></li><li><p>发挥比较优势，以国内大循环吸引全球资源要素。</p></li><li><p>保证经济循环畅通无阻，生产、分配、流通、消费各环节有机衔接。</p></li><li><p>构建新发展格局的举措：</p><ul><li><p>推动实施扩大内需战略同深化供给侧结构性改革有机结合。</p></li><li><p>发展实体经济。</p></li><li><p>加快科技自立自强。</p></li><li><p>推动产业链供应链优化升级。</p></li></ul></li></ul></li></ul></li></ol><h3 id="经济制度">经济制度</h3><ol type="1"><li><p>社会主义基本经济制度：公有制为主体、多种所有制共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等。</p><ul><li><p>社会主义基本经济制度的新概括包含了所有制、分配制、资源配置体制等方面。</p><ul><li><p>所有制结构是基本经济制度的基础，决定分配方式和资源配置方式。</p></li><li><p>合理有效的分配方式和资源配置方式有利于进一步完善所有制结构。</p></li><li><p>这三个方面是经济制度体系中具有长期性和稳定性的部分，起着规范方向的作用，对经济制度属性和经济发展方式有决定性影响，是新时代推动经济高质量发展的制度支撑。</p></li></ul></li></ul></li><li><p>所有制：两个毫不动摇</p><ul><li><p>公有制经济和非公有制经济都是社会主义市场经济的重要组成部分，都是我国经济社会发展的重要基础。要毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展。</p></li><li><p>公有制经济包括国有经济和集体经济、混合所有制经济中的国有成分和集体成分。</p><ul><li>国有企业是中国特色社会主义的重要物质基础和政治基础，是我们党执政兴国的重要支柱和依靠力量。</li></ul></li><li><p>非公有制经济包括个体经济、私营经济、港澳台投资经济、外商投资经济以及混合所有制经济中的非国有成分和非集体成分。</p><ul><li>非公有制经济是社会主义市场经济的重要组成部分，是稳定经济的重要基础，是国家税收的重要来源，是就业创业的重要领域，是技术创新的重要主体，是金融发展的重要依托，是经济持续发展的重要力量。</li><li>民营经济是非公有制经济的主要经济组织形式，是推进中国式现代化的主力军，是高质量发展的重要基础，是推动我国全面建成社会主义现代化强国、实现第二个百年奋斗目标的重要力量。</li></ul></li></ul></li><li><p>分配制：按劳分配为主体、多种分配方式并存。</p><ul><li>所有制决定分配制。</li><li>分配制是促进共同富裕的基础性制度。<ul><li>发挥初次分配的基础性作用。</li><li>发挥再分配的调节作用。</li><li>建立健全第三次分配机制，引导公益慈善事业。</li></ul></li></ul></li><li><p>构建高水平社会主义社会主义市场经济体制，关键是要处理好政府和市场的关系。</p><ul><li>把市场能有效调节的经济活动交给市场。</li><li>政府管好那些市场管不了或管不好的事情。</li></ul></li><li><p>建设现代化产业体系：</p><ul><li>巩固优势产业领先地位。保持优势产业的领先地位是支撑我国国际竞争力的基石。</li><li>大力发展战略性新兴产业。战略性新兴产业是引领国家未来产业发展的决定性力量。</li><li>构建优势高效的服务业新体系。现代服务业是现代产业体系的重要支撑。</li><li>发展现代流通产业。</li><li>加快发展数字经济。数字化是新的时代特征。</li><li>构建现代化基础设施体系。基础设施是经济社会发展的重要支撑。</li></ul></li><li><p>全面建设社会主义现代化强国，最艰巨繁重的任务仍然在农村，最广泛最深厚的基础依然在农村。</p></li><li><p>全面推进乡村振兴：</p><ul><li>总目标：农业农村现代化。</li><li>总方针：农业农村优先发展。</li><li>总要求：产业兴旺、生态宜居、乡风文明、治理有效、生活富裕。</li><li>具体举措：头等大事是保障粮食和重要农产品稳定安全供给。</li></ul></li><li><p>区域协调发展是贯彻新发展理念的重要内容，也是实现高质量发展的必然要求。</p></li></ol><h2 id="科教">7. 科教</h2><ol type="1"><li><p>教育、科技、人才是全面建设社会主义现代化国家的基础性、战略性支撑。</p><ul><li><p>全面建设社会主义现代化国家，教育是根本，科技是关键，人才是基础。</p></li><li><p>必须坚持科技是第一生产力，人才是第一资源，创新是第一动力。</p></li><li><p>坚持教育优先发展、科技自立自强、人才引领驱动，加快教育强国、科技强国、人才强国。</p><ul><li><p>教育优先发展重在夯实人力资源深度开发基础。</p></li><li><p>科技自立自强重在坚持独立自主开拓创新。</p></li><li><p>人才引领驱动重在巩固发展优势赢得竞争主动。</p></li><li><p>我国已建成世界上规模最大的教育体系，进入创新型国家行列，发展成为全球规模最宏大、门类最齐全的人才资源大国。</p></li></ul></li></ul></li><li><p>科教兴国战略，就是要全面落实科学技术是第一生产力的思想。</p><ul><li>科教兴国是我国的基本国策。</li></ul><p>创新驱动发展战略，就是要坚持创新是第一动力，</p><ul><li>创新在国家发展全局中居于核心位置。</li></ul><p>人才强国战略，就是要牢固树立人才资源是第一资源的理念。</p></li><li><p>建设教育强国是全面建成社会主义现代化强国的战略先导，是实现高水平科技自立自强的重要支撑，是促进全体人民共同富裕的有效途径，是以中国式现代化全面推进中华民族伟大复兴的基础工程：</p><ul><li>必须坚持教育为人民服务，为党治国理政服务。</li><li>坚持党对教育方针的全面领导是办好教育的根本保证。</li><li>坚持根据中国国情办教育。</li></ul><p>落实立德树人根本任务，必须着力解决好培养什么人、怎样培养人、为谁培养人的问题，这是教育的根本问题，也是建设教育强国的核心课题。</p><ul><li>培养什么人：社会主义建设者和接班人。</li><li>怎样培养人：系统思维，整体规划各个环节，整合各种资源，统筹多方力量。</li></ul></li><li><p>办好人民满意的教育：</p><ul><li>大力促进教育公平。</li><li>加快建设高质量教育体系。</li><li>提升教育服务经济社会发展能力。</li><li>坚持深化教育改革创新。</li><li>坚持把教师队伍建设作为基础工作。</li></ul></li><li><p>自主创新，就是从增强国家创新能力出发，加强原始创新、集成创新和开放创新，确保国家拥有自主可控的科技创新能力。</p><ul><li><p>抓住了自主创新，就抓住了科学技术发展的战略基点，抓住了结构调整和增长方式改变的中心环节，抓住了把握战略机遇期、实现经济长期稳定较快发展的关键。</p></li><li><p>我国面临的很多卡脖子问题，根子是基础理论研究跟不上。</p></li></ul></li><li><p>人才是人力资源中能力和素质较高的劳动者，在国家发展中具有重要战略地位，已经成为推动社会发展最活跃、最积极的因素。</p></li><li><p>做好人才工作：</p><ul><li>根本保证：坚持党对人才工作的全面领导。</li><li>重要保障：坚持深化人才发展体制机制改革。</li><li>社会条件：坚持营造识才爱才敬才用才的环境。</li></ul></li></ol><h2 id="民主">8. 民主</h2><ol type="1"><li><p>全过程人民民主是社会主义民主政治的本质属性。</p><ul><li>实现了过程民主和成果民主、程序民主和实质民主、直接民主和间接民主、人民民主和国家意志相统一。</li><li>全过程人民民主是最广泛、最真实、最管用的民主。</li><li>人民代表大会制度是实现全过程人民民主的重要载体。</li></ul></li><li><p>中国特色社会主义政治制度是中国共产党带领人民在革命、建设、改革的长期实践中形成的，集中体现了我国人民民主的本质属性，是保证人民当家做主科学有效的制度安排。</p><p>中国特色社会主义政治制度构成：根本政治制度、基本政治制度、重要政治制度等。</p><p>党的领导是人民当家做主和依法治国的根本保证，人民当家做主是社会主义民主政治的本质特征，依法治国是党领导人民治理国家的基本方式。</p></li><li><p>人民代表大会制度是我国的根本政治制度。</p><ul><li>是符合我国国情与实际、体现社会主义国家性质、保证人民当家做主、保障实现中华民族伟大复兴的好制度，是我们党在人类政治制度史上的伟大创造。</li></ul><p>中国共产党领导的多党合作和政治协商制度、民族区域自治制度以及基层群众自治制度构成了我国的基本政治制度。</p><ul><li>中国人民政治协商会议是实行中国共产党领导的多党合作和政治协商制度的重要机构。</li><li>民族区域自治制度是中国特色解决民族问题的正确道路的重要内容和制度保障。</li><li>基层群众自治制度是社会主义民主政治建设的基础。<ul><li>要实现人民自我管理、自我服务、自我教育、自我监督。</li></ul></li></ul></li><li><p>协商民主：在决策前和决策实施中开展广泛协商。</p><ul><li>保证和支持人民当家做主，通过依法选举、让人民代表来参与国家生活和社会生活的管理是十分重要的，通过选举以外的制度和方式让人民参与国家生活和社会生活的管理也是十分重要的。</li><li>政党协商、人大协商、政府协商、政协协商、人民团体协商、基层协商、社会组织协商。</li></ul></li><li><p>基层民主的形式：村民委员会、居民委员会等。</p><p>发展基层民主，是实现人民有效政治参与的重要渠道，是人民当家做主的有效途径，是社会主义民主最广泛的实践。</p></li><li><p>爱国统一战线：</p><ul><li>统战工作的本质要求是大团结大联合，解决的就是人心和力量问题。</li><li>统战工作的关键是要坚持求同存异。</li><li>统战是为了壮大共同奋斗的力量。</li><li>坚持党的领导是统战最根本最核心的问题。</li></ul></li><li><p>民族团结是我国各族人民的生命线，中华民族共同体意识是民族团结之本。</p><ul><li>对中华民族形成起决定作用的是对中华民族共同体的认可。</li><li>宗教工作本质上是群众工作。</li></ul></li><li><p>海外儿女大团结：</p><ul><li>高举爱国主义、社会主义旗帜。</li><li>抓好重点领域统战工作。</li><li>辩证把握四方面关系：<ul><li>固守圆心和扩大共识。</li><li>潜绩和显绩。</li><li>原则性和灵活性。</li><li>团结和斗争。</li></ul></li></ul></li></ol><h2 id="法治">9. 法治</h2><ol type="1"><li><p>法律是治国理政最大最重要的规矩。</p><p>党的十八大以来，全面依法治国总体格局基本形成。</p></li><li><p>全面依法治国是坚持和发展中国特色社会主义的本质要求和重要保障。</p></li><li><p>全面依法治国的唯一正确道路是中国特色社会主义法治道路。</p><ul><li><p>核心要义：坚持党的领导，坚持中国特色社会主义制度，贯彻中国特色社会主义法治理论。</p><ul><li>党的领导是社会主义法治的根本保证。</li><li>中国特色社会主义制度是中国特色社会主义法治体系的根本制度基础，是全面推进依法治国的根本制度保障。</li><li>中国特色社会主义法治理论是全面推进依法治国的行动指南。</li></ul></li><li><p>中国特色社会主义法治道路的基本原则：</p><ul><li>坚持中国共产党领导。</li><li>坚持以人民为中心。</li><li>坚持法律面前人人平等。</li><li>坚持依法治国和以德治国相结合。</li><li>坚持从中国实际出发。</li></ul></li><li><p>全面依法治国的重大关系：</p><ul><li><p>政治和法治的关系：</p><p>党和法的关系是政治和法治关系的集中反映，是全面依法治国的一个根本问题。</p><p>党的领导和社会主义法治是一致的，社会主义法制必须坚持党的领导，党的领导必须依靠社会主义法治。</p></li><li><p>改革和法治的关系：</p><p>法治下改革，改革中完善法治。深化改革离不开法律规范，法治建设紧跟改革开放步伐。</p></li><li><p>依法治国和以德治国的关系：</p><p>既重视发挥法律的规范作用，又重视发挥道德的教化作用，以法治体系道德理念、强化法律对道德建设的促进作用，以道德滋养法治精神、强化道德对法治文化的支撑作用。</p></li><li><p>依法治国和依规治党的关系。</p></li></ul></li><li><p>全面推进依法治国的总抓手是建设中国特色社会主义法治体系。</p></li></ul></li><li><p>宪法是国家的根本法，是治国安邦的总章程，是党和人民意志的体现，是国家各种制度和法律法规的总依据，具有最高的法律地位、法律权威、法律效力。</p><ul><li>坚持依宪治国、依宪执政要求：必须坚持党的领导和国体、政体不动摇；必须全面贯彻实施宪法。</li></ul></li><li><p>建设法治中国的总目标：</p><p>实现法律规范科学完备统一，执法司法公正高效权威，权力运行受到有效制约监督，人民合法权益得到充分尊重保障，法治信仰普遍确立，法治国家、法治政府、法治社会全面建成。</p><ul><li>到2025年，中国特色社会主义法治体系初步形成。</li><li>到2035年，法治国家、法治政府、法治社会基本建成，中国特色社会主义法治体系基本形成，人民平等参与、平等发展权利得到充分保障，国家治理体系和治理能力现代化基本实现。</li></ul></li><li><p>法治中国建设的工作布局：</p><ul><li>坚持依法治国、依法执政、依法行政共同推进。</li><li>坚持法治国家、法治政府、法治社会一体建设。<ul><li>法治国家是法治建设的目标。</li><li>法治政府建设是全面依法治国的重点任务和主体工程。</li><li>法治社会是构筑法治国家的基础。</li></ul></li><li>坚持统筹推进国内法治和涉外法治。</li></ul></li><li><p>建设更高水平法治中国的四个方面：</p><ul><li>完善以宪法为核心的中国特色社会主义法律体系。</li><li>扎实推进依法行政。</li><li>严格公正司法。</li><li>加快建设法治社会。</li></ul></li></ol><h2 id="文化">10. 文化</h2><ol type="1"><li><p>文化是一个国家、一个民族的灵魂。文化繁荣兴盛是实现中华民族伟大复兴的必然要求：</p><ul><li>文化繁荣兴盛是实现中华民族伟大复兴的精神支撑。</li><li>文化繁荣兴盛是建设社会主义现代化强国的应有之义。</li><li>文化繁荣兴盛是满足人民日益增长的美好生活需要的内在要求。</li><li>文化繁荣兴盛是在世界文化激荡中站稳脚跟的前提基础。</li></ul><p>建设社会主义文化强国、推动社会主义文化繁荣兴盛，关键在于坚定中国特色社会主义文化自信。</p><ul><li>文化自信的依据和来源：<ul><li>深厚基础：中华优秀传统文化。</li><li>坚强基石：党在带领人民在伟大斗争中孕育的革命文化和社会主义先进文化。</li><li>现实基础：中国特色社会主义伟大实践。</li></ul></li></ul><p>中国特色社会主义文化发展道路：</p><ul><li>坚持为人民服务、为社会主义服务的根本方向，是决定社会主义文化事业前途命运的关键。</li><li>坚持百花齐放、百家齐鸣，是繁荣发展社会主义文化的重要方针。</li><li>激发全民族文化创新创造活力。<ul><li>创新创造是文化的生命所在，是文化的本质特征。</li></ul></li></ul></li><li><p>建设具有强大凝聚力和引领力的社会主义意识形态：</p><ul><li>为什么要坚持马克思主义在意识形态领域指导地位的根本制度：<ul><li>这是历史的结论。</li><li>这是坚持和巩固我国社会主义制度、保证我国文化建设正确方向的必然要求。</li></ul></li><li>如何大力加强马克思主义理论建设：<ul><li>坚持用马克思主义，特别是中国化时代化的马克思主义武装全党、教育人民、指导实践。</li><li>深化马克思主义理论研究和建设。</li><li>加快构建中国特色哲学社会科学，坚持以马克思主义为指导，是当代中国哲学社会科学区别于其他哲学社会科学的根本标志。</li></ul></li><li>积极塑造主流舆论新格局：<ul><li>坚持正确的政治方向。<ul><li>党性原则是新闻舆论工作的根本原则。</li><li>坚持党性原则最根本的是坚持党对新闻舆论工作的领导。</li></ul></li><li>做大做强主流舆论阵地。</li><li>管好用好互联网是关键。<ul><li>互联网是意识形态工作的主阵地、主战场、最前沿。</li></ul></li></ul></li></ul></li><li><p>如何传承中华优秀传统文化：</p><ul><li>深刻把握中华文明的突出特性：连续性、创新性、统一性、包容性、和平性。</li><li>推动中华优秀传统文化创造性转化、创新性发展。</li><li>保护好、传承好文化遗产。</li></ul></li><li><p>繁荣发展文化事业和文化产业，是满足人民精神文化需求、保障人民文化权益的基本途径：</p><ul><li>把为人民服务作为文艺工作者的天职。<ul><li>中国精神是社会主义文艺的灵魂。</li></ul></li><li>文化产业在促进国民经济发展、满足人民文化需求等方面发挥着重要作用。<ul><li>衡量文化产业发展质量和水平，最重要的不是看经济效益，而是看能不能提供更多既能满足人民文化需求、又能增强人民精神力量的文化产品。</li></ul></li></ul></li><li><p>文化软实力集中体现了一个国家基于文化而具有的凝聚力和生命力，以及由此产生的吸引力和影响力。</p><ul><li>一个国家的文化软实力，根本上取决于其核心价值观的生命力、凝聚力、感召力。</li><li>讲好中国故事、传播好中国声音，根本在于传播理念，以我为主，以理服人，以情动人。</li></ul></li></ol><h2 id="民生">11. 民生</h2><ol type="1"><li><p>全面建设社会主义现代化国家，出发点和落脚点是让人民生活越过越好。</p><p>增进民生福祉是发展的根本目的。</p><ul><li>增进民生福祉是坚持立党为公、执政为民的本质要求。</li><li>增进民生福祉是社会主义生产的根本目的。</li><li>增进民生福祉是全面建设社会主义现代化国家的应有之义。</li></ul><p>要坚持在发展中增进民生福祉：</p><ul><li><p>发展是改善民生的物质基础，抓民生也是抓发展。</p></li><li><p>工作思路：坚守底线、突出重点、完善制度、引导预期。</p></li><li><p>重中之重：解决人民群众最关系最直接最现实的利益问题。</p></li><li><p>重要方针：坚持尽力而行、量力而行。</p></li><li><p>重要原则：坚持人人尽责、人人享有，让所有劳动者在推动发展中分享发展成果。</p></li></ul></li><li><p>就业是最基本的民生，是劳动者赖以生存和发展的基础、共享经济发展成果的基本条件，关系到亿万劳动者及其家庭的切身利益。</p></li><li><p>新时代加强社会建设的重要着力点就是健全和完善社会保障体系。</p><ul><li><p>我国基本建成以社会保险为主体、功能完备的社会保障体系，但仍存在不足：</p><p>要完善覆盖全民、统筹城乡、公平统一、安全规范、可持续的多层次社会保障体系。</p></li></ul></li><li><p>加强和创新社会治理，就是要在党的领导下，以政府为主导，以社会多元主体参与为基础，以维护人民群众根本利益为核心，通过合作、对话、协商、沟通等方式，依法对社会事务、社会组织和社会生活进行引导和规范，协调社会矛盾，化解社会矛盾，促进社会公平，推进社会稳定有序发展。</p><p>社会治理体系是进行社会治理的基础，也是提高社会治理效能的保障。</p><ul><li>社会治理理念：共建、共治、共享。<ul><li>共建是基础，共治是关键，共享是目标。</li></ul></li></ul></li></ol><h2 id="生态">12. 生态</h2><ol type="1"><li><p>生态环境是人类生存最为基础的条件，生态文明建设是关系中华民族永续发展的根本大计。</p><p>大自然是人类赖以生存发展的基本条件，尊重自然、顺应自然、保护自然是全面建设社会主义现代化国家的内在要求。</p><p>生态环境问题归根到底是经济发展方式和生活方式问题。</p><p>绿水青山就是金山银山，这是重要的发展理念。</p><ul><li>生态环境保护和经济发展是辩证统一、相辅相成的关系。</li><li>处理好绿水青山和金山银山的关系，关键在人，关键在思路。</li></ul><p>生态文明建设是重大经济问题，也是关系党的使命宗旨的重大政治问题、关系民生福祉的重大社会问题，我国开展的一系列工作：</p><ul><li>生态文明建设战略地位更加凸显。</li><li>生态文明制度体系更加健全。</li><li>污染防治和生态保护更加有力。</li></ul></li><li><p>绿色发展，就其要义来讲，是要解决好人与自然和谐共生问题。</p><p>要加快推动发展方式绿色低碳转型，坚持把绿色低碳发展作为解决生态环境问题的治本之策。</p><ul><li>生态环境问题，归根到底是资源过度开发、粗放利用、奢侈浪费造成的。</li><li>要处理好双碳承诺和自主行动的关系，目标确定，但是路径、节奏是自主的。</li></ul></li><li><p>用最严格制度最严密法治保护生态环境：</p><ul><li>实行最严格的生态环境保护制度。</li><li>全面建立资源高效利用制度。</li><li>严明生态环境保护责任制度。</li></ul></li><li><p>如何共建清洁美丽世界：</p><ul><li>坚持以人为本。</li><li>坚持科学治理。</li><li>坚持多边主义。</li><li>坚持共同但有区别的责任原则。</li></ul></li><li><p>如何推动全球可持续发展：</p><ul><li>积极参与全球气候治理。</li><li>积极推进全球生物多样性治理。</li><li>积极打造绿色一带一路。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>习近平新时代中国特色社会主义理论概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>习概_基本问题</title>
    <link href="/2024/09/02/%E4%B9%A0%E6%A6%82/%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/02/%E4%B9%A0%E6%A6%82/%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1 id="基本问题">基本问题</h1><h2 id="中国特色社会主义">1. 中国特色社会主义</h2><h3 id="方向决定道路道路决定命运">方向决定道路，道路决定命运</h3><ol type="1"><li><p>一个国家实行什么样的主义，关键要看这个主义能否解决这个国家面临的历史性课题。</p><ul><li>中国特色社会主义具有广泛的现实基础，是历史的结论、人民的选择。</li><li>中国特色社会主义既坚持了科学社会主义基本原则，又根据时代条件赋予其鲜明的中国特色。</li></ul></li><li><p>四个自信：道路自信、理论自信、制度自信、文化自信</p><ul><li><p>改革开放以来我们取得一切成绩和进步的根本原因，归结起来就是开辟了中国特色社会主义道路，形成了中国特色社会主义理论体系，确立了中国特色社会主义制度，发展了中国特色社会主义文化。</p><ul><li>中国特色社会主义道路是实现途径，理论体系是行动指南，制度是根本保障，文化是精神力量，四者统一于中国特色社会主义伟大实践。</li></ul></li><li><p>四个自信来源于实践、来源于人民、来源于真理。</p></li><li><p>四个自信的坚实根基是深厚的实践基础和人民的广泛参与、深切认同。</p></li><li><p>四个自信的理论支撑和根本依据是社会主义必然代替资本主义的客观规律。</p></li><li><p>四个自信的根基和底气：</p><ul><li>我们有中国共产党的领导，这是中国特色社会主义最本质的特征、中国特色社会主义制度的最大优势。</li><li>我们有新中国成立、改革开放以来特别是党的十八大以来形成的更为完善的制度保证、更为坚实的物质基础、更为主动的精神力量，这是中国特色社会主义独具的发展优势。</li><li>我们有连绵不绝的五千年中华文明，这是中国特色社会主义的文化根脉和突出优势。</li></ul></li><li><p>坚持道路自信、理论自信、制度自信，说到底是要坚持文化自信。文化自信是更基础、更广泛、更深厚的自信，是一个国家、一个民族发展中最基本、最深沉、最持久的力量。</p></li></ul></li></ol><h3 id="中国特色社会主义新时代">中国特色社会主义新时代</h3><ol type="1"><li><p>中国特色社会主义新时代是我国发展新的历史方位，标志着中国特色社会主义事业进入新的发展阶段。</p><ul><li>2012年党的十八大开启了中国特色社会主义新时代。</li><li>主要依据：<ul><li><p>我国社会主要矛盾发生新变化，这是基本依据。</p></li><li><p>党的主要任务发生新变化。</p></li><li><p>中国和世界关系发生新变化。</p></li><li><p>中国特色社会主义新时代的内涵：</p><ul><li>是承前启后、继往开来，在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代。</li><li>是决胜全面建成小康社会，进而全面建设社会主义现代化强国的时代。</li><li>是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代。</li><li>是全体中华儿女戮力同心、奋力实现中华民族伟大复兴中国梦的时代。</li><li>是我国不断为人类作出更大贡献的时代。</li></ul></li><li><p>重大意义：</p><ul><li><p>第一，从中华民族复兴的历史进程看，意味着近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的伟大飞跃，迎来了实现中华民族伟大复兴的光明前景。</p></li><li><p>第二，从科学社会主义发展进程看，意味着科学社会主义在21世纪的中国焕发出强大生机活力，在世界上高高举起了中国特色社会主义伟大旗帜。</p></li><li><p>第三，从人类文明进程看，意味着中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径，为解决人类问题贡献了中国智慧和中国方案。</p></li></ul></li></ul></li></ul></li><li><p>我国社会主要矛盾变化：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</p><ul><li><p>社会主要矛盾变化的依据：</p><ul><li><p>社会生产力水平总体上显著提高。</p></li><li><p>人民生活水平显著提高，对美好生活的向往更加强烈。</p></li><li><p>影响满足人们美好生活需要的因素主要是发展的不平衡不充分问题。</p></li><li><p>两个没有变：我国仍处于并将长期处于社会主义初级阶段的基本国情没有变，我国是世界上最大发展中国家的国际地位没有变。</p></li><li><p>新时代我国社会主要矛盾的变化，反映了社会发展的客观实际，明确了当代解决中国发展主要问题的根本着力点。</p></li></ul></li></ul></li><li><p>全面贯彻党的基本理论、基本路线、基本方略。</p><ul><li>党的基本理论是坚持和发展中国特色社会主义的行动指南。</li><li>党的基本路线是国家的生命线、人民的幸福线。</li><li>党的基本方略反映了党对中国特色社会主义的规律性认识。</li></ul></li><li><p>中国特色社会主义事业布局：“五位一体”总体布局和“四个全面”战略布局</p><ul><li><p>总体布局：经济建设、政治建设、文化建设、社会建设和生态文明建设五位一体，全面推进。</p></li><li><p>战略布局：全面建设社会主义现代化国家、全面深化改革、全面依法治国、全面从严治党。</p><ul><li>全面建设社会主义现代化国家是战略目标，居于引领地位；</li></ul></li><li><p>全面深化改革、全面依法治国、全面从严治党是战略举措，提供重要保障。</p></li></ul></li></ol><h2 id="中国式现代化">2. 中国式现代化</h2><h3 id="中国梦">中国梦</h3><ol type="1"><li><p>实现中华民族伟大复兴的中国梦，本质是国家富强、民族振兴、人民幸福。</p></li><li><p>2021年7月1日，习近平庄严宣告全面建成小康社会。</p><ul><li>伟大意义：<ul><li>践行了党为中国人民谋幸福、为中华民族谋复兴的初心使命。</li><li>第一个百年奋斗目标实现，中华民族实现了从大幅落后于时代到大踏步赶上时代的新跨越。</li><li>极大彰显了中国特色社会主义制度的优势。</li><li>探索了人类解决贫困问题的新路径，为推动人类文件进步作出了重大贡献。</li></ul></li></ul></li><li><p>党的二十大对全面建成社会主义现代化强国的战略安排：</p><ul><li>第一步，从2020年到2035年基本实现社会主义现代化。<ul><li>GDP达到中等发达国家水平。</li><li>实现高水平科技自立自强，进入创新型国家前列。</li><li>建成现代化经济体系，形成新发展格局。</li><li>建成教育、科技、人才、文化、体育、健康强国。</li><li>人的全面发展、全体人民共同富裕取得更为明显的实质性进展。</li><li>广泛形成绿色生产生活方式，生态环境根本好转。</li></ul></li><li>第二步，从2035年到21世纪中叶把我国建成富强民主文明和谐美丽的社会主义现代化强国。<ul><li>全体人民共同富裕基本实现。</li></ul></li></ul></li></ol><h3 id="中国式现代化-1">中国式现代化</h3><ol type="1"><li><p>中国式现代化是党领导人民长期实践的重大成果：</p><ul><li>新民主主义革命为实现现代化创造了根本社会条件。</li><li>社会主义革命和建设为现代化建设奠定了根本政治前提和制度基础，提供了宝贵经验、理论准备和物质基础。</li><li>改革开放和社会主义现代化建设为中国式现代化提供了充满活力的体制保证和快速发展的物质条件。</li><li>新时代提供了更为完善的制度保证、更为坚实的物质基础、更为主动的精神力量。<ul><li>习近平中国特色社会主义思想为中国式现代化提供了根本遵循；</li><li>“五位一体”总体布局和“四个全面”战略布局为中国式现代化提供坚实战略支撑；</li></ul></li></ul></li><li><p>中国式现代化的中国特色：</p><ul><li>人口规模巨大。这是中国式现代化的显著特征。</li><li>全体人民共同富裕。这是区别于西方现代化的显著标志。</li><li>物质文明和精神文明相协调。这是中国式现代化的崇高追求。</li><li>人与自然和谐共生。这是中国式现代化的鲜明特点。</li><li>走和平发展道路。这是中国式现代化的突出特征。</li></ul></li><li><p>中国式现代化的本质要求：坚持中国共产党的领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。</p><ul><li>为什么要强调党在中国式现代化建设中的领导地位：<ul><li>党的领导决定中国式现代化的根本性质。</li><li>党的领导确保中国式现代化锚定奋斗目标行稳致远。</li><li>党的领导激发建设中国式现代化的强劲动力。</li><li>党的领导凝聚建设中国式现代化的磅礴力量。</li></ul></li></ul></li><li><p>中国式现代化创造了人类文明新形态：</p><ul><li>提供了一种全新的现代化模式，是对西方现代化理论和实践的重大超越，为广大发展中国家提供了全新选择。</li></ul></li><li><p>推行中国式现代化的重大原则：</p><ul><li>坚持和加强党的全面领导</li><li>坚持中国特色社会主义道路</li><li>坚持以人民为中心的发展思想</li><li>坚持深化改革开放</li><li>坚持发扬斗争精神</li></ul></li><li><p>推行中国式现代化需要正确处理的关系：</p><ul><li>顶层设计与实践探索。</li><li>战略与策略。</li><li>守正与创新。</li><li>效率与公平。</li><li>活力与秩序。</li><li>自立自强与对外开放。</li></ul></li><li><p>推进中国式现代化必须团结奋斗：</p><ul><li>团结奋斗是中国共产党和中国人民最显著的精神标识，是中国人民创造历史伟业的必由之路。</li><li>中华民族是有着伟大团结奋斗精神的民族，团结奋斗的价值理念深深融入并影响着中国人的精神世界。</li><li>中国式现代化是一项伟大而艰巨的任务。</li></ul></li></ol><h2 id="坚持党的全面领导">3. 坚持党的全面领导</h2><ol type="1"><li>中国最大的国情就是中国共产党的领导：<ul><li>中国共产党的领导是在历史奋斗中形成的。</li><li>中国共产党的领导是人民当家做主的可靠保障。</li><li>中国共产党的领导关系中国特色社会主义的性质、方向和命运。</li><li>中国共产党的领导是实现中华民族伟大复兴的根本保证。</li></ul></li><li>为什么中国共产党是最高政治领导力量：<ul><li>中国共产党得到最广大人民群众的支持和拥护。</li><li>由我国国家性质和政治制度体系决定。</li><li>由中华民族伟大复兴事业决定。</li></ul></li><li>中国共产党的领导是全面的、系统的、整体的。</li><li>如何维护党的中央权威和集中统一领导：<ul><li>坚决贯彻党的理论、路线方针政策和党中央决策部署。</li><li>最关键的是坚决维护习近平同志党中央的核心、全党的核心地位。</li><li>维护党中央权威和集中统一领导，同坚持党的民主集中制是完全一致的。</li></ul></li><li>中国共产党的领导是国家治理体系的核心，党的领导制度是中国特色社会主义制度建设的关键。<ul><li>党的领导制度是中国特色社会主义制度的核心，是国家治理体系和治理能力现代化的关键。</li><li>如何健全党的全面领导制度：<ul><li>完善党在各种组织发挥领导作用的制度。</li><li>完善党协调各方的机制。</li><li>完善党领导各项事业的具体制度。</li></ul></li><li>1948年初，毛泽东为中共中央起草《关于建立报告制度》的党内指示，推动建立健全全党全军向党中央报告工作的制度，加强了党中央对重大工作的领导。</li></ul></li><li>中国共产党的领导是中国特色社会主义制度的最大优势：<ul><li>中国共产党以马克思主义为行动指南，在实践中不断推进马克思主义中国化时代化，为坚持和完善中国特色社会主义制度提供强大理论优势。</li><li>中国共产党的自身优势是中国特色社会主义制度优势的主要来源。</li><li>中国共产党能够集中全党力量、凝聚全民族共同意志，在各项事业中发挥总揽全局、协调各方的作用，确保中国特色社会主义制度的显著优势充分彰显。</li></ul></li></ol><h2 id="坚持以人民为中心">4. 坚持以人民为中心</h2><ol type="1"><li><p>坚持以人民为中心，是新时代坚持和发展中国特色社会主义的根本立场，是贯穿党治国理政全部活动的一条红线。</p><ul><li>党和国家事业取得历史性成就、发生历史性变革，根本原因就在于我们党始终坚守了为中国人民谋幸福、为中华民族谋复兴的初心和使命。</li></ul></li><li><p>人民立场是中国共产党的根本政治立场，这是我们党区别于其他政党的显著标志。</p><ul><li>坚持人民立场，就要始终牢记党的初心和使命。</li><li>坚持人民立场，就要始终保持党同人民群众的血肉联系。</li><li>坚持人民立场，就要热爱人民、尊重人民、敬畏人民。</li></ul></li><li><p>坚持人民至上是新时代党治国理政的根本价值取向。</p><ul><li><p>人民是党的工作的最高裁决者和最终评判者。</p></li><li><p>党永远要依靠人民创造新的历史伟业。</p><ul><li><p>必须尊重人民主体地位：中国共产党之所以能发展壮大，中国特色社会主义之所以能不断前进，正是因为依靠了人民。</p></li><li><p>必须尊重人民首创精神：正是因为充分尊重人民首创精神，最大程度激发人民的创造热情，党的事业才能保持与时俱进的活力。</p></li></ul></li></ul></li><li><p>群众路线是党始终坚持的根本工作方法，是党的生命线和根本工作路线。</p><ul><li>调查研究是贯彻群众路线的有效途径。</li></ul></li><li><p>共同富裕是中国特色社会主义的本质要求，是中国式现代化的重要特征。</p><ul><li>实现共同富裕是关系党的执政基础的重大政治问题。<ul><li>首先通过全国人民共同的奋斗把蛋糕做大做好，然后通过合理的制度安排正确处理增长和分配关系，把蛋糕切好分好。</li><li>其次，要从全局角度来把握共同富裕。</li><li>最后，要处理好先富和共富的关系</li></ul></li><li>必须坚持正确的原则和科学的思路。<ul><li>鼓励勤劳创新致富、坚持基本经济制度、尽力而为量力而行、坚持循序渐进的原则。</li></ul></li><li>推动全体人民共同富裕与促进人的全面发展是高度统一的。</li></ul></li></ol><h2 id="全面深化改革开放">5. 全面深化改革开放</h2><h3 id="改革开放">改革开放</h3><ol type="1"><li><p>改革开放是我们前进的重要法宝。</p><ul><li>改革开放是党和人民大踏步赶上时代的重要法宝。</li><li>改革开放是坚持和发展中国特色社会主义的必由之路。</li><li>全面深化改革开放是完成新时代目标任务的必然要求。</li></ul></li><li><p>改革开放是我们党的一次伟大觉醒，孕育了我们党从理论到实践的伟大创造。</p><p>改革开放是中国人民和中华民族发展史上的一次伟大革命，推动了中国特色社会主义事业的伟大飞跃。</p><p>改革开放是当代中国最显著的特征、最壮丽的气象，是决定当代中国命运的关键一招。</p></li><li><p>党的十一届三中全会是划时代的，开启了改革开放和社会主义现代化建设新时期；</p><p>党的十八届三中全会也是划时代的，实现改革从局部探索、破冰完成到系统集成、全面深化的转变，开创了我国改革开放新局面。</p></li><li><p>新时代全面深化改革开放，就其艰巨性、复杂性和系统性来说，是一场深刻的革命。</p><ul><li><p>全面深化改革开放的基本思路：</p><ul><li>必须勇于破除一切不合时宜的思维定势和固有观念。</li><li>必须勇于打破部门利益、行业利益、本位思想。</li><li>必须勇于跳出条条框框限制。</li><li>必须勇于破解我国开放型经济体制建设中的突出问题。</li></ul></li><li><p>全面深化改革开放是一场全面、系统、整体的制度创新：</p><ul><li><p>全面深化改革开放是一场思想理论的深刻变革、改革组织方式的深刻变革、国家制度和治理体系的深刻变革、人民广泛参与的深刻变革。</p></li><li><p>坚持以供给侧结构性改革为主线，加快建设现代化经济体系。</p></li></ul></li></ul></li><li><p>全面深化改革开放的正确方向：</p><ul><li>坚持和改善党的领导、坚持和完善中国特色社会主义制度。</li><li>坚持以人民为中心，促进社会公平正义、增进人民福祉。<ul><li>社会主义改革开放的出发点和落脚点，是为了更好实现和维护人民利益、为了让人民过上好日子。</li></ul></li><li>必须有利于进一步解放思想、进一步解放和发展生产力、进一步解放和增强社会活力。<ul><li>解放思想，是开启改革开放事业的思想前提。</li><li>解放和发展生产力，是改革开放的鲜明特征和首要任务。</li><li>解放和增强社会活力，是社会主义改革的内在要求和基本目的，也是新时代全面深化改革的关键所在。</li><li>三个“进一步”，既是改革的目的，也是改革的条件。</li></ul></li></ul></li></ol><h3 id="统筹推进">统筹推进</h3><ol type="1"><li><p>全面深化改革的总目标：完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化。</p><ul><li><p>改革的根本方向是完善和发展中国特色社会主义制度。</p></li><li><p>改革的鲜明指向和时代要求是推进国家治理体系和治理能力现代化。</p></li><li><p>统筹推进各领域各方面改革开放，必须以全面深化改革总目标为引领，以制度建设为主线，以经济体制改革为重点，以重要领域和关键环节改革为突破口。</p></li></ul></li><li><p>国家治理体系是管理国家的制度体系，国家治理能力是运用国家制度管理社会的能力。</p><ul><li>国家治理体系和能力是一个国家制度和执行能力的集中体现，是相辅相成的。</li><li>怎样推进国家治理体系和治理能力现代化：<ul><li>必须坚定中国特色社会主义制度自信。</li><li>必须更好发挥中国特色社会主义制度自信。</li><li>必须把中国特色社会主义制度优势转化为国家治理效能。</li></ul></li></ul></li><li><p>全面深化改革开放的正确方法论：</p><ul><li>增强全面深化改革的系统性、整体性、协同性。</li><li>加强顶层设计和摸着石头过河相结合。</li><li>统筹改革发展稳定。<ul><li>改革是经济社会发展的强大动力，发展是解决一切经济社会问题的关键，稳定是改革发展的前提。</li></ul></li><li>胆子要大，步子要稳。</li><li>坚持重大改革于法有据。</li></ul></li><li><p>改革开放永无止境。全面深化改革开放，是新时代坚持和发展中国特色社会主义的根本动力。</p><ul><li>改革开放永无止境是社会基本矛盾运动规律的深刻反映。<ul><li>改革开放以来，我国经济社会发展取得重大成就，根本原因就是改革调整生产关系，完善上层建筑，使之适应我国生产力发展的要求，激发我国社会发展的强大活力。</li></ul></li><li>改革开放永无止境是总结世界社会主义实践经验得出的重要结论。</li><li>改革开放永无止境是推进党和人民事业发展的必然要求。</li></ul></li><li><p>开放也是改革。</p><ul><li>开放带来进步，封闭必然落后。</li><li>构建更高水平开放型经济新体制。</li><li>对外政策：坚持经济全球化正确方向，反对保护主义和单边制裁。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>习近平新时代中国特色社会主义理论概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>习概_导论</title>
    <link href="/2024/09/01/%E4%B9%A0%E6%A6%82/%E5%AF%BC%E8%AE%BA/"/>
    <url>/2024/09/01/%E4%B9%A0%E6%A6%82/%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1 id="导论">导论</h1><h2 id="基本内容">基本内容</h2><ol type="1"><li><p>习近平新时代中国特色社会主义思想创立的时代背景：</p><ul><li>世界百年未有之大变局加速演进。</li><li>中华民族伟大复兴进入关键时期。</li><li>中国式现代化全面推进拓展。</li><li>科学社会主义在21世纪的中国焕发新的蓬勃生机。</li><li>中国共产党自我革命开辟新的境界。</li></ul></li><li><p>两个结合是我们党在探索中国特色社会主义道路中得出的规律性认识，是我们成功的最大法宝。</p><ul><li>马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合。</li></ul></li><li><p>习近平新时代中国特色社会主义思想是完整的科学体系：</p><ul><li>科学回答的重大时代课题：<ul><li>新时代坚持和发展怎样的中国特色社会主义。</li><li>建设什么样的社会主义现代化强国。</li><li>建设什么样的长期执政的马克思主义政党。</li></ul></li><li>主体内容：十个明确，集中体现了主要观点和基本精神，发挥统摄作用。</li><li>坚持和发展中国特色社会主义的基本方略：十四个坚持。</li><li>理论与实践成果：十三个方面成就。</li><li>世界观和方法论：六个必须坚持。</li></ul></li><li><p>习近平中国特色社会主义思想的历史地位：</p><ul><li><p>是当代中国马克思主义、21世纪马克思主义，是中华文化和中国精神的时代精华，实现了马克思主义中国化时代化新的飞跃。</p></li><li><p>使魂脉和根脉内在贯通，相互成就，是中华民族的文化主体性最有力的体现，是中华文化和中国精神的时代精华。</p></li><li><p>是全党全国各族人民为实现中华民族伟大复兴而奋斗的行动指南，是新时代党和国家事业发展的根本遵循。</p></li></ul></li><li><p>两个确立：</p><ul><li>确立习近平同志党中央的核心、全党的核心地位。</li><li>确立习近平新时代中国特色社会主义思想的指导地位。</li></ul></li><li><p>两个确立的决定性意义：</p><ul><li>坚强的领导核心和科学的理论指导是关乎党和国家前途命运、党和人民事业成败的根本性问题。</li><li>两个确立对新时代党和国家事业发展、对推进中华民族伟大复兴历史进程具有决定性意义。</li></ul></li></ol><h2 id="六个必须坚持">六个必须坚持</h2><p>必须坚持人民至上、自信自立、守正创新、问题导向、系统观念、胸怀天下。</p><ol type="1"><li>坚持人民至上是根本立场，体现了历史唯物主义群众观。</li><li>坚持自信自立是内在精神特质，体现了客观规律性和主观能动性的有机结合。</li><li>坚持守正创新是鲜明理论品格，体现了变与不变、继承与发展的内在联系。</li><li>坚持问题导向是重要实践要求，体现了矛盾的普遍性和客观性。</li><li>坚持系统观念是基本思想和工作方法，体现了辩证唯物主义普遍联系的原理。</li><li>坚持胸怀天下是中国共产党人的境界格局，体现了马克思主义追求人类进步和解放的崇高理想。</li></ol>]]></content>
    
    
    <categories>
      
      <category>习近平新时代中国特色社会主义理论概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>中国近现代史纲要总结二</title>
    <link href="/2024/07/05/%E6%94%BF%E6%B2%BB/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E6%80%BB%E7%BB%93%E4%BA%8C/"/>
    <url>/2024/07/05/%E6%94%BF%E6%B2%BB/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E6%80%BB%E7%BB%93%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h2 id="党史摘录">党史摘录</h2><h3 id="发展历程">发展历程</h3><ol type="1"><li><p>中国第一个马克思主义者：李大钊。</p><ul><li>1918年7月《法俄革命之比较观》：在中国第一次正确阐述十月革命性质。</li><li>1918年11月、12月《庶民的胜利》《布尔什维主义的胜利》。</li><li>1919年9月、11月《我的马克思主义观》，标志着马克思主义在中国进入系统传播阶段。</li></ul></li><li><p>早期马克思主义思想活动：</p><ul><li>早期马克思主义者：<ul><li>新文化运动精神领袖：李大钊、陈独秀。</li><li>五四爱国运动左翼骨干：毛泽东、周恩来。</li><li>旧民主主义革命时期活动家：董必武、林伯渠。</li></ul></li><li>早期马克思主义思想活动特点：<ul><li>重视马克思主义基本理论学习，坚持马克思主义革命原则。</li><li>注意从中国实际出发。</li><li>开始提出知识分子应当同劳动群众相结合的思想。</li></ul></li><li>五四运动后的新文化运动：马克思主义逐渐在思想文化领域占主导作用。<ul><li>继承并赋予了民主、科学新的内涵。</li><li>有力地推动了反封建的启蒙。</li></ul></li></ul></li><li><p>中国共产党的早期组织：</p><p>1920年3月，李大钊在北京大学组织马克思学说研究会，这是中国最早学习和研究马克思主义的团体。</p><p>1920年4月，俄共派维经斯基来华，会见李大钊、陈独秀，促进中国共产党的创建。</p><p>1920年8月，共产党早期组织在上海《新青年》编辑部成立。</p><p>1920年8月，上海社会主义青年团成立。</p><p>1920年10月，李大钊在北京成立共产党早期组织，11月定名为中国共产党北京分部。</p><p>1920年至1921年，不同地区的先进分子在各地都成立了共产党早期组织。</p><p>早期组织的活动：</p><ul><li>研究和宣传马克思主义和中国实际问题。</li><li>到工人中进行宣传和组织工作。</li><li>进行关于建党问题的研究和实际组织工作。</li></ul></li><li><p>1921年7月23日，中国共产党第一次全国代表大会在上海举行，最后一天转移到嘉兴。</p><ul><li><p>中国共产党成立的历史特点：</p><ul><li>成立在十月革命胜利，第二国际社会民主主义、修正主义破产后，接受完整的马克思主义。</li><li>在中国工人运动的基础上产生。<ul><li>中国工人阶级受帝国主义、本国资产阶级、封建势力三重压迫，具有坚强的革命性。</li></ul></li></ul></li><li><p>中国共产党必须加强自身建设的原因：</p><ul><li>当时的中国工人阶级人数少。</li><li>中国是一个幅员辽阔、人口众多、情况复杂、经济文化落后的半殖民地半封建国家。</li></ul></li><li><p>中国共产党成立的伟大意义：中国共产党的成立是一个开天辟地的大事变。</p><ol type="1"><li>中国革命有了坚强的领导核心。</li><li>中国人民踏上了争取民族独立、人民解放的道路。</li><li>形成了伟大的建党精神：<ul><li>坚持真理、坚守理想；践行初心、担当使命；不怕牺牲、英勇斗争；对党忠诚、不负人民</li></ul></li><li>深刻改变了近代以后中华民族发展的方向和进程，深刻改变了中国人民和中华民族的前途和命运，深刻改变了世界发展的趋势和格局</li></ol></li></ul></li><li><p>1927年8月7日，中共中央在汉口召开紧急会议（八七会议）。</p><ul><li>彻底清算了陈独秀右倾机会主义错误。</li><li>确定了土地革命和武装反抗国民党反动统治的总方针。<ul><li>明确提出土地革命是中国资产阶级民主革命的中心问题。</li></ul></li><li>毛泽东提出了以军事斗争作为党的工作重心的问题。</li></ul></li><li><p>1927年9月29日，毛泽东领导了三湾改编，从组织上确立了党对军队的领导。</p><ul><li>三湾改编是建设无产阶级领导的新型人民军队的重要开端。</li></ul></li><li><p>1929年12月，古田会议（红四军党的第九次代表大会）。</p><ul><li>确立了思想建党，政治建军原则。</li><li>党对军队绝对领导的根本原则和制度，发端于南昌起义，奠基于三湾改编，定型于古田会议。</li></ul></li><li><p>三次左倾错误：最终导致第五次反围剿失败。</p><ul><li><p>1927年11月至1928年4月，左倾盲动错误，盲目要求创造总暴动的局面。</p></li><li><p>1930年，左倾冒险主义错误，盲目要求攻打中心城市。</p></li><li><p>1931年至1935年，左倾教条主义错误：</p><ul><li><p>混淆民主革命和社会主义革命，将反帝反封建和反资产阶级并列。</p></li><li><p>坚持革命道路以城市为中心。</p></li><li><p>土地革命提出坚决打击富农。</p></li><li><p>军事斗争中，进攻中冒险主义、防御中保守主义、退却中逃跑主义。</p></li><li><p>党内斗争推向宗派主义和无情打击方针。</p></li></ul></li><li><p>中国共产党屡次左倾错误的原因：</p><ul><li>八七会议后党内左倾情绪未清理。</li><li>共产国际的错误干预。</li><li>马克思主义理论准备不足。</li></ul></li></ul></li><li><p>1934年10月，红一方面军开始长征。长征初期，博古、李德犯了逃跑主义错误。</p><p>1935年1月，遵义会议，集中解决了当时具有决定意义的军事问题和组织问题。</p><ul><li>确立了毛泽东在党中央和红军的领导地位。</li><li>开始确立马克思主义正确路线在党中央的领导地位。</li><li>开始形成毛泽东为核心的第一代领导集体。</li></ul><p>遵义会议开启了中国共产党独立自主解决中国革命实际问题的新阶段。</p><p>1935年10月，红一方面军到达陕北吴起镇。</p><p>1936年10月，红二、红四方面军先后与红一方面军在甘肃、宁夏会师，长征胜利结束。</p><ul><li>长征宣告了国民党消灭中国共产党和红军的图谋彻底失败。</li><li>宣告了党和红军北上抗日的战略转移。</li><li>实现了中国共产党和中国革命事业由挫折走向胜利的伟大转折。</li></ul></li><li><p>1935年8月1日，中国共产党八一宣言，呼吁全国同胞停止内战，一致抗日。</p><p>1935年12月，陕北瓦窑堡会议。</p><ul><li>阐明抗日民族统一战线的可能性，规定具体政策；批判左倾冒险主义、关门主义。</li></ul></li><li><p>抗日战争中的共产党：</p><ul><li>中国共产党主张实行全面抗战路线，即人民战争路线。</li><li>《论持久战》是中国共产党领导抗日战争的纲领性文件。<ul><li>抗日战争的最关键阶段是战略相持阶段。</li></ul></li><li>开辟敌后战场：<ul><li>平型关大捷：第一次重大胜利</li><li>忻口会战：国共合作最好的一次战役</li></ul></li><li>在全民族抗战中，游击战被提到战略的地位，具有全局性意义：<ul><li>战略防御阶段，正面战场为主，游击战争为辅。</li><li>战略相持阶段，游击战争为主。<ul><li>1940年8月，百团大战。</li></ul></li><li>游击战为战略反攻准备了条件。</li></ul></li></ul></li><li><p>1939年1月，国民党成立防共委员会。</p><p>1941年1月，国民党发动皖南事变。党在军事上自卫反击，在政治上揭露声讨。</p><p>中国共产党坚持抗战、团结、进步的方针：</p><ul><li>统一战线中的独立自主原则。<ul><li>思想上、政治上、组织上的独立性</li><li>对人民军队的绝对领导。</li><li>对国民党既团结又斗争、以斗争求团结。</li></ul></li><li>坚持抗战、团结、进步，反对妥协、分裂、倒退。</li><li>巩固抗日民族统一战线的策略总方针。<ul><li>发展进步势力，争取中间势力，孤立顽固势力。</li></ul></li></ul></li><li><p>抗日民主根据地建设：</p><ul><li>政治：三三制。<ul><li>抗日民族政府在工作人员分配上实行党员、党外进步人士、中间派各占1/3的原则。</li><li>党员包括工人和农民，党外进步人士为小资产阶级，中间派为开明绅士。</li></ul></li><li>经济：减租减息，发展生产。<ul><li>毛泽东提出的方针：发展经济，保障供给。</li><li>毛泽东发出号召：自己动手，丰衣足食。</li></ul></li><li>文化：创办干部学校和专门学校。</li></ul></li><li><p>大后方的抗日民主运动和进步文化工作：</p><ul><li>1939年10月，宪政运动，国民参政会中一些党派批评国民党一党专政。</li><li>1941年3月，中国民主政团同盟成立，1941年9月创办盟报《光明报》。</li><li>文化界各抗敌协会相继成立。</li><li>1938年9月至11月，六届六中全会提出了马克思主义中国化的命题。</li></ul><p>新民主主义理论的系统阐明，标志着毛泽东思想得到多方面展开而达到成熟。</p></li><li><p>1938年9月，六届六中全会。</p><ul><li>提出了马克思主义中国化的命题。<ul><li>普遍地、深入地学习马克思列宁主义的理论。</li><li>学习我们的历史遗产并给以批判地总结。</li><li>调查研究当前运动的特点及其规律性。</li></ul></li></ul></li><li><p>延安整风运动：反对主观主义。</p><ul><li>遵义会议以来主观主义、教条主义还未认真清理。</li></ul><p>1941年5月，毛泽东《改造我们的学习》，整风运动在高级干部中进行。</p><p>1942年2月，毛泽东《整顿党的作风》《反对党八股》，全党展开整风运动。</p><p>主观主义的实质是理论脱离实际。</p><p>主观主义的主要表现形式是经验主义和教条主义，尤其是教条主义。</p><ul><li>客服主观主义，必须以科学的态度对待马克思主义，一切从实际出发，实事求是。</li><li>调查研究是把理论和实际结合起来的不可或缺的中间环节。</li></ul></li></ol><h3 id="代表大会">代表大会</h3><ol type="1"><li><p>1921年7月，中国共产党第一次全国代表大会。</p><ul><li>确定党的名称为中国共产党。</li><li>党的纲领：以无产阶级革命军队推翻资本主义，采用无产阶级专政，实行社会主义。</li><li>决定首先集中精力组织工人。</li></ul></li><li><p>1922年7月，中国共产党第二次全国代表大会。</p><ul><li>最高纲领：实现共产主义。</li><li>民主革命纲领：打倒军阀，推翻帝国主义，统一中国为民主共和国。</li><li>两个重要原则：群众路线；党的建设。<ul><li>以往的斗争之所以成效甚少，就在于未能充分的发动群众。</li></ul></li><li>组成民主主义的联合战线。</li></ul></li><li><p>1923年6月，中国共产党第三次全国代表大会。</p><ul><li>决定全体共产党员以个人名义加入国民党，党在政治上、思想上、组织上保持自己的独立性。</li></ul></li><li><p>1944年5月，中国共产党六届七中全会，延安。</p><ul><li>通过了《关于若干历史问题的决议》，使全党对中国革命基本问题的认识达成一致。</li></ul></li><li><p>1945年4月，中国共产党第七次全国代表大会，延安。</p><ul><li><p>政治路线：放手发动群众，壮大人民力量，在我党的领导下，打败日本侵略者，解放全国人民，建立一个新民主主义的中国。</p></li><li><p>三大优良作风：理论与实践相结合、和人民群众紧密联系在一起、自我批评。</p></li><li><p>将毛泽东同志为首的党员所创造的马克思主义与中国具体实际结合的理论成果命名为毛泽东思想，规定毛泽东思想为党的一切工作的指针。</p></li><li><p>中共七大标志着党在政治、思想、组织上走向成熟。</p><ul><li><p>政治上：延安整风，走向团结。</p></li><li><p>思想上：毛泽东思想写入党章。</p></li><li><p>组织上：形成了一支久经考验的政治家集团。</p></li></ul></li></ul></li><li><p>1949年3月，中国共产党七届二中全会。</p><ul><li>提出迅速夺取全国胜利的方针。</li><li>工作中心：由乡村转移到城市。</li><li>两个转变：农业国转变到工业国、新民主主义转变到社会主义。</li><li>两个务必：务必继续保持谦虚谨慎、不骄不躁的作风，务必继续保持艰苦奋斗的作风。</li></ul></li><li><p>1956年9月，中国共产党第八次全国代表大会。</p><ul><li>主要矛盾：<ul><li>人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾。</li><li>人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾。</li></ul></li><li>经济建设方针：既反保守又反冒进，在综合平衡中稳步前进。</li><li>通过了中国共产党全国执政后制定的第一部宪章。</li></ul></li><li><p>1978年，党的十一届三中全会。</p><ul><li>党的十一届三中全会是划时代的，开启了改革开放和社会主义现代化建设新时期。</li></ul></li><li><p>1981年，党的十一届六中全会。</p><ul><li>主要矛盾：人民日益增长的物质文化需要同落后的社会生产之间的矛盾。</li></ul></li><li><p>1987年，党的十三大。</p></li></ol><ul><li><p>提出社会主义初级阶段理论和党在社会主义初级阶段的基本路线。</p></li><li><p>基本路线：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强民主文明的社会主义现代化国家而奋斗。</p></li></ul><ol start="11" type="1"><li><p>1992年，党的十四大：计划经济到社会主义市场经济。</p></li><li><p>1997年，党的十五大：党在社会主义初级阶段的基本纲领。</p></li><li><p>2002年，党的十六大：21世纪前20年，全面建成小康社会。</p></li><li><p>2007年，党的十七大：21世纪中叶，把我国建成富强民主文明和谐的社会主义现代化强国。</p></li><li><p>2012年，党的十八大：中国特色社会主义</p><ul><li><p>总依据：社会主义初级阶段。</p></li><li><p>总布局：经济、政治、文化、社会、生态文明建设五位一体。</p></li><li><p>四个全面：全面建成小康社会，全面深化改革，全面依法治国，全面从严治党。</p></li></ul></li><li><p>2013年11月，党的十八届三中全会。</p><ul><li>党的十八届三中全会也是划时代的，实现了改革从局部探索、破冰突围到系统集成、全面深化的转变，开创了我国改革开放新局面。</li></ul></li><li><p>2017年，党的十九大：</p><ul><li>主要矛盾：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</li><li>中国特色社会主义发展的战略安排：<ul><li>2020年，全面建成小康社会。</li><li>2035年，基本实现社会主义现代化。</li><li>21世纪中叶，把我国建成富强民主文明和谐美丽的社会主义现代化强国。</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>大学政治</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>中国近现代史纲要总结一</title>
    <link href="/2024/07/04/%E6%94%BF%E6%B2%BB/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E6%80%BB%E7%BB%93%E4%B8%80/"/>
    <url>/2024/07/04/%E6%94%BF%E6%B2%BB/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E6%80%BB%E7%BB%93%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1 id="中国近现代史纲要总结一">中国近现代史纲要总结一</h1><h2 id="社会变迁">社会变迁</h2><ol type="1"><li><p>从公元前5世纪的战国时期到1840年鸦片战争，我国处于封建社会。</p><ul><li><p>中国封建社会的主要矛盾：农民阶级和地主阶级的矛盾。</p></li><li><p>中国封建社会的结构：</p><ul><li>经济：封建地主所有制经济占主导地位。</li><li>政治：中央集权的封建君主专制制度。</li><li>社会：族权和政权相结合的封建宗法等级制度，核心是宗族家长制。</li><li>文化：以儒家思想为核心。</li></ul></li><li><p>中国封建社会的结构，巩固和维系其稳定和延续，也阻碍其发展，造成周期性政治经济危机。</p></li></ul></li><li><p>鸦片战争是我国沦为半殖民地半封建社会的开端。</p><p>1901年，八国联军侵华，《辛丑条约》签订，标志着我国彻底沦为半殖民地半封建社会。</p><ul><li><p>半殖民地：近代中国丧失了具有完整主权的独立国地位，但仍然维持着独立国家名义和部分主权。</p></li><li><p>半封建：列强武力将中国卷入资本主义经济体系，但不允许中国成为独立资本主义国家。</p></li><li><p>半殖民地半封建社会的基本特征：</p><ul><li>政治：列强日益支配中国，中国封建势力是列强压迫中国人民的社会基础和统治支柱。</li><li>经济：封建土地所有制广泛保持，新兴民族资本主义经济发展缓慢，力量弱小。</li><li>民生：各地区发展极不平衡，广大人民饥寒交迫，毫无政治权利。</li></ul></li><li><p>半殖民地半封建社会的阶级构成：</p><ul><li>地主阶级，部分转化为资本家。</li><li>农民阶级。</li><li>工人阶级，是中国沦为半殖民地半封建社会过程中最早出现的新阶级。</li><li>资产阶级，包括官僚买办资本家和民族资本家。</li></ul></li><li><p>半殖民地半封建社会的两大主要矛盾：两大矛盾的合流在第二次鸦片战争后期。</p><ul><li>帝国主义和中华民族的矛盾（占支配地位）。</li><li>封建主义和人民大众的矛盾。</li></ul><p>它们的合流就在第二次鸦片战争后期。</p></li><li><p>近代中国的核心问题：土地问题。</p></li><li><p>近代中国的两大历史任务：争取民族独立和人民解放，实现国家富强和人民幸福。</p></li></ul></li><li><p>新中国成立后，我国处于新民主主义社会。</p><ul><li><p>新民主主义社会的性质：社会主义因素占领导地位，属于社会主义体系。</p><ul><li>新民主主义社会不是一个独立的社会形态，而是一个过渡性社会形态。</li></ul></li><li><p>经济成分：其中合作社经济和国家资本主义经济属于过渡形式的经济。</p><ul><li>社会主义经济：国营经济、合作社经济</li><li>个体经济：农业、手工业</li><li>资本主义经济：私人资本主义经济、国家资本主义经济</li></ul></li><li><p>阶级构成：工人阶级、农民阶级和其他小资产阶级、民族资产阶级</p><ul><li><p>随着土地改革的基本完成，工人阶级和资产阶级的矛盾逐步成为我国社会的主要矛盾。</p></li><li><p>民族资产阶级的两面性：剥削工人；接受工人阶级及其政党领导。</p></li></ul></li></ul></li><li><p>1956年底，社会主义改造基本完成，标志着社会主义基本制度全面确立。</p><ul><li>主要矛盾：<ul><li>人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾。</li><li>人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾。</li></ul></li><li>主要任务：集中力量发展社会生产力，实现国家工业化，逐步满足人民日益增长的物质文化需要。</li><li>经济基础：社会主义公有制。</li><li>上层建筑：国体为人民民主专政，政体为人民代表大会制度。</li><li>我国进入社会主义初级阶段。</li></ul></li><li><p>1978年，十一届三中全会召开，改革开放。</p><ul><li>经济体制改革：以公有制为主体，多种所有制共同发展。</li><li>主要矛盾：人民日益增长的物质文化需要同落后的社会生产之间的矛盾。</li></ul></li><li><p>2017年，十九大：</p><ul><li>主要矛盾：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</li></ul></li></ol><h2 id="历史脉络">历史脉络</h2><h3 id="旧民主主义革命时期">旧民主主义革命时期</h3><ol type="1"><li><p>鸦片战争</p><ul><li>19世纪初，英国连续爆发经济危机，且对中国有极大贸易逆差。</li><li>第一次鸦片战争，《南京条约》<ul><li>停战并缔结永久对等关系，赔偿2100万银圆。</li><li>领土主权：割让香港岛。</li><li>关税主权：关税由英国决定。</li><li>开放广州、厦门、福建、宁波、上海，准许英商在华自由贸易。</li></ul></li><li>第二次鸦片战争，《天津条约》《北京条约》，西方列强转而维护清政府统治。</li><li>鸦片战争后，先进者开眼看世界：<ul><li>魏源《海国图志》：师夷长技以制夷</li><li>严复《救亡决论》：救亡</li><li>严复《天演论》：物竞天择、适者生存</li></ul></li></ul></li><li><p>太平天国</p><ul><li><p>运动背景：</p><ul><li>鸦片战争：赔偿军费导致银贵钱贱；开放贸易导致自然经济逐渐解体，无地贫农越来越多。</li><li>清朝统治：政治腐败、地方武装兴起</li></ul></li><li><p>《天朝田亩制度》：最能体现太平天国社会理想和农民起义特色的纲领性文件。</p><p>是一个以解决土地问题为中心的比较完整的社会改革方案。</p></li><li><p>《资政新篇》：中国近代历史上第一个比较系统的发展资本主义的方案。</p></li><li><p>失败原因：</p><ul><li>农民阶级的局限性。</li><li>领导团队：战略错误、政治腐败、后期制度坍塌。</li><li>对外交往：持友好态度。</li><li>理想信念：基督教与传统文化不合。</li></ul></li><li><p>影响：</p><ul><li>沉重打击封建统治阶级，带来清政府财政难题。</li><li>汉族官僚武装集团崛起，为军阀混战埋下伏笔。</li><li>中国农民起义的最高峰，其革命精神鼓舞后人。</li></ul></li></ul></li><li><p>洋务运动</p><ul><li><p>目的：维护清朝统治；自强、求富。</p></li><li><p>指导思想：中体西用。</p></li><li><p>洋务事业：</p><ul><li>兴办近代企业，其中官督民办的企业基本上是资本主义性质的企业。</li><li>建立新式陆海军</li><li>创办新式学堂：翻译学堂、工艺学堂、军事学堂</li></ul></li><li><p>影响：</p><ul><li>促进早期工业和民族资本主义发展，形成了很多城市。</li><li>工商业地位上升，产生了工人阶级和商人买办阶级。</li><li>是中国近代教育的开始。</li></ul></li><li><p>甲午战败，标志着洋务运动的失败。失败的原因：</p><ul><li>洋务运动具有封建性。</li><li>洋务运动对列强具有依赖性。</li><li>洋务运动管理具有腐朽性。</li></ul></li><li><p>洋务运动失败了，但实业救国的思潮继续延续下去。</p></li><li><p>帝国主义侵略中国的最终目的是要瓜分中国。</p><ul><li>甲午战争后掀起了瓜分中国的狂潮。</li><li>瓜分中国失败的原因：<ul><li>重要原因：列强之间的相互制约。</li><li>根本原因：中华民族不屈不挠的反侵略斗争。</li></ul></li></ul></li></ul></li><li><p>戊戌变法</p><ul><li><p>甲午战争后人民的民族意识普遍觉醒。</p></li><li><p>维新派宣传维新的活动：上书，著书立说，办学会、设学堂，办报纸</p><ul><li>康有为今文经运动，宣传维新思想。</li></ul><p>维新派和守旧派的论战是资产阶级思想与封建主义思想在中国的第一次正面交锋。</p></li><li><p>1898年，光绪颁布“明定国是”，逐渐实施变法：</p><ul><li>政治：裁撤冗员，改革行政。</li><li>经济：建设铁路，发展农工商，奖励发明。</li><li>军事：裁减旧兵，改练新军。</li><li>文化：废八股改策论，设立京师大学堂，各省设立新式学堂。</li></ul><p>戊戌政变，维新失败。</p><ul><li>京师大学堂保留了下来，成为中国近代国立高级教育的开端。</li></ul></li><li><p>性质：资产阶级性质的改良运动，并未触及封建制度的根本。是温和的、不彻底的。</p></li><li><p>失败的原因：维新派的局限性和守旧势力的强大</p><ul><li>民族资产阶级力量弱小。</li><li>维新派的局限性：不敢否定封建主义、对帝国主义抱有幻想、惧怕人民群众。</li></ul></li></ul></li><li><p>辛亥革命</p><ul><li><p>背景：</p><ul><li>八国联军侵华，民族危机加深。</li><li>清末新政破产，社会矛盾激化。</li><li>民族资产阶级的发展。</li></ul></li><li><p>1905年，孙中山在东京成立中国同盟会。</p><ul><li>政治纲领：驱除鞑虏，恢复中华，创立民国，平均地权。</li><li>纲领概括为三民主义：民族、民权、民生。<ul><li>民族：民族革命，推翻清政府，建立中华民族独立的国家。</li><li>民权：政治革命，推翻封建专制，建立民主共和国。</li><li>民生：社会革命，核定地价。</li></ul></li></ul></li><li><p>革命和改良的辩论：1905至1907年，《民报》《新民丛报》为主要论战阵地。</p><ul><li>要不要推翻清王朝。</li><li>要不要推翻帝制，实行共和。</li><li>要不要社会革命。</li></ul><p>要不要以革命的手段推翻清王朝是论战的焦点。</p><p>划清了革命和改良的界限，传播了民主革命思想，也暴露了革命派的思想弱点。</p></li><li><p>南京临时政府是一个资产阶级共和国性质的革命政权。</p><ul><li>局限性：试图用承认不平等条约来换取列强的支持，未提出满足农民需求的土地政策。</li></ul><p>1912年3月《中华民国临时约法》：资产阶级共和国宪法性质。</p><ul><li>规定了资产阶级共和国的国家、政府组织机构以及人民享有的各项民主权利。<ul><li>中华民国国民一律平等，享有自由民主权利。</li></ul></li><li>以根本大法的形式废除了封建君主专制制度，确认了资产阶级共和国的政治制度。</li></ul></li><li><p>辛亥革命的历史意义：</p><ul><li>推翻了清王朝，结束了封建君主专制。</li><li>建立资产阶级共和政府，使民主共和的观念深入人心，推动了中国人民的思想解放。</li><li>推动了中国的社会变革，促使中国的社会经济、思想习惯和社会风俗等方面积极变化。</li><li>沉重打击中外反动势力，推动亚洲各国民族解放运动的高涨。</li></ul></li><li><p>辛亥革命失败的根本原因：在帝国主义时代的半殖民地半封建的中国，资本主义建国方案行不通。</p><p>辛亥革命失败的主观原因：资产阶级革命派本身存在许多弱点和错误</p><ul><li>没有提出彻底的反帝反封建的革命纲领。</li><li>不能充分发动和依靠人民群众。</li><li>不能建立坚强的革命政党。</li></ul><p>这些弱点和错误归结于民族资产阶级的软弱性和妥协性。</p><ul><li>资产阶级革命派的骨干是民族资产阶级和小资产阶级知识分子。</li></ul></li><li><p>护法运动的败标志着中国民族资产阶级领导的旧民主主义革命终结。</p></li><li><p>对孙中山的评价：</p><p>孙中山具有顽强的革命精神，首先喊出振兴中华的口号，不断摸索救国救民的道路，始终坚持奋斗，是中国民主革命的先行者。他在领导人民推翻帝制、建立共和国的斗争中建立了历史功勋，是20世纪初期推动中国革命的主要代表。</p></li></ul></li></ol><h3 id="新民主主义革命时期">新民主主义革命时期</h3><ol type="1"><li><p>五四运动前的新文化运动</p><ul><li><p>背景：西方思想传播深入、尊孔思想抬头、辛亥革命失败和军阀混战的形势。</p></li><li><p>主要阵地：《新青年》和北京大学。</p></li><li><p>基本内容：</p><ul><li>提倡民主和科学，反对专制和迷信。</li><li>提倡个性解放，反对封建礼教。</li><li>提倡新文学，反对旧文学。</li></ul></li><li><p>基本口号：民主和科学。</p></li><li><p>历史意义：提倡资产阶级民主主义，掀起思想解放的潮流。</p></li><li><p>局限性：</p><ul><li>提倡资产阶级民主主义并不能提供有效的思想武器。</li><li>依靠有限的宣传手段来改造国民性是不可能的。</li><li>片面地、形式主义看问题，影响了运动后来的发展。</li></ul></li><li><p>十月革命的影响：</p><ul><li>十月革命发生在国情与中国近似的俄国，对中国先进分子具有吸引力。</li><li>社会主义俄国用平等的态度对待中国，推动了社会主义思想的传播。</li><li>十月革命中广泛发动工农群众赢得胜利的事实给予中国先进分子革命方法的启示。</li></ul></li></ul></li><li><p>五四运动：全国范围的群众性的反帝爱国运动。</p><ul><li><p>社会历史条件：</p><ul><li>新的社会力量的成长、壮大。产业工人达到200万人左右。</li><li>新文化运动掀起思想解放的潮流。</li><li>十月革命的影响。</li></ul></li><li><p>直接导火线：巴黎和会上中国外交的失败。</p></li><li><p>口号：外争主权，内除国贼；取消二十一条；还我青岛。</p></li><li><p>主张：拒绝在和约上签字，惩办曹汝霖、章宗祥、陆宗舆。</p></li><li><p>结果：释放被捕学生，罢免曹汝霖、章宗祥、陆宗舆，未参与签订巴黎和约。</p></li><li><p>五四运动表明中国人民对帝国主义的认识进入了理性的认识阶段。</p></li><li><p>历史特点：</p><ul><li>以先进青年知识分子为先锋、广大人民群众参与的彻底反帝反封建的爱国革命运动。</li><li>中国人民为拯救民族危亡、捍卫民族尊严、凝聚民族力量而掀起的爱国革命运动。</li><li>传播新思想新文化新知识的伟大思想启蒙运动。</li></ul></li><li><p>意义：</p><ul><li>中国旧民主主义革命走向新民主主义革命的转折点。</li><li>促进了马克思主义的传播，为中国共产党的诞生作准备。</li><li>孕育了以爱国、进步、民主、科学为主要内容的五四精神。</li></ul></li></ul></li><li><p>中国共产党诞生：详见总结二</p></li><li><p>大革命</p><ul><li><p>国民党一大确认了联俄、联共、扶助农工三大革命政策，标志着第一次国共合作的正式形成。</p><ul><li>民族：对外中华民族独立，对内各民族一律平等。</li><li>民权：强调民主权利应为一般平民所共有。</li><li>民生：平均地权、节制资本。后来又提出耕者有其田。</li></ul></li><li><p>1925年至1927年中国反帝反封建的革命，比以往任何一次革命，群众动员更广泛，斗争规模化更宏伟，社会内涵更深刻，因此称作大革命。</p></li><li><p>中国共产党在大革命中的不可替代作用：</p><ul><li>提出了反对帝国主义、反对军阀的政治口号。</li><li>倡导并组织了以国共合作为基础的统一战线。</li><li>发动了空前广泛而深刻的群众运动。</li><li>推动了国民革命军建立，在军队中进行了有效的政治工作，共产党人在战斗中身先士卒。</li></ul></li><li><p>四一二和七一五反革命政变是大革命失败的标志：反帝反封建的任务没有完成。</p><ul><li><p>失败的客观原因：反革命力量大大超过革命的力量，资产阶级严重动摇。</p></li><li><p>失败的主观原因：</p><ul><li>以陈独秀为代表的右倾机会主义错误，放弃了党对群众、武装力量的领导权。</li><li>不善于将马列主义基本原理同中国革命实际相结合。</li><li>共产国际的不切实际的指导。</li></ul></li><li><p>教训：</p><ul><li>中国的民主革命必须建立包括工人、农民、小资产阶级和民族资产阶级的广泛统一战线。</li><li>建立巩固工农联盟，才能保证革命胜利。</li><li>要实现对革命的领导，必须建立和掌握革命的武装。</li><li>中国共产党必须加强党的建设，把马克思主义原理与具体实践相结合。</li></ul></li></ul></li><li><p>大革命的意义：</p><ul><li>党开始探索马克思主义中国化的途径，初步提出新民主主义革命的基本思想。</li><li>党开始懂得土地革命和掌握革命武装的重要性。</li><li>中国人民觉悟和组织程度提高。</li></ul></li><li><p>国民党在清党分共后，变成了代表地主阶级、买办的大资产阶级利益反动集团控制的政党。</p><ul><li>国民党与北洋军阀无本质区别，中国仍是帝国主义和封建主义统治下的半殖民地半封建社会。</li></ul></li><li><p>国民党的独裁统治：</p><ul><li>用军队和特务镇压人民、消灭异己。</li><li>推行保甲制度，禁止革命活动。</li><li>厉行文化专制，控制舆论。</li></ul></li></ul></li><li><p>土地革命</p><ul><li><p>任务：</p><p>消灭封建地主土地私有制，实行农民土地私有制，使农民在政治上翻身，解放和发展农村生产力。</p></li><li><p>土地政策：</p><ul><li>井冈山第一个土地法：没收一切土地为政府所有，禁止土地买卖。</li><li>第二个土地法：没收一切公共土地及地主阶级的土地。保护了中农的利益。</li><li>依靠贫雇农，联合中农，限制富农，保护中小工商业者，消灭地主。以乡为单位，按人口平分土地，在原耕地基础上抽多补少、抽肥补瘦。</li></ul></li><li><p>1931年11月，中华苏维埃第一次全国代表大会在江西瑞金举行。</p><ul><li>通过了《中华苏维埃共和国宪法大纲》。</li><li>中华苏维埃共和国实行工农兵代表大会制度，性质是工农民主专政。</li></ul></li></ul></li><li><p>抗日战争</p><ul><li><p>抗日战争前期国民政府态度：攘外必先安内，妥协退让。</p></li><li><p>西安事变后，内战局面基本结束，国内和平初步实现。</p></li><li><p>国共第二次合作，抗日民族统一战线的新特点：</p><ul><li>广泛的民族性和复杂的阶级矛盾。</li><li>国共双方有政权和军队的合作。</li><li>没有固定组织形式和统一纲领。</li></ul></li><li><p>抗日战争过程：</p><ul><li><p>战略防御阶段：1937年卢沟桥事变到1938年广州、武汉失守。</p><ul><li>抗战初期正面战场败退的原因：日军力量有优势；国民党实施片面抗战，不敢发动群众。</li></ul></li><li><p>战略相持阶段：广州、武汉失守后进入战略相持阶段，直到日本投降。</p><ul><li>日本对国民党政治诱降，军事打击。</li></ul></li></ul></li><li><p>中国人民抗日战争在反法西斯战争中的地位：</p><ul><li>中国抗日战争是世界反法西斯战争的重要组成部分，中国战场是世界反法西斯战场的东方主战场。</li><li>中国抗日战争的胜利与世界反法西斯力量的援助分不开。</li></ul></li><li><p>抗日战争胜利的原因：</p><ul><li>决定因素是以爱国主义为核心的民族精神。</li><li>关键是中国共产党的中流砥柱作用。</li><li>重要法宝是全民族抗战。</li><li>中国抗日战争的胜利与世界反法西斯力量的援助分不开。</li></ul></li><li><p>抗日战争胜利的意义：</p><ul><li><p>中华民族走向伟大复兴的历史转折点。</p></li><li><p>捍卫了国家主权和领土完整。</p></li><li><p>促进中华民族大团结，形成伟大抗战精神。</p></li><li><p>对世界反法西斯战争的胜利产生巨大影响。</p></li></ul></li></ul></li><li><p>解放战争</p><ul><li><p>国际局势：美苏两极格局；国内局势：美国扶蒋反共，人民军队上百万，解放区人数近亿。</p></li><li><p>国统区的学生工人运动：南京520运动、北京反美军强暴运动。</p><ul><li>国民党独裁统治，官员贪污腐败</li><li>征收苛捐杂税，执行内战政策</li><li>恶性通货膨胀，民族工商业破产，工农业生产萎缩</li></ul></li><li><p>1949年，55位民主党派人士联合发表《对时局的意见》，支持中国共产党的领导。</p><ul><li>民主党派的社会基础：主要是民族资产阶级、城市小资产阶级</li><li>民主党派的政纲多主张爱国和民主。</li></ul></li><li><p>解放战争过程：</p><ul><li>1946年6月，国民党以进攻中原解放区为起点发动全面内战。</li><li>1947年6月，挺进大别山，开启战略进攻。<ul><li>人民解放军的战略进攻，标志着中国革命已经发展到了一个历史的转折点，这是蒋介石反革命统治、帝国主义的统治从发展到消灭的转折点。</li></ul></li><li>1948年，辽沈、淮海、平津三大战役，摧毁了国民党的主要军事力量。</li><li>1949年4月23日，人民解放军占领南京，国民党统治覆灭。</li></ul></li><li><p>中国革命胜利的原因：</p><ul><li>深刻的社会根源和雄厚的群众基础。</li><li>中国共产党的领导。</li><li>国际无产阶级和人民群众的支持。</li></ul></li><li><p>中国革命胜利的意义：</p><ul><li>实现了民族独立和人民解放。</li><li>根本上改变了中国社会的发展方向，创造了发展社会主义的政治前提。</li><li>是继十月革命和世界反法西斯战争胜利后世界历史中最重大的事件。</li></ul></li><li><p>中国革命胜利的基本经验：</p><ul><li><p>中国共产党的领导。</p></li><li><p>马克思主义与中国具体实际相结合。</p></li><li><p>三大法宝：统一战线、武装斗争、党的建设。</p></li><li><p>革命的根本问题是国家政权问题。</p></li></ul></li></ul></li></ol><h3 id="新中国时期">新中国时期</h3><ol type="1"><li><p>新中国成立</p><ul><li><p>开国大典前，毛泽东主持召开中央人民政府委员会第一次会议。</p><ul><li>接受《中国人民政治协商会议共同纲领》为施政纲领。</li></ul></li><li><p>中华人民共和国成立的伟大意义：</p><ul><li><p>彻底结束了旧中国半殖民地半封建社会的历史，实现中国高度统一和各民族空前团结。</p></li><li><p>冲破帝国主义的东方战线，壮大了世界和平民主和社会主义的力量。</p></li><li><p>是马克思列宁主义、毛泽东思想的胜利。</p></li><li><p>标志着新民主主义革命的基本胜利，新民主主义社会的建立。</p></li></ul></li><li><p>新中国面临的考验：</p><ul><li>保住革命胜利成果，巩固新生人民政权。</li><li>战胜严重经济困难，恢复发展国民经济。</li><li>巩固中华民族独立，维护国家主权安全。<ul><li>另起炉灶、打扫干净屋子再请客、一边倒。</li></ul></li><li>经受全国执政考验，继续保持优良作风。<ul><li>党政军机关：三反（贪污、浪费、官僚主义）</li><li>不法资本家：五反（行贿、偷税漏税、盗窃国家财产、偷工减料、盗窃经济情报）</li></ul></li></ul></li><li><p>新中国的两大任务：完成民主革命的遗留任务；恢复国民经济。</p><p>民主革命遗留任务：</p><ul><li><p>《中华人民共和国土地改革法》：实行农民土地所有制。保存富农经济。</p><p>我国历史上规模最大、进行最好的土地改革运动。</p></li><li><p>《中华人民共和国婚姻法》：婚姻自由。</p></li><li><p>镇压反革命运动。</p></li></ul><p>恢复国民经济：</p><ul><li>没收官僚资本，确立社会主义国营经济的领导地位。</li><li>恢复生产，打击投机，控制通胀。</li></ul></li><li><p>1950年，抗美援朝。</p><ul><li>保卫朝鲜国家安全，维护亚洲和平。</li><li>增强民族自信心和自豪感，提高国际威望。</li><li>为经济建设和社会改革提供了相对稳定的环境。</li></ul></li></ul></li><li><p>过渡时期</p><ul><li><p>新中国成立之初，设想“先建设，后一举过渡”；1952年，改变为“建设与过渡并举”。</p><ul><li>原因：国内阶级关系、主要矛盾变化；社会经济成分变化。</li></ul></li><li><p>1953年12月，提出过渡时期的总路线“一化三改”。</p></li><li><p>社会主义改造的必要性和条件：</p><ul><li>社会主义国营经济力量强大，资本主义经济力量弱小。</li><li>对个体农业进行社会主义改造，是保证工业发展的必要条件。</li><li>国际环境的要求。</li></ul></li><li><p>一五计划：集中发展重工业，相应地发展轻工业、农业和商业。</p><ul><li>成就：鞍山、包头、武汉三大钢铁基地；武汉长江大桥；青藏、康藏、新藏铁路。</li></ul><p>1956年底，三大改造基本完成。社会主义改造基本完成，标志着社会主义基本制度全面确立。</p><ul><li>历史经验：<ul><li>社会主义工业化建设和社会主义改造并举。</li><li>积极引导，逐步过渡。</li><li>和平改造。</li></ul></li><li>两个罕见事实：<ul><li>几亿人口大国较顺利地实现如此复杂困难的社会变革，没有造成破坏，反而促进了发展。</li><li>没有引起社会动荡，反而极大地加强了团结。</li></ul></li></ul></li></ul></li><li><p>社会主义建设</p><ul><li><p>1956年，毛泽东提出马原与中国具体实际第二次结合，为探索社会主义建设提供基本指导原则。</p><ul><li>《论十大关系》是中国共产党人开始探索中国国情的社会主义建设道路的标志。</li><li>调动一切积极因素建设我国。</li></ul><p>1956年9月，中共八大提出的经济建设方针：既反保守又反冒进，在综合平衡中稳步前进。</p></li><li><p>1957年4月，整风运动：反对官僚主义、宗派主义和主观主义。</p><ul><li>形式：开门整风。</li><li>极少数资产阶级右派分子进行攻击，引发了过于严重的全国群众性反右派运动。<ul><li>人民内部矛盾当作敌我矛盾，思想认识问题当作政治问题。</li></ul></li></ul></li><li><p>1958年5月，大跃进：鼓足干劲，力争上游，多快好省地建设社会主义。导致浮夸风、共产风。</p><p>1961年，八届九中全会：调整、巩固、充实、提高。</p><p>1966年8月，文化大革命全面发动。</p></li><li><p>全面建设社会主义的成就：</p><ul><li>建立了独立的、比较完整的工业体系和国民经济体系。</li><li>人民生活水平提高，文化教育医疗事业发展。</li><li>科技成果：两弹一星，</li><li>国际地位提高，国际环境改善。<ul><li>1971年，恢复联合国一切合法权利。</li><li>1972年，尼克松访华。</li></ul></li></ul></li></ul></li><li><p>改革开放</p><ul><li><p>1977年，华国锋提出“两个凡是”。</p><p>1978年5月11日，南京大学哲学系教授胡福明《实践是检验真理的唯一标准》。</p><p>这篇文章引发了全国范围内关于真理标准问题的讨论。</p><p>关于真理标准问题的讨论是继五四运动和延安整风运动后又一场马克思主义思想解放运动。</p><ul><li>实质：是不是坚持马克思主义、毛泽东思想。</li><li>成为正本清源、 拨乱反正和改革开放的思想先导。</li><li>为党纠正错误、重新走上实事求是路线作了思想理论准备。</li></ul><p>1979年，邓小平主持起草《中国共产党中央委员会关于建国以来党的若干历史问题的决议》。</p><ul><li>确立毛泽东同志的历史地位，坚持和发展毛泽东思想。</li><li>对建国30年来历史上的大事，要进行实事求是的分析。</li><li>宜粗不宜细，总结过去是为了引导大家团结一致向前看。</li></ul><p>《决议》标志着党在指导思想上的拨乱反正胜利完成。</p></li><li><p>1978年12月，党的十一届三中全会。</p><ul><li><p>会议内容：</p><ul><li><p>冲破长期左的错误，否定两个凡是，停止以阶级斗争为纲。</p></li><li><p>全党工作重心转移到社会主义现代化建设上来。</p></li><li><p>实行改革开放。</p></li></ul></li><li><p>意义：</p><ul><li>重新确立了马克思主义的思想路线、政治路线、组织路线。</li><li>形成了以邓小平同志为核心的党中央领导集体，揭开了社会主义改革开放的序幕。</li><li>中国进入了改革开放和社会主义现代化建设新时代。</li></ul></li></ul></li><li><p>拨乱反正：加快平反冤假错案，调整社会关系。</p><p>农村生产关系改革：解决政社合一的人民公社体制和农民的温饱问题。</p><ul><li>家庭联产承包责任制普遍施行：包产到户，结合承包经营和集体经济。</li><li>1983年10月，废除人民公社，建立乡镇政府作为基层政权，村民委员会为自治组织。</li></ul><p>城市经济体制改革：政企分开；从单一公有制到以公有制为主体。</p><p>对外开放格局：经济特区-沿海开放城市-沿海经济开放区-内地的多层次、有重点、点面结合。</p><ul><li><p>1980年，设立深圳、珠海、厦门、汕头经济特区。1983年增加海南为经济特区。</p></li><li><p>开放上海、南通等14个沿海港口城市。</p></li><li><p>设立长三角、珠三角、闽三角三个开放区。</p></li></ul></li><li><p>1992年，邓小平南方讲话。</p></li></ul></li></ol><h2 id="时间轴">时间轴</h2><h3 id="旧民主主义革命时期-1">旧民主主义革命时期</h3><ol type="1"><li><p>鸦片战争</p><ul><li>1840年，第一次鸦片战争爆发。</li><li>1841年，三元里人民的抗英斗争。</li><li>1842年8月29日，《南京条约》。</li><li>1856-1860年，第二次鸦片战争。</li></ul></li><li><p>太平天国</p><ul><li>1851年，金田起义，永安建制。</li><li>1853年，定都天京。</li><li>1856年，天京之变，杨秀清身亡。</li><li>1864年，天京陷落，洪秀全身亡。</li></ul></li><li><p>洋务运动</p><ul><li><p>1865年，李鸿章，江南制造总局。</p></li><li><p>1866年，左宗棠，福州船政局。</p></li><li><p>1873年，李鸿章，轮船招商局。</p></li><li><p>1890年，张之洞，汉阳铁厂。</p></li><li><p>1895年，甲午战争战败。</p></li></ul></li><li><p>戊戌变法</p><ul><li>1898年，光绪颁布“明定国是”，戊戌政变。</li></ul></li><li><p>联军侵华</p><ul><li>1901年，辛丑条约。</li></ul></li><li><p>辛亥革命</p><ul><li><p>1894年，孙中山在檀香山建立第一个革命团体兴中会，喊出振兴中华的口号。</p></li><li><p>1904年开始，出现了10多个革命团体，包括华兴会、光复会等。</p></li><li><p>1905年，孙中山在东京成立中国同盟会。</p></li><li><p>1911年4月27日，黄兴举行广州起义，也称黄花岗起义。</p></li><li><p>1911年5月，湖南、湖北、广东、四川保路运动。</p><p>1911年10月10日，武昌起义，建立湖北军政府。</p></li><li><p>1912年1月1日，孙中山在南京宣誓就职，改国号为中华民国，成立中华民国临时政府。</p><p>1912年2月12日，清帝退位，封建君主专制制度宣告覆灭。</p></li></ul></li><li><p>革命失败</p><ul><li>1912年3月10日，袁世凯在北京就任临时大总统。</li><li>1912年4月1日，孙中山正式卸任，随后临时政府迁往北京。</li><li>1913年，宋教仁遇刺，孙中山发动二次革命，但由于军力和财力不足，两个月后就失败。</li><li>1914年，孙中山在日本组织中华革命党，坚持武装斗争。</li><li>1915年，蔡锷在云南组织护国军，宣布独立，形成席卷半个中国的护国运动。</li><li>1916年1月1日，袁世凯称帝，以洪宪为年号。持续83天失败。不久后袁世凯去世。</li><li>1917年6月，张勋复辟，仅12天就失败。</li><li>1917年7月，段祺瑞上台，孙中山发起护法运动，最终失败。</li></ul></li></ol><h3 id="新民主主义革命时期-1">新民主主义革命时期</h3><ol type="1"><li>新文化运动和五四运动<ul><li>1915年9月，陈独秀在上海创办《青年杂志》，新文化运动开始。</li><li>1917年1月，蔡元培担任北京大学校长，聘请陈独秀担任文科学长，《新青年》迁址北京。</li><li>1919年5月4日，北京十几所学校学生在天安门前集会游行，五四运动爆发。</li><li>1919年6月7日，上海六七万工人为声援学生先后罢工，随后运动扩展到20多个省。</li></ul></li><li>中国共产党的诞生<ul><li>1921年7月23日，中国共产党第一次全国代表大会在上海举行，最后一天转移到嘉兴。</li></ul></li><li>大革命<ul><li>1922年7月，中共二大作出了关于建立民主主义的联合战线的决议。</li><li>1923年6月，中共三大决定全体共产党员以个人名义加入国民党。</li><li>1924年1月，国民党一大在广州召开。</li><li>1925年5月，以五卅运动为起点，大革命在全国范围内掀起高潮。</li><li>1926年6月，省港大罢工，持续16个月，是中国工人运动史上持续最久的政治大罢工。</li><li>1926年7月，以推翻北洋军阀统治为目标的北伐战争开始。</li><li>1926年3月，蒋介石中山舰事件。</li><li>1927年4月12日，蒋介石在上海发动“清党”。</li><li>1927年7月15日，汪精卫在武汉搜捕、屠杀共产党员和革命群众。</li><li>1927年4月18日，南京国民政府成立。</li><li>1928年12月29日，东北易帜，国民党在全国范围内建立了统治。</li></ul></li><li>土地革命<ul><li>1927年8月7日，中共中央在汉口召开八七会议。</li><li>1927年8月1日，南昌起义，打响了武装反抗国民党反动统治的第一枪。</li><li>1927年9月9日，秋收起义，打出了工农革命军的旗帜。</li><li>1927年9月29日，毛泽东领导了三湾改编，组织上确立了党对军队的领导。</li><li>1927年10月7日，起义部队开始了创建井冈山革命根据地的斗争。</li><li>1927年12月11日，广州起义。</li><li>1929年12月，古田会议（红四军党的第九次代表大会）。</li><li>1931年11月，中华苏维埃第一次全国代表大会在江西瑞金举行。</li><li>1934年10月，红一方面军开始长征。</li><li>1935年1月，遵义会议。</li><li>1935年10月，红一方面军到达陕北吴起镇。</li><li>1936年10月，红二、红四方面军先后与红一方面军在甘肃、宁夏会师，长征胜利结束。</li></ul></li><li>抗日战争<ul><li>1931年9月18日，日本发动九一八事变，武装侵占中国东北。</li><li>1937年7月7日，卢沟桥事变，日本全面侵华战争开始。</li><li>1935年8月1日，中国共产党八一宣言，呼吁全国同胞停止内战，一致抗日。</li><li>1935年12月，陕北瓦窑堡会议提出了抗日民族统一战线的政策。</li><li>1935年12月9日，北京学生抗日游行，遭到国民党镇压。</li><li>1936年12月12日，西安事变。</li><li>1937年9月22日，《中共中央为公布国共合作宣言》。</li><li>1939年1月，国民党成立防共委员会。</li><li>1941年1月，国民党发动皖南事变。</li><li>1945年4月至6月，中共七大在延安召开。</li><li>1945年8月15日，日本广播投降。</li><li>1945年9月2日，日本签署投降书。</li><li>1945年10月25日，中国政府在台湾举行受降仪式，台湾回归。</li></ul></li><li>解放战争<ul><li>1945年8月，蒋介石邀请毛泽东赴重庆谈判，签署双十协定，同意”长期合作，坚决避免内战“。</li><li>1946年1月，政治协商会议在重庆召开。</li><li>1946年6月，国民党以进攻中原解放区为起点发动全面内战。</li><li>1947年6月，挺进大别山，开启战略进攻。</li><li>1948年，辽沈、淮海、平津三大战役，摧毁了国民党的主要军事力量。</li><li>1949年4月23日，人民解放军占领南京，国民党统治覆灭。</li></ul></li></ol><h3 id="新中国时期-1">新中国时期</h3><ol type="1"><li><p>新中国成立</p><ul><li>1949年10月1日，开国大典。</li><li>1950年，抗美援朝。</li><li>1953年，美国代表在停战协议上签字。</li></ul></li><li><p>过渡时期</p><ul><li><p>1952年，提出一五计划，1953～1957年执行。</p></li><li><p>1953年12月，提出过渡时期的总路线。</p></li><li><p>1956年，社会主义改造基本完成，我国确立社会主义基本制度。</p></li></ul></li><li><p>社会主义建设时期</p><ul><li>1956年4月，毛泽东提出第二次结合。</li><li>1956年9月，中共八大。</li><li>1957年4月，整风运动：反对官僚主义、宗派主义和主观主义。</li><li>1958年5月，大跃进：鼓足干劲，力争上游，多快好省地建设社会主义。</li><li>1961年，八届九中全会：调整、巩固、充实、提高。</li><li>1966年8月，文化大革命全面发动。</li><li>1971年，中国恢复联合国一切合法权利。</li><li>1972年，尼克松访华。</li></ul></li><li><p>改革开放</p><ul><li>1977年，华国锋提出“两个凡是”。</li><li>1978年5月11日，南京大学哲学系教授胡福明：《实践是检验真理的唯一标准》。</li><li>1979年11月起，邓小平主持起草《决议》。</li><li>1978年12月，党的十一届三中全会。</li><li>1980年，设立深圳、珠海、厦门、汕头经济特区。1983年增加海南为经济特区。</li><li>1983年10月，废除人民公社，建立乡镇政府作为基层政权，村民委员会为自治组织。</li><li>1992年，邓小平南方讲话。</li></ul></li><li><p>新时代</p><ul><li>1987年，党的十三大：社会主义初级阶段理论和党的基本路线。</li><li>1992年，党的十四大：计划经济到社会主义市场经济。</li><li>1997年，党的十五大：党在社会主义初级阶段的基本纲领。</li><li>2002年，党的十六大：21世纪前20年，全面建成小康社会。</li><li>2007年，党的十七大：21世纪中叶，把我国建成富强民主文明和谐的社会主义现代化强国。</li><li>2012年，党的十八大：中国特色社会主义<ul><li><p>总依据：社会主义初级阶段。</p></li><li><p>总布局：经济、政治、文化、社会、生态文明建设五位一体。</p></li><li><p>四个全面：全面建成小康社会，全面深化改革，全面依法治国，全面从严治党。</p></li></ul></li><li>2017年，党的十九大：<ul><li>主要矛盾：人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</li><li>中国特色社会主义发展的战略安排：<ul><li>2020年，全面建成小康社会。</li><li>2035年，基本实现社会主义现代化。</li><li>21世纪中叶，把我国建成富强民主文明和谐美丽的社会主义现代化强国。</li></ul></li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>大学政治</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>思想道德与法治总结</title>
    <link href="/2024/07/03/%E6%94%BF%E6%B2%BB/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB%E6%80%BB%E7%BB%93/"/>
    <url>/2024/07/03/%E6%94%BF%E6%B2%BB/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1 id="思想道德与法治">思想道德与法治</h1><h2 id="绪论">0. 绪论</h2><ol type="1"><li>时代新人的特征：立大志，明大德，成大才，担大任。</li><li>道德和法律的关系：<ul><li>道德和法律都是调节人们思想行为，协调人际关系，维护社会秩序的重要手段。</li><li>道德和法律调节领域、方式和目标不同，但共同服务于一定的经济基础，组成上层建筑。</li><li>道德建设为法治建设提供思想指引和价值基础，法治建设为道德建设提供制度支持和法律支撑。</li></ul></li><li>思想道德素质指人民的思想境界和道德风貌，法治素养指人民理解和运用法律和法治思维的能力。</li></ol><h2 id="思想">1. 思想</h2><h3 id="人生观">人生观</h3><ol type="1"><li><p>人是一切社会关系的总和，社会属性是人的本质属性。</p></li><li><p>个人与社会的关系问题是认识和处理人生问题的重要着眼点和出发点。</p><ul><li>个人与社会是对立统一的关系。<ul><li>社会由人组成，是人的存在形式。</li><li>社会发展的重要基础是社会成员素质的不断提高。</li><li>社会发展的根本目标是推动和实现人的全面发展。</li></ul></li><li>个人与社会的关系中最根本的是个人利益与社会利益的关系。<ul><li>社会利益是所有人利益的有机统一。</li><li>社会利益是个人的根本利益和长远利益，也是个人利益实现的前提和基础。</li><li>在社会主义社会中，个人利益与社会利益在根本上是一致的。</li></ul></li><li>人的社会性决定了人只有在推动社会进步的过程中，才能实现自我的发展。</li></ul></li><li><p>人生观包括人生目的、人生态度、人生价值。</p><ul><li>人生目的是人生观的核心，决定人生道路、态度和价值选择。</li><li>人生价值包含自我价值和社会价值。<ul><li>自我价值是个体生存发展的必要条件，社会价值是社会存在和发展的重要条件。</li><li>自我价值实现是为社会创造更大价值的前提，社会价值是个体价值的保障。</li></ul></li></ul></li></ol><ul><li>世界观和人生观的关系：世界观决定人生观，人生观对世界观的巩固、发展和变化起重要作用。</li></ul><ol start="4" type="1"><li><p>正确的人生观：</p><ul><li><p>人生目的：服务人民、奉献社会。</p></li><li><p>人生态度：认真务实、乐观向上、积极进取。</p></li><li><p>人生价值：</p><ul><li>评价尺度：实践活动是否符合社会发展的客观规律，是否促进历史进步。<ul><li>在今天，最重要的是看一个人是否用自己的劳动和聪明才智服务人民、奉献社会。</li></ul></li><li>评价方法：<ul><li>既要看贡献大小，也要看尽力程度。</li><li>既要尊重物质贡献，也要尊重精神贡献。</li><li>既要注重社会贡献，也要注重自身完善。</li></ul></li><li>实现条件：从社会客观条件和个体自身条件出发，不断增强实现人生价值的能力和本领。<ul><li>社会实践是实现人生价值的必由之路。</li></ul></li></ul></li></ul></li><li><p>辩证对待人生矛盾：</p><ul><li>幸福观：<ul><li>幸福是总体性范畴，包含生活美好、家庭和睦等重要因素。</li><li>实现幸福离不开一定的物质条件，物质和精神都是幸福的重要方面。</li><li>幸福不能建立在损害社会、他人利益基础上。</li></ul></li><li>得失观：不拘泥于个人利益和一时的得失。</li><li>苦乐观：苦乐对立统一，相互转化。艰苦奋斗往往得到真正的快乐。</li><li>顺逆观：正视战胜逆境，在顺境戒骄戒躁。</li><li>生死观：生命有限，为人民服务无限。</li></ul></li></ol><ul><li>荣辱观：明辨是非。</li></ul><ol start="6" type="1"><li>错误人生观：拜金主义、享乐主义、极端个人主义。</li></ol><h3 id="理想和信念">理想和信念</h3><ol type="1"><li><p>理想指人们在实践中形成的、有实现可能性的、对未来社会和自身发展目标的向往与追求。</p><ul><li><p>理想的分类：个人和社会；近期和远期；崇高和一般；生活、职业、道德、政治理想。</p></li><li><p>理想具有超越性、实践性、时代性。</p></li><li><p>理想和现实的辩证关系：</p><ul><li><p>理想和现实是对立统一的关系。</p></li><li><p>实现理想具有长期性、艰巨性和曲折性，艰苦奋斗是实现理想的重要条件。</p></li></ul></li><li><p>个人理想和社会理想：个人理想以社会理想为指引，社会理想是个人理想的汇聚和升华。</p></li></ul></li><li><p>信念指人们在一定认识基础上确立的对某种思想或事物坚信不疑并身体力行的精神状态。</p><ul><li><p>信念具有执着性、支撑性、多样性。</p></li><li><p>信仰、信念、信心任何时候都至关重要。</p></li></ul></li><li><p>理想和信念总是相互依存的，理想是信念的对象，信念是理想实现的保障。</p></li><li><p>理想信念是精神之钙。</p><ul><li>理想指引方向，信念决定成败。</li><li>理想信念昭示奋斗目标、催生前进动力、提供精神支柱、提高精神境界。</li></ul></li><li><p>马克思主义信仰：</p><ul><li>马克思主义是我们认识和改造世界的强大思想武器。</li><li>马克思主义是科学的理论，揭示了人类社会发展规律。</li><li>马克思主义是人民的理论，创立了人民实现自身解放的思想体系。</li><li>马克思主义是实践的理论，指引人民改造世界。</li><li>马克思主义是不断发展的开放的理论，站在时代前沿。</li></ul><p>马克思主义只有与中国具体实际相结合、同中华优秀传统文化相结合，才能焕发出强大的生命力、创造力和感召力。</p></li><li><p>中国特色社会主义是我们的共同理想的原因：</p><ul><li>中国特色社会主义是科学社会主义。</li><li>中国特色社会主义是实现中国梦的正确道路。</li><li>中国共产党的领导是中国特色社会主义的本质特征。</li></ul></li><li><p>什么是共产主义远大理想：</p><ul><li>共产主义是现实运动和长远目标相统一的过程。</li><li>共产主义远大理想的最终实现是一个漫长艰辛的历史过程。</li></ul></li><li><p>实现中华民族伟大复兴是中华民族近代以来最伟大的梦想。</p><ul><li><p>实现中华民族伟大复兴的中国梦是一项光荣而艰巨的事业。</p></li><li><p>为实现中国梦注入青春能量：</p><ul><li>立鸿鹄志，做奋斗者。</li><li>心怀“国之大者”，敢于担当。</li><li>自觉躬身实践，知行合一。</li></ul></li></ul></li></ol><h3 id="中国精神">中国精神</h3><ol type="1"><li><p>中华民族崇尚精神的优秀传统的表现：</p><ul><li>对物质生活和精神生活相互关系的独到理解。</li><li>对品格养成的重视。</li><li>对理想的不懈追求。</li></ul></li><li><p>中国精神包含伟大的创造、奋斗、团结、梦想精神。</p><ul><li><p>中国精神是凝聚中国力量的精神纽带、激发创新创造的精神动力、推进复兴伟业的精神支柱。</p></li><li><p>中国共产党是中国精神的忠实继承者和坚定弘扬者。</p></li></ul></li><li><p>爱国主义是调节个人与祖国之间关系的道德准则、政治原则和法律规范。</p><ul><li><p>爱什么：祖国的大好河山、自己的骨肉同胞、祖国的灿烂文化、自己的国家。</p></li><li><p>新时代爱国主义的基本要求：</p><ul><li><p>坚持爱国爱党爱社会主义相统一。</p><ul><li>不同历史条件下形成的爱国主义具有不同的内涵和特点。</li><li>当代中国爱国主义的本质就是坚持爱国和爱党、爱社会主义的高度统一。</li></ul></li><li><p>维护祖国统一和民族团结。</p></li><li><p>尊重和传承中华民族历史文化。</p></li><li><p>坚持立足中国又面向世界。</p><ul><li>立足中国，维护国家发展主体性。</li><li>面向世界，推动构建人类命运共同体。</li></ul></li><li><p>爱国的方式：维护和推进祖国统一，促进民族团结，增强国家安全意识。</p></li></ul></li></ul></li><li><p>弘扬以爱国主义为核心的民族精神、以改革创新为核心的时代精神。</p><ul><li>民族精神和时代精神都是中国精神的重要组成部分。</li><li>民族精神赋予中国精神以民族特征，时代精神赋予中国精神以时代内涵。</li><li>民族精神曾是一定历史阶段中的时代精神，时代精神将不断丰富民族精神。</li></ul></li><li><p>改革创新是新时代的迫切要求。</p><ul><li><p>改革创新的意义和作用：</p><ul><li><p>创新是推动人类社会发展的重要力量。</p></li><li><p>创新能力是当今国际竞争新优势的集中体现。</p></li><li><p>改革创新是赢得未来的必然要求。</p></li><li><p>如何改革创新：树立改革创新自觉意识，增强改革创新能力本领。</p><ul><li>实施创新驱动发展战略，最根本的是要增强自主创新能力，最紧迫的是要破除体制机制障碍。</li></ul></li></ul></li></ul></li></ol><h2 id="道德">2. 道德</h2><h3 id="价值观">价值观</h3><ol type="1"><li><p>价值观反映特定时代精神，表现着一定时代人们的需要和利益诉求。</p><ul><li><p>在阶级社会里，占统治地位的价值观都是统治阶级的价值观。</p></li><li><p>核心价值观是国家的重要稳定器，各种文化之争本质上是价值观、意识形态之争。</p></li></ul></li><li><p>社会主义核心价值观：</p><ul><li>基本内容：富强、民主、文明、和谐，自由、平等、公正、法治，爱国、敬业、诚信、友善。<ul><li>富强、民主、文明、和谐：我们要建设怎样的国家。<ul><li>富强是促进社会进步、人的自由全面发展的物质基础。</li><li>民主是社会主义民主，人民当家作主。</li><li>文明是社会进步的重要标志，社会主义现代化国家的重要特征。</li><li>和谐是中华文明的核心价值理念。</li></ul></li><li>自由、平等、公正、法治：我们要建设怎样的社会。<ul><li>自由是社会活力之源，社会主义的价值理想。</li><li>公正是社会主义制度的本质要求。</li><li>法治是现代社会的主要特征。</li></ul></li><li>爱国、敬业、诚信、友善：我们要培育怎样的公民。<ul><li>爱国是最深沉、最持久的情感，是每个公民应当遵循的最基本的价值准则。</li><li>敬业是对待生产劳动和人类生存的一种根本价值态度。</li><li>诚信是个人立身处世的基本价值规范，是社会存续发展的重要价值基石。</li><li>友善是维系良好人际关系和社会关系的基本价值准则。</li></ul></li></ul></li><li>培育和践行社会主义核心价值观是：<ul><li>坚持和发展中国特色社会主义的价值遵循。</li><li>提高国家文化软实力的迫切要求。</li><li>推进社会团结奋进的最大公约数。</li></ul></li><li>社会主义核心价值观的特征：<ul><li>先进性，是反映人类社会发展进步的价值理念。<ul><li>社会主义是社会主义核心价值观的底色。</li><li>中华优秀传统文化是社会主义核心价值观的重要源泉。</li><li>广泛吸收借鉴人类一切文明成果。</li></ul></li><li>人民性是社会主义核心价值观的根本特性，人民立场是社会主义核心价值观的根本立场。<ul><li>为中国人民谋幸福，为中华民族谋复兴，是中国共产党人的初心和使命，也是党领导现代化建设的出发点和落脚点。</li></ul></li><li>真实性。<ul><li>西方的普世价值是一种迷惑、欺骗的价值观。</li><li>共同价值要求同存异、和而不同。</li></ul></li></ul></li><li>青年要勤学、修德、明辨、笃实，遵循社会主义核心价值观。</li></ul></li><li><p>社会主义核心价值体系：马克思主义、中国特色社会主义共同理想、以爱国主义为核心的民族精神、以改革创新为核心的时代精神、社会主义荣辱观。</p><ul><li>社会主义核心价值观是社会主义核心价值体系的精神内核。</li></ul></li></ol><h3 id="道德观">道德观</h3><ol type="1"><li><p>道德的本质是反映社会经济关系的特色意识形态，是社会利益关系的特殊调节方式，是一种实践精神。</p><ul><li><p>道德的特征：历史系、民族性、时代性、阶级性</p></li><li><p>道德的起源：劳动是首要前提，社会关系是客观条件，人的自我意识是主观条件。</p></li><li><p>道德的功能：认识、规范、调节。</p><ul><li>道德的调节方式包括道德评价（主要）、社会舆论、传统习俗、内心信念。</li></ul></li><li><p>道德的作用：</p><ul><li><p>为经济基础的形成、巩固和发展服务。</p></li><li><p>对其他社会意识形态的存在有重大的影响。</p></li><li><p>维护社会的秩序和稳定。</p></li><li><p>提高人的精神境界、促进人的自我完善、推动人的全面发展。</p></li><li><p>阶级斗争的工具。</p></li></ul></li><li><p>道德发展的基本规律：与社会生存方式的发展大体一致，螺旋式上升。</p></li><li><p>为什么人服务，是道德的核心问题。</p></li></ul></li><li><p>社会主义道德反映社会主义经济基础，具有先进性，以为人民服务为核心，以集体主义为原则。</p><ul><li><p>为人民服务</p><ul><li><p>为人民服务是社会主义经济基础和人际关系的客观要求。</p></li><li><p>为人民服务是社会主义市场经济健康发展的要求。</p></li><li><p>为人民服务是先进性和广泛性的统一。</p></li></ul></li><li><p>集体主义</p><ul><li>集体主义是调节社会利益关系的基本原则：<ul><li>国家、社会、个人利益辩证统一。</li><li>国家、社会整体利益高于个人利益。</li><li>重视保障个人利益。</li></ul></li><li>集体主义的层次性：<ul><li>无私奉献、一心为公，这是最高层次。</li><li>先公后私、先人后己。</li><li>顾全大局、遵纪守法、热爱祖国、诚实劳动，这是基本道德要求。</li></ul></li></ul></li></ul></li><li><p>优秀的道德成果：</p><ul><li><p>中华传统美德：</p><ul><li>重视整体利益，强调责任奉献。</li><li>推崇仁爱原则，注重以和为贵。</li><li>注重人伦关系，重视道德义务。</li><li>追求精神境界，向往理想人格。</li><li>强调精神修养，注重道德践履。</li></ul><p>中华传统美德的创造性转化和创新性发展：</p><ul><li>阐发传统美德，用起滋养社会主义道德建设。</li><li>反对复古论和虚无论。</li></ul></li><li><p>中国革命道德：中国传统道德的延续和发展。</p><ul><li>灵魂是为实现社会主义和共产主义的理想信念而奋斗。</li><li>红线是全心全意为人民服务。</li><li>始终把革命利益放在首位。</li><li>树立社会新风，建立新型人际关系。</li><li>修身自律，保持节操。</li></ul><p>中国革命道德的当代价值：</p><ul><li>有利于加强社会主义和共产主义的理想信念。</li><li>有利于培育和践行社会主义核心价值观。</li><li>有利于引导人们树立正确的道德观，培育良好道德风尚。</li></ul></li></ul></li><li><p>借鉴人类文明优秀道德成果：</p><ul><li>每个民族或国家都有各自的道德传统。</li><li>秉承正确态度和科学方法。</li><li>以我为主，为我所用，批判吸收。</li></ul></li><li><p>道德实践：</p><ul><li>遵守社会公德<ul><li>公共生活：（范围）广泛性、（内容）开放性、（对象）复杂性、（方式）多样性<ul><li>有序的公共生活是社会生产活动的重要基础，提高社会成员生活质量的基本保障，社会文明的重要标志。</li></ul></li><li>文明礼貌、助人为乐、爱护公物、保护环境、遵纪守法。</li><li>网络生活：正确使用网络、健康交往、避免沉迷、文明自律</li></ul></li><li>恪守职业道德：爱岗敬业、诚实守信、办事公道、热情服务</li><li>弘扬家庭美德：尊老爱幼、男女平等、夫妻和睦、勤俭持家、邻里互助</li><li>锤炼个人品德：自律、知行合一、积善成德、学思并重<ul><li>正确的道德认知和道德判断。</li><li>正向的道德认同和道德情感。</li><li>强化道德意志和道德信念。</li></ul></li></ul></li><li><p>志愿服务的精神是奉献、友爱、互助、进步。</p></li><li><p>良好的社会风气：知荣辱、讲正气、作奉献、促和谐。</p></li></ol><h2 id="法治">3. 法治</h2><ol type="1"><li><p>法律是由国家制定或认可，并由国家强制力保证实施的，反映由特定社会物质条件决定的统治阶级意志的规范体系。</p></li><li><p>我国社会主义法律的本质特征：</p><ul><li>体现了党的主张和人民意志的统一。</li><li>具有科学性和先进性。</li><li>是中国特色社会主义建设的重要保障。</li></ul></li><li><p>我国社会主义法律的运行：</p><ul><li>法律制定：起始性和关键性环节<ul><li>立法机关：全国人民代表大会及其常务委员会。</li><li>立法原则：公正、公平、公开。</li><li>立法环节：提出、审议、表决、公布。</li></ul></li><li>法律执行：行政执法是法律实施和实现的重要环节。<ul><li>执法机关：中央和地方各级政府、享有执法权的下属机构。</li><li>执法原则：合法性、合理性、信赖保护、效率。</li></ul></li><li>法律适用：<ul><li>司法机关：国家审判机关和检察机关。</li><li>司法原则：司法公正，公民在法律面前一律平等，事实为根据、法律为准绳。</li><li>司法的基本要求：正确、合法、合理、及时。</li></ul></li><li>法律遵守：守法是法律实施和实现的基本途径。</li></ul></li><li><p>习近平法治思想：</p><ul><li>习近平法治思想的意义：<ul><li>凝聚着中国共产党人在法治建设长期探索中形成的经验积累和智慧结晶。</li><li>标志着我们党对共产党执政规律、社会主义建设规律、人类社会发展规律的认识达到了新高度。</li><li>开辟了21世纪马克思主义法治理论和实践的新境界。</li><li>习近平新时代中国特色社会主义思想的重要组成部分。</li><li>全面依法治国的根本遵循和行动指南。</li></ul></li><li>十一个坚持：系统阐述了新时代推进全面依法治国的重要思想和战略部署。<ul><li>坚持党对全面依法治国的领导。</li><li>坚持以人民为中心。</li><li>坚持中国特色社会主义法治道路。</li><li>坚持依宪治国、依宪执政。</li><li>坚持在法治轨道上推进国家治理体系和治理能力现代化。</li><li>坚持建设中国特色社会主义法治体系。</li><li>坚持依法治国、依法执政、依法行政，共同推进法治国家、法治政府、法治社会一体建设。</li><li>坚持全面推进科学立法、严格执法、公正司法、全民守法。</li><li>坚持统筹推进国内法治和涉外法治。</li><li>坚持建设德才兼备的高素质法治工作队伍。</li><li>抓住领导干部这个关键少数。</li></ul></li></ul></li><li><p>中国特色社会主义法治道路的核心要义是要坚持党的领导，坚持中国特色社会主义制度，贯彻中国特色社会主义法治理论。</p><ul><li>为什么走中国特色社会主义法治道路：历史的必然结论，国家性质决定，基本国情的必然选择。</li><li>坚持中国特色社会主义法治道路遵循的原则：<ul><li>坚持中国共产党的领导。</li><li>坚持人民主体地位。</li><li>坚持法律面前人人平等。平等是社会主义法律的基本属性，是社会主义法制的基本要求。</li><li>坚持依法治国与以德治国相结合。</li><li>坚持从中国实际出发。</li></ul></li></ul></li><li><p>全面依法治国的宏伟目标是建设法治中国，要以建设中国特色社会主义法律体系为总抓手，坚持依法治国、依法执政、依法行政共同推进，坚持法治国家、法治政府、法治社会一体建设，坚持全面推进科学立法、严格执法、公正司法、全民守法。</p><ul><li><p>全面依法治国的根本目的是依法保障人民权益。</p></li><li><p>建设中国特色社会主义法律体系：</p><ul><li>完备的法律体系。</li><li>高效的法治实施体系。</li><li>严密的法治监督体系。</li><li>有力的法治保障体系。</li><li>完善的党内法规体系。</li></ul></li><li><p>共同推进法治国家、法治政府、法治社会一体建设：</p><ul><li><p>法治国家是目标，法治政府是重点和主体工程，法治社会是基础。</p></li><li><p>科学立法是全面依法治国的前提。</p></li><li><p>严格执法是全面依法治国的关键。</p></li><li><p>公正司法是全面依法治国的重点。</p></li><li><p>全民守法是全面依法治国的基础。</p></li></ul></li></ul></li><li><p>宪法的地位：</p><ul><li>我国宪法是国家的根本法，是党和人民意志的集中体现。</li><li>我国宪法是国家各项制度和法律法规的总依据。</li><li>我国宪法规定了国家的根本制度。</li><li>宪法是实现国家认同、凝聚社会共识、促进个人发展的基本准则，是维系一个国家、一个民族凝聚力的根本纽带。</li></ul><p>我国宪法的基本原则：</p><ul><li>党的领导</li><li>人民当家作主</li><li>尊重和保障人权</li><li>社会主义法治</li><li>民主集中制</li></ul><p>我国宪法规定的公民权利：</p><ul><li>政治权利：选举、表达、民主管理、监督</li><li>人身权利：生命健康、人身自由、人格尊严、住宅安全、通信自由</li><li>财产权利：私有财产权、继承权</li><li>社会经济权利：劳动权、休息权、社会保障权、物质帮助权</li><li>宗教信仰自由</li><li>文化教育权利</li></ul></li><li><p>法律权利：</p><ul><li>由一定的社会物质生活条件所制约。</li><li>因社会制度和国家法律不同而存在差异。</li><li>受法律维护或保障。</li></ul><p>法律义务：</p><ul><li>履行表现：作为和不作为</li><li>特点：历史的，源于现实需要，依法设定，可能发生变化。</li></ul><p>法律权利和法律义务的关系：</p><ul><li>人既享受法律权利，也承担法律义务。</li><li>法律权利的实现以履行义务为条件。</li><li>法律义务的设定和履行以法律权利的行使为依据。</li><li>有些法律权利和法律义务是复合的。</li></ul><p>依法行使法律权利的限制：</p><ul><li>目的正当性</li><li>必要限度</li><li>方式法定性</li><li>正当程序</li></ul><p>法律义务的内容：</p><ul><li>维护国家统一、民族团结</li><li>遵守宪法和法律</li><li>维护祖国安全、荣誉和利益</li><li>依法服兵役</li><li>依法纳税</li></ul></li><li><p>法治素养：</p><ul><li>尊重法律权威</li><li>学习法律知识：提升法治素养的前提<ul><li>收听收看法治节目、阅读法律报刊、运用新媒体学习法律知识</li><li>法治实践：参与立法讨论、旁听司法审判</li></ul></li><li>养成守法习惯</li><li>提高用法能力：维护自身权益和社会利益</li></ul></li><li><p>法治思维：</p></li></ol><ul><li><p>含义：正当性思维、规范性思维、逻辑思维、科学思维。</p></li><li><p>内容：</p><ul><li>法律至上：普遍适用和优先适用</li><li>权利制约：权利由法定、有权必有责、用权受监督、违法受追究</li><li>公平正义：<ul><li>权利公平：权利主体、享有权利、权利保护和救济平等</li><li>机会公平</li><li>规则公平</li><li>救济公平：司法、行政、社会救济公平</li></ul></li><li>权利保障：宪法、立法、行政、司法保障</li><li>程序正当：程序的合法性、中立性、参与性、公开性</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>大学政治</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>毛概总结</title>
    <link href="/2024/07/02/%E6%94%BF%E6%B2%BB/%E6%AF%9B%E6%A6%82%E6%80%BB%E7%BB%93/"/>
    <url>/2024/07/02/%E6%94%BF%E6%B2%BB/%E6%AF%9B%E6%A6%82%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1id="毛泽东思想和中国特色社会主义理论体系概论总结">毛泽东思想和中国特色社会主义理论体系概论总结</h1><h2 id="新民主主义革命理论">1. 新民主主义革命理论</h2><ol type="1"><li><p>新民主主义革命的根本任务：推翻帝国主义、封建主义和官僚资本主义的统治。</p></li><li><p>新民主主义革命的性质：资产阶级民主革命。</p><ul><li>建立各革命阶级在无产阶级领导下的联合专政，不破坏参加反帝反封建的资本主义成分。</li></ul></li><li><p>1948年，总路线：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命。</p><ul><li>领导力量：无产阶级<ul><li><p>无产阶级的基本优点：无私有生产资料，与先进的生产方式相联系，富于组织纪律性。</p></li><li><p>中国无产阶级的特点：坚决彻底，分布集中，和农民亲密团结。</p></li></ul></li><li>其他革命动力：农民阶级、城市小资产阶级、民族资产阶级<ul><li>农民问题是中国革命的基本问题。</li><li>新民主主义革命实质上是党领导下的农民革命，中国革命战争实质上是党领导下的农民战争。</li><li>贫农是无产阶级最可靠的同盟军，中农是无产阶级可靠的同盟军。</li></ul></li></ul></li><li><p>基本纲领：</p><ul><li><p>政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。</p><ul><li>国体：各革命阶级联合专政。</li><li>政体：民主集中制的人民代表大会制度。</li></ul></li><li><p>经济纲领：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归国家所有，保护民族工商业。</p><ul><li>没收官僚资本，包含着新民主主义革命和社会主义革命的双重性质。</li></ul></li><li><p>文化纲领：民族的科学的大众的文化。</p><ul><li>民族的：反帝国主义。</li><li>科学的：反封建迷信，实事求是。</li><li>大众的：民主的。</li></ul><p>共产主义思想居于指导地位。</p></li></ul></li><li><p>新民主主义革命道路：土地革命、武装斗争、农村革命根据地建设。</p><ul><li>土地革命是基本内容，武装斗争是主要形式，农村革命根据地建设是前两者的依托。</li></ul></li><li><p>新民主主义革命三大法宝：统一战线、武装斗争、党的建设。</p><ul><li>统一战线和武装斗争是中国革命的两个基本特点，也是两个基本武器。</li><li>统一战线是武装斗争的统一战线，武装斗争是统一战线的中心支柱。</li></ul></li><li><p>统一战线中的两个联盟：</p><ul><li>工人阶级同农民阶级、广大知识分子及其他劳动者的联盟，主要是工农联盟。是统一战线的基础。</li><li>工人阶级和非劳动人民的联盟，主要是与民族资产阶级的联盟。</li></ul></li><li><p>党建设、巩固和发展统一战线的实践经验：</p><ul><li>建立巩固的工农联盟。</li><li>正确对待资产阶级，尤其是民族资产阶级。</li><li>采取区别对待的方针。</li><li>坚持独立自主的原则。</li></ul></li><li><p>建设人民军队的经验：</p><ul><li>坚持党对军队的绝对领导。</li><li>建设全心全意为人民服务的人民军队。</li><li>开展革命的政治工作。<ul><li>人民军队政治工作的基本原则：<ul><li>官兵一致。</li><li>军民一致。</li><li>瓦解敌军、优待俘虏。</li></ul></li></ul></li><li>坚持正确的战略战术原则。</li></ul></li><li><p>党的建设包含三大建设：思想建设、组织建设、作风建设。</p><ul><li>思想建设始终是首位。</li><li>在任何时候重视组织建设。组织建设根本的是贯彻民主集中制。</li><li>重视作风建设。</li><li>联系党的政治路线。</li></ul></li></ol><h2 id="社会主义改造理论">2. 社会主义改造理论</h2><ol type="1"><li><p>1953年12月，过渡时期的总路线：</p><p>从中华人民共和国成立，到社会主义改造完成，这是一个过渡时期。党在这个时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造。</p><ul><li>主要任务是实现国家工业化，为此必须进行社会主义改造，确立社会主义基本制度。</li></ul></li><li><p>农业社会主义改造道路：</p><ul><li><p>积极引导农民组织起来，走互助合作道路。</p><ul><li>积极性的两个方面：个体积极性、互助合作积极性。</li></ul></li><li><p>遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路。</p></li><li><p>正确分析农村的阶级和阶层状况，制定正确的阶级政策。</p></li><li><p>坚持积极领导、稳步前进的方针，采取循序渐进的步骤。</p><ul><li>互助社：生产资料归个体，互帮互助，社会主义萌芽。</li><li>初级社：生产资料入股，统一经营，半社会主义。</li><li>高级社：生产资料归集体，按劳分配，完全社会主义。</li></ul></li><li><p>在实现农业合作化后，国家应努力用先进的技术装备发展农业经济。</p></li></ul></li><li><p>手工业社会主义改造道路：积极领导、稳步前进，从供销合作到生产合作</p><ul><li>手工业供销小组：把手工业者组织起来，社会主义萌芽。</li><li>手工业供销合作社：统一供销，生产分散完成，半社会主义。</li><li>手工业生产合作社：生产资料归集体，按劳分配，社会主义。</li></ul></li><li><p>资本主义工商业社会主义改造：</p><ul><li><p>和平赎买：私营企业改为国企，资本家在一定年限内有分红。</p><ul><li>有利于发挥私营工商业在国计民生方面的积极作用。</li><li>有利于争取和团结民族资产阶级。</li><li>有利于巩固和发展统一战线。</li><li>有利于发挥民族资产阶级的知识、才能、技术和管理经验。</li></ul><p>和平赎买的可行性：</p><ul><li>民族资产阶级的两面性。</li><li>长期的统一战线。</li><li>国营经济掌控经济命脉。</li></ul></li><li><p>从低级到高级的国家资本主义过渡形式：</p><ul><li>初级国家资本主义：由国家对私营工商业进行委托加工、计划订货、统购包销、经销代销。<ul><li>四马分肥：利润分给国家所得税、企业公积金、工人福利费、资方红利。</li></ul></li><li>个别企业的公私合营：国家入股，生产资料由国家与资本家共有。</li><li>全行业公私合营</li></ul></li></ul></li></ol><h2 id="社会主义建设初步">3. 社会主义建设初步</h2><ol type="1"><li><p>调动一切积极因素为社会主义事业服务。</p><ul><li>坚持中国共产党的领导。</li><li>发展社会主义民主政治。</li></ul></li><li><p>正确认识和处理社会主义社会矛盾的思想。</p><ul><li>党的八大提出的社会主义改造后社会主要矛盾：<ul><li>人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾。</li><li>人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾。</li></ul></li><li>两类社会矛盾：敌我矛盾和人民内部矛盾<ul><li>敌我矛盾：反抗社会主义者和人民的矛盾，采用专政的方法。</li><li>人民内部矛盾：人民根本利益一致基础上的矛盾，采用民主的方法。</li></ul></li><li>关于正确处理人民内部矛盾的问题是社会主义国家政治生活的主题。</li></ul></li><li><p>走中国工业化道路，必须采取正确的经济建设方针，必须调整和完善所有制结构，必须积极探索适合我国情况的经济体制和运行机制。</p><ul><li>中国工业化道路的问题，主要是指重工业、轻工业和农业的发展关系问题。</li><li>以农业为基础，以工业为主导，以农轻重为序发展国民经济的总方针。</li><li>两条腿走路的工业化发展思路：<ul><li>重工业和轻工业并举</li><li>中央工业和地方工业并举</li><li>沿海工业和内地工业并举</li><li>大型企业和中小型企业并举</li></ul></li></ul></li><li><p>四个现代化：工业、农业、科学文化、国防。</p></li><li><p>初步探索的意义：</p><ul><li>巩固和发展了我国的社会主义制度。</li><li>为开创中国特色社会主义提供了宝贵经验、理论准备和物质基础。</li><li>丰富了科学社会主义的理论和实践。</li></ul></li></ol><h2 id="中国特色社会主义">4. 中国特色社会主义</h2><ol type="1"><li><p>邓小平理论首要的基本的理论问题：什么是社会主义，怎样建设社会主义。</p><ul><li><p>搞清楚这个问题，关键是要在坚持社会主义基本制度的基础上进一步认清社会主义的本质。</p></li><li><p>社会主义的本质：解放和发展生产力，消灭剥削和两极分化，最终达到共同富裕。</p></li><li><p>社会主义的根本任务是发展生产力。</p></li></ul><p>邓小平理论的精髓：解放思想，实事求是。</p><ul><li>两条根本原则：以社会主义公有制经济为主体、共同富裕。</li><li>物质文明和精神文明两手抓。</li><li>一国两制、和平统一。</li></ul></li><li><p>社会主义初级阶段理论：</p><ul><li>社会主义初级阶段，就是指我国在生产力落后、商品经济不发达条件下建设社会主义的特定阶段。<ul><li>即我国从进入社会主义到基本实现社会主义现代化的整个历史阶段。</li></ul></li><li>我国正处于并将长期处于社会主义初级阶段。</li><li>两层含义：我国是社会主义社会，必须坚持社会主义；必须正视而不能超越初级阶段。</li></ul></li><li><p>党在社会主义初级阶段的基本路线：</p><p>领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放、自力更生、艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗。</p></li><li><p>三步走基本实现现代化：</p><ul><li>1990年国民生产总值比1980年翻一番，解决温饱问题。</li><li>20世纪末，国民生产总值再翻一番，人民生活达到小康水平。</li><li>21世纪中叶，人均国民生产总值达到中等发达国家水平，基本实现现代化。</li></ul></li><li><p>社会主义改革开放：</p><ul><li>改革：社会主义制度的自我完善和发展。<ul><li>改革是社会主义社会发展的直接动力。</li><li>判断改革得失的标准：是否有利于发展生产力，增强综合国力，提高人民生活水平。</li></ul></li><li>对外开放是建设中国特色社会主义的一项基本国策。<ul><li>对外开放的要求：<ul><li>范围：对发达和发展中国家开放经济、科技、教育、文化等领域。</li><li>学习内容：正确对待资本主义社会创造的现代文明成果。</li><li>开放原则：坚决维护中国人民的独立自主权利。</li></ul></li></ul></li></ul></li><li><p>社会主义市场经济理论：</p><ul><li>我国经济体制改革的核心问题：如何正确认识和处理计划和市场的关系。</li><li>理论要点：<ul><li>计划经济不等于社会主义，市场经济不等于资本主义。</li><li>要结合计划和市场的优势。</li><li>市场作为资源配置的手段不具有制度属性。</li></ul></li></ul></li><li><p>“一国两制”是一项基本国策，指在统一的国家内，国家主体实行社会主义制度，个别地区依法实行资本主义制度。</p><ul><li><p>一国两制是中国共产党领导人民实现祖国和平统一的伟大构想。</p><ul><li>针对台湾问题提出，先用于香港、澳门问题。</li></ul></li><li><p>一国两制为国际社会提供了新思路新方案。</p></li><li><p>一国两制的根本宗旨是维护国家主权、安全、发展利益。</p><ul><li>全面管治权和高度自治权统一。</li><li>坚持爱国者治港、爱国者治澳、依法治港治澳。</li></ul></li><li><p>一国两制的提出首先是为了实现和维护国家统一，任何危害国家主权安全、挑战中央权力和香港特别行政区基本法权威、利用香港对内地进行渗透破坏的活动，都是对底线的触碰，决不允许。</p></li></ul></li><li><p>三个代表重要思想：中国共产党必须始终代表</p><ul><li>中国先进生产力的发展要求</li><li>中国先进文化的前进方向</li><li>中国最广大人民的根本利益。</li></ul></li><li><p>科学发展观：</p><p>第一要义是发展，核心立场是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>大学政治</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>马克思主义基本原理总结</title>
    <link href="/2024/07/01/%E6%94%BF%E6%B2%BB/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <url>/2024/07/01/%E6%94%BF%E6%B2%BB/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1 id="马克思主义基本原理总结">马克思主义基本原理总结</h1><h2 id="导论">导论</h2><ol type="1"><li><p>1848年2月，《共产党宣言》发表，标志着马克思主义的公开问世。马克思主义产生的背景：</p><ul><li>社会根源：资本主义经济的发展。</li><li>阶级基础：英法德工人运动兴起，标志着现代无产阶级作为独立的政治力量登上历史舞台。</li><li>思想渊源：<ul><li>直接来源：德国古典哲学、英国古典政治经济学、英法空想社会主义；</li><li>自然科学：细胞学说、生物进化论、能量守恒与转化定律；</li><li>思想前提：从唯心主义到唯物主义的转变、从革命民主主义到共产主义的转变。</li></ul></li></ul></li><li><p>马克思主义创立时期的重要著作：</p><ul><li>1844年，马克思、恩格斯在《德法年鉴》上的论文表明他们完成了从唯心主义到唯物主义的转变、从革命民主主义到共产主义的转变，奠定了马克思主义的思想前提。</li><li>1845年《神圣家族》是马克思、恩格斯合著的第一本著作。</li><li>1845年马恩合著的《德意志意识形态》首次系统阐述了历史唯物主义的基本观点。</li><li>马克思<ul><li>1867年《资本论》第一卷，被称为工人阶级的圣经。</li><li>1871年《法兰西内战》科学总结了巴黎公社的历史经验。</li><li>1875年《哥达纲领批判》对未来社会从制度、发展阶段以及分配等方面作了原则构想。</li></ul></li><li>恩格斯<ul><li>1876-1878年《反杜林论》全面阐述了马克思主义理论体系。</li><li>《家庭、私有制和国家的起源》《路德维希·费尔巴哈和德国古典哲学的终结》进一步发展了马克思主义理论。</li></ul></li></ul></li><li><p>马克思主义是由马克思和恩格斯创立并为后继者所不断发展的科学理论体系。</p><ul><li><p>是关于自然、社会和人类思维发展一般规律的学说。</p></li><li><p>是关于社会主义必然代替资本主义、最终实现共产主义的学说。</p></li><li><p>关于无产阶级解放、全人类解放和每个人自由而全面发展的学说。</p></li><li><p>是无产阶级政党和社会主义国家的指导思想。</p></li><li><p>是指引人民创造美好生活的行动指南。</p></li></ul></li><li><p>马克思主义哲学、马克思主义政治经济学、科学社会主义是马克思主义的三个基本组成部分。</p></li><li><p>马克思主义的特征：科学性、人民性、实践性、发展性。</p><ul><li>马克思主义的基本特征，用一句话来概括就是科学性和革命性的统一。</li><li>人民性是马克思主义的本质属性和鲜明品格，人民至上是马克思主义的政治立场。</li><li>实践性是马克思主义理论区别于其他理论的根本特征，实践的观点是马克思主义的基本观点。</li></ul></li><li><p>马克思主义的历史发展：</p><ul><li>列宁把马克思主义基本原理同俄国实际相结合，创立了列宁主义。</li><li>中国共产党在不断探索中将马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，产生了毛泽东思想和中国特色社会主义理论体系。</li></ul></li><li><p>马克思主义的当代价值：</p><ul><li>观察当代世界变化的认识工具。</li><li>指引当代中国发展的行动指南。</li><li>引领人类社会进步的科学真理。</li></ul></li></ol><h2 id="哲学">哲学</h2><h3 id="辩证唯物论">辩证唯物论</h3><h4 id="物质统一性">物质统一性</h4><ol type="1"><li><p>物质是不依赖于人类意识而存在，并能为人类意识所反映的客观实在。</p><ul><li>这种客观实在性，是从自然存在和社会实在中抽象出的共同特性，是物质的唯一特性。</li></ul></li><li><p>运动是标志一切事物和现象的变化及其过程的哲学范畴，是物质的<strong>存在方式</strong>和<strong>根本属性</strong>。</p><p>相对静止是物质运动在一定条件下的稳定状态，运动和静止是对立统一的关系。</p><ul><li><p>运动和静止的区别在于运动的绝对性和静止的相对性。</p></li><li><p>运动和静止的联系表现在运动和静止相互依赖、渗透、包含。</p></li></ul></li><li><p>时空是运动着的物质的基本存在形式，时空和物质运动的不可分割性证明了时空具有客观性。</p><ul><li>具体物质形态的时空是有限的，而整个物质世界的时空是无限的。</li><li>物质运动时空的客观实在性是绝对的，具体特性是相对的。</li></ul></li><li><p>意识的本质是人脑的机能和属性，是客观世界的主观映像。</p><ul><li>意识是自然界和社会历史发展的产物，社会实践，特别是劳动，对意识产生发展起决定性作用。</li><li>意识在内容上是客观的，在形式上是主观的。</li><li>意识对物质的反作用：<ul><li>意识具有目的性和计划性。</li><li>意识具有创造性。</li><li>意识具有指导实践改造客观世界的作用。</li><li>意识具有调控人的行为和生理活动的作用。</li></ul></li></ul></li><li><p>尊重客观规律是正确发挥主观能动性的前提；充分发挥主观能动性，才能正确认识和利用客观规律。</p><ul><li><p>实践是客观规律性和主观能动性统一的基础：</p><ul><li><p>从实际出发是发挥人的主观能动性的前提。</p></li><li><p>实践是正确发挥人的主观能动性的根本途径。</p></li><li><p>正确发挥人的主观能动性，还要依赖于一定的物质条件和物质手段。</p></li></ul></li></ul></li><li><p>世界的物质统一性原理：自然界是物质的，人类社会是物质的，人的意识统一于物质。</p><ul><li>方法论：一切从实际出发。</li></ul></li><li><p>人类的实践活动是自然界与人类社会、客观世界和主观世界相分化与统一的关键。</p><ul><li>自然界和人类社会交叉重叠和相互作用。</li><li>主观世界具有相对独立性，从属于客观世界。</li></ul></li></ol><h4 id="唯物辩证法">唯物辩证法</h4><ol type="1"><li><p>唯物辩证法是关于世界普遍联系和变化发展的科学，联系和发展是唯物辩证法的总观点和总特征。</p><ul><li>本质上是批判的、革命的，是客观和主观辩证法的统一，是认识和改造世界的根本方法。<ul><li>系统观念是唯物辩证法普遍联系观点的应有之义。</li><li>坚持事物发展是一个过程的思想，用历史的眼光看问题。</li></ul></li></ul></li><li><p>联系是事物内部或事物之间相互影响、制约、作用的关系。</p><ul><li>联系的特点：客观性、普遍性、多样性、条件性。</li></ul></li><li><p>发展是运动的基本趋势，发展的实质是新事物的产生和旧事物的灭亡。</p><ul><li><p>新事物必然战胜旧事物的原因：</p><ul><li><p>新事物有新的要素、结构和功能，适应新环境和条件。</p></li><li><p>新事物否定了旧事物消极的部分，保留了旧事物合理的部分，添加了新内容。</p></li></ul></li></ul></li><li><p>对立统一规律，即矛盾规律，揭示了事物普遍联系的根本内容和变化发展的内在动力，从根本上回答了事物为什么会发展的问题，是唯物辩证法的实质和核心。</p><ul><li>矛盾是反映事物内部或事物之间的对立统一关系的哲学范畴。</li><li>矛盾的斗争性是无条件的、绝对的，矛盾的同一性是有条件的、相对的，斗争性寓于同一性之中。</li><li>矛盾的普遍性是无条件的、绝对的，矛盾的特殊性是有条件的、相对的，普遍性寓于特殊性之中。</li><li>矛盾的不平衡发展原理：根本矛盾贯穿事物发展始终，规定事物的性质，主要矛盾对事物发展起决定作用，矛盾的性质主要是由矛盾的主要方面决定的。</li></ul></li><li><p>量变质变规律：量变是质变的必要准备，质变是量变的必然结果。在总的量变中有阶段性和局部性的部分质变，在质变过程中也有旧质的量收缩和新质的量扩张。</p><ul><li><p>质是事物区别于其他事物的内在规定性，量是事物的规模、程度、速度等规定性。</p></li><li><p>度是保持事物质的稳定性的数量界限，量和质在度中得到统一。</p></li><li><p>量变质变规律体现了事物发展的渐进性和飞跃性的统一。</p></li></ul></li><li><p>否定之否定规律：事物的辩证发展经过第一次否定，使矛盾得到初步解决，而处于否定阶段的事物仍然具有片面性，还要经过再次否定，实现对立面的统一，使矛盾得到根本解决。</p><ul><li><p>辩证否定观：事物内部存在肯定因素和否定因素。</p><ul><li>否定是事物的自我否定、自我发展。</li><li>否定是旧事物向新事物事物发展的环节。</li><li>否定是新旧事物联系的环节。</li><li>辩证否定的实质是扬弃。</li></ul></li></ul></li><li><p>唯物辩证法五对基本范畴：</p><ul><li>内容和形式</li><li>现象和本质</li><li>原因和结果</li><li>必然和偶然</li><li>可能和现实</li></ul></li></ol><h4 id="实践和认识">实践和认识</h4><ol type="1"><li><p>实践是感性的、对象性的物质活动，全部社会生活在本质上是实践的。</p><ul><li><p>实践的基本特征是客观实在性、自觉能动性、社会历史性。</p></li><li><p>实践的基本结构包含三项基本要素：主体、客体、中介。</p><ul><li>主客体相互作用的关系包括实践关系、认识关系和价值关系。实践关系是最根本的关系。</li><li>主体、客体和中介是不断变化发展的，主要表现为主体客体化和客体主体化的双向运动。</li></ul></li><li><p>实践的形式包含三种基本类型：物质生产实践、社会政治实践、科学文化实践。</p><ul><li>物质生产实践是最基本的实践活动，构成全部社会生活的基础。</li><li>虚拟实践是实践活动的派生形式，具有相对独立性。</li></ul></li></ul></li><li><p>唯物主义能动反映论：认识是主体在实践基础上对客体的能动反映。</p><ul><li><p>认识既具有反映客体内容的反映性特征，也具有实践的主体能动的创造性特征。</p></li><li><p>认识的过程：</p><ul><li>从实践到认识：感性认识到理性认识的飞跃<ul><li>理性认识依赖于感性认识。</li><li>感性认识有待于发展和深化为理性认识。</li><li>感性认识和理性认识相互渗透、包含。</li></ul></li><li>从认识到实践：理性认识到实践的飞跃</li></ul></li><li><p>认识中的影响因素包含理性因素和非理性因素。</p></li><li><p>认识的两大规律：反复性和无限性。</p></li></ul></li><li><p>实践是认识的基础，对认识活动起决定作用。实践和认识是具体的历史的统一。</p><ul><li>实践是认识的来源、发展动力、目的，也是检验认识真理性的唯一标准。</li></ul></li><li><p>认识世界的目的是改造世界，改造世界分为改造客观世界和主观世界。</p><ul><li>认识必然和争取自由，是人类认识世界和改造世界的根本目标。<ul><li>自由是有条件的：认知条件和实践条件。</li></ul></li></ul></li><li><p>真理是人们对于客观事物及其规律的正确反映。</p><ul><li><p>真理的内容是客观的，标准也是客观的，真理的客观性决定了它是一元的。</p></li><li><p>真理是个发展过程，既是绝对的，也是相对的。真理的绝对性和相对性相互依存、相互包含。</p><ul><li>真理的发展就是由相对性向绝对性转化。</li></ul></li><li><p>实践是检验真理的唯一标准，但一定历史阶段的具体实践具有局限性。</p><ul><li>原因：真理的本性是主观和客观的一致，实践是主观见之于客观的物质活动。</li></ul></li></ul></li><li><p>价值是反映主体和客体之间意义关系的范畴。</p><ul><li>价值的基本特性：主体性、客观性、多维性、社会历史性。</li><li>价值判断的基本特点：<ul><li>以主客体之间价值关系为认识对象。</li><li>评价结果与评价主体直接相关。</li><li>正确与否依赖于对客体状况和主体需要的认识。</li><li>有科学和非科学之分。</li></ul></li></ul></li><li><p>真理和价值的辩证统一：实践受真理尺度（规律性）和价值尺度（目的性）制约。</p></li></ol><h3 id="唯物史观">唯物史观</h3><h4 id="人类社会发展规律">人类社会发展规律</h4><ol type="1"><li><p>社会历史观的基本问题是社会存在和社会意识的关系问题。</p><ul><li><p>社会存在主要包括物质生产方式、自然地理环境和人口因素。</p><ul><li>物质生产方式是劳动者和劳动资料结合的特殊方式，生产力和生产关系的统一体。<ul><li>物质生产方式集中体现了人类社会的物质性，是社会历史发展的决定力量。</li></ul></li><li>自然地理环境是人类社会生存和发展永恒的、必要的条件，是人们生活和生产的自然基础。</li></ul></li><li><p>社会意识是社会生活的精神方面，是社会存在的反映。</p><ul><li>社会意识按层次划分为社会心理和社会意识形式，社会意识形式分为意识形态和非意识形态。<ul><li>社会心理以人们的感性认识为主。</li><li>社会意识形式以人们的理性认识为主，以社会心理为基础，指导和影响社会心理。<ul><li>意识形态：反映一定经济政治关系的思想体系，思想道德、艺术哲学等。</li><li>非意识形态：不具有社会经济政治性质，自然科学、形式逻辑等。</li></ul></li></ul></li></ul></li></ul></li><li><p>社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在。</p><ul><li><p>先进的社会意识对社会发展起积极的促进作用，落后的社会意识对社会发展起消极的阻碍作用。</p></li><li><p>方法论意义：</p><ul><li>两个划分：从社会生活各领域中划分出经济领域，从一切社会关系中划分出生产关系。</li><li>两个归结：把一切社会关系归结于生产关系，并进一步归结于生产力发展。</li></ul></li></ul></li><li><p>社会基本矛盾是生产力和生产关系的矛盾、经济基础和上层建筑的矛盾。</p><ul><li>生产力和生产关系矛盾是更根本的矛盾，决定了经济基础和上层建筑矛盾的产生和发展，又受到经济基础和上层建筑矛盾的制约，前者的解决有赖于后者的解决。</li><li>社会基本矛盾是历史发展的根本动力。</li></ul></li><li><p>阶级斗争是社会基本矛盾在阶级社会中的直接表现，是阶级社会发展的直接动力。</p><ul><li><p>阶级和阶级斗争是唯物史观的基本观点。</p></li><li><p>阶级斗争根源于阶级之间物质利益的根本对立，根源于社会经济关系的冲突。</p></li><li><p>革命是阶级斗争的最高形式，实质是革命阶级推翻反动阶级统治，用新社会制度代替旧社会制度。</p></li></ul></li><li><p>改革是在统一社会形态内，通过调整、变革不合适生产力发展要求的生产关系和上层建筑的某些部分或环节，实现该社会形态的自我发展和自我完善。是推动社会发展的又一重要动力。</p></li><li><p>生产方式的发展变革是世界历史形成和发展的基础，普遍交往是世界历史的基本特征。</p><ul><li><p>交往是一定历史条件下现实的个人、群体之间在物质和精神上相互来往、作用，彼此联系的活动。</p><ul><li>交往是与生产力的发展相伴随的。</li></ul></li><li><p>人类历史向世界历史转变是资本主义生产方式向世界扩张的结果，世界历史的形成又反过来促进了生产力的普遍发展和人类的普遍交往。</p></li></ul></li><li><p>人的发展最根本的是人的自由程度的提高。</p><ul><li>三个阶段：人的依赖关系占统治地位、人的独立性以物的依赖关系为基础、自由个性</li><li>只有在共产主义社会，人才能真正得到自由而全面的发展。</li></ul></li><li><p>社会形态是社会的经济形态、政治形态和意识形态的具体的、历史的统一。</p><ul><li>社会形态更替的特点：统一性和多样性、必然性和人们的历史选择性、前进性和曲折性</li></ul></li><li><p>在社会历史发展过程中，人民群众起决定性作用。</p><ul><li><p>从质上说，人民群众是指一切对社会历史发展起推动的人；</p><p>从量上说，人民群众是指社会人口中的绝大多数。</p><ul><li>人民群众中最稳定的主体部分始终是从事物质资料生产的劳动群众。</li></ul></li><li><p>人民群众是社会历史实践的主体，是历史的创造者。</p><ul><li>人民群众是社会物质、精神财富的创造者。</li><li>人民群众是社会变革的决定力量。</li><li>人民群众既是先进生产力和先进文化的创造主体，也是实现自身利益的根本力量。</li><li>人民群众创造历史的活动受到经济、政治、精神文化等社会历史条件的制约。</li></ul></li><li><p>群众观点：</p><ul><li>坚信人民群众自己解放自己的观点</li><li>全心全意为人民服务的观点</li><li>一切向人民群众负责的观点</li><li>虚心向人民群众学习的观点</li></ul></li><li><p>群众路线：一切为了群众，一切依靠群众，从群众中来，到群众中去。</p><ul><li>群众路线是无产阶级政党的根本工作路线，也是党的根本领导方法和工作方法。</li><li>群众是划分为阶级的，阶级通常是由政党领导的，政党是由领袖来主持的。</li></ul></li></ul></li><li><p>历史人物都要受到社会发展客观规律的制约，不能决定和改变历史发展的总进程和方向。</p><ul><li>任何历史人物的出现都体现了必然性和偶然性的统一。</li></ul></li></ol><h4 id="人类社会基本矛盾">人类社会基本矛盾</h4><ol type="1"><li><p>生产力标志了人类改造自然的实际程度和实际能力范畴，表示人与自然的关系。</p><ul><li>生产力的基本要素：生产资料（劳动资料和劳动对象）、劳动者<ul><li>劳动资料：劳动过程中用以改变劳动对象的物质资料或条件，其中最重要的是生产工具。</li><li>劳动对象：通过劳动加工变为使用价值的物质资料。</li><li>劳动者：运用劳动资料作用劳动对象的人，是生产力中最活跃的因素。</li></ul></li></ul></li><li><p>生产关系是物质生产过程中不以人意志转移的经济关系，是社会关系中最基本的关系。</p><ul><li>狭义生产关系是直接生产过程中的相互关系。<ul><li>包括生产资料所有制关系、生产中人与人的关系和产品分配关系。</li><li>生产资料所有制关系是最基本、决定性的。它构成全部生产关系的基础，是区分不同生产方式，判定社会经济结构性质的客观依据。</li></ul></li></ul></li><li><p>生产力决定生产关系，生产关系反作用于生产力。</p><ul><li><p>生产力是生产的物质内容，生产关系是生产的社会形式，二者有机统一构成社会的生产方式。</p></li><li><p>生产力和生产关系的矛盾运动及其规律：生产关系一定要适合生产力状况。</p><ul><li>生产力的状况决定生产关系的产生及其变化发展的方向和形式。</li><li>生产关系适合生产力时对生产力发展起促进作用，反之起阻碍作用。</li><li>方法论意义：确认生产力发展是社会进步的最高标准。</li></ul></li></ul></li><li><p>经济基础是社会一定发展阶段的生产力所决定的生产关系的总和。</p><p>上层建筑是建立在一定经济基础上的意识形态及与之相适应的制度、组织和设施。</p><ul><li>观念上层建筑即意识形态。</li><li>政治上层建筑即政治法律制度、设施和政治组织。<ul><li>政治上层建筑是在一定意识形态指导下建立起来的，是统治阶级意志的体现。</li><li>政治上层建筑一经形成，就影响和制约人们的思想理论观点。</li><li>政治上层建筑在上层建筑中占主导地位，国家政权是核心。</li></ul></li></ul></li><li><p>经济基础决定上层建筑，上层建筑对经济基础有反作用。</p><ul><li>这种反作用表现在为自己的经济基础服务，它的性质取决于经济基础的性质。</li></ul></li><li><p>经济基础和上层建筑的矛盾运动及其规律：</p><ul><li>矛盾：<ul><li>新上层建筑不完全适应经济基础的要求。</li><li>上层建筑相对独立，有脱离经济基础的倾向。</li><li>经济基础总会变化，造成上层建筑落后。</li><li>维护旧经济基础的上层建筑成为发展新经济基础的阻碍。</li></ul></li><li>规律：经济基础决定上层建筑的产生、性质和发展变化的方向，上层建筑反作用取决于和服务于经济基础的性质和要求。</li></ul></li></ol><h2 id="政治经济学">政治经济学</h2><h3 id="商品和价值规律">商品和价值规律</h3><ol type="1"><li><p>商品是用来交换的、能满足人们某种需要的<strong>劳动产品</strong>。</p><ul><li>使用价值是商品能满足人的某种需要的属性，是商品的自然属性，为一切劳动产品所共有。</li><li>价值是凝结在商品中的无差别的一般人类劳动，是商品特有的社会属性。<ul><li>商品的价值在质的规定性上是相同的。</li><li>交换价值是不同使用价值之间交换的量的关系。取决于价值。</li></ul></li><li>价值和使用价值是对立统一的关系。<ul><li>对立性体现在二者不可兼得。</li><li>统一性体现在没有使用价值的物品没有价值，有使用价值但不是劳动产品也没有价值。</li></ul></li></ul></li><li><p>生产商品的劳动可区分为具体劳动和抽象劳动，它们是同一劳动的两种规定。</p><ul><li>具体劳动是生产一定使用价值的具体形式的劳动，抽象劳动是无差别的一般人类劳动。</li><li>具体劳动形成商品的使用价值，抽象劳动形成商品的价值。</li></ul></li><li><p>社会必要劳动时间是现有社会正常生产条件下，在社会平均劳动熟练程度和劳动强度下制造某种使用价值所需要的劳动时间。社会必要劳动时间决定商品价值的量。</p><ul><li><p>商品的价值量与生产商品所耗费的社会必要劳动时间成正比，和劳动生产率成反比。</p><ul><li>影响劳动生产率的因素：劳工熟练程度、科技发展水平。</li><li>商品的价值量以简单劳动为尺度计量，复杂劳动等于多倍的简单劳动。</li></ul></li></ul></li><li><p>商品价值形式：简单的或偶然的价值形式、总和的或扩大的价值形式、一般的价值形式、货币形式。</p></li><li><p>货币是长期交换过程中形成的固定充当一般等价物的商品。</p><ul><li><p>货币的五种基本职能：</p><ul><li>价值尺度、流通手段（最基本）</li><li>贮藏手段、支付手段、世界货币</li></ul></li><li><p>货币产生后整个世界分化为具体商品和货币的两极。</p><ul><li><p>商品内在的使用价值和价值的矛盾成为外在的商品和货币的矛盾。</p></li><li><p>货币的出现并没有也不可能消除商品经济的矛盾，反而有可能使矛盾扩大和加深。</p></li></ul></li></ul></li><li><p>价值规律是商品经济的基本经济规律。</p><ul><li>基本内容：商品的价值量由生产商品的社会必要劳动时间决定</li><li>客观要求：商品交换以价值量为基础，按照等价交换的原则进行。</li><li>表现形式：商品的价格围绕价值自发波动。</li><li>积极作用：<ul><li>自发地调节生产资料和劳动力在社会各生产部门之间的分配比例。</li><li>自发地刺激社会生产力的发展。</li><li>自发地调节社会收入的分配。</li></ul></li><li>消极作用：导致社会资源浪费、收入两极分化，阻碍技术进步。</li></ul></li></ol><h3 id="剩余价值和资本">剩余价值和资本</h3><ol type="1"><li><p>劳动力是人的劳动能力，是人的脑力和体力的总和。劳动力的使用即劳动。</p><ul><li>劳动力成为商品的两个基本条件：劳动者在法律上是自由人，且没有任何生产资料。</li><li>劳动力商品价值包括维持劳动者及家属生存所必需生活资料价值和劳动者接受教育训练支出费用。</li><li>劳动力商品的使用价值是价值的源泉，它在消费过程中能够创造比本身价值更大的新价值。<ul><li>剩余价值是工人创造的超过劳动力价值的部分价值。</li><li>货币所有者购买劳动力商品后能获得剩余价值，货币也就转化为资本。</li></ul></li></ul></li><li><p>绝对剩余价值指必要劳动时间不变，延长工作日长度或提高劳动强度而生产的剩余价值。</p><p>相对剩余价值指工作日长度不变，缩短必要劳动时间而相对延长剩余劳动时间所生产的剩余价值。</p><ul><li>超额剩余价值指企业由于提高劳动生产率使商品的个别价值低于社会价值的差额。</li></ul><p>资本家提高对工人剥削程度最基本的方法是绝对剩余价值和相对剩余价值的生产。</p></li><li><p>资本是能够带来剩余价值的价值，本质不是物，而是一定历史社会形态下的生产关系。</p><ul><li><p>不变资本是以生产资料形态存在的资本，通过工人的具体劳动转移到新产品中去。</p></li><li><p>可变资本是用来购买劳动力的部分资本，不被转移到新产品中去，而是由工人的劳动再生产出来。</p><ul><li><spanclass="math inline">\(剩余价值率=\frac{剩余价值}{可变资本}\)</span>。</li></ul></li></ul></li><li><p>资本积累就是剩余价值的资本化，它的源泉是剩余价值。</p><ul><li>资本积累是社会财富占有两极分化的重要原因，也是资本主义社会失业现象产生的根源。</li><li>资本积累的历史趋势是资本主义制度的必然灭亡和社会主义制度的必然胜利。</li><li>资本的原始积累指暴力掠夺生产资料和货币财富作为资本。</li></ul></li><li><p>资本技术构成指由生产技术水平决定的生产资料和劳动力之间的比例。</p><p>资本价值构成指不变资本和可变资本的比例，由资本的技术构成决定并反映技术构成变化。</p><p>资本价值构成也称资本有机构成。</p><ul><li>资本有机构成在资本主义生产过程中呈现不断提高的趋势。有机构成提高，可变资本减少，导致劳动力需求降低，工人失业，形成相对过剩人口。<ul><li>相对过剩人口的形式包括流动过剩人口、潜在过剩人口、停滞过剩人口。</li></ul></li></ul></li><li><p>资本循环指资本从一种形式出发，经过一系列形式的变化又回到出发点的运动。</p><ul><li><p>产业资本循环的三个阶段和资本的三种不同职能：</p><ul><li>购买阶段：货币资本</li><li>生产阶段：生产资本</li><li>售卖阶段：商品资本</li></ul></li><li><p>产业资本运动的两个前提条件：产业资本的三种职能形式在空间上并存、在时间上继起。</p></li><li><p>资本周转指资本周而复始的循环。</p><ul><li>影响资本周转快慢的因素：资本周转时间、生产资本中固定资本和流动资本的构成。</li></ul></li></ul></li><li><p>社会总产品又称社会总价值，包括生产资料转移价值、劳动力价值和剩余价值。</p><ul><li>社会总产品的第1部类由生产生产资料的部门构成，第2部类由生产消费资料的部门构成。</li></ul><p>社会再生产指连续不断重复的社会生产。它的核心问题是社会总产品的价值补偿和实物补偿问题。</p><ul><li><p>社会再生产顺利进行的条件：</p><ul><li><p>生产资料生产满足两大部类对消耗生产资料的补偿、扩大生产规模后对追加生产资料的需求。</p></li><li><p>消费资料生产满足两大部类劳动者个人和社会消费、扩大生产规模后对追加消费资料的需求。</p></li></ul></li></ul></li></ol><h3 id="资本主义制度">资本主义制度</h3><h4 id="经济基础">经济基础</h4><ol type="1"><li><p>所有制指生产资料的归属与支配，所有权指法律规定的人对占有物行使权利的界限。</p><ul><li>所有制是所有权的基础，所有权是所有制的法律形态。</li></ul></li><li><p>商品经济是以交换为目的而进行生产的经济形式。</p><ul><li>商品经济产生的社会历史条件：社会分工的存在；生产资料和劳动产品属于不同的所有者。</li><li>私有制基础上商品经济基本矛盾是私人劳动和社会劳动的矛盾，进一步发展成资本主义基本矛盾。</li></ul></li><li><p>资本主义生产关系产生的两个途径：从小商品经济中分化而出、从商人和高利贷者转化而来。</p><ul><li>资本主义生产过程是劳动过程和价值增殖过程的统一。<ul><li>劳动过程生产物质资料，价值增殖过程生产剩余价值。</li><li>价值增殖过程中劳动分为必要劳动和剩余劳动，剩余劳动是剩余价值的唯一源泉。</li></ul></li><li>资本主义简单再生产指资本家获得剩余价值后全部用于个人消费。</li><li>资本主义扩大再生产指资本家将获得剩余价值的一部分转化为资本，使生产在扩大的规模上进行。<ul><li>资本主义扩大再生产的源泉是资本积累。</li></ul></li></ul></li><li><p>工资是劳动力的价值，利润是剩余价值的转化形式。</p><ul><li>资本从利润率低的部门流向利润率高的部门使利润率趋于平均化，转化为平均利润。</li><li>商品价值转化成生产价格，即成本价格加平均利润，不再以价值而是以生产价格为基础进行交换。<ul><li>利润平均化规律反映了资本家在瓜分剩余价值上存在竞争和矛盾。</li></ul></li></ul></li><li><p>资本主义的基本矛盾是生产资料资本主义私人占有和生产社会化之间的矛盾。</p><ul><li>两个具体方面：<ul><li>生产无限扩大的趋势与劳动人民支付能力需求相对缩小的矛盾。</li><li>单个企业内部生产的有组织性和整个社会生产的无政府状态之间的矛盾。</li></ul></li><li>资本主义经济危机是资本主义条件下以强制的方式解决社会再生产的实现问题的途径。<ul><li>根本原因是资本主义的基本矛盾，本质特征是生产相对过剩。</li><li>经济危机周期爆发使得社会再生产也呈现周期性，包括危机、萧条、复苏、高涨四个阶段。</li></ul></li></ul></li></ol><h4 id="上层建筑">上层建筑</h4><ol type="1"><li><p>国家的实质是阶级统治的工具。</p></li><li><p>资本主义国家职能以服务于资本主义制度和资产阶级利益为根本内容，是资产阶级政治统治的工具。</p><ul><li><p>对内进行政治统治和社会管理。</p></li><li><p>对外进行国际交往和维护国家安全及利益。</p></li></ul></li><li><p>资本主义民主制度：资本主义法律制度、政权组织形式、选举制度、政党制度等。</p><ul><li>法律制度的基本原则包括私有制、主权在民、分权制衡和人权。</li><li>政权组织形式为立法权、行政权、司法权三权分立。</li></ul></li><li><p>资本主义意识形态为资本主义经济基础服务，是资产阶级阶级意识的集中体现。</p></li></ol><h4 id="垄断资本主义">垄断资本主义</h4><ol type="1"><li><p>生产集中指生产资料、劳动力与商品生产日益集中于少数大企业。</p><p>资本集中指许多小资本合并成大资本的过程。</p></li><li><p>垄断指资本主义大企业通过联合，对特定商品的生产、销售和价格进行操纵和控制。</p><ul><li><p>价格协定是最简单的垄断组织形式。</p></li><li><p>垄断利润指凭借垄断而获得的超过平均利润的利润。</p><ul><li>垄断价格=成本价格+平均利润+垄断利润。</li></ul></li></ul></li><li><p>垄断条件下存在竞争的原因：</p><ul><li>垄断没有消除产生竞争的经济条件（商品经济）。</li><li>垄断必须通过竞争来维持。</li><li>社会生产是复杂多样的。</li></ul><p>垄断条件下竞争的新特点：</p><ul><li>目的：获得高额垄断利润，巩固扩大垄断地位。</li><li>手段：不仅采用经济手段，也使用更复杂、残酷的手段。</li><li>范围：各个领域、各个国家。</li></ul><p>垄断资本向世界范围内扩展的基本形式：借贷资本输出、生产资本输出、商品资本输出。</p></li><li><p>金融资本：工业垄断资本和银行垄断资本融合而成的垄断资本。</p><ul><li>形成途径：金融联系、资本参与和人事参与。</li><li>形成条件：金融自由化和金融创新。</li></ul><p>金融资本扩张的后果：</p><ul><li>金融垄断资本脱离实体经济发展。</li><li>金融垄断资本控制能力提升。</li></ul><p>金融寡头控制社会的方式：操纵国民经济命脉，实际上控制国家政权。</p><ul><li>经济：通过控股层层控制企业。</li><li>政治：亲自担任或指派代理人。</li><li>此外，还会建立政策咨询机构，通过新闻出版、文化教育等领域左右国家。</li></ul></li><li><p>资本主义的发展经过了自由竞争资本主义和垄断资本主义两个阶段。</p><ul><li>垄断资本主义包括私人垄断资本主义和国家垄断资本主义两种形式。</li></ul></li><li><p>国家垄断资本主义是国家政权和私人垄断资本融合的垄断资本主义。</p><ul><li>形成原因：生产力发展、经济危机的深化、缓和社会矛盾的需求。</li><li>主要形式：<ul><li>国营企业、国家与私人合营企业。</li><li>国家参与私人垄断资本的再生产过程。</li><li>宏观调节使用财政、货币等经济手段。</li><li>微观调节使用反托拉斯法、公共事业规制、社会经济规制等法律手段。</li></ul></li><li>国家垄断资本主义是资本主义经济制度内的经济关系调整。</li></ul></li><li><p>垄断资本国际化产生的组织促进了经济全球化的发展，但根本上是为资产阶级攫取高额利润服务的。</p><ul><li>国际垄断同盟：国际卡特尔、七国集团、欧盟。</li><li>国际经济调节体系：国际货币基金组织、世界银行、世界贸易组织。</li></ul></li></ol><h4 id="资本主义变化">资本主义变化</h4><ol type="1"><li><p>二战后资本主义的变化实质上是资本主义制度基本框架内的变化。</p><ul><li>生产资料所有制：<ul><li>二战前：私人资本所有制、私人股份资本所有制。</li><li>二战后：国家资本所有制、法人资本所有制。</li></ul></li><li>劳资关系与分配关系：资本家采取职工持股、社会福利等激励制度。</li><li>社会阶层和阶级结构：资本所有权和经营权分离、知识型和服务型劳动者增加</li><li>经济危机形态：去工业化和产业空心化、高度金融化、财政严重债务化。</li></ul><p>原因：科技和生产力发展、工人阶级争取自身权益的斗争、资本主义改良。</p></li><li><p>当代资本主义的变化：</p><ul><li>科技创新加速资本主义生产方式变化。</li><li>国际金融资本的垄断成为当代资本主义最突出、最鲜明、最主要的特征。<ul><li>金融垄断寡头化、金融垄断国际化、经济虚拟化和产业空心化。</li></ul></li><li>发达资本主义国家实行霸权主义和强权政治。</li><li>资本主义国家经济发展失调、政治体制失灵、社会融合机制失效。</li></ul></li><li><p>经济全球化：生产全球化、贸易全球化、金融全球化。</p><ul><li><p>原因：科技进步和生产力发展、跨国公司发展、各国经济体制变革和国际经济组织发展。</p></li><li><p>对发展中国家影响：</p><ul><li><p>积极影响：提供先进技术和管理经验、更多就业机会，推动国际贸易和跨国公司发展。</p></li><li><p>消极影响：增加经济风险，加剧发展中国家资源短缺和环境污染，发达/发展中国家地位不平等、收益不平衡。</p></li></ul></li></ul></li></ol><h2 id="社会主义">社会主义</h2><h3 id="历史">历史</h3><ol type="1"><li><p>空想社会主义的局限性在于，未能揭示资本主义必然灭亡的经济根源，看不到埋葬资本主义的力量，找不到通往理想社会的道路。</p><ul><li>早期空想社会主义：1516托马斯·莫尔《乌托邦》、1602康帕内拉《太阳城》</li><li>空想平均社会主义：18世纪，摩莱里《自然法典》、马布利《论法制或法律的原则》</li><li>批判的空想社会主义是科学社会主义的直接思想来源：19世纪初，圣西门、傅立叶、欧文</li></ul></li><li><p>科学社会主义创立的基础是唯物史观、剩余价值学说，创立的标志是1848年2月的《共产党宣言》。</p></li><li><p>1864年，第一国际：马恩指导下建立的国际工人运动联合组织。</p><p>1871年，巴黎公社失败的教训：</p><ul><li>无产阶级革命成功的首要条件是有革命的武装。</li><li>必须建立无产阶级的新型国家，必须建立无产阶级政党，发挥党的政治领导作用。</li><li>无产阶级政权要为人民服务。</li></ul></li><li><p>列宁根据资本主义发展中经济政治不平衡发展的规律，提出了社会主义革命可能在一国或数国首先发生的论断。</p><p>1917年11月7日（俄历10月25日）：十月革命。</p><ul><li>建立了世界上第一个社会主义国家。</li><li>激励了殖民地半殖民地的民族民主革命。</li><li>促进了马克思列宁主义的传播。</li></ul><p>历史条件：科技进步；资本主义进入垄断阶段；资本主义各国间经济政治发展不平衡加剧引发一战。</p></li><li><p>列宁领导的苏维埃俄国对社会主义的探索：</p><ul><li><p>巩固政权时期：制定社会主义过渡计划，提出社会主义改造方法。</p></li><li><p>战时共产主义时期：余粮收集制、取消商品货币关系、经济强制措施。</p></li><li><p>新经济政策时期：1921年，俄共十大。标志着列宁正在探索符合俄国情况的建设社会主义的道路。</p><ul><li>粮食税取代余粮收集制，允许私人自由贸易。</li><li>恢复商品货币关系，允许私人小工业企业发展。</li><li>采取一些国家资本主义的形式来发展生产。</li></ul></li><li><p>列宁的论述：</p><ul><li>建设社会主义是一个长期探索、不断实践的过程。</li><li>大力发展生产力、提高劳动生产率为首位。</li><li>在多种经济成分并存的条件下，利用商品、货币和市场发展经济。</li><li>利用资本主义建设社会主义。</li></ul></li></ul></li><li><p>苏联模式：1936年，苏维埃第八次非常代表大会通过的宪法中，宣布苏联已经建成社会主义。</p><ul><li>经济上：单一的生产资料公有制，过度集中的指令性计划经济模式。</li><li>政治上：过度集权的领导体制、自上而下的干部任命制、软弱而低效的监督机制。</li></ul></li></ol><h3 id="科学社会主义">科学社会主义</h3><ol type="1"><li><p>科学社会主义基本原则是马克思主义的核心内容：</p><ul><li>资本主义必然灭亡，社会主义必然胜利。</li><li>无产阶级是最先进最革命的阶级，肩负推翻资本主义、建设社会主义的历史使命。</li><li>无产阶级政党是无产阶级的先锋队，社会主义事业必须始终坚持无产阶级政党的领导。</li><li>无产阶级革命是无产阶级斗争的最高形式，以建立无产阶级专政的国家政权为目的。</li><li>在生产资料公有制的基础上组织生产，满足全体社会成员需要为生产的根本目的。</li><li>对社会生产进行有计划的指导和条件，实行按劳分配。</li><li>大力解放和发展生产力，消灭剥削和两极分化，实现共同富裕。</li><li>坚持科学理论指导，大力发展社会主义先进文化。</li><li>合乎自然规律地改造和利用自然，努力实现人与自然的和谐共生。</li><li>实现共产主义是最高理想。</li></ul></li><li><p>中国特色社会主义既坚持了科学社会主义基本原则，又根据时代和国情赋予其鲜明的中国特色。</p><ul><li>这是中国特色社会主义蓬勃发展的根本原因。</li></ul></li><li><p>如何正确把握科学社会主义基本原则：</p><ul><li>坚持科学社会主义基本原则，将其与本国实际和时代特征相结合。</li><li>紧跟时代和实践的发展，进一步丰富和发展科学社会主义基本原则。</li></ul></li><li><p>社会主义建设具有艰巨性、长期性，发展道路具有多样性；社会主义发展具有前进性和曲折性。</p></li><li><p>社会主义如何改革：</p><ul><li>要坚持正确理论指导和改革方向，选择正确改革方式，妥善处理改革、发展和稳定的关系。</li></ul></li></ol><h3 id="共产主义">共产主义</h3><ol type="1"><li><p>实现共产主义是历史发展的必然，是长期的历史过程。共产主义的特征有：</p><ul><li>物质财富极大丰富，消费资料按需分配。</li><li>社会关系高度和谐，人民精神境界提高。</li><li>根本特征是每个人自由而全面地发展。</li></ul></li><li><p>共产主义远大理想和中国特色社会主义共同理想：</p><ul><li><p>两者关系：最终理想和阶段性理想、最高纲领和较低纲领、全人类理想和全体中国人民理想。</p></li><li><p>坚持远大理想和共同理想的辩证统一。</p></li><li><p>坚定理想信念，投身新时代中国特色社会主义事业。</p></li></ul></li><li><p>预见未来社会的方法论原则：</p><ul><li>揭示人类社会发展一般规律。</li><li>剖析旧世界，阐发新世界。</li><li>在社会主义社会发展中不断深化对未来社会的认识。</li><li>立足于一般特征，不具体描述细节。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>大学政治</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件质量管理_工程技术</title>
    <link href="/2024/06/24/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/4.%20%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/06/24/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/4.%20%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="工程技术">4. 工程技术</h1><h2 id="需求">4.1 需求</h2><ol type="1"><li>需求开发</li></ol><p>需求是一切工程活动的基础。</p><p>需求类别：</p><ul><li>客户需求</li><li>产品需求</li><li>产品组件需求</li></ul><ol start="2" type="1"><li>需求获取</li></ol><p>客户所受到的限制也应当作为需求开发过程中需要重点关注的内容。</p><ul><li><p>通常采取所谓的需求“诱导”方式进行。</p></li><li><p>“诱导”一词的含义不仅仅是普通的需求采集，它隐含了应更加积极地、前瞻性地识别那些客户没有明确提供的额外需求。</p></li></ul><ol start="3" type="1"><li>需求汇总</li></ol><ul><li>整理各种来源的信息，识别缺失的信息</li><li>解决冲突的需求</li><li>需求的整理和转化</li><li>推导未显式描述的需求内容</li></ul><ol start="4" type="1"><li>需求验证</li></ol><p>对需求进行分析和确认，以确保符合使用者预期</p><p>典型活动包括</p><ul><li>建立和维护操作概念和相关的场景</li><li>分析需求</li><li>确认需求</li></ul><ol start="5" type="1"><li>需求文档</li></ol><p>需求开发工作完成的一个基本标志是形成了一份完整的、规范的、经过评审的需求规格说明书。</p><p>需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。</p><p>特征：内聚、完整、一致、原子、可跟踪、非过期、可行性、非二义性、强制、可验证</p><h2 id="设计">4.2 设计</h2><p>考虑点：</p><ol type="1"><li><p>团队智慧</p><p>发挥团队智慧两大挑战：</p><ul><li>确定整体架构之前很难进行分工</li><li>鼓励团队成员在讨论和评审会议中的参与程度</li></ul></li><li><p>设计标准</p><p>命名规范、接口标准、系统出错信息、设计表示标准</p></li><li><p>复用</p><p>建立一套复用管理流程，具体而言，包括</p><ul><li><p>复用接口标准</p></li><li><p>复用文档标准</p></li><li><p>复用质量保证机制</p></li></ul></li><li><p>可测试性</p><p>尽可能减少测试代码的数量，制作合理的测试计划。</p></li><li><p>可用性</p><ul><li>在设计阶段就开始考虑。</li><li>针对每一个关键功能都定义操作概念和操作场景。</li><li>可以邀请最终用户参与场景的评审，使用模拟、原型等技术，更好的把握用户真实意图。</li></ul></li></ol><h2 id="实现">4.3 实现</h2><p>考虑点：评审、复用、可用性。</p><h2 id="集成">4.4 集成</h2><ul><li>大爆炸集成策略</li><li>逐一添加集成策略</li><li>集簇集成策略</li><li>扁平化集成策略</li></ul><h2 id="验证和确认">4.5 验证和确认</h2><p>都是为了提升最终产品的质量而采取的措施。</p><p>目的不同。</p><ul><li><p>验证是目的是确保选定的工作产品与事先指定给该工作产品的需求一致。</p></li><li><p>确认的目标则是确保开发完成的产品或者产品组件在即将要使用该产品或者产品组件的环境中工作正确。</p></li></ul><p>验证和确认活动：</p><ol type="1"><li><p>环境准备</p></li><li><p>对象选择</p></li><li><p>活动实施</p></li><li><p>结果分析</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件质量管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件质量管理_质量管理</title>
    <link href="/2024/06/23/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/3.%20%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    <url>/2024/06/23/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/3.%20%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="质量管理">3. 质量管理</h1><h2 id="概念">3.0 概念</h2><p>软件质量：</p><p>与软件产品满足规定的和隐含的需求能力有关的特征或者特性的全体。</p><h3 id="面向用户的质量观">3.0.1 面向用户的质量观</h3><p>定义质量为满足用户需求的程度。在这个定义中，就需要进一步明确：</p><ul><li>用户究竟是谁？</li><li>用户需求的优先级是什么？</li><li>这种用户的优先级对软件产品的开发过程产生什么样的影响？</li><li>怎样来度量这种质量观下的质量水平？</li></ul><h3 id="质量管理策略">3.0.2 质量管理策略</h3><p>用缺陷管理来替代质量管理。</p><ul><li><p>高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷。</p></li><li><p>PSP：各个组件的高质量是通过高质量评审来实现的</p></li></ul><h4 id="测试消除缺陷流程">测试消除缺陷流程</h4><ol type="1"><li>发现异常行为</li><li>理解工作方式</li><li>找出出错原因</li><li>确定修改方案</li><li>测试修改有效</li></ol><h4 id="评审发现缺陷流程">评审发现缺陷流程</h4><ol type="1"><li>理解程序流程</li><li>发现缺陷的位置和原因</li><li>修正缺陷</li></ol><h2 id="评审">3.1 评审</h2><h3 id="质量控制指标">3.1.1 质量控制指标</h3><h4 id="yield">Yield</h4><p>度量每个阶段在消除缺陷方面的效率。</p><ul><li>Phase Yield = <spanclass="math inline">\(100\times\frac{某阶段发现的缺陷个数}{某阶段注入的缺陷个数+进入该阶段前遗留的缺陷个数}\)</span></li><li>Process Yield = <spanclass="math inline">\(100\times\frac{第一次编译前发现的缺陷个数}{第一次编译前注入的缺陷个数}\)</span></li></ul><h4 id="afr">A/FR</h4><p>PSP质检成本/PSP失效成本。</p><ul><li>理论上，A/FR的值越大，往往意味着越高的质量。</li><li>过高的A/FR往往意味着做了过多的评审，反而会导致开发效率的下降。</li><li>作为指南，在PSP中A/FR的期望值就是2.0。</li></ul><h4 id="pqi">PQI</h4><p>5个数据乘积：</p><ul><li>设计质量：设计的时间应该大于编码的时间</li><li>设计评审质量：设计评审的时间应该大于设计时间的50%</li><li>代码评审质量：代码评审时间应该大于编码时间的50%</li><li>代码质量：代码的编译缺陷密度应当小于10个/千行</li><li>程序质量：代码单元测试缺陷密度应当小于5个/千行</li></ul><h4 id="评审速度">评审速度</h4><p>评审速度(Review Rate)是一个用以指导软件工程师开展有效评审的指标。</p><ul><li>高质量的评审需要软件工程师投入足够的时间进行评审。</li><li>在PSP的实践中，代码评审速度小于200 LOC/小时，文档评审速度小于4Page/小时。</li></ul><h4 id="drl">DRL</h4><p>缺陷消除效率比，度量的是不同缺陷消除手段消除缺陷的效率。</p><ul><li><p>计算方式：</p><p>以某个测试阶段（一般为单元测试）每小时发现的缺陷数为基础，其他阶段每小时发现缺陷数与该测试阶段每小时发现的缺陷的比值就是DRL。</p></li></ul><h3 id="其他因素">3.1.2 其他因素</h3><p>打印后评审往往效果更好</p><ul><li>单个屏幕可以展现的内容比较有限</li><li>评审人员的注意力</li></ul><p>评审时机选择：编译（UT）之前 VS. 之后</p><p>个人评审和小组评审</p><ul><li><p>小组评审意义</p></li><li><p>先后顺序</p></li></ul><h2 id="质量路径">3.2 质量路径</h2><h3 id="质量路径-1">3.2.1 质量路径</h3><p>Step 1：各种测试</p><p>Step 2：进入测试之前的产物质量提升</p><p>Step 3：评审过程度量和稳定</p><p>Step 4：质量意识和主人翁态度</p><p>Step 5：个体review的度量和稳定</p><p>Step 6：诉诸设计</p><p>Step 7：缺陷预防</p><p>Step 8：用户质量观——其他质量属性</p><h3 id="设计">3.2.2 设计</h3><h4 id="设计内容">设计内容</h4><table><thead><tr class="header"><th></th><th><strong>动态信息</strong></th><th><strong>静态信息</strong></th></tr></thead><tbody><tr class="odd"><td><strong>外部信息</strong></td><td>交互信息（服务、消息等）</td><td>功能（继承、类结构等）</td></tr><tr class="even"><td><strong>内部信息</strong></td><td>行为信息（状态机）</td><td>结构信息（属性、业务逻辑等）</td></tr></tbody></table><h5 id="psp设计模板">PSP设计模板</h5><ul><li><p>操作规格模板（Operational Specification Template，简称OST）</p></li><li><p>功能规格模板（Functional Specification Template，简称FST）</p></li><li><p>状态规格模板（State Specification Template，简称SST）</p></li><li><p>逻辑规格模板（Logical Specification Template，简称LST）</p></li></ul><table><thead><tr class="header"><th></th><th><strong>动态信息</strong></th><th><strong>静态信息</strong></th></tr></thead><tbody><tr class="odd"><td><strong>外部信息</strong></td><td>OST/FST</td><td>FST</td></tr><tr class="even"><td><strong>内部信息</strong></td><td>SST</td><td>LST</td></tr></tbody></table><h5 id="uml图">UML图</h5><table><thead><tr class="header"><th></th><th><strong>动态信息</strong></th><th><strong>静态信息</strong></th></tr></thead><tbody><tr class="odd"><td><strong>外部信息</strong></td><td>用例图、时序图</td><td>类图</td></tr><tr class="even"><td><strong>内部信息</strong></td><td>状态机图</td><td>？</td></tr></tbody></table><h4 id="设计层次">设计层次</h4><figure><img src="/image/软件质量管理/设计层次.png" alt="设计层次" /><figcaption aria-hidden="true">设计层次</figcaption></figure><p>PSP模板</p><figure><img src="/image/软件质量管理/PSP设计模板.png" alt="PSP设计模板" /><figcaption aria-hidden="true">PSP设计模板</figcaption></figure><h3 id="设计评审">3.2.3 设计评审</h3><h4 id="状态机验证">状态机验证</h4><p>正确状态机：完整、正交</p><p>验证方法：</p><ul><li>检验状态机，消除死循环和陷阱状态。</li><li>检查状态转换，验证完整性和正交性。</li><li>评价状态机，检验是否体现设计意图。</li></ul><h4 id="符号化执行">符号化执行</h4><p>符号化验证方法的基本思想是将描述设计的逻辑规格（一般用伪代码程序表示）用代数符号来表示，然后系统地开展分析和验证。具体步骤如下：</p><ol type="1"><li>识别伪码程序中的关键变量</li><li>将这些变量用代数符号表示，重写伪码程序</li><li>分析伪码程序的行为</li></ol><p>优缺点：</p><ol type="1"><li><p>实施简单，可以给出一般化的验证结果。</p></li><li><p>通常用在验证一些复杂算法中，特别是对遗留系统的改造中，往往应用这种方法来识别和理解原有的设计。</p></li><li><p>不适用于有复杂逻辑的场合，而且，纯手工的验证方法也容易引入一些人为的错误。</p></li></ol><h4 id="执行表">执行表</h4><p>用一种有序的方法来跟踪伪码程序的执行状况，分析程序行为，从而验证设计。具体步骤如下：</p><ol type="1"><li>识别伪码程序的关键变量</li><li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量</li><li>初始化被选定的变量</li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ol><h4 id="跟踪表">跟踪表</h4><p>跟踪表验证方法是对执行表验证方法的一种扩充。具体步骤如下：</p><ol type="1"><li>识别伪码程序的关键变量</li><li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量</li><li>初始化被选定的变量</li><li>识别将伪码程序符号化的机会，并加以符号化</li><li>定义并且优化用例组合</li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ol><h4 id="正确性检验">正确性检验</h4><p>将伪码程序当成数学定理，采用形式化方法加以推理和验证。这种方法的步骤如下：</p><ol type="1"><li>分析和识别用例</li><li>对于复杂伪码程序的结构，应用正确性检验的标准问题逐项加以验证</li><li>对于不能明确判断的复杂程序结构，使用跟踪表等辅助验证。</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件质量管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件质量管理_项目管理</title>
    <link href="/2024/06/22/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/2.%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <url>/2024/06/22/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/2.%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="项目管理">2. 项目管理</h1><p>管理的三大关键要素：</p><ul><li>目标</li><li>状态</li><li>纠偏</li></ul><h2 id="概念">2.0 概念</h2><p>应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。</p><h3 id="三大目标">三大目标</h3><p>成本、质量、工期。</p><h2 id="团队动力学">2.1 团队动力学</h2><h3 id="知识工作">2.1.1 知识工作</h3><p>软件开发是一项既复杂又富有创造性的知识工作。</p><ul><li>处理和讨论极其抽象的概念</li><li>把不同的部分（不可见）整合成一个可以工作的系统</li></ul><h4 id="知识工作管理">知识工作管理</h4><p>关键规则：管理者无法管理工作者，知识工作者必须实现并且学会自我管理。</p><p>知识工作者必须</p><ul><li>有积极性</li><li>能做出准确的估算和计划</li><li>懂得协商承诺</li><li>有效跟踪他们的计划</li><li>持续地按计划交付高质量产物</li></ul><h4 id="领导者">领导者</h4><p>知识工作者的管理需要的是领导者，而不是经理。</p><h4 id="激励手段">激励手段</h4><p>三种主要手段</p><ol type="1"><li>威逼</li><li>利诱</li><li>鼓励承诺</li></ol><h5 id="领导方式">领导方式</h5><p>交易型</p><ul><li>承诺奖励激励</li><li>人们通常能找到新的方式来获得奖励，同时少做工作。</li><li>威逼和利诱属于交易型领导方式。</li></ul><p>转变型</p><ul><li>用成就激励</li><li>鼓励承诺属于转变型领导方式。</li></ul><p>交易型领导方式很少能产生成功并且有创造性的团队，因此转变型领导方式是首选。</p><h6 id="承诺激励">承诺激励</h6><p>个人级别的差异</p><ul><li>有些人对待承诺十分认真。</li><li>有些人对待承诺十分轻率。</li></ul><p>当满足以下情况，团队承诺比个人承诺的激励作用更大</p><ul><li>所有团队成员共同参与作出承诺。</li><li>团队依赖于每一位成员履行自己的承诺。</li></ul><p>一个软件开发团队在制定承诺时，要保证</p><ul><li>承诺是自愿的</li><li>承诺是公开的</li><li>承诺是可信（行）的</li><li>向团队承诺</li></ul><h6 id="维持激励">维持激励</h6><p>维持激励需要及时的绩效反馈。</p><p>包括</p><ul><li>根据一个详细计划衡量进度</li><li>当前计划不准确时重做计划</li><li>为漫长而富有挑战性的项目提供中间反馈，即里程碑</li></ul><h5 id="马斯洛需求层次理论">马斯洛需求层次理论</h5><figure><img src="/image/软件质量管理/maslo.png" alt="maslo" /><figcaption aria-hidden="true">maslo</figcaption></figure><ol type="1"><li>自我实现是最高的层次</li><li>激励来自为没有满足的需求而努力奋斗</li><li>低层次的需求必须在高层次需求满足之前得到满足</li><li>满足高层次的需求的途径比满足低层次的途径更为广泛</li></ol><h5 id="期望理论">期望理论</h5><ol type="1"><li><p>海兹伯格：</p><ul><li>激励因素（内在因素）：<ul><li>成就感，责任感，晋升，被赏识、认可</li></ul></li><li>保健因素（外在因素）：<ul><li>工作环境，薪金，工作关系，安全等</li></ul></li></ul></li><li><p>麦克勒格X理论</p><ul><li>不喜欢他们的工作并努力逃避工作</li><li>缺乏进取心，没有解决问题与创造的能力</li><li>更喜欢经常的指导，避免承担责任，缺乏主动性</li><li>自我中心，对组织需求反应淡漠，反对变革</li></ul><p>用马斯洛的底层需求（生理和安全）进行激励。</p></li><li><p>麦克勒格Y理论</p><ul><li>如果给予适当的激励和支持性的工作氛围，会达到很高的绩效预期</li><li>具有创造力，想象力，雄心和信心来实现组织目标</li><li>能够自我约束，自我导向与控制，渴望承担责任</li></ul><p>用马斯洛的高层需求（自尊和自我实现）进行激励。</p></li><li><p>期望理论</p><p>人们在下列情况下能够受到激励并且出大量成果<spanclass="math inline">\(M=V\times E\)</span></p><ul><li>相信他们的努力很可能会产生成功的结果（V）</li><li>他们也相信自己会因为成功得到相应的回报（E）</li></ul></li></ol><h3 id="自主团队">2.1.2 自主团队</h3><p>自主团队具备如下的特点：</p><ul><li>自行定义项目的目标</li><li>自行决定团队组成形式以及成员的角色</li><li>自行决定项目的开发策略</li><li>自行定义项目的开发过程</li><li>自行制定项目的开发计划</li><li>自行度量、管理和控制项目工作</li></ul><h4 id="外部环境">外部环境</h4><p>项目启动阶段获得管理层的支持。</p><ul><li>体现出已经尽最大的可能在满足管理层的需求的工作态度。</li><li>在计划中体现定期需要向管理层报告的内容。</li><li>向管理层证明他们所制定的工作计划是合理的。</li><li>在计划中体现为了追求高质量而开展的工作。</li><li>在工作计划中允许必要的项目变更。</li><li>向管理层寻求必要的帮助。</li></ul><p>在项目进展过程中获得管理层的支持</p><ul><li>严格遵循定义好的开发过程开展项目开发工作。</li><li>维护和更新项目成员的个人计划和团队计划。</li><li>对产品质量进行管理。</li><li>跟踪项目进展，并定期向管理层报告。</li><li>持续地向管理层展现优异的项目表现。</li></ul><h4 id="tsp启动过程">TSP启动过程</h4><ol type="1"><li>第一次会议：建立产品目标和业务目标</li><li>第二次会议：角色分配、小组目标定义</li><li>第三次会议：开发流程定义与策略选择</li><li>第四次会议：整体计划</li><li>第五次会议：质量计划</li><li>第六次会议：个人计划以及计划平衡</li><li>第七次会议：风险评估</li><li>第八次会议：准备向管理层汇报计划</li><li>第九次会议：向管理层汇报计划内容</li><li>启动总结</li></ol><h4 id="tsp角色和职责">TSP角色和职责</h4><p>领导者和经理的区别</p><table><thead><tr class="header"><th><strong>角色经理</strong></th><th><strong>团队领导者</strong></th></tr></thead><tbody><tr class="odd"><td>告知</td><td>倾听</td></tr><tr class="even"><td>指导</td><td>询问</td></tr><tr class="odd"><td>说服</td><td>激励/挑战</td></tr><tr class="even"><td>决定</td><td>促进达成一致</td></tr><tr class="odd"><td>控制</td><td>教练</td></tr><tr class="even"><td>监控</td><td>授权</td></tr><tr class="odd"><td>设定目标</td><td>挑战</td></tr></tbody></table><ol type="1"><li><p>项目组长：</p><ul><li>建设和维持高效率的团队。</li><li>激励团队成员积极工作。</li><li>合理处理团队成员的问题。</li><li>向管理层提供项目进度相关的完整信息。</li><li>充当合格的会议组织者和协调者。</li></ul></li><li><p>计划经理：</p><p>开发完整的、准确的团队计划和个人计划，每周准确的报告项目小组状态。</p></li><li><p>开发经理：</p><p>开发优秀的软件产品，充分利用团队成员的技能。</p></li><li><p>质量经理：</p><ul><li><p>项目团队严格按照质量计划开展工作，开发出高质量的软件产品</p></li><li><p>所有的小组评审工作都正常开展，并且都形成了评审报告</p></li></ul></li><li><p>过程经理：</p><ul><li>所有团队成员准确的记录、报告和跟踪过程数据。</li><li>所有的团队会议都有相应会议记录。</li></ul></li><li><p>支持经理</p><ul><li>项目小组在整个开发过程中都有合适的工具和环境</li><li>跟踪项目小组的风险和问题</li><li>项目小组在开发过程中满足复用目标</li></ul></li><li><p>开发人员</p></li></ol><h4 id="scrum角色和职责">SCRUM角色和职责</h4><p>典型SCRUM团队由一名产品负责人、开发团队和一名SCRUM Master组成。</p><ul><li>SCRUM团队是跨职能的自组织团队</li></ul><ol type="1"><li><p>产品负责人：</p><p>职责：将开发团队开发的产品价值最大化。</p><p>工作：管理产品待办列表的唯一负责人。</p></li><li><p>开发团队：</p><p>负责在每个 Sprint 结束时交付潜在可发布并且“完成”的产品增量。</p></li><li><p>Scrum Master：</p><p>促进和支持SCRUM，帮助每个人理解 SCRUM理论、实践、规则和价值。</p></li></ol><h2 id="估算计划和跟踪">2.2 估算、计划和跟踪</h2><h3 id="估算">2.2.1 估算</h3><p>目的：给各类计划提供决策依据</p><p>对象：规模、时间和日程</p><p>怎么做估算？</p><ol type="1"><li><p>估算要的是过程，而非结果；估算的过程是相关干系人达成一致共识的过程</p></li><li><p>最终目标是达成共识</p></li><li><p>建立信心</p><ul><li><p>足够详细</p></li><li><p>依赖数据</p></li><li><p>最好的猜测（注意检验猜测所依据的假设）</p></li></ul></li></ol><h4 id="probe估算方法">PROBE估算方法</h4><p>精确度量往往不便于早期估算，有助于早期估算的度量往往难以产生精确结果。</p><p>PROBE：精确度量和早期规划之间的桥梁。</p><p>PROBE估算流程：</p><ol type="1"><li>概要设计</li><li>代理识别和代理规模</li><li>估算并调整程序规模/资源</li><li>计算预测区间</li></ol><p>概要设计过程：</p><ol type="1"><li>确定产品功能，以及产生这些功能所需的程序组件/模块</li><li>将这些程序组件/模块与你以前写的程序相比较，估算它们的规模</li><li>将程序组件/模块估算综合给出总规模</li></ol><p>估算结果整合：</p><ul><li>整合一个开发人员做的多个估算<ul><li>累积各个部分的估算</li><li>进行一次线性回归计算</li><li>计算一个预测区间</li></ul></li><li>多个开发人员可以整合独立进行的估算，通过以下方式<ul><li>进行单独的线性回归预测</li><li>将计划的规模或者时间相加</li><li>将个人范围的平方相加，再对其计算平方根获得预测区间</li></ul></li></ul><h4 id="srum故事点">SRUM故事点</h4><p>度量实现一个故事需要付出的工作量。</p><ul><li><strong>抽象：</strong>混合了对于开发特性所要付出的努力、开发复杂度、个中风险以及类似东西</li><li><strong>相对：</strong>设定标准之后，考虑其他特性与标准之间的相对大小关系</li></ul><h3 id="计划">2.2.2 计划</h3><h4 id="工作分解结构">工作分解结构</h4><p>创建方法：</p><ol type="1"><li>识别和分析可交付成果及相关工作；</li><li>确定工作分解结构的结构与编排方法；</li><li>自上而下逐层细化分解；</li><li>为工作分解结构组成部分制定和分配标志编码；</li><li>核实工作分解的程度是必要且充分的。</li></ol><p>检查标准：</p><ol type="1"><li>最底层要素不能重复，即任何一个工作包只应该在 WBS中的一个地方出现。</li><li>所有要素必须清晰完整定义，即相应的数据词典必须完整定义。</li><li>最底层要素必须有定义清晰的责任人，可以支持成本估算和进度安排。</li><li>最底层的要素是实现目标的成分必要条件，即项目的工作范围得到完整体现。</li></ol><h4 id="通用计划框架">通用计划框架</h4><figure><img src="/image/软件质量管理/通用计划框架.png" alt="通用计划框架" /><figcaption aria-hidden="true">通用计划框架</figcaption></figure><h4 id="各类计划">各类计划</h4><ol type="1"><li><p>质量计划</p><ul><li><p>确定需要开展的质量保证活动。</p></li><li><p>典型的质量保证活动：个人评审、团队评审、单元测试、集成测试、系统测试、验收测试等。</p></li><li><p>需要解决的关键问题：该开展哪些活动，以及这些活动开展的程度，如时间、人数和目标。</p></li></ul></li><li><p>风险计划</p><ul><li>目的：在风险发生前，识别出潜在的问题，以便在产品或项目的生命周期中规划和实施风险管理活动，以消除潜在问题对项目产生的负面影响。</li><li>风险管理：<ul><li>风险识别<ul><li>识别与成本、进度及绩效相关的风险，审查可能影响项目的环境因素、工作分解结构的所有组件、项目计划的所有组件</li><li>记录风险的内容、条件及可能的结果，识别每一风险相关的干系人</li><li>利用已定义的风险参数，评估已识别的风险，依照定义的风险类别，将风险分类并分组，排列降低风险的优先级</li></ul></li><li>风险应对：制定相应的风险管理策略。<ul><li>风险转嫁</li><li>风险解决</li><li>风险缓解</li></ul></li></ul></li></ul></li></ol><h3 id="跟踪">2.2.3 跟踪</h3><p>目的：了解项目进度。</p><ul><li><p>在项目实际进展与计划产生严重偏离时，可采取适当的纠正措施。</p></li><li><p>项目进度滞后与否需要参照物，即项目计划。</p></li><li><p>项目跟踪需要管理针对偏差而采取的纠偏措施。</p></li></ul><h4 id="挣值管理方法">挣值管理方法</h4><p>Earned Value Management，简称EVM。</p><ul><li><p>每项任务实现附以一定价值</p></li><li><p>100%完成该项任务，就获得相应价值</p></li></ul><p>采用与进度计划、成本预算和实际成本相联系的三个独立的变量，进行项目绩效测量。</p><ul><li><p>简单实现：</p><p>仅仅关注进度信息。</p><ol type="1"><li><p>建立 WBS，定义工作范围</p></li><li><p>为 WBS 中每一项工作定义一个价值（PV）</p></li><li><p>最后按照一定的规则将某一数值赋给已经完成的工作或者正在进行的工作。</p><p>常用规则分别为 0-100 规则和 50-50规则，前者只有当某项任务完成时，该任务的 PV 值将转化成 EV值；后者只需要开始某项任务，即可以赋原 PV 值的 50%作为 EV值，完成时，再加上另外的 50%。而实际完成的工作所需成本 AC 不对 EV值产生任何影响。</p></li></ol></li><li><p>中级实现在简单实现的基础上，加入日程偏差的计算。典型计算方式有：</p><ul><li>日程偏差 SV = EV – PV；</li><li>日程偏差指数 SPI = EV/PV；</li></ul></li><li><p>高级实现在中级实现的基础上，还需要考察项目的实际成本。</p></li></ul><h5 id="常用evm度量">常用EVM度量</h5><p>BAC表示按照PV值的曲线，当项目完成的时候所需预算或者时间</p><p>成本差异CV = EV-AC</p><p>成本差异指数CPI = EV/AC</p><p>日程偏差SV = EV – PV</p><p>日程偏差指数SPI = EV/PV</p><p>预计完成成本EAC = AC+(BAC-EV)/CPI = BAC/CPI</p><h5 id="燃尽图">燃尽图</h5><p>纵坐标为总估计时间，横坐标为迭代时间线，估计曲线为估计的剩余任务，实际曲线为实际的剩余任务。</p><h5 id="局限性">局限性</h5><p>EVM 一般不能应用软件项目的质量管理。</p><p>EVM需要定量化的管理机制，这就使其在一些探索型项目以及常用的敏捷开发方法中的应用受到限制</p><p>EVM完全依赖项目的准确估算，然而在项目早期，很难对项目进行非常准确的估算。</p>]]></content>
    
    
    <categories>
      
      <category>软件质量管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件质量管理_概述</title>
    <link href="/2024/06/21/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/1.%20%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/06/21/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/1.%20%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="概述">1. 概述</h1><h2 id="软件危机">1.0 软件危机</h2><p>软件在改变（定义？颠覆？）我们的世界。</p><p>软件自身的变化：规模、比例。</p><h3 id="软件四大本质困难和挑战">软件四大本质困难和挑战</h3><p>复杂性、不可见性、可变性、一致性</p><ul><li>除了不可见性，其他三个本质难题因项目而异</li><li>四大本质难题相互促进</li><li>本质难题变化带动软件方法（过程）演变</li></ul><h3 id="软件危机-1">软件危机</h3><p>软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。</p><h3 id="软件工程">软件工程</h3><p>一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。</p><p>软件工程的两大视角</p><ul><li>管理视角——能否复制成功？</li><li>技术视角——是否可以将问题解决得更好？</li></ul><h2 id="软件项目与过程管理">1.1 软件项目与过程管理</h2><p>管理的三大关键要素：</p><ul><li>目标</li><li>状态</li><li>纠偏</li></ul><h3 id="软件项目管理">1.1.1 软件项目管理</h3><p>应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。</p><ul><li>三大目标：成本、质量、工期</li><li>估算、计划、跟踪、风险管理、范围管理、人员管理、沟通管理，等等</li></ul><p>核心问题：复制成功</p><h4 id="软件过程">软件过程</h4><p>为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合</p><ul><li>这组实践间往往有一定先后顺序，作为整体来实现事先定义的一个或者多个目标。</li></ul><h4 id="广义软件过程">广义软件过程</h4><p>理论基石：软件产品和服务的质量，很大程度上取决于生产维护该软件或者服务的过程的质量。</p><p>广义软件过程包括技术、人员以及狭义过程。</p><ul><li>也称软件开发方法、软件开发过程。</li><li>极限编程方法、SCRUM方法、Gate方法</li><li>敏捷软件过程／方法、轻量型过程／方法以及重型过程／方法等</li></ul><h4 id="生命周期模型">生命周期模型</h4><p>对软件过程的一种人为的划分。</p><ul><li>生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分。</li><li>生命周期模型往往不包括技术实践。</li><li>瀑布模型、迭代式模型、增量模型、螺旋模型、原型法等等</li></ul><h3 id="软件过程管理">1.1.2 软件过程管理</h3><p>管理对象：软件过程</p><p>目的：让软件过程在开发效率、质量等方面有着更好性能绩效</p><ul><li>软件项目管理：产品生产管理（SCRUM、Kanban）</li><li>软件过程管理：流水线的设计、建设、维护、优化（CMMI、SPICE）</li></ul><h4 id="软件过程改进">软件过程改进</h4><ul><li>管理参考模型：CMM/CMMI、SPICE</li><li>改进参考元模型：PDCA、IDEAL</li></ul><h2 id="软件发展三大阶段">1.2 软件发展三大阶段</h2><ol type="1"><li>软硬件一体化阶段（50年代~70年代）</li></ol><ul><li>软件完全依附于硬件</li><li>软件作坊</li></ul><ol start="2" type="1"><li>软件成为独立的产品（70年代~90年代）</li><li>网络化和服务化（90年代中期迄今）</li></ol><h3 id="软硬件一体化">1.2.1 软硬件一体化</h3><h4 id="软件完全依附于硬件">软件完全依附于硬件</h4><p>软件应用典型特征：</p><ul><li><p>软件支持硬件完成计算任务</p></li><li><p>功能单一</p></li><li><p>复杂度有限</p></li><li><p>几乎不需要需求变更</p></li></ul><p>软件开发典型特征</p><ul><li>硬件太贵</li><li>团队以硬件工程师和数学家为主</li></ul><p>实践：Measure twice, cut once</p><h4 id="软件作坊">软件作坊</h4><p>软件应用典型特征</p><ul><li>功能简单</li><li>规模小</li></ul><p>软件开发典型特征</p><ul><li>很多非专业领域的人员涌入软件开发领域</li><li>高级程序语言出现</li><li>质疑权威文化盛行</li></ul><p>实践：Code and fix</p><h3 id="软件成为独立产品">1.2.2 软件成为独立产品</h3><p>软件应用特征</p><ul><li>摆脱了硬件束缚</li><li>功能强大</li><li>规模和复杂度剧增</li><li>个人电脑出现，普通人成为软件用户<ul><li>需求多变</li><li>兼容性要求</li></ul></li><li>来自市场的压力</li></ul><p>实践：</p><ul><li>形式化方法</li><li>结构化程序设计、瀑布模型</li><li>CMM/CMMI</li></ul><h3 id="网格化和服务化">1.2.3 网格化和服务化</h3><p>软件应用特征</p><ul><li>功能更复杂，规模更大</li><li>用户数量急剧增加（这会带来什么问题？）</li><li>快速演化和需求不确定</li><li>分发方式的变化（SaaS）</li></ul><p>典型软件过程和实践</p><ul><li><p>迭代式</p></li><li><p>敏捷宣言</p><ul><li>个体和互动胜过流程和工具</li><li>可以工作的软件胜过详尽的文档</li><li>客户合作胜过合同谈判</li><li>响应变化胜过遵循计划</li></ul></li><li><p>XP、SCRUM、Kanban</p></li><li><p>开源软件开发方法</p></li></ul><h3 id="软件发展现状">1.2.4 软件发展现状</h3><p>软件应用典型特征</p><ul><li><p>进一步服务化和网络化（移动是主流）</p></li><li><p>用户需求多样性进一步凸显</p></li><li><p>软件产品和服务的地位变化</p></li><li><p>错综复杂的部署环境</p></li><li><p>近乎苛刻的用户期望</p><ul><li>多：功能丰富，个性化</li><li>快：快速使用，及时更新，快速解决问题</li><li>好：稳定，可靠，安全，可信</li><li>省：用户的获得成本低，最好免费</li></ul></li></ul><p>软件开发典型特征</p><ul><li>空前强大的开发和部署环境——XaaS<ul><li>IaaS</li><li>PaaS</li><li>SaaS, FaaS</li></ul></li><li>盛行共享和开源</li><li>潜在支撑获得了长足进步（AI，Bigdata， Cloud，etc.）</li></ul><p>典型DevOps实践和方法</p><ul><li>方法论基础：敏捷软件开发、精益思想以及Kanban方法。</li><li>以领域驱动设计为指导的微服务架构方式</li><li>大量虚拟化技术的使用</li><li>一切皆服务的理念指导</li><li>构建了强大的工具链，支持高水平自动化</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件质量管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件系统设计_软件架构复习</title>
    <link href="/2024/06/14/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/06/14/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="软件架构复习">软件架构复习</h1><h2 id="总览">0. 总览</h2><ol type="1"><li>软件架构</li><li>质量属性</li><li>架构模式</li><li>架构设计</li><li>架构文档化</li><li>架构评价</li><li>微服务</li></ol><h2 id="软件架构">1. 软件架构</h2><h3 id="什么是软件架构">1.1 什么是软件架构？</h3><p>程序或计算系统的结构，由软件元素、这些元素外部可⻅的属性、这些元素的关系组成。</p><h3 id="软件架构师做什么">1.2 软件架构师做什么？</h3><p>联络：客户、技术团队和业务需求分析师</p><p>软件工程</p><p>技术知识</p><p>风险管理。</p><h3 id="架构来自哪里">1.3 架构来自哪里？</h3><p>NFRs、ASRs、质量要求、涉众、组织、技术环境、业务目标</p><h3 id="架构41视图">1.4 架构4+1视图</h3><p>逻辑视图：描述架构中重要的元素及其之间的关系</p><p>进程视图：描述架构的并发和通信元素</p><p>物理视图：描述主要过程和元素是如何被映射到应⽤程序硬件</p><p>开发视图：捕获软件组件的内部组织</p><p>架构⽤例：捕获架构的需求；与多个特定视图关联</p><h3 id="架构活动和过程">1.5 架构活动和过程</h3><h4 id="架构活动">架构活动</h4><ul><li><p>创造系统的商业案例</p></li><li><p>理解需求</p></li><li><p>创造和选择架构</p></li><li><p>与包括开发者在内的涉众沟通架构</p></li><li><p>分析或评估架构</p><ul><li><p>总的⽅法</p></li><li><p>质量特定技术</p></li></ul></li><li><p>实现架构</p></li><li><p>确保架构符合要求</p></li></ul><h4 id="架构过程">架构过程</h4><ol type="1"><li>确定ASRs</li><li>架构设计</li><li>文档化</li><li>架构评估</li></ol><h3 id="软件架构知识领域">1.6 软件架构知识领域</h3><p>软件设计基本概念</p><ul><li><p>总体设计概念</p></li><li><p>上下⽂：软件开发⽣命周期——需求、设计、构建和测试</p></li><li><p>设计过程（⻆⾊、活动、⼯作产品）</p></li><li><p>软件设计的可⽤⼯具</p></li></ul><p>关键技术问题：并⾏性、事件控制和处理、分布式、异常处理、交互式系统、持久化</p><p>软件结构和架构</p><ul><li><p>架构结构和视点</p></li><li><p>架构样式和模式（宏观架构）</p></li><li><p>设计模式（微观架构）</p></li></ul><p>软件设计⽅法</p><ul><li><p>架构⽅法（如属性驱动设计）</p></li><li><p>设计⽅法（如动态系统开发⽅法）</p></li></ul><p>软件设计质量分析和评估</p><ul><li><p>质量属性</p></li><li><p>质量分析和评估⽅法、技术、⼯具</p><ul><li><p>设计审查（如 SEI 的架构权衡分析⽅法）</p></li><li><p>静态分析和动态分析</p></li><li><p>模拟和原型</p></li></ul></li><li><p>度量</p><ul><li><p>指标：架构层次</p></li><li><p>与技术有关的度量</p></li></ul></li></ul><p>设计建模和表示</p><ul><li><p>架构和设计标记（架构描述语⾔ ADL Architecture DescriptionLanguages）</p></li><li><p>统⼀建模语⾔（UML）</p></li><li><p>设计⽂档（视图和超越视图）</p></li><li><p>其他：视能⼒、关注点和领域⽽定</p></li></ul><h2 id="质量属性">2. 质量属性</h2><h3 id="软件需求">2.1 软件需求</h3><h4 id="功能需求">功能需求</h4><p>系统必须完成的、为涉众提供价值的内容。</p><ul><li>功能的实现可能⽤了很多的结构，但功能是与结构⽆关的。</li></ul><h4 id="质量需求nfrs">质量需求（NFRs）</h4><p>整个系统的期望特征，在功能需求之上。</p><ul><li>如果质量属性很重要，软件架构将约束功能的分配到不同的结构。</li></ul><h4 id="约束">约束</h4><p>0 ⾃由度、预定义的设计决定</p><ul><li>接受设计决定、协调其他受影响的设计决定，如此来满⾜约束</li></ul><h3 id="质量属性-1">2.2 质量属性</h3><p>内部/外部属性</p><h4 id="建模质量属性场景">建模质量属性场景</h4><p>源、刺激、制品、环境、响应、度量</p><h4 id="举例">举例</h4><p>可用性、互操作性、可修改性、性能、安全性、可测试性、其他</p><h4 id="质量属性战术">质量属性战术</h4><p>战术是影响质量属性响应控制的设计决定。</p><ul><li>战术的集合被称为架构策略。</li></ul><h4 id="架构设计决策检查列表">架构设计决策检查列表</h4><h3 id="架构重要需求">2.3 架构重要需求</h3><p>在架构上有深刻影响的需求。</p><p>如何收集、确认ASRs：</p><ol type="1"><li>从需求文档收集</li><li>采访涉众</li><li>理解业务目标</li><li>质量属性效用树</li></ol><h2 id="架构模式">3. 架构模式</h2><h3 id="架构模式-1">3.1 架构模式</h3><p>⼀系列在实践中能反复地看到的设计决定。</p><ul><li>上下文：经常出现的、普遍的、引起问题的情形</li><li>问题：适当地概括的，在给定上下⽂中出现</li><li>解决方案：成功的、适当抽象的架构解决⽅案</li></ul><h3 id="模块模式">3.2 模块模式</h3><p>分层模式（微内核模式）</p><h3 id="组件-连接件模式">3.3 组件-连接件模式</h3><p>代理人模式、MVC模式、管道、过滤器模式、C/S模式、P2P模式、SO模式、发布-订阅模式、数据共享模式</p><h3 id="分配模式">3.4 分配模式</h3><p>Map-Reduce模式、Multi-Tier模式</p><h3 id="模式与战术">3.5 模式与战术</h3><ol type="1"><li><p>战术⽐模式简单：使⽤单⼀的结构或机制来处理单⼀的架构要求</p></li><li><p>模式通常将多个设计决定合并到⼀个包</p></li><li><p>模式和战术⼀起构成了软件架构师的主要⼯具</p></li><li><p>战术是设计的建造⽅块，⽤来创建架构模式</p></li><li><p>⼤多数模式由⼏个不同的战术组成</p><ul><li><p>所有战术为了⼀个共同⽬的</p></li><li><p>经常被选择来保证不同的质量属性</p></li></ul></li></ol><h2 id="架构设计">4. 架构设计</h2><h3 id="通用设计策略">4.1 通用设计策略</h3><p>抽象、分解、迭代、重用</p><h3 id="设计决策分类">4.2 设计决策分类</h3><p>职责、协调、数据、资源、元素映射、技术</p><h3 id="属性驱动设计add">4.3 属性驱动设计（ADD）</h3><p>输⼊：需求</p><p>输出：软件元素、⻆⾊、职责、属性、关系</p><p>步骤：</p><ol type="1"><li>确认需求</li><li>选择并分解元素</li><li>识别ASR</li><li>选择满足ASR的设计<ul><li>确认关注点</li><li>列出可选项（模式/战术）</li><li>选择模式/战术</li><li>决定模式/战术和ASR间关系</li><li>捕捉初步架构视图</li><li>解决不一致</li></ul></li><li>实例化元素，分配职责</li><li>定义元素接口</li><li>验证、细化需求</li><li>重复2-7直到所有架构重要需求被满足</li></ol><h2 id="架构文档化">5. 架构文档化</h2><h3 id="视图">5.1 视图</h3><h4 id="样式模式和视图">样式、模式和视图</h4><p>架构样式：元素和关系类型的专⻔化，以及如何使⽤它们的⼀组约束。</p><p>架构模式：软件系统中的基础结构组织⽅法的表达。</p><ul><li>架构模式关注问题和上下午，样式侧重方法。</li></ul><p>样式的三个分类：</p><ul><li>一组样式单元：模块样式</li><li>一组有运行时行为和交互的元素：组件-连接件样式</li><li>与环境中的非软件结构关联：分配样式</li></ul><p>架构视图：⼀组系统元素及其关系的表示。</p><ul><li>视图让我们将系统实体划分成感兴趣和易于管理的系统表示。</li><li>不同的视图⽀持不同的⽬标和⽤户，凸显出不同系统元素和关系</li><li>不同视图在不同程度上展现不同的质量属性</li></ul><h4 id="结构性视图">结构性视图</h4><h5 id="模块视图">模块视图</h5><p>模块是提供⼀套连贯的职责的实现单元。</p><p>包含：</p><ul><li>分解视图 Decomposition view</li><li>使⽤视图 Uses view</li><li>概括视图 Generalization view</li><li>分层视图 Layered view</li><li>⽅⾯视图 Aspects view</li><li>数据模型视图 Data model view</li></ul><p>元素：模块，提供⼀套连贯职责的实现单元</p><p>关系：</p><ul><li><p>“⼀部分”：部分⼦模块和整体聚合模块之间的部分、整体关系</p></li><li><p>“依赖于”：两个模块之间的依赖关系。特定的模块视图详细说明了依赖关系的含义</p></li><li><p>“是”：更具体的⼦模块和更⼀般的⽗模块之间的泛化、专⻔化关系</p></li></ul><p>约束：不同模块视图可能会施加特定的拓扑约束，例如限制模块之间的可⻅性。</p><p>⽤途</p><ul><li><p>代码构建蓝图</p></li><li><p>变更影响分析</p></li><li><p>规划增量开发</p></li><li><p>需求追踪分析</p></li></ul><h5 id="组件-连接件视图">组件-连接件视图</h5><p>显示运行时组件。</p><ul><li><p>例如进程、对象、客户机、服务器和数据存储</p></li><li><p>“连接”指明了哪些连接器连接到哪些组件。</p></li></ul><p>包含：</p><ul><li>管道-过滤器视图 Pipe-and-filter view</li><li>客户机-服务端视图 Client-server view</li><li>点对点视图 Peer-to-peer view</li><li>⾯向服务架构视图 Service-oriented view</li><li>发布-订阅视图 Publish-subscribe view</li><li>共享数据视图 Shared-data view</li><li>多层视图 Multi-tier view</li></ul><p>元素：</p><ul><li><p>组件。主要处理单元和数据存储。组件有⼀组端⼝，通过这些端⼝与其他组件进⾏交互（通过连接器）</p></li><li><p>连接器。组件间交互的途径。连接器有⼀组⻆⾊（接⼝），指示组件如何在交互中使⽤连接器</p></li></ul><p>约束：</p><ul><li><p>组件只能连接到连接器，⽽不是直连其他组件</p></li><li><p>连接器只能连接到组件，⽽不是直连其他连接器</p></li><li><p>连接只能在相容的端⼝和⻆⾊上建⽴</p></li><li><p>接⼝委托只能在两个相容端⼝或⻆⾊上定义</p></li><li><p>连接器不能孤⽴出现，必须连接到组件</p></li></ul><p>⽤途</p><ul><li><p>演示系统如何⼯作</p></li><li><p>通过指定运⾏时元素的结构和⾏为来指导开发</p></li><li><p>帮助解释运⾏时系统质量属性，如性能和可⽤性</p></li></ul><h5 id="分配视图">分配视图</h5><p>描述了软件单元到软件开发或执⾏环境元素的映射。</p><p>包含：</p><ul><li>部署视图 Deployment view</li><li>安装视图 Install view</li><li>⼯作安排视图 Work assignment view</li><li>其他分配视图 Other allocation view</li></ul><p>元素</p><ul><li><p>软件元素。软件元素具有环境所需的属性</p></li><li><p>环境元素。环境元素具有提供给软件的属性</p></li></ul><p>关系：被分配。软件元素被分配到环境元素，属性取决于特定视图。</p><p>⽤途：</p><ul><li><p>⽤于对性能、可⽤性、安全性 security 和安全性 safety进⾏解释</p></li><li><p>⽤于解释分布式开发和将⼯作分配给团队</p></li><li><p>⽤于解释软件版本的并⾏访问</p></li><li><p>⽤于解释系统安装的形式和机制</p></li></ul><h4 id="质量视图">质量视图</h4><p>包含</p><ul><li><p>安全视图 Security view</p></li><li><p>性能视图 Performance view</p></li><li><p>可靠性视图 Reliability view</p></li><li><p>通信视图 Communication view</p></li><li><p>异常视图 Exception view（错误处理视图 error- handlingview）</p></li></ul><h3 id="视图文档化">5.2 视图文档化</h3><h3 id="选择视图">选择视图</h3><h4 id="选择视图-1">选择视图</h4><ol type="1"><li><p>构建涉众-视图表</p></li><li><p>组合视图</p><ol type="1"><li>确定上表中的边缘视图</li><li>通过将⼀个视图的元素与另⼀个视图中的元素相关联，将每个边缘视图与另⼀个更具⽀持性的视图相结合</li></ol></li><li><p>确定优先级和阶段</p><ul><li><p>分解视图</p></li><li><p>⼋⼆开原则</p></li><li><p>按顺序完成所有视图</p></li></ul></li></ol><h4 id="涉众文档">涉众文档</h4><p>左列是涉众的类别，右列是对应涉众如何使⽤这个⽂档。</p><h4 id="涉众-视图表">涉众-视图表</h4><p>左边是涉众，右边每⼀列都是⼀个视图，值分别表示：</p><ul><li>d 详细信息</li><li>s ⼀些细节</li><li>o ⼤概信息</li><li>x ⽆所谓。</li></ul><h3 id="超越视图">5.3 超越视图</h3><p>文档信息、架构信息、视图间映射。</p><h2 id="架构评价">6. 架构评价</h2><h3 id="架构分析评价方法">6.1 架构分析+评价方法</h3><p>软件架构分析⽅法 SAAM，Software Architecture Analysis Method</p><p>架构层级可修改性分析 ALMA，Architecture Level ModifiabilityAnalysis</p><p>软件架构性能评估 PASA，Performance Assessment of SoftwareArchitecture</p><p>架构权衡分析⽅法 ATAM，Architecture Trade-off Analysis Method</p><h3 id="atam">6.2 ATAM</h3><p>架构权衡分析⽅法，Architecture Tradeoff Analysis Method</p><ol start="0" type="1"><li><p>合作与准备</p><p>参与者：团队领导和主要项目决策者</p><p>输入：架构文档</p><p>输出：评价计划</p></li><li><p>评估1</p><p>参与者：评估团队和项目决策者</p><p>输出：架构展示、业务驱动因素、质量属性需求优先级列表、效用树、风险、敏感点和权衡点</p><ol type="1"><li>展示 ATAM</li><li>展示业务驱动因素</li><li>展示架构</li><li>识别架构⽅法</li><li>⽣成效⽤树</li><li>分析架构⽅法</li></ol></li><li><p>评估2</p><p>参与者：评估团队、项目决策者、架构涉众</p><p>输出：涉众社区的优先级场景列表、风险主题和受威胁的业务驱动因素</p><ol type="1"><li>展示 ATAM 和结果</li><li>头脑⻛暴和定优先级</li><li>分析架构⽅法</li><li>展示结果</li></ol></li><li><p>后续⾏动</p><p>参与者：评估团队和主要涉众</p><p>输出：最终评估报告</p></li></ol><h4 id="atam输出">ATAM输出</h4><ul><li>架构的简短展示</li><li>业务⽬标的表达</li><li>由质量属性场景表达的定优先级的质量属性需求</li><li>效⽤树</li><li>⼀组⻛险和⾮⻛险</li><li>⼀组⻛险主题</li><li>从架构决定到质量需求的映射</li><li>⼀组确定的敏感点和权衡点</li><li>最终评估报告</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件系统设计_详细设计复习</title>
    <link href="/2024/06/13/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/06/13/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="详细设计复习">详细设计复习</h1><h2 id="软件模式">1. 软件模式</h2><p>软件开发的总体指导思路或参照样板。</p><ul><li>软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等。</li><li>在软件生存期的每一个阶段都存在着一些被认同的模式。</li></ul><h3 id="组成">组成</h3><ul><li>问题描述</li><li>前提条件(环境或约束条件)</li><li>解法</li><li>效果。</li></ul><h3 id="大三律">大三律</h3><p>只有经过三个以上不同类型(或不同领域)系统的校验，一个解决方案才能从候选模式升格为模式。</p><h2 id="设计模式">2.设计模式</h2><p>被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><h3 id="基本要素">基本要素</h3><ul><li>模式名称 (Pattern name)</li><li>问题 (Problem)</li><li>解决方案 (Solution)</li><li>效果 (Consequences)</li></ul><h3 id="分类">分类</h3><p>根据其目的分为</p><ul><li>创建型（Creational）：创建对象</li><li>结构型（Structural）：处理类或对象的组合</li><li>行为型（Bahavioral）：描述对类或对象怎样交互和分配职责</li></ul><p>根据范围，即模式主要用于处理类/对象之间关系分为</p><ul><li>类模式：处理类和子类的关系，这些关系在编译时确定，是静态的</li><li>对象模式：处理对象间关系，这些关系在运行时变化，是动态的</li></ul><h3 id="考察内容">考察内容</h3><table><thead><tr class="header"><th>范围/目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr class="odd"><td>类模式</td><td>工厂方法模式</td><td>（类）适配器模式</td><td>模板方法模式</td></tr><tr class="even"><td>对象模式</td><td>抽象工厂模式<br />原型模式</td><td>（对象）适配器模式<br />组合模式<br />装饰模式<br />外观模式</td><td>命令模式<br />中介者模式<br />观察者模式<br />状态模式<br />策略模式</td></tr></tbody></table><h3 id="设计模式与类库框架">设计模式与类库框架</h3><ol type="1"><li><p>设计模式比库的层次更高。设计模式告诉我们如何构建类和对象以解决特定问题。</p></li><li><p>框架和库不是设计模式；它们提供了具体的实现，我们将这些实现链接到我们的代码中。</p></li></ol><h2 id="设计原则">3. 设计原则</h2><p>对于面向对象的软件系统设计来说，在支持可维护性的同时，需要提高系统的可复用性。</p><ul><li>软件的复用可以提高软件的开发效率和软件质量，节约开发成本。</li><li>恰当的复用还可以改善系统的可维护性。</li></ul><p>目标：开闭原则</p><p>指导：最小知识原则</p><p>基础：单一职责原则、可变性封装原则</p><p>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</p><ol type="1"><li><p>开闭原则：一个软件实体应当对扩展开放，对修改关闭。</p></li><li><p>单一职责原则：一个类只负责一个功能领域中的相应职责。</p></li><li><p>里氏代换原则：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</p></li><li><p>依赖倒转原则：</p><p>抽象不应该依赖于细节，细节应该依赖于抽象</p><p>针对接口编程，不要针对实现编程。</p></li><li><p>接口隔离原则：客户端不应该依赖那些它不需要的接口。</p><ul><li>将一些大的接口细化成一些小的接口供客户端使用。</li></ul></li><li><p>合成复用原则：复用时尽量使用对象组合，而不使用继承。</p></li><li><p>迪米特法则：一个软件实体应当尽可能少的与其他实体发生相互作用。</p></li></ol><h2 id="表驱动法">4. 表驱动法</h2><h3 id="目标">目标</h3><p>将复杂逻辑从代码中⽴出来，以便于单独维护。</p><h3 id="原理">原理</h3><p>从表⾥⾯查找信息⽽不使⽤逻辑语句。</p><h3 id="查询">查询</h3><h4 id="直接访问">直接访问</h4><p>通过索引值（如下标）直接从表中找到对应的条⽬。</p><h4 id="索引访问">索引访问</h4><p>当⽆法直接从表中查询需要的条⽬时，就需要借助其他⽅法先获取表键值</p><ul><li>⽅法：先⽤⼀个基本类型的数据从索引表中查出⼀个键值，然后再⽤这⼀键值查出主数据。</li></ul><h4 id="阶梯访问">阶梯访问</h4><p>基本思想：通过确定每项命中的阶梯层次确定其归类。</p><ul><li>⽐索引访问⽅法节省空间，当阶梯多了⽐较次数就多。</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件系统设计_设计模式</title>
    <link href="/2024/06/12/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/06/12/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="设计模式">设计模式</h1><p>被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><h2 id="概念">0. 概念</h2><h3 id="基本要素">基本要素</h3><ul><li>模式名称 (Pattern name)</li><li>问题 (Problem)</li><li>解决方案 (Solution)</li><li>效果 (Consequences)</li></ul><h3 id="分类">分类</h3><p>根据其目的分为</p><ul><li>创建型（Creational）：创建对象</li><li>结构型（Structural）：处理类或对象的组合</li><li>行为型（Bahavioral）：描述对类或对象怎样交互和分配职责</li></ul><p>根据范围，即模式主要用于处理类/对象之间关系分为</p><ul><li>类模式：处理类和子类的关系，这些关系在编译时确定，是静态的</li><li>对象模式：处理对象间关系，这些关系在运行时变化，是动态的</li></ul><h3 id="设计模式与类库框架">设计模式与类库框架</h3><ol type="1"><li><p>设计模式比库的层次更高。设计模式告诉我们如何构建类和对象以解决特定问题。</p></li><li><p>框架和库不是设计模式；它们提供了具体的实现，我们将这些实现链接到我们的代码中。</p></li></ol><h3 id="考察内容">考察内容</h3><table><thead><tr class="header"><th>范围/目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr class="odd"><td>类模式</td><td>工厂方法模式</td><td>（类）适配器模式</td><td>模板方法模式</td></tr><tr class="even"><td>对象模式</td><td>抽象工厂模式<br />原型模式</td><td>（对象）适配器模式<br />组合模式<br />装饰模式<br />外观模式</td><td>命令模式<br />中介者模式<br />观察者模式<br />状态模式<br />策略模式</td></tr></tbody></table><h2 id="工厂模式">1. 工厂模式</h2><h3 id="简单工厂模式">简单工厂模式</h3><p>专门定义一个类来负责创建其他类的实例，根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><ul><li><p>又称静态工厂模式。</p></li><li><p>将对象的创建和对象本身业务处理分离可以降低系统的耦合度。</p></li></ul><h3 id="工厂方法模式">工厂方法模式</h3><p>简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这违背了开闭原则。</p><h4 id="概念-1">概念</h4><p>工厂方法模式（Factory Method Pattern）又称为工厂模式。</p><ul><li>也叫虚拟构造器（Virtual Constructor）模式、多态工厂（PolymorphicFactory）模式。</li></ul><ol type="1"><li>工厂父类负责定义创建产品对象的公共接口</li><li>工厂子类则负责生成具体的产品对象</li></ol><p>通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><ul><li>允许系统在不修改工厂角色的情况下引进新产品。</li></ul><h4 id="优缺点">优缺点</h4><p>优点：</p><ol type="1"><li>用户只需要关心所需产品对应的工厂，无须关心创建细节、具体产品类名。</li><li>工厂可以自主确定创建何种对象、如何创建对象。</li><li>在系统中加入新产品时，只要添加具体工厂和具体产品。</li></ol><p>缺点：</p><ol type="1"><li>添加新产品时系统中类的个数成对增加，提高了系统复杂度。</li><li>系统中加入抽象层，提高了系统理解难度和实现难度。</li></ol><h4 id="适用环境">适用环境</h4><ol type="1"><li>一个类不知道它所需要的对象的类。</li><li>一个类通过其子类来指定创建哪个对象。</li><li>客户端不需要关心是哪一个工厂子类，需要时动态指定。<ul><li>可将具体工厂类名存储在数据库或配置文件中。</li></ul></li></ol><h4 id="配置文件实例化具体工厂">配置文件实例化具体工厂</h4><p>将具体类的类名写入配置文件中，再通过Java的反射机制，读取XML格式的配置文件，根据存储在XML文件中的类名字符串生成对象。</p><h3 id="抽象工厂模式">抽象工厂模式</h3><p>有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p><ul><li>产品等级结构：产品的继承结构</li><li>产品族：由同一个工厂生产的 ，位于不同产品等级结构中的一组产品</li></ul><h4 id="问题">问题</h4><p>系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品。</p><h4 id="概念-2">概念</h4><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p><ul><li><p>又称为Kit模式。</p></li><li><p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p></li><li><p>工厂方法模式针对一个产品等级结构，而抽象工厂模式需要面对多个。</p></li></ul><h4 id="优缺点-1">优缺点</h4><p>优点：</p><ol type="1"><li>隔离了具体类的生成，只需改变具体工厂的实例，就在某种程度上改变整个软件系统的行为。</li><li>实现高内聚低耦合的设计目的。</li><li>保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的具体工厂和产品族修改已有系统，符合开闭原则。</li></ol><p>缺点：</p><p>添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品。</p><ul><li>即：增加新的工厂和产品族容易，增加新的产品等级结构麻烦。</li></ul><h4 id="和工厂方法模式区别">和工厂方法模式区别</h4><p>工厂模式创建同一个产品的不同类型，抽象工厂模式创建不同类的产品。</p><ul><li>产品种类单一，适合用工厂模式。</li><li>有多个种类，各种类型时，适合抽象工厂模式。</li></ul><h4 id="适用环境-1">适用环境</h4><p>对所有的工厂模式：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节。</p><ol type="1"><li>系统中有多于一个的产品族，属于同一个产品族的产品将在一起使用。</li><li>所有的产品以同样的接口出 现，从而使客户端不依赖于具体实现。</li></ol><h3 id="模式扩展">模式扩展</h3><h4 id="开闭原则的倾斜性">开闭原则的倾斜性</h4><ol type="1"><li><p>增加产品族：对于增加新的产品族，工厂模式很好的支持了开闭原则，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</p></li><li><p>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持开闭原则。</p></li></ol><h4 id="工厂模式的退化">工厂模式的退化</h4><ol type="1"><li>只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式。</li><li>工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li></ol><h2 id="原型模式">2. 原型模式</h2><h3 id="概念-3">概念</h3><p>用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><ul><li><p>基本工作原理：</p><p>将一个原型对象传给要发动创建的对象，该对象请求原型对象拷贝原型自身来实现创建。</p></li><li><p>包含角色：抽象原型类、具体原型类、客户类</p></li><li><p>类包含一些成员对象，在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为深克隆和浅克隆。</p></li><li><p>clone()满足：</p><ol type="1"><li>对任何的对象x，都有x.clone() !=x，即克隆对象与原对象不是同一个对象。</li><li>对任何的对象x，都有x.clone().getClass()==x.getClass()，克隆对象与原对象类型一样。</li><li>如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</li></ol></li></ul><h3 id="优缺点-2">优缺点</h3><p>优点：</p><ol type="1"><li>简化对象的创建过程，通过已有实例提高新实例的创建效率。</li><li>动态增加或减少产品类。</li><li>可以使用深克隆保存对象的状态。</li></ol><p>缺点：</p><ol type="1"><li>需要为每一个类配备一个克隆方法。</li><li>实现深克隆的代码较为复杂。</li></ol><h3 id="适用环境-2">适用环境</h3><ol type="1"><li>创建新对象成本较大。</li><li>系统要保存对象的状态。</li><li>避免使用分层次的工厂类来创建分层次的对象。</li></ol><h3 id="模式扩展-1">模式扩展</h3><p>相似对象复制：通过原型模式获得相同对象后再对其属性进行修改，从而获取所需对象。</p><h2 id="适配器模式">3. 适配器模式</h2><h3 id="概念-4">概念</h3><p>将一个接口转换成客户希望的另一个接口。</p><ul><li>也称包装器（Wrapper）。</li><li>既可以作为类结构型模式，也可以作为对象结构型模式。</li><li>包含角色：目标抽象类、适配器类、适配者类、客户类</li></ul><h3 id="优缺点-3">优缺点</h3><p>适配器模式优点：</p><ol type="1"><li>将目标类和适配者类解耦。<ul><li>通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li></ul></li><li>增加了类的透明性和复用性。</li><li>灵活性和扩展性好。<ul><li>通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合开闭原则。</li></ul></li></ol><p>类适配器：</p><p>优点：适配器类是适配者类的子类，可以置换一些适配者的方法，灵活性强。</p><p>缺点：在很多编程语言中适配器类不能同时适配多个适配者类。</p><p>对象适配器：</p><p>优点：同一个适配器可以把适配者类和它的子类都适配到目标接口。</p><p>缺点：不容易置换适配者类的方法。</p><h3 id="适用环境-3">适用环境</h3><ol type="1"><li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ol><h3 id="模式扩展-2">模式扩展</h3><h4 id="默认适配器模式">默认适配器模式</h4><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式。</p><h4 id="双向适配器">双向适配器</h4><p>如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器。</p><h2 id="组合模式">4. 组合模式</h2><h3 id="概念-5">概念</h3><p>组合多个对象形成树形结构以表示“整体-部分”的结构层次。</p><ul><li><p>对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。</p></li><li><p>又称“整体-部分”（Part-Whole）模式</p></li><li><p>包含角色：抽象构件、叶子构件、容器构件、客户类</p></li><li><p>关键：</p><p>定义一个抽象构件类，既可以代表叶子，又可以代表容器，递归组合成树形结构。</p><p>而客户端针对该抽象构件类进行编程。</p></li></ul><h3 id="优缺点-4">优缺点</h3><p>优点：</p><ol type="1"><li>清楚地定义分层次的复杂对象。</li><li>客户端可以一致的使用组合结构或其中单个对象。</li><li>定义了包含叶子对象和容器对象的类层次结构，递归组合成树形结构。</li><li>更容易在组合体内加入对象构件。</li></ol><p>缺点：</p><ol type="1"><li>设计更加抽象困难。</li><li>很难对容器中的构件类型进行限制。</li></ol><h3 id="适用环境-4">适用环境</h3><ol type="1"><li>需要表示一个对象整体或部分层次。</li><li>客户端可以针对抽象构件编程，无须关心对象层次结构的细节。</li><li>对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们。</li></ol><h2 id="装饰模式">5. 装饰模式</h2><h3 id="概念-6">概念</h3><p>动态地给一个对象增加一些额外的职责。</p><ul><li><p>又称包装器（Wrapper），和适配器别名相同，但使用场合不同。</p></li><li><p>包含角色：抽象构件、具体构件、抽象装饰类、具体装饰类</p></li><li><p>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性。</p><ul><li>继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。</li><li>关联关系使系统具有较好的松耦合性， 因此使得系统更加容易维护。</li><li>关联关系的缺点是比继承关系要创建更多的对象。</li></ul></li></ul><h3 id="优缺点-5">优缺点</h3><p>优点：</p><ol type="1"><li>提供比继承更多的灵活性。</li><li>通过一种动态的方式来扩展一个对象的功能。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。</li><li>具体构件类与具体装饰类可以独立变化。</li></ol><p>缺点：</p><ol type="1"><li>产生很多小对象。</li><li>装饰模式比继承更加易于出错，排错也很困难。<ul><li>对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul></li></ol><h3 id="适用环境-5">适用环境</h3><ol type="1"><li>以动态、透明的方式给单个对象添加职责。</li><li>动态地给一个对象增加、撤销功能。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。<ul><li>系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长</li><li>类定义不能继承（final类）。</li></ul></li></ol><h3 id="模式扩展-3">模式扩展</h3><h4 id="装饰模式简化">装饰模式简化</h4><ol type="1"><li>一个装饰类的接口必须与被装饰类的接口保持相同。</li><li>不要把太多的逻辑和状态放在具体构件类中。</li><li>如果只有一个具体构件类而没有抽象构件类，抽象装饰类可以作为具体构件类的直接子类。</li></ol><h4 id="透明装饰模式和半透明装饰模式">透明装饰模式和半透明装饰模式</h4><ul><li>透明装饰模式：完全针对抽象编程，不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型。</li><li>半透明装饰模式：允许声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li></ul><h2 id="外观模式">6. 外观模式</h2><h3 id="概念-7">概念</h3><p>外部与一个子系统的通信通过统一的外观对象进行，为子系统中的一组接口提供一致的界面。</p><ul><li><p>Facade Pattern</p></li><li><p>包含角色：外观、子系统</p></li><li><p>在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性。</p></li><li><p>通过引入一个新的外观类降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p></li></ul><h3 id="优缺点-6">优缺点</h3><p>优点：</p><ol type="1"><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。</li><li>实现了子系统与客户之间的松耦合关系。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ol><p>缺点：</p><ol type="1"><li>不能很好地限制客户使用子系统类。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了开闭原则。</li></ol><h3 id="适用环境-6">适用环境</h3><ol type="1"><li>为一个复杂子系统提供一个简单接口。</li><li>客户程序与多个子系统之间存在很大的依赖性。</li><li>使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ol><h3 id="模式扩展-4">模式扩展</h3><ol type="1"><li>在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互。</li><li>不要试图通过外观类为子系统增加新行为。</li><li>抽象外观类。</li></ol><h2 id="模板方法模式">7. 模板方法模式</h2><h3 id="概念-8">概念</h3><p>定义一个操作中算法的骨架，而将一些步骤延迟到子类中。</p><ul><li><p>使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></li><li><p>包含角色：抽象类、具体子类</p></li><li><p>只有类之间的继承关系，没有对象关联关系</p></li><li><p>模板方法：</p><p>定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。</p></li></ul><h3 id="优缺点-7">优缺点</h3><p>优点：</p><ol type="1"><li>在一个类中抽象地定义算法，而由它的子类实现细节的处理。</li><li>是代码复用的一项基本技术。</li><li>导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合开闭原则。</li></ol><p>缺点：</p><p>导致类的个数增加。</p><h3 id="适用环境-7">适用环境</h3><ol type="1"><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类。</li><li>对一些复杂的算法进行分割。</li><li>控制子类的扩展。</li></ol><h3 id="模式扩展-5">模式扩展</h3><h4 id="好莱坞原则">好莱坞原则</h4><p>子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，父类控制对子类的调用。</p><h4 id="钩子方法的使用">钩子方法的使用</h4><p>使得子类可以控制父类的行为。</p><ol type="1"><li><p>最简单的钩子方法就是空方法，也可以在钩子方法中定义一个默认的实现，如果子类不覆盖钩子方法，则执行父类的默认实现代码。</p></li><li><p>比较复杂一点的钩子方法可以对其他方法进行约束，这种钩子方法通常返回一个boolean类型，即返回true或false，用来判断是否执行某一个基本方法。</p></li></ol><h2 id="命令模式">8. 命令模式</h2><p>动机：对发送者和接收者完全解耦，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p><h3 id="概念-9">概念</h3><p>将请求封装为对象，从而使我们可用不同的请求对客户进行参数化。</p><ul><li><p>对请求排队或者记录请求日志，以及支持可撤销的操作。</p></li><li><p>包含如下角色：抽象命令类、具体命令类、调用者、接收者、客户类</p></li><li><p>本质：对命令进行封装，将发出命令的责任和执行命令的责任分割开。</p></li><li><p>允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口。</p></li><li><p>关键：引入了抽象命令接口，发送者针对抽象命令接口编程。</p></li></ul><h3 id="优缺点-8">优缺点</h3><p>优点：</p><ol type="1"><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的Undo和Redo。</li></ol><p>缺点：</p><p>可能会导致某些系统有过多的具体命令类。</p><h3 id="适用环境-8">适用环境</h3><ol type="1"><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销操作和恢复操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令。</li></ol><h2 id="中介者模式">9. 中介者模式</h2><p>动机：</p><p>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式。</p><h3 id="概念-10">概念</h3><p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><ul><li><p>Mediator Pattern</p></li><li><p>又称调停者模式</p></li><li><p>包含如下角色：抽象中介者、具体中介者、抽象同事类、具体同事类</p></li><li><p>职责：中转与协调</p></li></ul><h3 id="优缺点-9">优缺点</h3><p>优点：</p><ol type="1"><li>简化对象之间交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ol><p>缺点：</p><p>具体中介者类非常复杂，使得系统难以维护。</p><h3 id="适用环境-9">适用环境</h3><ol type="1"><li><p>系统中对象间存在复杂引用关系。</p></li><li><p>一个对象由于引用了其他很多对象并且直接和这些对象通信而难以复用。</p></li><li><p>通过一个中间类来封装多个类中的行为。</p></li></ol><h2 id="观察者模式">10. 观察者模式</h2><p>动机：</p><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系。</p><h3 id="概念-11">概念</h3><p>定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</p><ul><li><p>又称发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p></li><li><p>让主题和观察者之间松耦合。</p></li></ul><h3 id="优缺点-10">优缺点</h3><p>优点：</p><ol type="1"><li>实现表示层和数据逻辑层的分离。<ul><li>定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li></ul></li><li>在观察目标和观察者之间建立一个抽象的耦合。</li><li>支持广播通信。</li><li>符合开闭原则的要求。</li></ol><p>缺点：</p><ol type="1"><li>如果观察者太多，将所有的观察者都通知到会花费很多时间。</li><li>观察者和观察目标之间的循环依赖会导致系统崩溃。</li><li>没有相应的机制让观察者知道所观察的目标对象如何发生变化。</li></ol><h3 id="适用环境-10">适用环境</h3><ol type="1"><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li></ol><h2 id="状态模式">11. 状态模式</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的（stateful）对象。</p><h3 id="概念-12">概念</h3><p>一个对象在其内部状态改变时改变它的行为。</p><ul><li><p>包含角色：环境类、抽象状态类、具体状态类。</p></li><li><p>关键：引入抽象状态类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</p></li><li><p>环境类与抽象状态类：</p><ul><li><p>环境类：拥有状态的对象</p></li><li><p>环境类有时候可以充当状态管理器(StateManager)的角色，可以在环境类中对状态进行切换操作。</p></li><li><p>状态类的产生是由于环境类存在多个状态，并且</p><ul><li>这些状态经常需要切换， 在不同的状态下对象的行为不同</li></ul><p>因此将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为。</p></li></ul></li></ul><h3 id="优缺点-11">优缺点</h3><p>优点：</p><ol type="1"><li>封装了转换规则。</li><li>枚举可能的状态，可以方便地增加新的状态。</li><li>状态转换逻辑与状态对象合成一体。</li><li>让多个环境对象共享一个状态对象。</li></ol><p>缺点：</p><ol type="1"><li>增加系统类和对象的个数</li><li>使用不当将导致程序结构和代码的混乱。</li><li>对开闭原则的支持并不太好<ul><li>增加新的状态类需要修改那些负责状态转换的源代码。</li></ul></li></ol><h3 id="适用环境-11">适用环境</h3><ol type="1"><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句。</li></ol><h3 id="模式扩展-6">模式扩展</h3><ol type="1"><li>共享状态</li><li>简单状态模式（状态不变）</li><li>可切换状态的状态模式</li></ol><h2 id="策略模式">12. 策略模式</h2><h3 id="概念-13">概念</h3><p>一组各自封装的算法族，可以相互替换。策略让算法可以独立于使用它的用户而变化。</p><h3 id="适用环境-12">适用环境</h3><ol type="1"><li>当许多相关类仅在其行为上有所不同时。</li><li>算法的不同变体。</li><li>算法使用用户不应知道的数据。</li><li>一个类定义了许多行为，而这些行为在它的操作中表现为多个条件语句。</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件系统设计_面向对象设计原则</title>
    <link href="/2024/06/11/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2024/06/11/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="面向对象设计原则">面向对象设计原则</h1><p>需求：系统需要满足的目标</p><p>规约：系统的外部可观察到的行为</p><p>架构：</p><ul><li><p>系统一级的主要组成部分</p></li><li><p>各部分的交互方法</p></li><li><p>使用的技术</p></li></ul><p>设计：</p><ul><li>如何完成任务</li><li>需要写的代码<ul><li>可维护、可复用</li></ul></li></ul><p>面向对象软件设计：将实现的约束条件应用到面向对象分析所产生的概念模型的过程。</p><ul><li><p>用方法和属性来描述用于构成系统的类</p></li><li><p>添加不明显属于领域的类，比如接口</p></li><li><p>描述类是如何构成组件的</p></li></ul><p>难点：将一个系统分解成对象</p><h2 id="面向对象设计原则概述">0. 面向对象设计原则概述</h2><p>目标：提高软件的可维护性和可复用性</p><p>Robert C.Martin认为一个软件设计可维护性较低通常的4个原因：</p><ul><li><p>过于僵硬（Rigidity）</p></li><li><p>过于脆弱（Fragility）</p></li><li><p>复用率低（Immobility）</p></li><li><p>黏度过高（Viscosity）</p></li></ul><p>Peter Coad认为，一个好的系统设计具备的三个性质:</p><ul><li>可扩展性（Extensibility）</li><li>灵活性（Flexibility）</li><li>可插入性（Pluggability）</li></ul><p>软件的复用拥有众多优点，如可以提高软件的开发效率，提高软件质量，节约开发成本。</p><p>恰当的复用还可以改善系统的可维护性。</p><p>面向对象设计复用的目标在于实现支持可维护性的复用。</p><p>在面向对象的设计里面，可维护性复用都是以面向对象设计原则为基础的，这些设计原则首先都是复用的原则，遵循这些设计原则可以有效地提高系统的复用性，同时提高系统的可维护性。</p><p>面向对象设计原则也是对系统进行合理重构的指南针，重构是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。</p><p>常用的7个面向对象设计原则：</p><ul><li>单一职责原则</li><li>开闭原则</li><li>里氏代换原则</li><li>依赖倒转原则</li><li>接口隔离原则</li><li>合成复用原则</li><li>迪米特法则</li></ul><p>这些原则并不是孤立存在的，它们相互依赖，相互补充。</p><h2 id="单一职责原则">1. 单一职责原则</h2><p>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类里。</p><ul><li>对一个类而言，应该仅有一个引起它变化的原因。</li></ul><p>一个类承担的职责越多，它被复用的可能性越小。让一个类承担过多的职责相当于将这些职责耦合，当其中一个职责变化时，可能会影响其他职责的运作。</p><p>数据职责（属性）和行为职责（方法）。</p><h2 id="开闭原则">2. 开闭原则</h2><p>一个软件实体应当对扩展开放，对修改关闭。</p><ul><li><p>在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。</p></li><li><p>软件实体可以指一个软件模块，一个由多个类组成的局部结构或一个独立的类。</p></li></ul><p>抽象化是开闭原则的关键。</p><p>对可变性封装原则：找到系统的可变因素并将其封装起来。</p><h2 id="里氏代换原则">3. 里氏代换原则</h2><p>如果对每一个类型为<span class="math inline">\(S\)</span>的对象<spanclass="math inline">\(o_1\)</span>，都有类型为<spanclass="math inline">\(T\)</span>的对象<spanclass="math inline">\(o_2\)</span>，使得以<spanclass="math inline">\(T\)</span>定义的所有程序<spanclass="math inline">\(P\)</span>在所有的对象<spanclass="math inline">\(o_2\)</span>都代换成<spanclass="math inline">\(o_1\)</span>时，程序<spanclass="math inline">\(P\)</span>的行为没有变化，那么类型<spanclass="math inline">\(S\)</span>是类型<spanclass="math inline">\(T\)</span>的子类型。</p><ul><li>所有引用基类的地方必须能透明地使用其子类的对象。</li></ul><p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h2 id="依赖倒转原则">4. 依赖倒转原则</h2><p>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><ul><li><p>要针对接口编程，不要针对实现编程。</p></li><li><p>代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。</p></li></ul><p>如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。</p><p>依赖倒转原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件中。</p><p>类之间的耦合：</p><ul><li>零耦合关系</li><li>具体耦合关系</li><li>抽象耦合关系</li></ul><p>依赖倒转原则要求客户端依赖于抽象耦合，以抽象方式耦合是依赖倒转原则的关键。</p><h2 id="接口隔离原则">5. 接口隔离原则</h2><p>客户端不应该依赖那些它不需要的接口。</p><ul><li>一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。</li></ul><p>使用多个专门的接口，而不使用单一的总接口。每一个接口应该承担一种相对独立的角色。</p><p>使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</p><ul><li>只提供用户需要的行为，而隐藏用户不需要的行为。</li></ul><h2 id="合成复用原则">6. 合成复用原则</h2><p>尽量使用对象组合，而不是继承来达到复用的目的。</p><p>合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。</p><h2 id="迪米特法则">7. 迪米特法则</h2><p>也称最小知识原则。几种典型定义：</p><ol type="1"><li><p>不和“陌生人”说话。</p></li><li><p>只与你的直接朋友通信。</p></li><li><p>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p></li></ol><ul><li>一个软件实体应当尽可能少的与其他实体发生相互作用。</li></ul><p>对于一个对象，其朋友包括以下几类:</p><ul><li>当前对象本身</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ul><p>狭义迪米特法则：</p><p>如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p>广义的迪米特法则：</p><p>指对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制。</p><p>迪米特法则的主要用途在于控制信息的过载：</p><ol type="1"><li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及;</li><li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限;</li><li>在类的设计上，只要有可能，一个类型应当设计成不变类;</li><li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ol><h2 id="小结">8. 小结</h2><ol start="0" type="1"><li><p>对于面向对象的软件系统设计来说，在支持可维护性的同时，需要提高系统的可复用性。</p></li><li><p>软件的复用可以提高软件的开发效率，提高软件质量，节约开发成本，恰当的复用还可以改善系统的可维护性。</p></li><li><p>单一职责原则要求在软件系统中，一个类只负责一个功能领域中的相应职责。</p></li><li><p>开闭原则要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</p></li><li><p>里氏代换原则可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</p></li><li><p>依赖倒转原则要求抽象不应该依赖于细节，细节应该依赖于抽象;要针对接口编程，不要针对实现编程。</p></li><li><p>接口隔离原则要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</p></li><li><p>合成复用原则要求复用时尽量使用对象组合，而不使用继承。</p></li><li><p>迪米特法则要求一个软件实体应当尽可能少的与其他实体发生相互作用。</p></li></ol><p>目标：开闭原则</p><p>指导：最小知识原则</p><p>基础：单一职责原则、可变性封装原则</p><p>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</p>]]></content>
    
    
    <categories>
      
      <category>软件系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程_4_内核驱动</title>
    <link href="/2024/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E7%AB%A0%20%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"/>
    <url>/2024/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E7%AB%A0%20%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第4章-内核驱动">第4章 内核驱动</h1><h2 id="什么是内核">0. 什么是内核？</h2><p>操作系统是一系列程序的集合，其中最重要的部分构成了内核。</p><p>单内核/微内核</p><ul><li>单内核是一个很大的进程，内部可以分为若干模块，运行时是一个独立的二进制文件，模块间通讯通过直接调用函数实现</li><li>微内核中大部分内核作为独立的进程在特权下运行，通过消息传递进行通讯</li></ul><p>Linux内核的能力</p><ul><li>内存管理，文件系统，进程管理，多线程支持，抢占式，多处理支持</li></ul><p>Linux内核区别于其他UNIX商业内核的优点</p><ul><li>单内核，模块支持</li><li>免费/开源</li><li>支持多种CPU，硬件支持能力非常强大</li><li>Linux开发者都是非常出色的程序员</li><li>通过学习Linux内核的源码可以了解现代操作系统的实现原理</li></ul><h3 id="配置内核">配置内核</h3><p>下载源码、解压、make clean、<strong>make menuconfig</strong></p><figure><img src="/image/Linux系统编程/menu.png" alt="menu" /><figcaption aria-hidden="true">menu</figcaption></figure><p>编译内核：</p><ul><li>make</li><li>make zImage、make bzImage：生成压缩内核镜像</li><li>make modules：编译模块</li></ul><p>make install：将编译好的内核copy到/boot</p><h2 id="驱动">1. 驱动</h2><p>许多常见驱动的源代码集成在内核源码里，也有第三方开发的驱动，可以单独编译成模块.ko。编译需要内核头文件的支持。</p><p>驱动运行在内核态。</p><h3 id="加载模块">加载模块</h3><p>底层命令：</p><p>insmod：<code>insmod [options] module_file</code></p><ul><li><code>-f</code>: 强制加载模块，即使模块已被其他进程使用。</li><li><code>-o</code>: 指定模块的参数。</li><li><code>-v</code>: 显示详细信息。</li></ul><p>rmmod：<code>rmmod [options] module_name</code></p><ul><li><code>-f</code>: 强制卸载模块，即使模块已被其他进程使用。</li><li><code>-s</code>: 模块卸载后，不更新/proc/modules文件。</li><li><code>-w</code>: 在卸载模块之前，等待其关闭所有文件描述符。</li></ul><p>高层命令：</p><p>modprobe：<code>modprobe [options] module_name</code></p><ul><li><code>-a</code>: 自动加载所有依赖的模块。</li><li><code>-c</code>: 从 /etc/modprobe.conf 中读取配置。</li><li><code>-d</code>: 检测模块依赖，但不加载它们。</li><li><code>-e</code>: 禁止使用某些内核特性（如 SMP）。</li><li><code>-k</code>: 保留内核符号表。</li><li><code>-l</code>: 列出可以加载的模块，而不实际加载它们。</li><li><code>-n</code>: 禁止自动插入已指定名字的模块。</li><li><code>-p</code>: 使用预设的模块参数。</li><li><code>-r</code>: 删除模块及其依赖的模块。</li><li><code>-s</code>: 使模块静默加载，不输出信息。</li><li><code>-v</code>: 输出更多的信息。</li></ul><p>模块依赖</p><p>自动按需加载/卸载</p><p>moddep：列出指定内核模块所依赖的其他模块</p><p>lsmod：列出当前内核加载的所有模块及其各种信息</p><p>modinfo：显示关于内核模块的详细信息</p><h3 id="模块编写">模块编写</h3><p>不能使用c库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/moduleparam.h&gt;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> test;<br><span class="hljs-built_in">module_param</span>(test, <span class="hljs-type">int</span>, <span class="hljs-number">0644</span>);<span class="hljs-comment">//module_param(变量名称，类型, 访问许可掩码)</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">hello_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(KERN_INFO “Hello world test=%d \n” , test);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">hello_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;Goodbye world\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-built_in">MODULE_DESCRIPTION</span>(<span class="hljs-string">&quot;Test&quot;</span>);<br><span class="hljs-built_in">MODULE_AUTHOR</span>(<span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-built_in">module_init</span>(hello_init);<br><span class="hljs-built_in">module_exit</span>(hello_exit);<br></code></pre></td></tr></table></figure><h4 id="导出符号">导出符号</h4><p>如果一个模块需要向其他模块导出符号（方法或全局变量），需要使用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">EXPORT_SYMBOL(<span class="hljs-params">name</span>)</span>;<br><span class="hljs-constructor">EXPORT_SYMBOL_GPL(<span class="hljs-params">name</span>)</span>;<br></code></pre></td></tr></table></figure><p>符号必须在模块文件的全局部分导出。</p><p>/proc/kallsyms 可以显示所有导出的符号。</p><h3 id="字符设备">字符设备</h3><h4 id="设备号">设备号</h4><p>一个字符设备或者块设备都有一个主设备号和次设备号。</p><ul><li>主设备号和次设备号统称为设备号。<ul><li>主设备号用来表示一个特定的驱动程序。</li><li>次设备号用来表示使用该驱动程序的各设备。</li></ul></li></ul><h4 id="cdev">cdev</h4><p>linux内核中使用cdev结构体来描述字符设备。该结构体是所有字符设备的抽象，其包含了大量字符设备所共有的特性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> cdev *my_cdev = cdev<span class="hljs-constructor">_alloc()</span>;<br>my_cdev-&gt;ops = &amp;my_fops;<br>void cdev<span class="hljs-constructor">_init(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">cdev</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file_operations</span> <span class="hljs-operator">*</span><span class="hljs-params">fops</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="初始化加载过程">初始化加载过程</h4><ol type="1"><li>申请设备号</li><li>定义文件操作结构体 file_operations</li><li>创建并初始化定义结构体 cdev</li><li>将cdev注册到系统，并和对应的设备号绑定</li><li>在/dev文件系统中用mknod创建设备文件，并将该文件绑定到设备号上</li></ol><p>申请释放设备号：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">first</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>;<br><span class="hljs-built_in">int</span> alloc<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">firstminor</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>;<br>void unregister<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">first</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span>;<br></code></pre></td></tr></table></figure><p>设备注册与释放</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> cdev<span class="hljs-constructor">_add(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">dev_t</span> <span class="hljs-params">num</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span>;<br>void cdev<span class="hljs-constructor">_del(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux系统编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程_3_编程</title>
    <link href="/2024/05/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0%20Linux%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0%20Linux%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第3章-linux编程">第3章 Linux编程</h1><h2 id="编程前的准备">0. 编程前的准备</h2><h3 id="编译命令">0.1 编译命令</h3><p>gcc -c（编译）</p><p>gcc（链接 或者 编译 + 链接）</p><p>g++（C++对应的命令，其实就是换了前端）</p><p>gcc [options] [filename]</p><p>基础可选项:</p><ul><li>-E: 只对源程序进行预处理(调用cpp预处理器)</li><li>-S: 只对源程序进行预处理、编译</li><li>-c: 执行预处理、编译、汇编而不链接</li><li>-o output_file: 指定输出文件名</li><li>-g: 产生调试工具必需的符号信息</li><li>-O/On: 在程序编译、链接过程中进行优化处理</li><li>-Wall: 显示所有的警告信息</li><li>-Idir: 指定额外的头文件搜索路径</li><li>-Ldir: 指定额外的库文件搜索路径</li><li>-lname: 链接时搜索指定的库文件</li><li>-DMACRO[=DEFN]: 定义MACRO宏</li></ul><h3 id="make">0.2 make</h3><p>make [-f Makefile] [option] [target]</p><p>makefile描述模块间的依赖关系，make命令根据makefile对程序进行管理和维护；make判断被维护文件的时序关系。</p><h4 id="make执行顺序">make执行顺序</h4><ol type="1"><li>make会在当前目录下找名字叫“Makefile” 或“makefile” 的文件。</li><li>查找文件中的第一个目标文件（target），举例中的hello</li><li>如果hello文件不存在，或是hello所依赖的文件修改时间要比hello新，就会执行后面所定义的命令来生成hello文件。</li><li>如果hello所依赖的.o文件不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（类似一个堆栈的过程）</li><li>make根据.o文件的规则生成 .o 文件，然后再用 .o文件生成hello文件。</li></ol><h4 id="makefile规则结构">Makefile规则结构</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">target <span class="hljs-string">...</span> : prerequisites <span class="hljs-string">...</span><br><span class="hljs-keyword">command</span>```<br></code></pre></td></tr></table></figure><ul><li>target是一个目标文件，可以是Object File，也可以是执行文件</li><li>prerequisites是要生成target所需要的文件或是目标</li><li>command是make需要执行的命令。（可以是任意的Shell命令）</li></ul><p>例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hello : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span><br>gcc -o hello <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span><br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs<span class="hljs-selector-class">.h</span><br>cc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br><span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.c</span> defs<span class="hljs-selector-class">.h</span> command<span class="hljs-selector-class">.h</span><br>cc -c <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.c</span><br>clean :<br>rm edit <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span>.o<br></code></pre></td></tr></table></figure><p>伪目标：clean</p><p>取名不能和文件名重名，可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”。</p><ul><li><p>一般没有依赖的文件，但也可以为伪目标指定所依赖的文件。</p></li><li><p>伪目标同样可以作为“默认目标”，只要将其放在第一个。</p></li></ul><h4 id="预定义变量">预定义变量</h4><ul><li>$&lt; 第一个依赖文件的名称</li><li>$?所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚</li><li>$+所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件</li><li>$^ 所有的依赖文件，以空格分开，不包含重复的依赖文件</li><li>$* 不包括扩展名的目标文件名称</li><li>$@ 目标的完整名称</li><li>$% 如果目标是归档成员，则该变量表示目标的归档成员名称</li></ul><h4 id="多目标扩展">多目标扩展</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">targets</span> <span class="hljs-attr">...</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">target-pattern</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">prereq-patterns</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">commands</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = foo.o bar.o<br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br><span class="hljs-variable">$(objects)</span>: %.o: %.c<br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><ul><li>目标从$object中获取</li><li>“%.o”表明要所有以“.o”结尾的目标，即“foo.obar.o”，就是变量$object集合的模式</li><li>依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是依赖的目标就是“foo.c bar.c”</li></ul><h4 id="函数">函数</h4><p>调用语法：</p><ul><li><p><code>$(&lt;function&gt; &lt;arguments&gt;)</code></p></li><li><p><code>$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</code></p></li><li><p>字符串处理函数</p><ul><li><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></li><li><code>$(strip &lt;string&gt;)</code></li></ul></li><li><p>文件名操作函数</p><ul><li><code>$(dir &lt;names...&gt;)</code></li><li><code>$(basename &lt;names...&gt;)</code></li></ul></li><li><p>foreach函数：<code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></p></li><li><p>if函数：<code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code></p></li><li><p>call函数：<code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code></p></li></ul><h2 id="文件系统">1. 文件系统</h2><p>文件：可以被读写的对象。</p><ul><li>文件的属性包含访问权限、文件类型。</li></ul><p>文件系统：文件及其属性的集合。</p><h3 id="文件类型和结构">1.1 文件类型和结构</h3><p>文件类型：</p><ul><li>-：常规文件</li><li>d：目录</li><li>l：链接</li><li>c：字符设备文件</li><li>b：块设备文件</li><li>p：管道</li><li>s：套接字</li></ul><p>文件结构：字节流</p><h3 id="vfsvirtual-file-system-switch">1.2 VFS：Virtual File SystemSwitch</h3><p>用户程序系统调用的统一接口，连接Ext2、FAT等多种不同的文件系统。</p><p>虚拟、只存在于内存。</p><p>组件：</p><ul><li>超级块：文件系统的元数据，它包含了文件系统的全局信息，如块大小、inode和数据块的数量、分配策略等。</li><li>i-node：文件的元数据，如文件的大小、创建时间、最后访问时间、最后修改时间、文件权限等，但不包括文件名和文件数据本身。</li><li>文件：打开的文件，包含了读写文件的当前位置、文件的状态等。</li><li>dentry：文件系统中的一个目录入口，即一个路径名与一个i-node的映射。</li></ul><h3 id="硬链接和符号链接">1.3 硬链接和符号链接</h3><p>硬链接：</p><ul><li>不同的文件名对应同一个inode</li><li>不能跨越文件系统</li><li>对应系统调用link</li></ul><p>符号链接</p><ul><li>存储被链接文件的文件名(而不是inode)实现链接</li><li>可跨越文件系统</li><li>对应系统调用symlink</li></ul><h3 id="系统调用和库函数">1.4 系统调用和库函数</h3><p>都是C函数。</p><p>系统调用：Linux内核的对外接口；用户程序和内核之间唯一的接口。</p><p>库函数：依赖于系统调用，提供较复杂功能。</p><h4 id="基础io系统调用">基础I/O系统调用</h4><ul><li>文件描述符：非负整数<ul><li>STDIN_FILENO (0)、STDOUT_FILENO (1)、STDERR_FILENO (2)</li></ul></li><li>基础I/O函数<ul><li>open/creat、close、read、write、lseek</li><li>dup/dup2</li><li>fcntl</li><li>ioctl</li></ul></li></ul><h5 id="opencreat">open/creat</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br>(Return: a <span class="hljs-keyword">new</span> file descriptor <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>flags：文件访问模式。</p><ul><li>O_RDONLY：只读</li><li>O_WRONLY：只写</li><li>O_RDWR：读写</li><li>O_APPEND：追加</li><li>O_TRUNC：如果文件存在，截断到0字节</li><li>O_CREAT：文件不存在则创建</li><li>O_EXCL：与 <code>O_CREAT</code>标志结合使用。如果文件已存在则报错。</li></ul><p>mode：八进制数，文件权限。</p><figure><img src="/image/Linux系统编程/权限.png" alt="权限" /><figcaption aria-hidden="true">权限</figcaption></figure><p>umask：一个环境变量，决定了文件创建时的权限掩码。</p><ul><li>mode &amp; ~umask，得到最终创建的文件权限。</li></ul><h5 id="close">close</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h5 id="readwrite">read/write</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br>(返回值: 读到的字节数，若已到文件尾为<span class="hljs-number">0</span>，若出错为<span class="hljs-number">-1</span>)<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br>(返回值: 若成功为已写的字节数，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h5 id="lseek">lseek</h5><p>改变文件读写位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br>(Return: the resulting offset location <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>whence（出发点）：</p><ul><li>SEEK_SET</li><li>SEEK_CUR</li><li>SEEK_END</li></ul><h5 id="dupdup2">dup/dup2</h5><p>复制文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span></span>;<br>(Return: the <span class="hljs-keyword">new</span> file descriptor <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h5 id="fcntl">fcntl</h5><p>管理文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">long</span> arg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> flock *lock)</span></span>;<br>(返回值: 若成功则依赖于cmd，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><p>cmd：</p><ul><li>F_DUPFD：复制文件描述符</li><li>F_GETFD/F_SETFD：获取设置文件描述符控制标志</li><li>F_GETFL/F_SETFL：获取设置文件描述符状态标志</li><li>F_GETOWN/F_SETOWN：获取设置I/O可用性标志</li><li>F_GETLK/F_SETLK/F_SETLKW：获取设置文件锁</li></ul><h5 id="ioctl">ioctl</h5><p>控制设备。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> request, ...)</span></span>;<br></code></pre></td></tr></table></figure><p>重定向用到了哪些系统调用？</p><h4 id="标准io库">标准I/O库</h4><p>主要考察缓冲。</p><p>文件流</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs julia">FILE* fp;<br>// <span class="hljs-literal">stdin</span> <span class="hljs-literal">stdout</span> <span class="hljs-literal">stderr</span><br></code></pre></td></tr></table></figure><p>三种缓冲：</p><ul><li>块缓冲</li><li>线性缓冲</li><li>无缓冲</li></ul><p>setbuf、setvbuf</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setvbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> mode, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>mode：_IOFBF（满缓冲）、_IOLBF（行缓冲）、_IONBF（无缓冲）</p><p>流式I/O函数：</p><ul><li><p>open/close</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fclose</span><span class="hljs-params">(FILE *stream)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>mode：r w a r+(读写) w+(读写，无则新建，有则清空)a+(读与追加，无则新建)</p></li><li><p>read/write</p><ul><li><p>每次一个字符的I/O</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getc</span>(<span class="hljs-params">FILE *fp</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fgetc</span>(<span class="hljs-params">FILE *fp</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getchar</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span>;<br>（Result: Reads the next character <span class="hljs-keyword">from</span> a stream <span class="hljs-keyword">and</span> returns it <span class="hljs-keyword">as</span> an unsigned <span class="hljs-built_in">char</span> cast to an <span class="hljs-built_in">int</span>, <span class="hljs-keyword">or</span> EOF <span class="hljs-keyword">on</span> end of file <span class="hljs-keyword">or</span> error.）<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">ungetc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> c, FILE *stream</span>)</span>; <span class="hljs-comment">// 将字符插回流中</span><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> putc(<span class="hljs-built_in">int</span> c, <span class="hljs-keyword">FILE</span> *fp);<br><span class="hljs-built_in">int</span> fputc(<span class="hljs-built_in">int</span> c, <span class="hljs-keyword">FILE</span> *fp);<br><span class="hljs-built_in">int</span> putchar(<span class="hljs-built_in">int</span> c);<br>(<span class="hljs-keyword">Return</span>: the <span class="hljs-keyword">character</span> <span class="hljs-keyword">if</span> success; -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure></li><li><p>每次一行的I/O</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span>; <span class="hljs-comment">//not recommended.</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>直接I/O(二进制I/O)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span></span>;<br>(Return: the number of a items successfully read <span class="hljs-keyword">or</span> written.)<br></code></pre></td></tr></table></figure></li><li><p>格式化I/O</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">scanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sscanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>reposition</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">ftell</span><span class="hljs-params">(FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rewind</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fgetpos</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">fpos_t</span> *pos)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fsetpos</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">fpos_t</span> *pos)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>flush</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fflush</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>流与文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fileno</span><span class="hljs-params">(FILE *fp)</span></span>;<br><span class="hljs-function">FILE *<span class="hljs-title">fdopen</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>临时文件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">char *<span class="hljs-built_in">tmpnam</span>(char *s);<br>(返回值: 指向唯一路径名的指针)<br>FILE *<span class="hljs-built_in">tmpfile</span>(void);<br>(返回值: 若成功为文件指针，若出错为NULL)<br></code></pre></td></tr></table></figure></li></ul><h4 id="高级系统调用">高级系统调用</h4><p>stat、fstat：返回文件状态信息，存储在buf中</p><p>lstat：获取符号链接本身的状态信息，存储在buf中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> filedes, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> &#123;<br><span class="hljs-type">mode_t</span> st_mode; <span class="hljs-comment">/*file type &amp; mode*/</span><br><span class="hljs-type">ino_t</span> st_ino; <span class="hljs-comment">/*inode number (serial number)*/</span><br><span class="hljs-type">dev_t</span> st_rdev; <span class="hljs-comment">/*device number (file system)*/</span><br><span class="hljs-type">nlink_t</span> st_nlink; <span class="hljs-comment">/*link count*/</span><br><span class="hljs-type">uid_t</span> st_uid; <span class="hljs-comment">/*user ID of owner*/</span><br><span class="hljs-type">gid_t</span> st_gid; <span class="hljs-comment">/*group ID of owner*/</span><br><span class="hljs-type">off_t</span> st_size; <span class="hljs-comment">/*size of file, in bytes*/</span><br><span class="hljs-type">time_t</span> st_atime; <span class="hljs-comment">/*time of last access*/</span><br><span class="hljs-type">time_t</span> st_mtime; <span class="hljs-comment">/*time of last modification*/</span><br><span class="hljs-type">time_t</span> st_ctime; <span class="hljs-comment">/*time of last file status change*/</span><br><span class="hljs-type">long</span> st_blksize; <span class="hljs-comment">/*Optimal block size for I/O*/</span><br><span class="hljs-type">long</span> st_blocks; <span class="hljs-comment">/*number 512-byte blocks allocated*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>测试文件类型：sys/stat.h</p><ul><li>S_ISREG()</li><li>S_ISDIR()</li><li>S_ISCHAR()</li><li>S_ISBLK()</li><li>S_ISFIFO()</li><li>S_ISLNK()</li><li>S_ISSOCK()</li></ul><p>文件权限</p><ul><li><p>rwx</p></li><li><p>SUID：需要有效uid</p></li><li><p>SGID：需要有效gid</p></li><li><p>Sticky bit：只有owner</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchmod</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">mode_t</span> mode)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchown</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lchown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">mode_t</span> <span class="hljs-title">umask</span><span class="hljs-params">(<span class="hljs-type">mode_t</span> mask)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">symlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">readlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> bufsiz)</span></span>;<br>(Return: the count of characters placed in the buffer <span class="hljs-keyword">if</span> success;<span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>目录</p><ul><li>mkdir/rmdir</li><li>chdir/fchdir, getcwd</li><li>读取目录：DIR数据结构<ul><li>opendir/closedir</li><li>readdir</li><li>telldir</li><li>seekdir</li></ul></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rmdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchdir</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dir)</span></span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *<span class="hljs-built_in">readdir</span>(DIR *dir);<br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">telldir</span><span class="hljs-params">(DIR *dir)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seekdir</span><span class="hljs-params">(DIR *dir, <span class="hljs-type">off_t</span> offset)</span></span>;<br></code></pre></td></tr></table></figure><p>文件锁 important</p><ul><li><p>记录锁</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fcntl</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> fd, <span class="hljs-built_in">int</span> cmd, <span class="hljs-keyword">struct</span> flock *<span class="hljs-keyword">lock</span></span>)</span>;<br>(返回值: 若成功则依赖于cmd，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure></li><li><p>劝告锁</p><ul><li>检查，加锁有应用程序自己控制</li></ul></li><li><p>强制锁</p><ul><li>检查，加锁由内核控制</li><li>影响[open() read() write()]等</li></ul></li><li><p>共享锁</p></li><li><p>排他锁</p></li><li><p>共享模式强制锁</p></li><li><p>租借锁</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">flock</span>&#123;<br>...<br><span class="hljs-type">short</span> l_type; <span class="hljs-comment">/* Type of lock: F_RDLCK, F_WRLCK, F_UNLCK */</span><br><span class="hljs-type">short</span> l_whence; <span class="hljs-comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR,</span><br><span class="hljs-comment">SEEK_END */</span><br><span class="hljs-type">off_t</span> l_start; <span class="hljs-comment">/* Starting offset for lock */</span><br><span class="hljs-type">off_t</span> l_len; <span class="hljs-comment">/* Number of bytes to lock */</span><br><span class="hljs-type">pid_t</span> l_pid; <span class="hljs-comment">/* PID of process blocking our lock (F_GETLK only) */</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>cmd</p><ul><li>F_GETLK：获得文件的封锁信息</li><li>F_SETLK：对文件的某个区域封锁或解除封锁</li><li>F_SETLKW：功能同F_SETLK，wait方式。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/file.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lockf</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">off_t</span> len)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="多核编程">2. 多核编程</h2><h3 id="exec">exec</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>execl</code>、<code>execlp</code>和<code>execle</code>：可变参数为逐个列举。<code>execl</code>和<code>execle</code>带有环境变量，而<code>execlp</code>不带环境变量。实际上会调用对应的v系列函数。</p></li><li><p><code>execv</code>、<code>execvp</code>和<code>execve</code>：可变参数为NULL结尾的指针数组。<code>execv</code>和<code>execvp</code>不带环境变量，而<code>execve</code>可以传递环境变量。前两者最终会调用execve函数。</p></li></ul><h3 id="fork">fork</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)<br>&#123;子进程执行的代码段；&#125;<br><span class="hljs-keyword">else</span><br>&#123;父进程执行的代码段；&#125;<br></code></pre></td></tr></table></figure><h3 id="wait-waitpid">wait &amp; waitpid</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *status)</span></span>;<br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *status, <span class="hljs-type">int</span> options)</span></span>;<br></code></pre></td></tr></table></figure><p>wait：调用wait函数的进程会被挂起，等待任意一个子进程结束，如果该子进程结束了，此函数会回收子进程的资源。</p><ul><li>如果成功，wait会返回被收集的子进程的进程ID；</li><li>如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。</li></ul><p>waitpid：回收指定进程号的子进程，可以设置是否阻塞。</p><ul><li><p>pid=0，等待任意子进程。</p></li><li><p>pid=-1，回收所有子进程。</p></li><li><p>pid&lt;-1，其绝对值为某个进程组的组id，回收该进程组的所有进程。</p></li><li><p>status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。</p></li><li><p>options：WNOHANG，非阻塞。</p></li></ul><ol type="1"><li><p>当正常返回的时候，waitpid返回收集到的子进程的进程ID；</p></li><li><p>如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0；　　</p></li><li><p>如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在；</p><p>当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD。</p></li></ol><h3 id="signal">Signal</h3><p>信号处理</p><ul><li><p>忽略信号</p></li><li><p>不能忽略的信号： SIGKILL, SIGSTOP、一些硬件异常信号</p></li><li><p>执行系统默认动作</p></li><li><p>捕捉信号</p></li></ul><p>signal函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span></span>;<br>(Returned Value: the previous handler <span class="hljs-keyword">if</span> success, SIG_ERR <span class="hljs-keyword">if</span> error)<br></code></pre></td></tr></table></figure><p>handler为用户定义的函数。</p><h4 id="kill和raise">kill和raise</h4><p>kill向进程发送信号，raise向当前进程发送信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span></span>;<br>(Returned Value: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success, <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>;<br>(Returned Value: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success, <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h4 id="alarm和pause">alarm和pause</h4><p>alarm：一定时间后发送SIGALRM信号。</p><p>pause：挂起等待信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pause</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>组合两者可以让进程等待一段时间后执行。</p><h4 id="可靠信号机制">可靠信号机制</h4><h3 id="可重入函数">可重入函数</h3><p>可以被中断的函数。</p><p>不可重入函数：</p><ul><li>系统资源</li><li>全局变量</li><li>使用静态数据结构</li><li>malloc、free</li><li>标准IO函数</li></ul><h3 id="posix-thread">POSIX Thread</h3><p>编译：gcc thread.c –o thread –lpthread</p><h4 id="创建和终止">创建和终止</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_t</span> *thread,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_attr_t</span> *attr,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> *arg)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="等待和分离">等待和分离</h4><p>Joinable Thread：可连接线程</p><ul><li>可以被其他线程等待（join）的线程。</li></ul><p>Detached Thread：分离线程</p><ul><li>启动后独立运行的线程。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;pthread.h&gt;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_join(<span class="hljs-params">pthread_t</span> <span class="hljs-params">th</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">thread_return</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_detach(<span class="hljs-params">pthread_t</span> <span class="hljs-params">th</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="线程同步">线程同步</h4><h5 id="信号量">信号量</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_init(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-params">pshared</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">value</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_wait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_post(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_destroy(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_trywait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_getvalue(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">sval</span>)</span>;<br></code></pre></td></tr></table></figure><p>生产者-消费者问题：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/wait.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;fcntl.h&gt;</span><br><span class="hljs-comment">#include &lt;semaphore.h&gt;</span><br><br><span class="hljs-comment">#define BUFFER_SIZE 10</span><br><span class="hljs-comment">#define PRODUCER_COUNT 3</span><br><span class="hljs-comment">#define CONSUMER_COUNT 2</span><br><br>sem_t empty, full, mutex;<br>int buffer[BUFFER_SIZE];<br>int <span class="hljs-keyword">in</span> = <span class="hljs-number">0</span>;<br>int out = <span class="hljs-number">0</span>;<br><br>void produce(int index) &#123;<br>    sem_wait(&amp;empty);<br>    sem_wait(&amp;mutex);<br><br>    printf(<span class="hljs-string">&quot;生产者%d生产了一个产品\n&quot;</span>, index);<br>    buffer[<span class="hljs-keyword">in</span>] = index;<br>    <span class="hljs-keyword">in</span> = (<span class="hljs-keyword">in</span> + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br><br>    sem_post(&amp;mutex);<br>    sem_post(&amp;full);<br>&#125;<br><br>void consume(int index) &#123;<br>    sem_wait(&amp;full);<br>    sem_wait(&amp;mutex);<br><br>    printf(<span class="hljs-string">&quot;消费者%d消费了一个产品\n&quot;</span>, index);<br>    buffer[out] = -<span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 或者可以用某种方式标记为已消费<br>    out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br><br>    sem_post(&amp;mutex);<br>    sem_post(&amp;empty);<br>&#125;<br><br>int main() &#123;<br>    <span class="hljs-regexp">//</span> 初始化信号量<br>    <span class="hljs-keyword">if</span> (sem_init(&amp;empty, <span class="hljs-number">1</span>, BUFFER_SIZE) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sem_init(&amp;full, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sem_init(&amp;mutex, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    pid_t pid;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; PRODUCER_COUNT; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 子进程，生产者<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                produce(i);<br>                sleep(rand() % <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 随机睡眠以模拟不同生产者生产速度<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; CONSUMER_COUNT; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 子进程，消费者<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                consume(i);<br>                sleep(rand() % <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 随机睡眠以模拟不同消费者消费速度<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 等待所有生产者和消费者结束<br>    <span class="hljs-keyword">while</span> (wait(NULL) &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-regexp">//</span> 销毁信号量<br>    sem_destroy(&amp;empty);<br>    sem_destroy(&amp;full);<br>    sem_destroy(&amp;mutex);<br><br>    <span class="hljs-keyword">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="互斥量">互斥量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex, <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *mutexattr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><br><span class="hljs-type">int</span> buffer[BUFFER_SIZE];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> out = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 互斥量初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex, empty, full;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        <span class="hljs-keyword">while</span> (in == BUFFER_SIZE) &#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>); <span class="hljs-comment">// 生产者等待</span><br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        &#125;<br><br>        <span class="hljs-comment">// 生产产品</span><br>        buffer[in] = *(<span class="hljs-type">int</span>*)arg;<br>        in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产了产品 %d\n&quot;</span>, *(<span class="hljs-type">int</span>*)arg);<br><br>        <span class="hljs-comment">// 通知消费者有新产品</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        full++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有产品</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        <span class="hljs-keyword">while</span> (out == in) &#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>); <span class="hljs-comment">// 消费者等待</span><br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        &#125;<br><br>        <span class="hljs-comment">// 消费产品</span><br>        <span class="hljs-type">int</span> product = buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费了产品 %d\n&quot;</span>, product);<br><br>        <span class="hljs-comment">// 通知生产者有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        empty++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; mutex init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;empty, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; empty init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;full, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; full init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_t</span> pid, cid;<br>    <span class="hljs-type">int</span> producer_arg = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> consumer_arg = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建生产者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, producer, &amp;producer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建消费者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;cid, <span class="hljs-literal">NULL</span>, consumer, &amp;consumer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(cid, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 销毁互斥量</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;empty);<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;full);<br></code></pre></td></tr></table></figure><h5 id="条件变量">条件变量</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_init(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>, <span class="hljs-params">pthread_condattr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond_attr</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_destory(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_wait(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>, <span class="hljs-params">pthread_mutex_t</span> <span class="hljs-params">mutex</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_signal(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-params">cond</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_broadcast(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-params">cond</span>)</span>;<br></code></pre></td></tr></table></figure><p>条件变量使用：与互斥量结合</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><br><span class="hljs-type">int</span> buffer[BUFFER_SIZE];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> out = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 互斥量初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-comment">// 条件变量初始化</span><br><span class="hljs-type">pthread_cond_t</span> empty, full;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">while</span> (in == BUFFER_SIZE) &#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;empty, &amp;mutex);<br>        &#125;<br><br>        <span class="hljs-comment">// 生产产品</span><br>        buffer[in] = *(<span class="hljs-type">int</span>*)arg;<br>        in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产了产品 %d\n&quot;</span>, *(<span class="hljs-type">int</span>*)arg);<br><br>        <span class="hljs-comment">// 通知消费者有新产品</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;full);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有产品</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">while</span> (out == in) &#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;full, &amp;mutex);<br>        &#125;<br><br>        <span class="hljs-comment">// 消费产品</span><br>        <span class="hljs-type">int</span> product = buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费了产品 %d\n&quot;</span>, product);<br><br>        <span class="hljs-comment">// 通知生产者有空余位置</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;empty);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; mutex init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化条件变量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_cond_init</span>(&amp;empty, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; empty init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_cond_init</span>(&amp;full, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; full init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_t</span> pid, cid;<br>    <span class="hljs-type">int</span> producer_arg = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> consumer_arg = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建生产者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, producer, &amp;producer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建消费者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;cid, <span class="hljs-literal">NULL</span>, consumer, &amp;consumer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(cid, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 销毁互斥量</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;empty);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;full);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程取消">线程取消</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cancel(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcancelstate(<span class="hljs-params">int</span> <span class="hljs-params">state</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldstate</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcanceltype(<span class="hljs-params">int</span> <span class="hljs-params">type</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldtype</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="线程局部存储-tls">线程局部存储 TLS</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_key_create(<span class="hljs-params">pthread_key_t</span> <span class="hljs-operator">*</span><span class="hljs-params">key</span>, <span class="hljs-params">void</span> (<span class="hljs-operator">*</span><span class="hljs-params">destructor</span>)</span>(void*));<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_key_delete(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>)</span>;<br>void *pthread<span class="hljs-constructor">_getspecific(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setspecific(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>, <span class="hljs-params">const</span> <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">value</span>)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux系统编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程_2_Shell</title>
    <link href="/2024/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E7%AB%A0%20Shell%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E7%AB%A0%20Shell%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第2章-shell编程">第2章 Shell编程</h1><p>Shell：指令解释器和编程环境。</p><p>用户和操作系统之间的接口，作为核外程序存在。</p><p>Shell的双重角色：</p><ul><li>命令解释程序<ul><li>Linux的开机启动过程；进程树</li><li>Shell的工作步骤</li><li>打印提示符；得到命令行；解析命令；查找文件；准备参数；执行命令</li></ul></li><li>独立的程序设计语言解释器</li></ul><p>Shell列举：ash、bsh、bash、sh、csh、zsh</p><h2 id="脚本文件">脚本文件</h2><p>注释：#</p><p>退出码：</p><ul><li>0：正常返回</li><li>1~128：错误码</li><li>129+：信号量</li></ul><h3 id="执行脚本文件">执行脚本文件</h3><ol type="1"><li><p>$ sh script_file</p></li><li><p>chmod +x script_file</p><p>./script_file</p></li><li><p>source script_file或 . script_file</p></li></ol><h3 id="用户环境">用户环境</h3><ol type="1"><li>.bash_profile，.bash_logout，.bashrc<ul><li>.bash_profile：用户登录时被读取，其中命令被bash执行</li><li>.bashrc：启动一个新的shell时被读取并执行</li><li>.bash_logout：登录退出时读取执行</li></ul></li><li>Alias：alias/unalias</li><li>环境变量<ul><li>export/env/set</li></ul></li></ol><h3 id="变量">变量</h3><ul><li>用户变量</li><li>环境变量</li><li>参数变量和内部变量</li></ul><h4 id="用户变量">用户变量</h4><p>用户在shell脚本里定义的变量。</p><ul><li><p>变量的赋值与使用：var=value echo $var</p></li><li><p>read命令：read var（读取用户输入并赋值给var）</p><ul><li>-p：在提示符后添加文本</li><li>-s：不显示用户输入</li><li>-r：用户输入不能修改</li><li>-n[字符数]：指定读取字符数，例如-n1</li></ul></li><li><p>引号</p><ul><li>单引号内的所有字符保持本身字符的意思，不被bash解释</li><li>除了$、``（不是单引号）、，双引号内的所有字符将保持字符本身含义，不被bash解释</li></ul></li></ul><h4 id="环境变量">环境变量</h4><p>Shell环境提供的变量，通常使用大写字母做名称。</p><table><thead><tr class="header"><th>环境变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$HOME</td><td>当前用户登录目录</td></tr><tr class="even"><td>$PATH</td><td>以冒号分隔的用来搜索命令的目录清单</td></tr><tr class="odd"><td><span class="math inline">\(PS1 |命令行提示符，通常是”\)</span>”字符</td><td></td></tr><tr class="even"><td>$PS2</td><td>辅助提示符，用来提示后续输入，通常是”&gt;”字符</td></tr><tr class="odd"><td>$IFS</td><td>输入区分隔符。当shell读取输入数据时会把一组字符看成是单词之间的分隔符，通常是空格、制表符、换行符等。</td></tr></tbody></table><h4 id="参数变量和内部变量">参数变量和内部变量</h4><p>调用脚本程序时如果带有参数，对应的参数和额外产生的一些变量。</p><table><thead><tr class="header"><th>环境变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$#</td><td>传递到脚本程序的参数个数</td></tr><tr class="even"><td>$0</td><td>脚本程序的名字</td></tr><tr class="odd"><td>$1</td><td>脚本程序的参数</td></tr><tr class="even"><td>$*</td><td>一个全体参数组成的清单，它是一个独立的变量，各个参数之间用环境变量IFS中的第一个字符分隔开</td></tr><tr class="odd"><td><span class="math inline">\(@ |“\)</span>*”的一种变体，它不使用IFS环境变量。</td><td></td></tr></tbody></table><h3 id="条件测试">条件测试</h3><p>test expression 或 [ expression ]</p><ul><li>字符串比较</li><li>算术比较</li><li>文件相关测试</li><li>逻辑操作</li></ul><table><thead><tr class="header"><th>字符串比较</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>str1 = str2</td><td>相同则为真</td></tr><tr class="even"><td>str1!=str2</td><td>不同则为真</td></tr><tr class="odd"><td>-z str</td><td>字符串为空则结果为真</td></tr><tr class="even"><td>-n str</td><td>字符串不为空则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>算术比较</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>expr1 –eq expr2</td><td>两个表达式相等则结果为真</td></tr><tr class="even"><td>expr1 –ne expr2</td><td>两个表达式不等则结果为真</td></tr><tr class="odd"><td>expr1 –gt expr2</td><td>expr1 大于 expr2 则结果为真</td></tr><tr class="even"><td>expr1 –ge expr2</td><td>expr1 大于或等于 expr2 则结果为真</td></tr><tr class="odd"><td>expr1 –lt expr2</td><td>expr1 小于 expr2 则结果为真</td></tr><tr class="even"><td>expr1 –le expr2</td><td>expr1 小于或等于 expr2 则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>文件条件测试</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>-e file</td><td>文件存在则结果为真</td></tr><tr class="even"><td>-d file</td><td>文件是一个子目录则结果为真</td></tr><tr class="odd"><td>-f file</td><td>文件是一个普通文件则结果为真</td></tr><tr class="even"><td>-s file</td><td>文件的长度不为零则结果为真</td></tr><tr class="odd"><td>-r file</td><td>文件可读则结果为真</td></tr><tr class="even"><td>-w file</td><td>文件可写则结果为真</td></tr><tr class="odd"><td>-x file</td><td>文件可执行则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>逻辑操作</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>! expr</td><td>逻辑表达式求反</td></tr><tr class="even"><td>expr1 –a expr2</td><td>两个逻辑表达式“And”（“与”）</td></tr><tr class="odd"><td>expr1 –o expr2</td><td>两个逻辑表达式“Or”（“或”）</td></tr></tbody></table><h3 id="条件语句">条件语句</h3><h4 id="if语句">if语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ expression ]<br><span class="hljs-keyword">then</span><br>statements<br><span class="hljs-keyword">elif</span> [ expression ]<br><span class="hljs-keyword">then</span><br>statements<br><span class="hljs-keyword">elif</span> …<br><span class="hljs-keyword">else</span><br>statements<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h4 id="case语句">case语句</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">case</span> str <span class="hljs-built_in">in</span><br>str1 | <span class="hljs-type">str2</span>) statements;;<br>str3 | <span class="hljs-type">str4</span>) statements;;<br>*) statements;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="重复语句">重复语句</h3><h4 id="for语句">for语句</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">in</span> list<br><span class="hljs-keyword">do</span><br>statements<br>done<br></code></pre></td></tr></table></figure><h4 id="while语句">while语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span><br>statements<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="until语句">until语句</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">until</span> condition<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">statements</span><br>done<br></code></pre></td></tr></table></figure><h4 id="select语句">select语句</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">select</span> item in itemlist<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">statements</span><br>done<br></code></pre></td></tr></table></figure><p>生成菜单列表</p><h3 id="命令表">命令表</h3><p>命令的组合。</p><ul><li><p>分号串联：command1 ; command2 ; …</p></li><li><p>条件组合，AND和OR：</p><p><code>statement1 &amp;&amp; statement2 &amp;&amp; …</code>和<code>statement1 || statement2 || …</code></p></li></ul><h3 id="语句块">语句块</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&#123;<br>stateme<span class="hljs-symbol">nt1</span><br>stateme<span class="hljs-symbol">nt2</span><br>…<br>&#125;<br>&#123; stateme<span class="hljs-symbol">nt1</span>; stateme<span class="hljs-symbol">nt2</span> ; … ; &#125;<br></code></pre></td></tr></table></figure><h3 id="函数">函数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">func</span><span class="hljs-params">()</span></span><br>&#123;<br>statements<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量：local关键字</p><p>函数调用：func para1 para2 ...</p><p>返回值：return</p><h3 id="杂项命令">杂项命令</h3><ul><li>break：从for/while/until循环退出</li><li>continue：跳到下一个循环继续执行</li><li>exit n：以退出码”n”退出脚本运行</li><li>return：函数返回</li><li>export：将变量导出到shell，使之成为shell的环境变量</li><li>set：为shell设置参数变量</li><li>unset：从环境中删除变量或函数</li><li>trap：指定在收到操作系统信号后执行的动作</li><li>“:”(冒号命令)：空命令</li><li>“.”(句点命令)或source在当前shell中执行命令</li></ul><h3 id="捕获命令输出">捕获命令输出</h3><p><code>$(command)</code>和<code>`(command)`</code></p><h3 id="算术扩展">算术扩展</h3><p><code>$((...))</code></p><h3 id="参数扩展">参数扩展</h3><p>批处理 1_tmp, 2_tmp, …</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>i=1<br><span class="hljs-keyword">while</span> [ “<span class="hljs-variable">$i</span>” –ne 10 ]; <span class="hljs-keyword">do</span><br><span class="hljs-built_in">touch</span> “<span class="hljs-variable">$&#123;i&#125;</span>_tmp”<br>i=$((<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure><p>更复杂形式：</p><figure><img src="/image/Linux系统编程/参数.png" alt="参数扩展" /><figcaption aria-hidden="true">参数扩展</figcaption></figure><h3 id="即时文档">即时文档</h3><p>在shell脚本中向一条命令传送输入数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">cat</span> &gt;&gt; file.txt &lt;&lt; !CATINPUT!<br>Hello, this is a here document.<br>!CATINPUT!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux系统编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程_1_基础</title>
    <link href="/2024/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E7%AB%A0%20Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E7%AB%A0%20Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第1章-linux系统基础">第1章 Linux系统基础</h1><h2 id="linux概念与使用">1. Linux概念与使用</h2><p>基于GNU通用公共协议的类Unix操作系统。</p><ul><li>开源、流行、支持大多数平台</li></ul><h3 id="gnulinux系统">GNU/Linux系统</h3><p>GNU软件/库+Linux内核</p><p>版本：Ubuntu、Debian、Mint、Red Hat、Fodore、SuSe</p><h3 id="boot-loader">Boot loader</h3><p>Boot loader加载并启动Linux内核。</p><p>常见的Boot loader：</p><ul><li>LILO：Linux Loader</li><li>GRUB：Grand Unified Boot Loader<ul><li>配置文件：<code>/boot/grub/grub.conf</code>（旧版）</li><li>不需要和LILO一样进行配置激活（自动识别加载系统内核和initrd文件）</li><li>使用grub-install安装在MBR中</li></ul></li></ul><p>GRUB引导过程：</p><ol type="1"><li>MBR上的引导程序，负责加载GRUB的第二阶段</li><li>完整的内核加载在/boot/grub目录下</li></ol><p>要能读懂GRUB配置文件</p><p>基本结构：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">default</span>=<span class="hljs-number">0</span>  # 默认启动第一个系统<br><span class="hljs-attribute">timeout</span>=<span class="hljs-number">5</span>  # 等待超时时间<span class="hljs-number">5</span>秒<br><span class="hljs-attribute">splashimage</span>=(hd0,<span class="hljs-number">0</span>)/grub/splash.xpm.gz  # 背景图片<br><span class="hljs-attribute">hiddenmenu</span>  # 隐藏菜单，若要显式，在启动时按下ESC<br><span class="hljs-attribute">title</span> Red Hat Enterprise Linux AS (<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5)  # 定义操作系统的说明信息<br>    <span class="hljs-attribute">root</span> (hd0,<span class="hljs-number">0</span>) <br>    <span class="hljs-attribute">kernel</span> /vmlinuz-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5 ro root＝/dev/sda2 rhgb quiet<br>    <span class="hljs-attribute">initrd</span> /initrd-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5.img<br></code></pre></td></tr></table></figure><p>GRUB2：<code>/boot/grub/grub.cfg</code></p><h3 id="虚拟终端">虚拟终端</h3><p>控制台模拟了一个或多个虚拟终端。</p><p>每个虚拟终端是独立的控制台，不同用户可以使用不同的虚拟终端。</p><p>切换方式：Ctrl+Alt+Fn / Alt+Fn</p><h2 id="linux基础命令">2. Linux基础命令</h2><p>命令行：$ 和 #（root）</p><p>$ command option(s) argument(s)</p><p>主要命令都需要掌握。</p><h3 id="基础命令">0. 基础命令</h3><ul><li>passwd：修改密码</li><li>mkpasswd：生成随机密码</li><li>date, cal：打印日期/日历</li><li>who, finger：查看系统上在线的用户信息</li><li>clear：清空屏幕</li><li>echo：打印信息</li><li>write, wall, talk：与其他用户信息通信。<ul><li><code>write username</code>：提示输入消息内容，然后将消息发送给<code>username</code>。</li><li><code>wall</code>：即write all，发送给所有用户</li><li><code>talk username</code>：连接目标用户，启动聊天会话</li></ul></li></ul><h3 id="目录命令">1. 目录命令</h3><ul><li><p>pwd：打印工作目录</p></li><li><p>cd</p></li><li><p>mkdir</p></li><li><p>rmdir</p></li><li><p>ls：列出目录中的内容</p><ul><li><p>-l：以长格式显示文件和目录的信息。</p><p>包括文件或目录的权限模式、所有者、群组、大小和最后修改日期。</p></li><li><p>-a：显示所有文件，包括以.开头的隐藏文件。</p></li><li><p>-R：递归列出所有子目录中的内容。</p></li></ul></li><li><p>mknod：创建字符设备或块设备<code>mknod [options] [name] [type] [major minor]</code></p><ul><li><code>[options]</code>：可选的标志，如 <code>-m</code>用来设置文件的权限模式。</li><li><code>[major minor]</code>：设备的节点号。主节点号和次节点号用于识别设备类型。对于字符设备，主节点号通常表示设备类，而次节点号表示特定的设备。</li></ul></li></ul><h3 id="文件命令">2. 文件命令</h3><ul><li><p>touch：创建新文件、更新文件修改时间</p></li><li><p>cp</p></li><li><p>mv：移动并重命名文件</p></li><li><p>ln：链接文件</p><ul><li>硬链接：<code>ln source_file link_name</code></li><li>符号链接：<code>ln -s /full/path/to/source source_directory/link_name</code></li></ul></li><li><p>rm</p></li><li><p>cat</p></li><li><p>chown：改变文件或目录的所有者。<code>chown [options] [user:group] [file...]</code></p><ul><li><p><code>[options]</code>：</p><p><code>-R</code> 用于递归改变所有子目录和文件的所有者；</p><p><code>-h</code>：对于符号链接，改变链接本身的所有者，而不是链接指向的文件。</p></li><li><p><code>[user:group]</code>：指定新的所有者和组。用户名可以单独指定，或者与组名一起指定。如果只指定用户名，则默认组为用户所属的默认组。</p></li><li><p><code>[file...]</code>：要改变所有者的文件或目录列表。</p></li></ul></li><li><p>chgrp：改变文件或目录的组所有权。<code>chgrp [options] [group] [file...]</code></p></li><li><p>more/less：分页查看文件内容</p><ul><li>more：逐页显示文件，空格下一页，<code>b</code>上一页，<code>q</code>退出</li><li>less：滚动显示文件，功能更多。<ul><li>按 <code>/</code> ，输入搜索词搜索文件内容，按 <code>n</code>查找下一个匹配项，按 <code>p</code> 查找上一个匹配项。</li></ul></li></ul></li></ul><h4 id="文件权限">文件权限</h4><p>三个访问等级：</p><ul><li>用户</li><li>群组</li><li>其他</li></ul><p>三个权限：</p><ul><li>读 r</li><li>写 w</li><li>执行 x</li></ul><p>ls -l会展示文件权限</p><p>默认文件权限</p><p>file：-rw-r--r--</p><p>Directory：drwxr-xr-x</p><p>第一个字符表示文件类型，后续9个字符分别为u、g、o的rwx。</p><p>文件类型：</p><ul><li>-：常规文件</li><li>d：目录</li><li>l：链接</li><li>c：字符设备文件</li><li>b：块设备文件</li><li>p：管道</li><li>s：套接字</li></ul><p>修改权限：<code>chmod who operator what filename</code></p><ul><li>who:<ul><li>u：文件所有者</li><li>g：群组</li><li>o：系统其他用户</li><li>a：all</li></ul></li><li>operator:<ul><li>+：添加权限</li><li>-：删除权限</li><li>=: 设置明确权限</li></ul></li><li>what: rwx</li></ul><p>将u、g、o各自的rwx权限看为一个二进制数，可以用数字为它们赋予权限。</p><ul><li><p>r=4,w=2,x=1</p></li><li><p>chmod 765 file：u=rwx,g=rw,o=rx</p></li></ul><h4 id="文件编辑">文件编辑</h4><p>vi、emacs、gedit</p><h3 id="进程">3. 进程</h3><p>进程是一个正在执行的程序实例。由执行程序、它的当前值、状态信息以及通过操作系统管理此进程执行情况的资源组成。</p><ul><li><p>ps：报告进程状态</p></li><li><p>pstree：展示进程树</p></li><li><p>jobs, fg, bg, ctrl-z：任务控制</p><ul><li><p>jobs：查看当前 shell环境中所有在后台运行的任务列表，会给出每个任务的唯一编号。</p></li><li><p>fg %1：将一个后台任务调至前台执行，用%指定任务编号。</p></li><li><p>bg %1：将一个在后台暂停的任务继续运行在后台。</p></li><li><p>Ctrl+Z：将当前前台执行的任务挂起到后台。</p></li></ul></li><li><p>kill：杀死进程<code>kill [PID]</code>、发送信号给进程<code>kill [signal] [PID]</code></p></li><li><p>nohup：无视挂起信号运行指令</p></li><li><p>nice, renice：调整进程优先级</p><p>nice介于-20～19，影响调度优先级，nice越低优先级越高</p><ul><li><p>nice：启动一个新进程，并为其设置一个nice值。</p></li><li><p>renice：改变正在运行的进程的nice值。</p></li></ul></li><li><p>top：展示占用CPU最高的进程列表</p></li></ul><h3 id="寻找帮助">4. 寻找帮助</h3><p>man、info、--help</p><h3 id="重定向">5. 重定向</h3><p>标准输入、标准输出、标准错误</p><ul><li>对应的文件描述符：0, 1, 2</li></ul><p><code>&lt;、&gt;</code>：覆盖文件</p><p><code>&gt;&gt;</code>：追加到末尾</p><p><code>2&gt;</code>：将标准错误输出到文件，而标准输出仍然会输出到命令行</p><p><code>&gt;&amp;</code>：将标准输出和错误都输出到文件</p><p><code>2&gt;&amp;1</code>：将标准错误输出重定向到标准输出，与上个选项的区别是会打印到命令行</p><h3 id="管道">6. 管道</h3><p>一个进程的输出作为另一个进程的输入。</p><p><code>命令1|命令2</code>：命令1的输出会直接传递给命令2作为输入。</p><h3 id="高级命令">7. 高级命令</h3><ul><li><p>find：查找文件。<code>find [options] [path...] [-exec [command] &#123;&#125; +]</code></p><ul><li><code>[options]</code>：find命令的行为选项，如<code>-name</code>、<code>-type</code>、<code>-mtime</code> 等。<ul><li><code>-print</code>：打印找到的文件名。</li><li><code>-delete</code>：删除找到的文件。</li></ul></li><li><code>[path...]</code>：要搜索的目录路径。如果省略，默认在当前目录搜索。</li></ul></li><li><p>sed：通过模式匹配对文本进行处理。</p></li><li><p>grep：在文本文件中搜索指定的文本字符串。<code>grep [options] [pattern] [file...]</code></p><ul><li>选项：<ul><li><code>-i</code>：忽略大小写。</li><li><code>-v</code>：反转匹配，只显示不匹配的行。</li><li><code>-c</code>：计数，只输出匹配行的数量。</li><li><code>-n</code>：显示匹配行及其行号。</li><li><code>-l</code>：只输出包含匹配字符串的文件名。</li><li><code>-L</code>：只输出不包含匹配字符串的文件名。</li><li><code>-r</code> 或 <code>-R</code>：递归搜索目录中的所有文件。</li><li><code>-E</code>：使用扩展正则表达式。</li><li><code>-o</code>：只输出匹配到的部分，而不是整行内容。</li></ul></li></ul></li></ul><p>基本正则表达式：</p><ul><li><code>.</code>：匹配任意单个字符。<ul><li>例子：<code>grep '.$' file.txt</code> 将匹配 file.txt中以任意字符结尾的行。</li></ul></li><li><code>*</code>：匹配前一个字符出现零次或多次。<ul><li>例子：<code>grep 'o*' file.txt</code> 将匹配 file.txt中包含零个或多个 “o” 的行。</li></ul></li><li><code>^</code>：匹配行的开始。<ul><li>例子：<code>grep '^A' file.txt</code> 将匹配 file.txt 中以 “A”开头的行。</li></ul></li><li><code>$</code>：匹配行的结束。<ul><li>例子：<code>grep 'B$' file.txt</code> 将匹配 file.txt 中以 “B”结尾的行。</li></ul></li><li><code>[abc]</code>：匹配方括号内的任意一个字符。<ul><li>例子：<code>grep '[abc]' file.txt</code> 将匹配 file.txt 中包含“a”、“b” 或 “c” 的行。</li></ul></li><li><code>[^abc]</code>：匹配不在方括号内的任意一个字符。<ul><li>例子：<code>grep '[^abc]' file.txt</code> 将匹配 file.txt 中不包含“a”、“b” 或 “c” 的行。</li></ul></li><li><code>\</code>：转义字符，用于匹配特殊字符。<ul><li>例子：<code>grep '\\.' file.txt</code> 将匹配 file.txt中包含一个反斜杠后跟一个点（<code>.</code>）的行。</li></ul></li><li><code>()</code>：标记子表达式的开始和结束。<ul><li>例子：<code>grep '(abc|def)' file.txt</code> 将匹配 file.txt 中包含“abc” 或 “def” 的行。</li></ul></li><li><code>|</code>：逻辑或操作符。<ul><li>例子：<code>grep 'A|B' file.txt</code> 将匹配 file.txt 中包含 “A” 或“B” 的行。</li></ul></li><li><code>\&lt;</code>：匹配单词的开始（前面必须有一个单词边界）。<ul><li>例子：<code>grep '\&lt;word' file.txt</code> 将匹配 file.txt 中以“word” 开头的行，其中 “word” 是一个单词。</li></ul></li><li><code>\&gt;</code>：匹配单词的结束（后面必须有一个单词边界）。<ul><li>例子：<code>grep '\&gt;word' file.txt</code> 将匹配 file.txt 中以“word” 结尾的行，其中 “word” 是一个单词。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux系统编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云计算_5_云数据中心</title>
    <link href="/2024/04/05/%E4%BA%91%E8%AE%A1%E7%AE%97/5-%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2024/04/05/%E4%BA%91%E8%AE%A1%E7%AE%97/5-%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云数据中心">5-云数据中心</h1><h2 id="基本设计">1. 基本设计</h2><p>外部：不间断的电源、足够带宽的网络</p><p>内部：散热（保证设备安全）</p><h2 id="云数据中心特征">2. 云数据中心特征</h2><h3 id="特征">2.0 特征</h3><ol type="1"><li><p>高设备利用率</p><ul><li><p>通过虚拟化整合云平台系统与数据中心硬件资源，减少物理服务器数量</p></li><li><p>优化资源利用率、简化管理，降低成本、快速响应业务需求的变化等</p></li><li><p>较大的数据中心有更低的单位运营成本：网络、存储、管理</p></li></ul></li><li><p>绿色节能</p><ul><li><p>能源</p></li><li><p>功耗：服务器、空调</p></li></ul></li><li><p>自动化管理</p><ul><li><p>人力成本是大多数管理数据中心站点最大成本因素</p></li><li><p>无人值守，远程管理</p></li><li><p>门禁、通风、温度、湿度、电力均可远程调度与控制</p></li></ul></li><li><p>高可用性</p><ul><li><p>各个部分的冗余、容错、容灾设计</p></li><li><p>扩展和升级时，保持正常运行</p></li></ul></li></ol><h3 id="绿色节能技术">2.1 绿色节能技术</h3><h4 id="耗电原因">耗电原因</h4><ul><li>技术因素<ul><li>云计算中心规模不断扩大，硬件设备数量激增，导致总体耗电量大幅上升。</li><li>为了保证高可用性和稳定性，通常采用功耗相对较高的高性能处理器、内存和存储设备。</li><li>虚拟化技术的广泛应用也带来了额外的能耗。</li></ul></li><li>商业因素<ul><li>客户需求不断增长<spanclass="math inline">\(\rightarrow\)</span>数据中心建设、扩容。</li><li>激烈的市场竞争<spanclass="math inline">\(\rightarrow\)</span>不断优化更新技术。</li></ul></li></ul><h4 id="采取措施">采取措施</h4><ol type="1"><li><p>优化技术</p><ul><li>使用更高能效设备、服务器架构和更智能的资源调度策略。</li></ul></li><li><p>节约能源</p><ul><li><p>在数据中心设计和运营中充分考虑节能因素。</p><p>例如，采用更为合理的布局和散热系统设计，减少冷却能耗；</p><p>合理安排数据中心工作时间，充分利用自然冷却等方式降低能耗。</p></li></ul></li><li><p>提升硬件使用率</p><ul><li><p>例如，推广容器化技术，实现应用打包和快速部署；</p><p>采用无服务器架构，减少闲置服务器数量等。</p></li></ul></li><li><p>可再生能源</p></li><li><p>绿色云生态系统</p><ul><li>与硬件厂商、政府部门等共同合作，构建一个绿色云生态系统。通过政策引导、技术创新和市场机制等手段，推动整个行业的绿色发展。</li></ul></li></ol><h4 id="具体节能技术">具体节能技术</h4><ul><li>配电系统：高压直流配电、市电直供配电</li><li>空调系统节能：高温回风、精确制冷、自然冷空调</li><li>集装箱数据中心节能技术<ul><li>服务器设备、网络设备、空调设备、供电设备等高密度地装入固定尺寸的集装箱中</li><li>高密度、模块化、按需快速部署、移动便捷</li></ul></li><li>管理系统节能策略和算法：供电管理</li><li>新能源应用</li></ul><h3 id="自动化管理">2.2 自动化管理</h3><p>目标：使得在规模较大的情况下，实现较少人员对数据中心的高度智能管理。</p><p>工作范围：按需分配/收回资源；自动配电、冷却、消防等。</p><p>具体内容：资源的自动化调度和对业务的灵活响应。</p><ul><li>既需要单业务自治，也需要对业务和资源进行全局控制和协调。</li></ul><h4 id="特征和内容">特征和内容</h4><ol type="1"><li><p>全面可视化：多层级运行时视图，全面掌握数据中心资产、配置和各层次依赖关系的现状</p></li><li><p>自动的控制执行：全面自动化流程</p></li><li><p>多层次的无缝集成：流畅地自动执行在不同层次和组成部分之间地各种处理流程，快速的协调数据中心内外的所有变更，实现端到端的流程管理</p></li><li><p>综合与实时的报告：提供全面综合和透视依赖关系的报告提高管理水平</p></li><li><p>全生命周期支持：自动化整个“计划—实施—检查—更正”的IT流程生命周期</p></li></ol><p>实现的三个阶段：</p><ol type="1"><li><p>IT服务操作：监控和管理IT基础设施的广义集合</p><ul><li><p>目标：生成有效的全局IT支撑架构，提高IT服务质量，对活动和过程进行协调和执行</p></li><li><p>活动和过程：事故管理、事件监控和管理、问题管理</p></li></ul></li><li><p>IT服务管理：制定设施间的交互和协作处理，确保IT服务符合标准规范</p><ul><li><p>定义：根据客户需求的层次确保IT服务质量的一系列过程</p></li><li><p>主题：服务管理、服务层管理、IT资产管理、财务管理</p></li></ul></li><li><p>数据中心自动化：维护IT环境，定制、检查和执行服务层协议</p></li></ol><p>采用数据中心自动化工具必须具备如下条件</p><ul><li>管理系统</li><li>定义过程</li><li>认知非自动化过程的成本</li><li>内部流程资源</li></ul><h3 id="容灾备份">2.3 容灾备份</h3><table><thead><tr class="header"><th><strong>对比维度</strong></th><th><strong>备份</strong></th><th><strong>容灾</strong></th></tr></thead><tbody><tr class="odd"><td>使用目的</td><td>避免数据丢失，一般通过快照、备份等技术构建数据的数据备份副本，故障时可以通过数据的历史副本恢复用户数据。</td><td>避免业务中断，一般是通过复制技术（应用层复制、主机I/O层复制、存储层复制）在异地构建业务的备用主机和数据，主站点故障时备用站点可以接管业务。</td></tr><tr class="even"><td>使用场景</td><td>针对病毒入侵、人为误删除、软硬件故障等场景，可将数据恢复到任意备份点。</td><td>针对软硬件故障以及海啸、火灾、地震等重大自然灾害，运行故障切换，尽快恢复业务。源端可用区恢复正常时，可轻松利用故障恢复能力重新切换回到源端可用区。</td></tr><tr class="odd"><td>成本</td><td>通常是生产系统的1~2%。</td><td>通常是生产系统的20%~100%（根据不同的RPO/RTO要求而定），高级别的双活容灾，要求备用站点也要部署一套和主站点相同的业务系统，基础设施成本需要翻倍计算。</td></tr></tbody></table><p>容灾备份：</p><p>异地建立、维护备份存储系统，利用地理分离保证系统和数据对灾难性事件的抵御能力。</p><ul><li>容灾系统的抵抗程度：数据级容灾和应用级容灾。</li></ul><h4 id="关键技术">关键技术</h4><p>技术核心：复制数据</p><ul><li><p>镜像：将符合指定规则的报文复制到目的端口</p></li><li><p>快照：拷贝指定数据集合，用于数据备份恢复、提供额外访问通道。</p></li><li><p>基于IP的SAN的远程数据容灾备份技术：主数据中心复制到备份数据中心。</p></li><li><p>数据库复制。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云计算_4_网络</title>
    <link href="/2024/04/04/%E4%BA%91%E8%AE%A1%E7%AE%97/4-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/04/04/%E4%BA%91%E8%AE%A1%E7%AE%97/4-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算网络">4-云计算网络</h1><h2 id="基本架构">1. 基本架构</h2><p>云数据中心需要基础网络将所有设备组织在本地网络里面——基础网络架构。</p><p>传统树结构：建造方便简单，但不便于拓展与升级</p><ul><li>任意一个核心交换机故障导致上千台服务器失效</li></ul><p>架构需求：低成本、高可扩展性、低配置开销、健壮性、节能</p><h3 id="改进树结构">1.1 改进树结构</h3><h4 id="fattree">FatTree</h4><ol type="1"><li>K叉树，K个Pod(集装器)，每个Pod有K个交换机，其中K/2个为接入交换机，K/2个为汇聚交换机。</li><li>Pod中每个交换机有K个接口。<ul><li>接入交换机的K/2个接口接主机，K/2个接口接汇聚交换机；</li><li>汇聚交换机的K/2个接口接接入交换机，K/2个接核心交换机。</li></ul></li><li>有<spanclass="math inline">\((K/2)^2\)</span>个核心交换机，每个交换机K个端口接K个汇聚交换机。</li><li>一个Pod内的所有交换机相互连接：完全二分图。</li><li>一个Pod内的每个汇聚交换机与一部分核心交换机连接，但是一个Pod和每一个核心交换机都有连接。</li></ol><p>两级路由表，允许两级前缀查询：Pod间流量尽可能均匀分布于核心交换机</p><p>任意两个不同Pod主机之间存在K条路径</p><ul><li>将流量在这些路径间分散</li><li>任意给定Pod的低层和高层交换机对位于本Pod的任意子网都有终结性表项</li><li>在全负载最坏的情况下实现约87%的聚合带宽</li></ul><p>与传统层次结构相比，FatTree有如下特点：</p><ul><li>消除了树形结构上层链路对吞吐量的限制</li><li>为内部节点间通信提供多条并行链路</li><li>与现有数据中心网络使用的以太网结构和IP 配置的服务器兼容</li><li>但是布线复杂了；扩展时需要重构；受到端口数限制等。</li></ul><p>FatTree的扩展性受限于核心交换机端口数量，目前比较常用的是48端口10G核心交换机，在3层树结构中能够支持27648台主机。</p><h4 id="vl2">VL2</h4><p>若干服务器连接到机架(接入)交换机；</p><p>每台接入交换机与两台汇聚交换机连接；</p><p>每台汇聚交换机与所有核心交换机连接。</p><p>特点：</p><ul><li>扁平寻址，允许服务实例被放置到网络覆盖的任何地方</li><li>负载均衡将流量统一分配到网络路径</li><li>终端系统的地址解析拓展到巨大的服务器池</li></ul><p>核心思想：使用FatTree同样的拓扑结构建立扁平的第二层网络。</p><p>机制：</p><ul><li>IP地址仅仅作为名字使用，没有拓扑含义；将服务器的名字与其位置分开。</li><li>使用可扩展、可靠的目录系统来维持名字和位置间的映射。</li><li>当服务器发送分组时，服务器上的VL2代理开启目录系统以得到实际的目的位置，然后将分组发送到目的地。</li></ul><p>优势：VL2是目前最易用于对现有数据中心网络改造的结构；应用程序使用服务地址通信而底层网络使用位置信息地址进行转发，使得虚拟机能够在网络中任意迁移而不影响服务质量。</p><p>缺点：VL2依赖于中心化的基础设施来实现2层语义和资源整合，面临单点失效和扩展性问题。</p><h3 id="递归层次结构">1.2 递归层次结构</h3><p>每一个高层的网络拓扑，由多个低层的递归单元按照递归规律相互连接构成，同时也是更高层级网络的一个递归单元。</p><ul><li>增加服务器数量<spanclass="math inline">\(\rightarrow\)</span>提高总的递归层次<ul><li>添加服务器更加灵活，可增加的数量增大</li><li>对交换机性能要求低</li></ul></li></ul><p>递归层次结构：DCell、Ficonn、BCube、MDCube</p><h4 id="ficonn">FiConn</h4><p>服务器使用两个网卡端口：主用端口连接低层网络，备用端口连接高层网络</p><p>递归定义的结构</p><ul><li>第0层为基本构建单元，n个服务器连接一个具有n个端口的交换机</li><li>每个低层<strong>FiConn</strong>中备用端口空闲的一半服务器与其他相同层次的FiConn网络中备用端口空闲的服务器连接</li><li>k层服务器、k层端口、k层链路</li></ul><h4 id="bcube">BCube</h4><p>主要使用交换机构建层次化网络</p><p>第0层：n服务器连接1交换机</p><p>第1层：n个0层连接n个交换机</p><p>……</p><p>第k层：n个k-1层连接nk交换机</p><p>交换机n个端口，服务器k+1个端口。</p><h3 id="光交换网络">1.3 光交换网络</h3><p>使用光纤交换机调整网络拓扑。</p><h2 id="软件定义网络">2. 软件定义网络</h2><h3 id="openflow">2.1 OpenFlow</h3><p>使用集中控制器控制OpenFlow Switch的Flow Table。</p><p>Controller 会为特定的工作负载计算最佳路径，从而对 Switch的数据转发定义路径。</p><p>核心理论：控制转发分离架构、可编程性</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云计算_3_虚拟化</title>
    <link href="/2024/04/03/%E4%BA%91%E8%AE%A1%E7%AE%97/3-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/04/03/%E4%BA%91%E8%AE%A1%E7%AE%97/3-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="虚拟化技术">3-虚拟化技术</h1><p>问题：云计算涉及到哪些虚拟化技术？需要对哪些资源做虚拟化？对应的虚拟化技术和产品是什么？</p><h2 id="什么是虚拟化">0. 什么是虚拟化</h2><p>虚拟化是云计算的核心技术。</p><p>本质：通过虚拟化层逻辑化原先的物理设备，实现软硬件解耦。</p><p>核心思想：</p><ul><li><p>利用软件或固件管理程序构成虚拟化层，把物理资源映射为虚拟资源。</p></li><li><p>在虚拟资源上可以安装和部署多个虚拟机，实现多用户共享物理资源。</p></li></ul><h2 id="服务器虚拟化">1. 服务器虚拟化</h2><p>硬件级、操作系统级、程序库API、应用程序</p><p>代表产品：</p><p>裸机虚拟化（VMware vSphere）、操作系统级虚拟化（VMwareWorkstation、Docker）</p><h3 id="硬件级虚拟化">1.1 硬件级虚拟化</h3><p>使用作为虚拟化层的软件管理客户操作系统，使其独立于主机操作系统，同时运行在同硬件上。</p><ul><li>Hypervisor、Virtual Machine Monitor（VMM）</li></ul><p>要求：高效、隔离、复制</p><p>类别：裸机虚拟化、寄居虚拟化</p><h4 id="优势">优势</h4><ol type="1"><li>封装性：虚拟机快照、克隆、挂起和恢复非常便捷</li><li>多实例：降低计算机资源损耗</li><li>隔离</li><li>硬件无关性</li><li>特权功能</li></ol><h4 id="可虚拟化架构">可虚拟化架构</h4><p>使用特权级分隔应用软件和系统软件的架构。</p><p>原因：提高虚拟机控制软件直接访问硬件的效率、低特权级的虚拟机之间更易实现资源隔离。</p><h4 id="虚拟化硬件对象">虚拟化硬件对象</h4><p>CPU、内存、I/O设备</p><h5 id="cpu虚拟化">CPU虚拟化</h5><ul><li>任意时刻一个物理CPU只能运行一个虚拟CPU</li><li>每个客户操作系统可以使用一个或多个虚拟CPU</li><li>各个操作系统之间虚拟CPU运行相互隔离，互不影响</li></ul><p>调度：VMM决定哪个虚拟CPU在哪个物理CPU上运行，保证隔离、公平和性能</p><p>执行：虚拟CPU保证虚拟机的指令正确运行。</p><ul><li>实现技术：模拟执行、监控执行</li></ul><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：解释、扫描、翻译</li><li>基于硬件辅助的虚拟化：硬件针对虚拟化作出支持</li><li>修改操作系统的类虚拟化：修改客户机操作系统，配合VMM进行虚拟化</li></ol><h5 id="内存虚拟化">内存虚拟化</h5><p>把物理内存统一管理，包装成多个虚拟的物理内存提供给虚拟机使用。</p><p>每个虚拟机拥有各自独立的内存空间。</p><p>VMM的工作：</p><ol type="1"><li>维护客户机物理地址和宿主机器的机器地址之间的映射</li><li>截获虚拟机对客户机物理地址的访问，并根据所记录的映射关系，转换成机器地址</li></ol><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：影子页表，直接把客户机虚拟地址翻译为物理地址</li><li>基于硬件辅助的虚拟化：硬件辅助地址转换</li><li>修改操作系统的类虚拟化：客户机直接使用VMM的机器地址到物理地址的翻译表</li></ol><h5 id="io虚拟化">I/O虚拟化</h5><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：VMM进行设备模拟并处理所有设备请求与响应</li><li>基于硬件辅助的虚拟化：DMA地址重映射</li><li>修改操作系统的类虚拟化：修改客户机操作系统，客户机直接与物理设备交互</li></ol><h3 id="操作系统级虚拟化">1.2 操作系统级虚拟化</h3><p>在主机操作系统中插入一个虚拟化层。</p><p>在同一个操作系统内核内，运行多个虚拟机；虚拟机可以访问内核。</p><p>虚拟机/容器</p><p>容器的优缺点：</p><ul><li>启动/停止开销最小，资源需求低，可扩展性强</li><li>可同步虚拟机与宿主操作系统环境状态的变化</li><li>允许虚拟机中进程访问尽可能多的主机资源</li><li>同一个容器中的操作系统级虚拟机必须使用相同的客户操作系统</li><li>资源隔离性较差</li></ul><h2 id="云数据中心虚拟化">2. 云数据中心虚拟化</h2><p>为什么要虚拟化？</p><ul><li>一台物理设备一个用户 vs.一台物理设备多个用户：提升资源共享与复用的效率，降低成本</li><li>固定大小与位置的存储空间 vs.灵活扩展和空间分布的空间：提升可扩展性，提升存储资源使用效率</li><li>为了实现服务器、存储虚拟化，要求网络也要能够方便、灵活地调整：随着虚拟机的迁移一起迁移</li></ul><h3 id="服务器虚拟化-1">服务器虚拟化</h3><p>将一个或多个物理服务器虚拟成多个逻辑上的服务器。</p><p>虚拟机、容器。</p><h3 id="存储虚拟化">存储虚拟化</h3><p>把分布的异构存储设备统一为一个或几个大的存储池。</p><p>存储虚拟化将系统中分散且异构的存储资源整合起来，形成一个统一连续编址的逻辑存储空间。</p><h3 id="网络虚拟化">网络虚拟化</h3><p>在底层物理网络和网络用户之间增加一个抽象层。</p><p>云数据中心对网络的需求</p><ul><li>提高数据传输效率：应对数据同步、备份、虚拟机迁移等的大流量</li><li>提高管理效率：采用统一的交换网络减少布线、维护和扩容的成本</li></ul><p>网络虚拟化技术：</p><ul><li><p>核心层网络虚拟化</p></li><li><p>虚拟机网络虚拟化</p></li><li><p>接入层网络虚拟化</p></li></ul><h2 id="虚拟机迁移">3. 虚拟机迁移</h2><h3 id="需求">需求</h3><ol type="1"><li><p>负载平衡需要</p></li><li><p>物理服务器定期升级的需要</p></li></ol><p>关注重点：实时迁移</p><ul><li>保持虚拟机运行的同时，将其从一个计算机迁移到另一个计算机，并在目的计算机恢复运行</li></ul><h3 id="迁移内容">迁移内容</h3><ul><li>内存迁移：最困难</li><li>网络迁移：迁移网络设备、协议状态和配置</li><li>存储设备迁移：使用NAS作为存储设备共享数据</li></ul><p>分类：</p><ul><li>物理机到虚拟机 P2V</li><li>虚拟机到虚拟机 V2V</li><li>虚拟机到物理机 V2P</li></ul><h3 id="内存迁移方案">内存迁移方案</h3><table><thead><tr class="header"><th>迁移方案</th><th>具体描述</th><th>优势与劣势</th></tr></thead><tbody><tr class="odd"><td>Stop and Copy</td><td>A停机，将对应内存全部复制到B，启动B</td><td>方法简单，总迁移时间最短，但停机时间无法接受</td></tr><tr class="even"><td>Stop and Copy和Pull阶段结合</td><td>A停机，将部分内存复制到B，启动B，B运行中遇到缺失内存，再到A内存中复制</td><td>停机时间很短，总迁移时间很长。Pull阶段复制造成的性能下降，用户体验差</td></tr><tr class="odd"><td>Push和Stop and Copy阶段结合</td><td>A不停机，保持对外服务，将变化的内存迭代地复制到B，直到最后剩余很少要复制的再停止A，复制最后变动到B，启动B</td><td>平衡了停机时间和总迁移时间之间的矛盾。需要有一种算法能够测定工作集，以避免反复重传。可能会占用大量的网络带宽，对其他服务造成影响</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云计算_2_架构</title>
    <link href="/2024/04/02/%E4%BA%91%E8%AE%A1%E7%AE%97/2-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/04/02/%E4%BA%91%E8%AE%A1%E7%AE%97/2-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算架构">2-云计算架构</h1><h2 id="计算架构的演化">1. 计算架构的演化</h2><h3 id="发展历程">1.1 发展历程</h3><ol type="1"><li>中央集权架构：所有计算、计算资源、业务逻辑都集中于一台主机</li><li>客户机/服务机架构（C/S架构）<ul><li>客户端：承载少量计算任务和所有IO任务</li><li>服务器：承载主要计算任务</li><li>优点：充分利用客户端计算能力；关注点分离，简化软件复杂度、编程模式</li><li>缺点：持久链接，系统伸缩能力受限；客户端开发维护成本高；平台相关，升级换代麻烦</li></ul></li><li>中间层架构：将业务逻辑和数据服务分别放在两个服务器上（还是C/S架构）<ul><li>客户机到中间件为无状态的非持久链接：提升架构弹性</li></ul></li><li>浏览器/服务器架构（B/S架构）<ul><li>对客户机、中间层架构的扩展——客户端开发、维护成本降低，升级改动小</li><li>客户端：负载进一步缩减，仅显示和运行基于浏览器的脚本程序</li><li>服务器：Web服务器层屏蔽各中间件的差异，提供通用的用户访问界面</li><li>扩展性高：对客户机性能无要求</li><li>对网络性能要求高</li></ul></li><li>C/S和B/S混合架构<ul><li>没有一种架构能够适用于所有场景</li><li>有些服务需要持久的链接（内部用户）</li><li>有些仅通过非持久链接即可（外部用户）</li></ul></li><li>面向服务的架构（SOA）</li><li>微服务架构：在SOA思想上对系统业务做彻底的组件化、服务化。</li></ol><h3 id="面向服务的架构soa">1.2 面向服务的架构（SOA）</h3><p>通过定义良好的接口，联系应用程序的不同服务的组件模型。</p><p>接口：中立定义，独立于硬件平台、操作系统和编程语言。</p><ul><li><p>服务交互方式统一、通用。</p></li><li><p>服务只做本职工作，暴露接口。</p></li><li><p>通过统一的界面协调多个服务：控制复杂性，更容易管理。</p></li></ul><p>SOA的目标：系统更有弹性，更灵活、更快地响应不断改变的企业业务需求，解决软件重用问题。</p><p>具体通过：</p><ul><li>简单的服务间接口</li><li>粗粒度：调用者和服务层只需一次交互</li><li>松耦合：服务间相对独立无依赖</li><li>位置透明</li><li>协议无关</li></ul><p>SOA架构角色：</p><ul><li>服务请求者</li><li>服务提供者</li><li>服务注册中心</li></ul><p>操作：</p><ul><li>发布</li><li>查询</li><li>绑定和调用</li></ul><h2 id="云计算架构二维视角">2. 云计算架构二维视角</h2><p>基础架构 + 应用程序（后端+前端）</p><h3 id="基础架构">2.1 基础架构</h3><p>虚拟化层</p><ul><li><p>将硬件转换为统一的IT资源（可灵活拆分、统一计量、统一管理、软件定义的）</p></li><li><p>可以在不同的抽象层实现：应用层、操作系统层、体系结构层、硬件层等</p></li></ul><p>Web服务层</p><ul><li><p>将云资源提供给客户的一种最方便的方式，解决大部分客户无法直接使用虚拟机的问题；</p></li><li><p>支持面广、对客户端要求低，只需要浏览器就可以访问。</p></li></ul><p>服务总线层</p><ul><li>中间件层，封装计算服务、数据存储、消息传递</li><li>分离用户与虚拟化层、连接用户与Web服务层。</li></ul><p>客户机用户界面</p><ul><li><p>Web门户，将各种服务混搭集成在一个页面。</p></li><li><p>基于Ajax，Javascript，趋势是使用功能完善的组件</p><ul><li>如JavaBeans/Applets，Silvedight/.NET等</li><li>可下载和安装在客户机上</li></ul></li></ul><p>###　2.2 云应用程序结构</p><p>传统操作系统上的应用程序：进程、线程、服务、shell（应用程序的控制接口）</p><ul><li>进程就是最终产品，每一个进程可运行多个指令序列（线程），一个线程对应一种服务。</li></ul><p>云环境中的应用程序：应用程序、应用实例、服务、云命令行界面（控制端）</p><ul><li><p>应用程序由多个同时运行的实例支撑</p></li><li><p>不同的应用实例运行在不同的服务器上，每一个应用实例提供一种或多种服务</p></li><li><p>服务间相互独立</p></li></ul><h2 id="云计算逻辑架构">3. 云计算逻辑架构</h2><h3 id="云体">3.1 云体</h3><p>云计算的物质基础，使用的资源集合，构成云计算的软硬件环境。</p><ul><li><p>例如网络、服务器、存储器、交换机等。</p><p>广义的云体包括数据中心机器辅助设施如电力、空调、机架、冷却等系统。</p></li></ul><p>目前，云体就是数据中心。</p><p>云计算的横向架构。</p><p>传统系统环境：进程/线程/内存管理 + 文件系统 + 进程间通信/网络。</p><p>云运行时环境：计算资源+持久存储+通信</p><h4 id="云数据中心">云数据中心</h4><p>数据集中存储、计算、交换的中心。</p><p>传统数据中心的问题</p><ul><li>机器过多、利用率过低</li><li>应用迁移太困难</li><li>存储需求增长太快</li></ul><p>云数据中心：重视虚拟化，以提高资源利用率</p><p>软件定义数据中心：</p><ul><li>软件定义计算：计算节点虚拟化。</li><li>软件定义存储：分离管理接口与数据读写。管理接口统一，数据读写可以兼容各种方式。</li><li>软件定义网络：数据平面（数据转发）和控制平面（转发表的设置等）分离；集中控制，分布式转发。</li></ul><h3 id="云栈">3.2 云栈</h3><p>又称云平台，是在云上建造的运行环境。</p><ul><li><p>支持应用程序的发布、运行、监控、调度、伸缩，</p><p>并为应用程序提供辅助服务机制，如访问控制、权限管理等。</p></li></ul><h4 id="云栈的三层模式">云栈的三层模式</h4><ol type="1"><li>基础设施即服务层：硬件+虚拟化</li><li>平台即服务层：应用程序的运行环境</li><li>软件即服务层：Web应用服务</li></ol><h4 id="云计算技术架构">云计算技术架构</h4><p>SOA构建层+管理中间件层+资源池层+物理资源层</p><p>管理中间件层和资源池层是云计算技术的最关键部分。</p><h4 id="iaas实现机制">IaaS实现机制</h4><ol type="1"><li>配置工具：在分配的节点上准备任务运行环境。</li><li>系统管理模块：管理和分配所有可用的资源，其核心是负载均衡。</li><li>服务目录：用户可以访问的服务清单。</li><li>用户交互接口：Web用户访问接口。</li><li>监视统计模块：监视节点运行状态，统计节点使用情况。</li></ol><h3 id="云计算">3.3 云计算</h3><p>利用云体和云平台所进行的计算或处理。</p><p>无论在哪个层面开展，只要符合“按量计费、资源可伸缩”就是云计算。</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云计算_1_概念</title>
    <link href="/2024/04/01/%E4%BA%91%E8%AE%A1%E7%AE%97/1-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/04/01/%E4%BA%91%E8%AE%A1%E7%AE%97/1-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算概念">1-云计算概念</h1><p>大规模分布式计算模式，通过一系列技术实现按需交付。</p><h2 id="计算模式的发展历程">1. 计算模式的发展历程</h2><p>主机系统与集中计算<spanclass="math inline">\(\rightarrow\)</span>集群计算<spanclass="math inline">\(\rightarrow\)</span>个人计算机与桌面计算<spanclass="math inline">\(\rightarrow\)</span>分布式计算<spanclass="math inline">\(\rightarrow\)</span>网格计算<spanclass="math inline">\(\rightarrow\)</span>​云计算</p><ul><li><strong>效用计算</strong>：将IT资源包装成可以度量的服务提供给用户。</li><li><strong>服务计算</strong>（软件即服务SaaS）：将应用程序作为服务提供。</li></ul><p>云计算：效用计算+服务计算</p><h3 id="对计算的追求">对计算的追求</h3><p>自动化、高性能、易使用</p><h3 id="云计算持续优化的动力">云计算持续优化的动力</h3><ol type="1"><li>节能</li><li>降低成本</li><li>提升资产安全</li><li>提升信息系统容灾备份能力</li></ol><h2 id="云计算的特征与分类">2. 云计算的特征与分类</h2><h3 id="特征">2.1 特征</h3><ul><li><p>物理特征：大规模</p></li><li><p>技术特征：虚拟化</p></li><li><p>商业特征：按需服务</p></li><li><p>使用特征：通用、高可伸缩</p></li><li><p>目标：高可靠</p></li></ul><h3 id="云部署模型">2.2 云部署模型</h3><p>公有云：由第三方云提供者拥有的可公共访问的云环境</p><p>私有云：由一家组织单独拥有，利用云计算技术来访问组织内部的IT资源</p><p>混合云：由两种或者更多不同云部署模型组成的云环境</p><h3 id="云服务模型">2.3 云服务模型</h3><ul><li>软件作为服务：Software as a Service，SaaS</li><li>平台作为服务：PaaS</li><li>基础设施作为服务：IaaS</li></ul><h4 id="iaas">IaaS</h4><p>通过虚拟机方式对外提供计算、存储和网络能力</p><ul><li>虚拟机安装操作系统，享有公网IP，使用公网访问虚拟机</li><li>额外租用存储设备挂载到虚拟机</li><li>多个虚拟机之间通过公用网络、私有网络进行通信</li></ul><p>类似租用独立的计算机，用户自行解决多台机器之间的协同问题</p><p>优势</p><ul><li>允许用户动态申请和释放资源</li><li>按使用量计费</li><li>更高的资源使用效率（节能环保）</li></ul><h4 id="paas">PaaS</h4><p>提供用户应用程序的开发和运行环境，包括应用编程接口和运行平台等，支持应用从创建到运行整个生命周期需要的各种软硬件资源和工具。</p><ul><li>经过封装的IT能力，或逻辑资源：数据库、文件系统和应用运行环境</li><li>主要面向软件开发者（包括应用服务上）</li></ul><p>PaaS自身负责资源的动态扩展和容错管理，用户无需考虑节点间的配合问题。</p><p>用户自主权降低，需按照给定的编程环境和编程模型构建应用。</p><h4 id="saas">SaaS</h4><p>通过标准的Web浏览器或软件客户端访问云上的应用。</p><h3 id="相关技术">2.4 相关技术</h3><p>虚拟化技术、容器技术、数据加密、分布式计算与分布式存储等。</p><h4 id="分布式计算">分布式计算</h4><p>多个通过网络互联的计算机相互之间传递数据，实现信息共享，协作共同完成处理任务。</p><p>优势：</p><ul><li>资源共享</li><li>多设备负载均衡</li><li>将程序放在最适合的计算机上运行</li></ul><h2 id="云计算三元认知">3. 云计算三元认知</h2><h3 id="商业模式">3.1 商业模式</h3><p>一种全新的商业模式、服务类型。</p><ul><li>在软件服务基础上提供平台和基础设施服务</li><li>具体实现：云平台，包括计算范式和实现方式</li></ul><h3 id="计算范式">3.2 计算范式</h3><p>理论实现，针对商业模式的架构设计。</p><ul><li>云体逻辑结构：具体落地的云平台逻辑结构。<ul><li>物理结构：云数据中心</li><li>计算+存储+通信</li></ul></li><li>云栈逻辑结构：面向服务的云平台逻辑结构。<ul><li>物理结构：管理系统的结构</li><li>基础设施即服务，平台即服务，软件即服务</li></ul></li></ul><h3 id="实现方式">3.3 实现方式</h3><p>数据中心+云平台管理系统</p><ul><li>软件定义数据中心：软件定义计算，软件定义存储，软件定义网络，软件定义安全。</li></ul><h2 id="云计算的开源方法论">4. 云计算的开源方法论</h2><h3 id="什么是开源">4.1 什么是开源</h3><p>开源是一种方法论、一种构造大规模复杂软件的协作方式。</p><p>开源软件：</p><p>一种版权持有人为任何人和任何目的提供学习、修改和分发权力，并公布源代码的计算机软件。</p><ol type="1"><li><p>许可证不应限制任何个人或团体将包含该开源软件的广义作品进行销售或赠予</p></li><li><p>开源软件的程序必须包含源代码，必须允许发布源代码及以后的程序</p></li><li><p>开源软件许可证必须允许修改和派生作品，并允许使用原有软件的许可条款发布他们</p></li></ol><p>开源不一定自由，开源不一定免费；自由不一定免费；免费不一定开源，不一定自由。</p><h3 id="开源的价值与意义">4.2 开源的价值与意义</h3><ol type="1"><li>开源促进国家信息技术创新，带动经济发展</li><li>软件厂商依托开源提升研发能力</li><li>用户使用开源技术改变信息化路线</li><li>企业自主开源，引领技术发展路径</li></ol><h2 id="云计算技术的挑战与未来">5. 云计算技术的挑战与未来</h2><h3 id="难点">5.1 难点</h3><ol type="1"><li><p>数据中心安全控制</p></li><li><p>构建高度同构化的虚拟资源</p></li><li><p>高可用性的实现——资源管理</p></li><li><p>容错的实现——任务管理</p><p>当集群中的服务出现故障时，服务器集群上的程序执行不会被中端或挂起。</p></li><li><p>节能（负载均衡）——任务管理</p><p>任务调度；虚拟机调度。</p></li><li><p>云安全与隐私保护——安全管理</p><p>基础设施安全，平台安全，软件安全；数据完整性和隐私保护等。</p></li></ol><p><span class="math inline">\(集群可用性=\frac{MTTF(两个相邻故障之间的系统平均正常运行时间)}{MTTF+MTTR(发生故障后修复及还原工作状态的平均时间)}\)</span></p><h3 id="风险与挑战">5.2 风险与挑战</h3><ol type="1"><li><p>增加了安全漏洞</p><ul><li>远程使用IT资源需要云用户将信任边界扩展到外部的云，建立这样的安全架构同时又不引入安全漏洞是非常困难的</li><li>重叠的信任边界和不断增加的数据曝光为恶意的云用户提供了更多的攻击IT资源、窃取或破坏企业数据的机会</li></ul></li><li><p>降低了运营管理控制能力</p><ul><li>云用户对云资源的管理控制低于对企业内部IT资源的管理控制<ul><li>云提供者可能不遵守它发布的云服务保证</li><li>云用户和云提供者之间较长的地理距离可能需要更多的网络跳数，会带来延迟波动和带宽受限</li></ul></li></ul></li><li><p>云提供者之间有限的可移植性</p><ul><li>由于缺乏行业标准，不同的云提供者提供的服务存在较大差异</li></ul></li><li><p>法规和法律问题</p><ul><li><p>第三方云提供者通常选择造价较低、方便的地理位置建立数据中心，而云用户通常不会意识到所使用IT资源和自身数据所存放的位置</p></li><li><p>某些云用户可能会遇到严重的法律问题</p><p>例如：英国法律规定，英国公民的个人数据只能留在英国境内</p></li><li><p>潜在的数据获得和公开</p><p>例如：某些国家的法律规定，某些类型的数据必须向某些政府机构或数据主体公开</p></li></ul></li></ol><h3 id="缺陷与未来">5.3 缺陷与未来</h3><ul><li>从平台角度看——没有统一的标准</li><li>从计算角度看——针对松耦合的数据处理</li><li>从数据角度看——管理和分析商业数据</li><li>从资源集成角度看——必须集中到云中</li><li>从信息安全角度看——暴露、丢失的风险</li></ul><p>这也恰是网格的优势。</p><p>未来：云格计算</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_07_演化学习</title>
    <link href="/2023/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07_%E6%BC%94%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07_%E6%BC%94%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="演化学习">演化学习</h1><h2 id="动机">1. 动机</h2><p>人工神经网络：从生物神经系统中得到灵感</p><p>涌现学习模型：模仿生物的声明演化形式</p><p>遗传算法：学习是问题候选假设在进化中的一种竞争，较好的候选假设在自然选择中不断演化。</p><p>进化论：（个体）适应+（自然）选择+（种群）进化</p><h2 id="遗传算法">2. 遗传算法</h2><p>genetic algorithms</p><p>通过对当前最好的假设模型重组来产生后续假设模型。</p><ul><li>生成并测试的柱状搜索</li><li>假设的各个部分相互作用，每一部分对总体的影响难以建模</li></ul><p>算法的一般形式：</p><ol type="1"><li><span class="math inline">\(t:=0\)</span>，初始化种群<spanclass="math inline">\(P(t)\)</span></li><li>循环至终止条件<ul><li>评估<span class="math inline">\(P(t)\)</span>每个染色体的适应度</li><li>根据适应度函数选择部分染色体</li><li>根据所选择的染色体产生后代</li><li>根据<spanclass="math inline">\(P(t)\)</span>中染色体的适应度，选择被替换的染色体，以后代替换</li><li><span class="math inline">\(t:=t+1\)</span></li></ul></li></ol><p>四个问题：</p><ul><li><p>染色体<spanclass="math inline">\(\rightarrow\)</span>模式，每个<属性-值>对用二进制的一位表示：1、0、#（表示1and0）</p><ul><li>模式：0、1、#组成的任意串</li></ul></li><li><p>适应度函数</p></li><li><p>染色体选择：基于适应度函数，与适应度成比例选择</p></li><li><p>后代产生</p><ul><li><p>选择父母：</p><ul><li><p>锦标赛选择：</p><p>每次有放回地取出一定数量个体，选择其中最好个体进入子代种群，重复至新种群与原种群规模相同</p></li><li><p>截断选择：</p><p>适应度前f个染色体进入下一代种群，复制染色体填充种群规模到原种群规模</p></li></ul></li></ul></li></ul><p>遗传算子：对从当前群体中选择的染色体进行重组以产生后代</p><ul><li><p>两个染色体单点/多点交叉替换形成两个新的候选个体</p></li><li><p>变异，随机选择候选个体，以小概率<spanclass="math inline">\(p=1/L\)</span>（L为染色体长度）选位取反</p><ul><li>避免局部收敛，保证种群多样性</li></ul></li></ul><p>后代种群的演化</p><ul><li><p>简易方案：后代染色体直接替代父代染色体</p><ul><li>易丢失优解</li></ul></li><li><p>精英法：每代保留上代最优染色体，丢弃最差个体</p><ul><li>往往与选择算子混用</li></ul></li><li><p>锦标赛法：父母染色体与后代染色体竞争，胜者放入下一代种群</p></li><li><p>小生境法：</p><p>每代个体划分为若干类，每个类中选择若干适应度较大的个体作为一个类的优秀代表组成一个群；</p><p>种群中，以及不同种群之间杂交、变异产生新一代个体群。</p><ul><li>预选择机制：只用高适应度子代替换父代</li><li>排挤机制：预定义原型。所产生的子代要保持和原型的模式不一致，模式相似的个体被替换</li><li>共享机制：计算适应度和模式的关联关系，共享这种模式</li></ul></li></ul><p>优点：</p><ul><li>无需理解问题内部相关性和因果性</li><li>以一个随机的群体开始，以适应度作为某种启发式</li><li>保证整个种群的演化</li></ul><p>问题：</p><ul><li>表示：编码不规范以及编码存在表示的不准确性</li><li>约束：单一遗传算法编码不能全面地将优化问题的约束表示出来</li><li>效率：效率比传统方法低，容易出现过早收敛</li><li>理论保证：对遗传算法的精度、可行性、计算复杂性等方面还没有有效的定量分析方法</li></ul><p>模式定理：高适应度的短模式会在演化的过程中增加占比。</p><h2 id="其他">3. 其他</h2><p>自然计算：模仿自然界特点，具有自适应、自组织、自学习能力的模型和算法</p><ul><li>遗传算法、蚁群算法、粒子群算法、免疫算法</li><li>往往用来解决非凸优化问题</li></ul><p>蚁群优化：模拟蚂蚁觅食，更新信息素</p><p>粒子群优化：模拟鸟群觅食，更新移动位置</p><p>学习分类器系统</p><p>课件没有文字介绍</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_06_神经元</title>
    <link href="/2023/11/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06_%E7%A5%9E%E7%BB%8F%E5%85%83/"/>
    <url>/2023/11/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06_%E7%A5%9E%E7%BB%8F%E5%85%83/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="神经元">神经元</h1><h2 id="脑和神经元">1. 脑和神经元</h2><h3 id="生物学基础">生物学基础</h3><ol type="1"><li><p>神经元内化学物质调节内部电位。</p></li><li><p>跨膜电位达到一个阈值时，则激活或放电。</p></li><li><p>（固定）时间和强度的脉冲传递给轴突</p></li><li><p>轴突像树枝状，连接到突触</p></li></ol><p>人脑有<spanclass="math inline">\(10^{11}\)</span>个神经元，每个神经元处理速度<spanclass="math inline">\(10^{-3}s\)</span>。</p><p>赫布理论：连接强度调整量与输入输出的乘积成正比。</p><ul><li>又称为长程增强机制或神经可塑。</li></ul><h3 id="mp神经元">MP神经元</h3><p>输入<span class="math inline">\(X=[x_1,x_2,...]\)</span></p><p>权值<span class="math inline">\(W=[w_1,w_2,...]\)</span></p><p>激活函数<spanclass="math inline">\(f(net)=f(\Sigma(w_i*x_i))\)</span></p><p>偏置单元<span class="math inline">\(x_0\)</span>，对应权值<spanclass="math inline">\(w_0\)</span></p><ul><li>输入<span class="math inline">\(X\)</span>，输出<spanclass="math inline">\(f(net)\)</span></li></ul><p>局限性：</p><ul><li>输入方面：线性求和</li><li>输出方面：单一输出值</li><li>更新机制：时钟同步更新</li><li>权值的物理意义：兴奋性连接与抑制性连接；不存在由正到负/由负到正的连接</li></ul><p>激活函数</p><ul><li>单位阶跃函数：<span class="math inline">\(f(x):= \begin{cases}1,\quad x\ge 0 \\[2ex] 0, \quad x\lt0 \end{cases}\)</span><ul><li>不连续，对变化敏感，在x=0处不可微</li><li>一般适合单层感知机</li></ul></li><li>Sigmoid函数：<spanclass="math inline">\(f(x):=\frac{1}{1+e^{-x}}\)</span><ul><li>连续、光滑、严格单调，范围在(0,1)，S形非线性</li><li>导数始终小于1且不以0为对称轴</li><li>饱和类激活函数</li></ul></li><li>ReLU：<span class="math inline">\(f(x):=max(0,x)\)</span></li><li>Leaky ReLU：<span class="math inline">\(f(x):=\begin{cases}x,\quadx\ge0\\ax,\quad x\lt 0 \end{cases}\)</span><ul><li>若a遵循均匀分布随机采样，则为Randomized Leaky ReLU</li></ul></li></ul><p>ReLU都是非饱和类激活函数。</p><h2 id="感知机学习">2. 感知机学习</h2><p>最简单形式的前馈式人工神经网络。</p><p>二元线性分类器，使用特征向量作为输入，把矩阵上的输入x映射到输出值f(x)上（二元值）。</p><p>感知机学习算法</p><ol type="1"><li>权值初始化</li><li>输入样本对</li><li>计算输出</li><li>根据学习规则调整权重</li><li>继续输入下一对样本，循环至对所有样本的实际输出与期望输出相等</li></ol><p>学习规则：<span class="math inline">\(\Delta w_i=c(d-sign(\Sigmaw_i·x_i))x_i\)</span></p><ul><li>c是常数，表示学习率</li><li>d是期望的输出，值为1或-1</li><li>sign是感知机的输出，值为1或-1</li></ul><h2 id="线性可分性">3.线性可分性</h2><p>决策边界：</p><p>即不同决策的输入间的边界。</p><ul><li>鉴别函数</li><li>神经元激活阈值</li></ul><p>多分类决策边界：每个输出神经元定义一条决策边界。</p><p>感知机收敛理论：给定一个线性可分数据集，感知机将在有限次迭代中收敛到一个决策边界。</p><ul><li><p>设<spanclass="math inline">\(\gamma\)</span>是分离超平面与最接近的数据点之间的距离，则迭代次数的界是<spanclass="math inline">\(1/\gamma^2\)</span>。</p></li><li><p>感知机学习可以收敛的前提是训练样例必须线性可分，否则只能收敛到近似目标概念。</p></li></ul><p>感知机学习缺点：单层神经网络，不能解决非线性可分问题。</p><ul><li>异或</li></ul><p>感知机表达能力：n维实例空间的超平面决策。</p><ul><li>候选假设空间：所有可能的权向量的集合</li></ul><p>二层神经网络可以表达所有布尔函数</p><ul><li>广义布尔函数m-of-n：n个输入值至少有m个为真，则输出为真</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_05_支持向量机</title>
    <link href="/2023/11/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05_%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2023/11/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05_%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="支持向量机">支持向量机</h1><p>20231031</p><p>18:30-21:20</p><p>20231107</p><p>18:30-21:20</p><p>从统计学的观点来看，机器学习的目的是得到映射：<spanclass="math inline">\(X\rightarrow Y\)</span></p><ul><li>类的先验概率：<span class="math inline">\(p(y=i)\)</span></li><li>样本的先验概率：<span class="math inline">\(p(x)\)</span></li><li>类的条件概率：<span class="math inline">\(p(x|y=i)\)</span></li><li>后验概率：<span class="math inline">\(p(y=i|x)\)</span></li></ul><p>统计机器学习方法从概率框架的角度粗略分类：</p><ul><li>生成式模型：估计<span class="math inline">\(p(x|y=i)\)</span>和<spanclass="math inline">\(p(y=i)\)</span>，用贝叶斯定理求<spanclass="math inline">\(p(y=i|x)\)</span></li><li>判别式模型：直接估计<span class="math inline">\(p(y=i|x)\)</span><ul><li>判别函数：不假设概率模型，直接求一个把各类分开的边界</li></ul></li></ul><h2 id="感知机">感知机</h2><h3 id="二分类">二分类</h3><p>二分类问题可以看作是在特征空间上对类别进行划分的任务。</p><p>线性超平面、线性可分</p><ul><li><p><spanclass="math inline">\(w^Tx+b=0\)</span>：划分超平面的线性方程</p><p><spanclass="math inline">\(w\)</span>为法向量，决定了超平面的方向；<spanclass="math inline">\(b\)</span>为位移量，决定了超平面和原点之间的距离</p><p><span class="math inline">\(f(x)=sign(w^Tx+b)\)</span></p></li></ul><h2 id="线性支持向量机">线性支持向量机</h2><h3 id="间隔与支持向量">间隔与支持向量</h3><p>一个点到分界超平面的垂直距离称为这个点对应的间隔（margin）：<spanclass="math inline">\(\frac{|f(x)|}{||w||}=\frac{|w^Tx+b|}{||w||}\)</span>。</p><p>具有最小间隔的点称为支持向量（supported vectors）。</p><p>支持向量机（supported vectormachine，SVM）最大化（所有训练样本的）最小间隔。</p><h3 id="分类与评价">分类与评价</h3><p><span class="math inline">\(f(\vec x)\gt0\)</span>则为正类，<spanclass="math inline">\(f(\vec x)\lt0\)</span>则为负类。</p><p><span class="math inline">\(y_i=\{-1,1\}\)</span>，<spanclass="math inline">\(y_if(\vec x_i)\gt0\)</span>为正确，<spanclass="math inline">\(y_if(\vec x_i)\lt0\)</span>为错误。</p><ul><li>假设能完全分开，且<spanclass="math inline">\(|y_i|=1\)</span>，那么<spanclass="math inline">\(y_if(\vec x_i)=|f(x_i)|\)</span></li></ul><h2 id="非线性支持向量机">非线性支持向量机</h2><p>将样本从原始空间映射到一个更高维的特征空间，使样本在这个特征空间内线性可分。</p><p>非线性核：RBF/高斯核、多项式核</p><h2 id="多类支持向量机">多类支持向量机</h2><p>1vs rest/1v1</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_04_集成学习</title>
    <link href="/2023/10/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="集成学习">集成学习</h1><h2 id="集成学习原理">集成学习原理</h2><h3 id="特点分类">特点（分类）</h3><p>多个分类器集成在一起，以提高分类准确率；</p><p>由训练数据构建基分类器，然后根据预测结果投票。</p><ul><li><p>集成学习本身不是一种分类器，而是一种分类器结合方法。</p></li><li><p>通常集成分类器性能会好于单个分类器。</p></li></ul><h4 id="例多数投票法结合">例：多数投票法结合</h4><p>每个二分类器的分类精度为p，则集成T个分类器的分类精度为<spanclass="math inline">\(\Sigma_{k=\frac{T}{2}+1}^T(_k^T)p^k(1-p)^{T-k}\)</span></p><ul><li>当<span class="math inline">\(p\gt0.5\)</span>且<spanclass="math inline">\(T\rightarrow\infty\)</span>时，上式<spanclass="math inline">\(\rightarrow 1\)</span></li></ul><h3 id="bias-variance-tradeoff问题">Bias-Variance tradeoff问题</h3><p>Bias：学习结果的期望和真实规律的差距</p><p><span class="math inline">\(Bias=E[\hat f(x)]-f(x)\)</span></p><p>Variance：学习结果自身的不稳定性</p><p><span class="math inline">\(Variance=E[(\hat f(x)-E[\hatf(x)])^2]\)</span></p><p>Total Error：以均方误差为例</p><p><spanclass="math inline">\(Err(x)=Bias^2+Variance+Random\,Error\)</span></p><h4 id="核心问题">核心问题</h4><p>序列集成（基学习器）法</p><ul><li>利用基学习器之间的依赖关系依次生成</li><li>减少偏差bias</li></ul><p>并行集成（基学习器）法</p><ul><li>利用基学习器之间的独立关系并行生成</li><li>减少方差variance</li></ul><p>问题：如何训练和结合每个学习器</p><h3 id="结合策略">结合策略</h3><p>平均法（回归问题）</p><ul><li>简单平均</li><li>加权平均</li></ul><p>投票法（分类问题）</p><ul><li>绝对多数</li><li>相对多数</li><li>加权投票</li></ul><p>学习法（Stacking）</p><h3 id="多样性策略学习基学习器">多样性策略（学习基学习器）</h3><p>数据层面</p><ul><li>输入样本的扰动，构建基学习器</li><li>输出样本的扰动，构建基学习器</li></ul><p>属性层面</p><ul><li>随机选择部分属性，构建基学习器</li></ul><p>参数层面</p><ul><li>算法模型参数的扰动，构建基学习器</li></ul><h2 id="bagging和随机森林">Bagging和随机森林</h2><h3 id="bagging">Bagging</h3><p>Bagging（Boosting aggregating）基本原理：</p><p>有放回采样方法。统计上的目的是得到统计量分布以及置信区间。</p><h4 id="bagging-算法流程">Bagging 算法流程</h4><p>输入：训练集S，基学习算法I，整数T（训练轮数/自助Bootstrap数）</p><p><span class="math inline">\(for\;i = 1\;to\;T\)</span> <spanclass="math inline">\(\{\)</span> <spanclass="math inline">\(S&#39;=从S中自助采样（有放回的独立采样）\)</span><span class="math inline">\(C_i=I(S&#39;)\)</span> <spanclass="math inline">\(\}\)</span></p><p><span class="math inline">\(C^*(x)=argmax_{y\inY}\Sigma_{i=1}^T(C_i(x)=y)\)</span></p><p>输出：分类器<span class="math inline">\(C^*\)</span></p><p>优点：</p><p>并行式集成学习，降低分类器方差，改善泛化。</p><ul><li>其性能依赖于基分类器的稳定性，若基分类器稳定，则其误差主要由基分类器bias决定</li><li>由于采样概率相同，bagging方法不侧重于任何特定实例</li><li>可以并行化处理，提高效率</li></ul><p>缺点：</p><ul><li>当基学习器具有高bias，集成之后也会具有较高bias</li><li>集成之后的模型会损失可解释性</li><li>依赖数据集，计算可能会比较昂贵</li></ul><p>代表性算法：随机森林（Random Forest，RF）</p><h3 id="随机森林">随机森林</h3><ol type="1"><li>训练用例的个数为N，特征数目为M，输入特征数目m以确定决策树上个结点的决策结果。<ul><li>m应远小于M。</li></ul></li><li>从N个训练样例中以有放回抽样的方式取样N次，形成一个训练集（即bagging取样），并用未抽到的用例作预测，评估其误差。</li><li>对于每一个结点，随机选择m个特征（通常为M的均方根<spanclass="math inline">\(log_2M\)</span>），根据这m个特征，计算其最佳的分裂方式。</li><li>每棵树都会完整成长而不会剪枝，这有可能在建完一棵正常树状分类器后会被采用。</li><li>以上过程做充分多次以产生足够多的随机树。</li></ol><p>特点：</p><ul><li>差异性：每棵树是不同的；每棵树使用的特征是不同的的</li><li>缓解维度灾难：每棵树没有使用全部特征，特征空间被减小了</li><li>可并行化：每棵树使用不同数据、不同特征，可以有效采用并行化技术</li><li>训练-测试划分：训练和测试的划分不是必须的，因为构建每棵决策树时，总有30%的数据没有采样</li><li>稳定性：通过多数投票或者平均，结果较为稳定</li></ul><h2 id="boosting">Boosting</h2><h3 id="概率近似正确pac学习理论">概率近似正确（PAC）学习理论</h3><p>强可学习：在PAC框架中，一个概念，如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这个概念是强可学习的。</p><p>弱可学习：在PAC框架中，一个概念，如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测略好，那么就称这个概念是弱可学习的。</p><p>PAC学习理论：</p><ul><li>强学习器和弱学习器是等价的</li><li>一个概念是强学习的充分必要条件是这个概念是弱可学习的</li><li>可以通过提升方法（Boosting）将弱学习器转为强学习器</li></ul><h3 id="boosting-1">Boosting</h3><p>代表性算法：Adaptive Boost（AdaBoost）</p><p>从弱学习算法出发，通过改变训练数据的概率（权值）分布，反复学习，得到一系列弱分类器，然后进行组合，构成一个强分类器。</p><p>策略：</p><ul><li>权值分布：提高那些被前一轮弱分类器错误分类样本的权值，降低那些被正确分类样本的权值。</li><li>弱分类器组合：采用加权多数表决策略；增加分类误差率小的弱分类器权重，减小分类误差率大的弱分类器权重。</li></ul><h3 id="adaboost">AdaBoost</h3><p>以分类问题为例：分类器的误差率和权重系数</p><p>AdaBoost采用加权表决。</p><p>AdaBoost算法的另一个解释：</p><ul><li><p>AdaBoost的模型为加法模型</p></li><li><p>AdaBoost的损失函数为指数函数：<spanclass="math inline">\(L(y,f(x))=exp[-yf(x)]\)</span></p></li><li><p>AdaBoost的学习算法为前向分步算法</p></li><li><p>AdaBoost的算法是一个二分类学习算法</p></li><li><p>AdaBoost的最终分类器：<spanclass="math inline">\(f(x)=\Sigma_{k=1}^K\alpha_kG_k(x_i)\)</span></p></li></ul><h4 id="加法模型">加法模型</h4><p><spanclass="math inline">\(f(x)=\Sigma_{m=1}^M\beta_mb(x;\gamma_m)\)</span></p><p>基函数（共M个）：<spanclass="math inline">\(b(x;\gamma_m)\)</span></p><p>基函数参数：<span class="math inline">\(\gamma_m\)</span></p><p>基函数系数：<span class="math inline">\(\beta_m\)</span></p><p>目标函数：<spanclass="math inline">\(min_{(\beta_m,\gamma_m)}\Sigma_{i=1}^NL(y_i,\Sigma_{m=1}^M\beta_mb(x_i;\gamma_m))\)</span></p><h4 id="前向分步算法">前向分步算法</h4><p>学习目标函数为加法模型，如果能够从前到后，每一步只学习一个基函数及其系数，逐步逼近要优化的总目标函数，就可以简化优化的复杂度。</p><p>输入：</p><ul><li>训练数据集<spanclass="math inline">\(T=\{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}\)</span>；</li><li>损失函数<span class="math inline">\(L(Y,f(x))\)</span>；</li><li>基函数集<span class="math inline">\(\{b(x;\gamma)\}\)</span></li></ul><p>输出：加法模型<span class="math inline">\(f(x)\)</span></p><ol type="1"><li>初始化<span class="math inline">\(f_0(x)=0\)</span></li><li>对<span class="math inline">\(m=1,2,...,M\)</span><ol type="1"><li>极小化损失函数得到<spanclass="math inline">\(\beta_m,\gamma_m\)</span>：<spanclass="math inline">\((\beta_m,\gamma_m)=argmin_{\beta,\gamma}\Sigma_{i=1}^NL(y_i,f_{m-1}(x_i)+\betab(x_i;\gamma))\)</span></li><li>更新：<spanclass="math inline">\(f_m(x)=f_{m-1}(x)+\beta_mb(x;\gamma_m)\)</span></li></ol></li><li>得到加法模型：<spanclass="math inline">\(f(x)=f_M(x)=\Sigma_{m=1}^M\beta_mb(x;\gamma_m)\)</span></li></ol><h3 id="提升树">提升树</h3><p>提升（Boosting）方法主要采用加法模型，即基函数的线性组合，与前向分步算法。</p><p>以决策树为基函数的提升方法称为提升树（boosting tree）。</p><ul><li><spanclass="math inline">\(f_M(x)=\Sigma_{m=1}^Mh_m(x)\)</span>，其中<spanclass="math inline">\(h_m(x)\)</span>表示决策树，<spanclass="math inline">\(M\)</span>为决策树个数</li></ul><h4 id="提升树算法流程">提升树算法流程</h4><p>回归问题</p><ol type="1"><li>初始化<span class="math inline">\(f_0(x)=0\)</span></li><li>对<span class="math inline">\(m=1,2,...,M\)</span><ol type="1"><li>计算<spanclass="math inline">\(argmin\Sigma_{i=1}^NL(y_i,f_{m-1}(x_i)+h_m(x_i))\)</span></li><li>得到<span class="math inline">\(h_m(x)\)</span></li><li>更新<spanclass="math inline">\(f_m(x)=f_{m-1}(x)+h_m(x)\)</span></li></ol></li><li>得到回归问题提升树：<spanclass="math inline">\(f_M(x)=\Sigma_{m=1}^Mh_m(x)\)</span></li></ol><p>当采用平方误差损失函数：<spanclass="math inline">\(L(y,f_{m-1}(x)+h_m(x))=(y-f_{m-1}(x)-h_m(x))^2=(r-h_m(x))^2\)</span></p><p>其中残差<span class="math inline">\(r=y-f_{m-1}(x)\)</span>。</p><p>可以拟合残差<spanclass="math inline">\(r_{m_i}\)</span>学习一个回归树，得到<spanclass="math inline">\(h_m(x)\)</span>。</p><p>推广到一般损失：第m轮第i个样本的负梯度作为残差的近似值：<spanclass="math inline">\(-[\frac{\partial L(y,f(x_i))}{\partialf(x_i)}]_{f=f_{m-1}}\)</span></p><h3 id="gbdt">GBDT</h3><p>Gradient Boosting Decision Tree，梯度提升树</p><h4 id="算法流程">算法流程</h4><ol type="1"><li>初始化弱分类器</li><li>循环<ol type="1"><li>对每个样本计算负梯度</li><li>构建新的样本集合</li><li>根据对树的约束，构建CART树</li><li>计算叶子区域最佳拟合值</li><li>更新得到强学习器</li></ol></li><li>得到最终强学习器</li></ol><p>回归问题</p><ol type="1"><li>初始化<spanclass="math inline">\(f_0(x)=argmin_\gamma\Sigma_{i=1}^NL(y_i,\gamma)\)</span></li><li>对<span class="math inline">\(m=1,2,...,M\)</span><ol type="1"><li>计算残差<span class="math inline">\(r_{mi}=-[\frac{\partialL(y,f(x_i))}{\partial f(x_i)}]_{f=f_{m-1}},i=1,2,...,N\)</span></li><li>残差<spanclass="math inline">\(rmi\)</span>拟合一个回归树，得到第m棵树的叶结点区域<spanclass="math inline">\(R_{mj},j=1,2,...,J\)</span></li><li>对<span class="math inline">\(j=1,2,...,J\)</span>计算<spanclass="math inline">\(Y_{mj}=argmin_c\Sigma_{x_i\inR_{mj}}L(y_i,f_{m-1}(x_i)+\gamma)\)</span></li><li>更新<spanclass="math inline">\(f_m(x)=f_{m-1}(x)+\Sigma_{j=1}^J\gamma_{mj}I(x\inR_{mj})\)</span></li></ol></li><li>得到回归问题提升树：<spanclass="math inline">\(f_M(x)=\Sigma_{m=1}^M\Sigma_{j=1}^J\gamma_{mj}I(x\inR_{mj})\)</span></li></ol><h3 id="xgboost">XGBoost</h3><p>Extreme Gradient Boosting</p><ul><li><p>GBDT的一种高效实现</p></li><li><p>目标函数通过二阶泰勒展开式做近似</p></li><li><p>定义了树的复杂度，并应用到目标函数中</p></li><li><p>分裂结点处通过结构打分和分割损失动态生长</p></li><li><p>分裂结点的候选集合通过一种分布式Quantile Sketch得到</p></li><li><p>可以处理稀疏、缺失数据</p></li><li><p>可以通过特征的列采样防止过拟合</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_03_树学习</title>
    <link href="/2023/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="树学习">树学习</h1><p>20230926</p><p>18:30-21:30</p><p>20231010</p><p>18:30-21:30</p><h2 id="符号学习">符号学习</h2><p>推理的角度：</p><ul><li>演绎推理：<span class="math inline">\(P\rightarrowQ\)</span>，P为真则Q为真</li><li>反绎推理：<span class="math inline">\(P\rightarrowQ\)</span>，Q为真则P为真</li><li>归纳推理：P为真，Q未必为真</li></ul><p>符号（概念）学习是一类归纳推理。</p><h3 id="概念学习">概念学习</h3><p>给定样例集合，以及每个样例是否属于某个概念，自动地推断出该概念的一般定义。</p><h4 id="概念学习任务">概念学习任务</h4><ul><li>实例集合X</li><li>目标概念c：定义在实例集X上的布尔函数<spanclass="math inline">\(c:X\rightarrow\{0,1\}\)</span></li><li>训练样例：正例<spanclass="math inline">\((c(x)=1)\)</span>，反例<spanclass="math inline">\((c(x)=0)\)</span></li><li>假设集H：每个假设h表示X上定义的布尔函数<spanclass="math inline">\(h:X\rightarrow\{0,1\}\)</span></li></ul><p>概念学习：寻找一个假设h，使对于X中的所有x，<spanclass="math inline">\(h(x)=c(x)\)</span></p><p>归纳学习假设：任一假设如果在足够大的训练样例集合中能很好地逼近目标概念函数，它也能在未见实例中很好地逼近目标概念。</p><h4 id="作为搜索的概念学习">作为搜索的概念学习</h4><p>当假设的表示确定后，也就确定了概念学习算法所有假设的空间。</p><p>搜索的目标是为了寻找最好的拟合训练样例的假设。</p><p>搜索的操作：</p><ul><li>用逻辑变量替换常量</li><li>合取表达式去掉部分条件</li><li>对表达式增加析取项</li><li>用属性的超类来替换属性</li></ul><h4 id="假设的一般到特殊序">假设的一般到特殊序</h4><ul><li><p>更泛化</p><p><span class="math inline">\(令h_j和h_k是定义在X上的布尔函数，h_j\ge_gh_k即h_j更泛化于h_k\)</span></p><p><span class="math inline">\(当且仅当(\forall x\inX)[(h_k(x)=1)\rightarrow (h_j(x)=1)]\)</span></p></li><li><p>严格泛化：记为<spanclass="math inline">\(h_j\gt_gh_k\)</span></p></li><li><p>更特化：记为<spanclass="math inline">\(h_j\ge_sh_k\)</span></p></li></ul><h3 id="寻找极大特殊假设find-s">寻找极大特殊假设，Find-S</h3><ol type="1"><li><p>将h初始化为H中最特殊的假设</p></li><li><p>对每个正例x：</p><p>对h的每个属性约束，如果x满足，不处理；</p><p>否则将该约束替换为x满足的另一个最一般的约束</p></li><li><p>输出假设h</p></li></ol><p>对以属性合取式表示的假设空间，输出与正例一致的最特殊的假设。</p><h3id="列表消除算法list-then-eliminate">列表消除算法，List-Then-Eliminate</h3><ol type="1"><li>变型空间Version Space：假设空间H中所有假设的列表</li><li>对每个样例<spanclass="math inline">\(&lt;x,c(x)&gt;\)</span>，从变型空间中移除<spanclass="math inline">\(h(x)\neq c(x)\)</span>的假设h</li><li>输出变型空间中的假设列表</li></ol><p>要列出所有假设，在实际中往往不可能。</p><h2 id="变型空间">变型空间</h2><p>一致：一个假设h与训练样例集合D一致，当且仅当<spanclass="math inline">\(Consistent(h,D)\equiv(\forall&lt;x,c(x)&gt;\inD)\quad h(x)=c(x)\)</span>。</p><p>变型空间（Version Space）：</p><p>关于假设空间H和训练样例集合D的变型空间，是H中与训练样例D一致的所有假设构成的子集。<spanclass="math inline">\(VS_{H,D}\equiv\{h\inH|Consistent(h,D)\}\)</span></p><ul><li><p>极大泛化：H中和D一致的极大一般成员的集合</p><p><span class="math inline">\(G\equiv\{g\inH|Consistent(g,D)\and(\neg\exist g&#39;\in H[(g&#39;\gt_g g)\andConsistent(g&#39;,D)])\}\)</span></p></li><li><p>极大特化：H中和D一致的极大特殊成员的集合</p><p><span class="math inline">\(S\equiv\{s\inH|Consistent(s,D)\and(\neg\exist s&#39;\in H[(s\gt_s s&#39;)\andConsistent(s&#39;,D)])\}\)</span></p></li></ul><h3 id="表示定理">表示定理</h3><p>令X为任意的实例集合，H为X上定义的布尔函数集合。令<spanclass="math inline">\(c:X\rightarrow[0,1]\)</span>为X上定义的任一目标概念，并令D为任意训练样例的集合<spanclass="math inline">\(\{&lt;x,c(x)&gt;\}\)</span>。对所有的X，H，c，D以及良好定义的S和G：<spanclass="math inline">\(VS_{H,D}\equiv\{h\in H|(\exist s\in S)(\exist g\inG)[g\gt_g h\gt_s s]\}\)</span></p><ul><li>其中G为极大泛化集合，S为极大特化集合。</li></ul><h3 id="正例和反例的作用">正例和反例的作用</h3><p>正例用于S泛化，搜索S集合；反例用于G特化，缩小G集合。</p><p>反例对于超泛化具有抑制作用。</p><h3 id="候选消除算法">候选消除算法</h3><p>将G集合初始化为H中最一般的假设：<spanclass="math inline">\(G_0=\{&lt;?,...,?&gt;\}\)</span></p><p>将S集合初始化为H中最特殊的假设：<spanclass="math inline">\(S_0=\{&lt;\empty,...,\empty&gt;\}\)</span></p><p>对每个训练样例d，</p><ul><li><p>如果d是正例：</p><ul><li><p>从G中移去所有与d不一致的假设</p></li><li><p>对S中每一个与d不一致的假设s：</p><ul><li><p>从S中移除s</p></li><li><p>把s的所有极小泛化假设h加入到S中</p><p>h满足与D一致，而且G中某个成员比h更一般</p></li><li><p>从S中移去所有比S中另一假设更一般的假设</p></li></ul></li></ul></li><li><p>如果d是反例：</p><ul><li><p>从S中移去所有和d不一致的假设</p></li><li><p>对G中每一个与d不一致的假设g：</p><ul><li><p>从G中移除g</p></li><li><p>把g的所有极小特化假设h加入到G中</p><p>h满足与D一致，而且S中某个成员比h更特殊</p></li><li><p>从G中移去所有比G中另一假设更特殊的假设</p></li></ul></li></ul></li></ul><h3 id="归纳偏置">归纳偏置</h3><p>归纳推理的根本问题：</p><ul><li>目标概念假设不在假设空间怎么办？</li><li>能设计包含所有假设的空间吗？</li><li>假设空间大小对未见实例的泛化能力有什么影响？</li><li>假设空间大小对所需训练样例数量有什么影响？</li></ul><p>假设空间往往是合取的有偏表示，而真实空间是析取的无偏表示。</p><p>无偏学习的无用性：</p><p>无偏学习需要X中所有实例进行训练，无法进行泛化，变型空间和候选消除算法失效。</p><p>因此，归纳学习必须给定某种形式的预先假定，即归纳偏置。</p><ul><li><p>核心：学习器从训练样例中泛化并推断新实例分类过程中所采用的策略</p></li><li><p>精确定义：</p><ul><li><p>给定任意训练数据<spanclass="math inline">\(D_c=\{x,c(x)\}\)</span>，目标概念c，学习算法L</p></li><li><p>推断新实例性<span class="math inline">\(x_i\)</span></p></li><li><p>归纳推理过程为：</p><p><span class="math inline">\((D_c\and x_i)\rightarrowL(x_i,D_c)\)</span></p><p><span class="math inline">\((B\and D_c\and x_i)\vdashL(x_i,D_c)\)</span></p></li></ul><p>学习器的归纳偏置为附加的前提集合B，通过B，则归纳推理可由演绎推理派生</p></li></ul><h4 id="有偏性">有偏性</h4><ul><li>无归纳偏置</li><li><span class="math inline">\(c\in H\)</span></li><li><span class="math inline">\(c\inH\)</span>且任何实例，除非可由其他先验推出，否则为反例</li></ul><p>有偏性越强，则学习器的归纳能力越强。</p><p>有偏程度不同的三种归纳学习算法：</p><ul><li>机械式学习器</li><li>候选消除算法</li><li>Find-S</li></ul><h2 id="决策树学习">决策树学习</h2><ul><li><p>实例：“属性-值”对表示，应用最广的归纳推理算法之一</p></li><li><p>目标函数具有离散的输出值</p></li><li><p>很好的健壮性（样例可以包含错误，也可以处理缺少属性值的实例）</p></li><li><p>能够学习析取表达式</p></li></ul><p>决策树学习算法：</p><ul><li>ID3、Assistant、C4.5</li><li>搜索一个完整表示的假设空间，表示为多个if-then规则</li></ul><p>归纳偏置：优先选择较小的树</p><h3 id="算法框架">算法框架</h3><p>问题设置：</p><ul><li>可能的实例集X</li><li>未知的目标函数<span class="math inline">\(f:X\rightarrowY\)</span></li><li>假设函数集<span class="math inline">\(H=\{h|h:X\rightarrowY\}\)</span></li></ul><p>输入：未知目标函数f的训练样例<spanclass="math inline">\(\{&lt;x_i,y_i&gt;\}\)</span></p><p>输出：最佳近似f的假设<span class="math inline">\(h\in H\)</span></p><p>算法框架：</p><ol type="1"><li>处理基本情况</li><li>寻找最好的分类属性A</li><li>用A建立一个节点划分样例</li><li>递归处理每一个划分作为其子节点/子树</li></ol><h3 id="假设空间搜索">假设空间搜索</h3><p>搜索的假设空间就是可能的决策树的集合。</p><p>从一个假设空间中搜索一个正确拟合训练样例的假设。</p><p>从简单到复杂的爬山算法遍历假设空间。从空的树开始，然后逐步考虑更加复杂的假设。引导爬山搜索的评估函数是信息增益度量。</p><h3 id="如何选择最佳属性">如何选择最佳属性</h3><p>衡量给定的属性区分训练样例的能力：信息增益</p><p>信息的度量：熵，刻画了样例集合的纯度。</p><ul><li><p>目标属性为布尔值的样例集S的熵：</p><p><spanclass="math inline">\(Entropy(S)=-p_+log_2p_+-p_-log_2p_-\)</span></p><p>其中，<span class="math inline">\(p_+\)</span>为正例的概率，<spanclass="math inline">\(p_-\)</span>为反例的概率。</p></li><li><p>熵的一般定义：</p><p><spanclass="math inline">\(Entropy(S)=\Sigma_{i=1}^c(-p_ilog_2p_i)\)</span></p></li></ul><p>信息增益：使用属性分割样例，导致期望熵降低</p><p><span class="math inline">\(Gain(S,A)=Entropy(S)-\Sigma_{v\inValues(A)}\frac{|S_v|}{S}Entropy(S_v)\)</span></p><ul><li><p>其中<spanclass="math inline">\(Values(A)\)</span>是属性A所有可能值的集合</p></li><li><p><spanclass="math inline">\(S_v\)</span>是S中属性A的值为v的子集，即<spanclass="math inline">\(S_v=\{s\in S|A(s)=v\}\)</span></p></li><li><p>第二项是用A分类S后熵的期望值</p></li></ul><h3 id="用于学习布尔函数的id3算法">用于学习布尔函数的ID3算法</h3><p><span class="math inline">\(ID3(Examples,Attributes)\)</span></p><ol type="1"><li><p>创建树的Root结点</p></li><li><p>如果Examples的目标属性均为正，则返回label=+的单结点树Root</p></li><li><p>如果Examples的目标属性均为反，那么返回label=-的单结点树Root</p></li><li><p>如果Attributes为空，那么返回单结点树Root，label设置为Examples中最普遍的目标属性值</p></li><li><p>否则</p><ul><li><p><span class="math inline">\(A\leftarrowAttributes中分类Examples能力最好的属性\)</span></p></li><li><p><span class="math inline">\(Root的决策属性\leftarrowA\)</span></p></li><li><p><span class="math inline">\(对于A的每个可能值v_i\)</span></p><ul><li><p><spanclass="math inline">\(令Examples_{v_i}为Examples中满足A属性值为v_i的子集\)</span></p></li><li><p><span class="math inline">\(如果Examples_{v_i}为空\)</span></p><ul><li><p><spanclass="math inline">\(在这个分支下加一个叶子结点，\)</span></p><p><spanclass="math inline">\(结点的label设置为Examples中最普遍的目标属性值\)</span></p></li></ul></li><li><p><spanclass="math inline">\(否则，在这个分支下加一个子树ID3(Examples_{v_i},Attributes-\{A\})\)</span></p></li></ul></li></ul></li><li><p>结束，返回树Root</p></li></ol><h4 id="id3算法特点">ID3算法特点</h4><p>假设空间：包含所有的决策树</p><p>遍历过程：仅维持单一的当前假设</p><ul><li>变型空间候选消除算法维持满足训练样例的所有假设</li></ul><p>不进行回溯，局部最优</p><p>基于统计，对错误样例不敏感，不适用于增量处理。</p><p>改进算法：C4.5等。</p><h3 id="决策树学习中的归纳偏置">决策树学习中的归纳偏置</h3><p><span class="math display">\[ 搜索策略决定了归纳偏置\begin{cases}近似：优先选择较短的树\\ 有限选择信息增益高的属性更接近根结点的树\end{cases}\]</span></p><h3 id="奥卡姆剃刀原理">奥卡姆剃刀原理</h3><p>如果对于同一现象有两种不同的假说，应该采取比较简单的那一种。</p><ul><li>不是简单的选择最简化的假设，而是推理所依据的是使可证伪的假设的数目更少。</li></ul><h2 id="其他树算法">其他树算法</h2><h3 id="c4.5算法">C4.5算法</h3><p>属性选择指标：</p><p>信息增益率：信息增益/该属性的熵</p><ul><li>信息增益准则对可取值数目较多的属性有所偏好</li><li>避免对取值数目较少的属性有所偏好，采用以下启发式：<ul><li>先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的</li></ul></li></ul><h3 id="cart算法">CART算法</h3><h4 id="属性选择指标分类">属性选择指标（分类）</h4><p>信息增益和增益率准则均需要计算对数。</p><p>基尼指数：模型的纯度，越小纯度越高。</p><ul><li><p>K个分类：<spanclass="math inline">\(Gini(p)=\Sigma_{k=1}^K(1-p_k)p_k=1-\Sigma_{k=1}^Kp_k^2\)</span></p></li><li><p>数据集D：<spanclass="math inline">\(Gini(D)=1-\Sigma_{k=1}^K(\frac{C_k}{D})^2\)</span></p></li><li><p>属性A对数据集的划分：<spanclass="math inline">\(Gini(D,A)=\frac{|D_1|}{D}Gini(D_1)+\frac{|D_2|}{D}Gini(D_2)\)</span></p></li><li><p>基尼指数和熵是正相关的，均可用来表示一个集合的混乱程度，并作为叶子结点的损失</p></li></ul><h4 id="属性选择指标回归">属性选择指标（回归）</h4><p>采用方差和度量。</p><p>度量目标是对于划分特征A，对应划分点s两边的数据集<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>，求出使<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>各自集合的均方差最小，同时<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>的均方差之和最小。</p><p><span class="math inline">\(min_{A,s}[min_{c_1}\Sigma_{x_i\inD_1(A,s)}(y_i-c_i)^2+min_{c_2}\Sigma_{x_i\inD_2(A,s)}(y_i-c_2)^2]\)</span></p><p>回归树输出不是类别，采用叶子结点的均值或者中位数来预测输出结果。</p><h4 id="连续值处理">连续值处理</h4><p>连续特征离散化：</p><ul><li>C4.5基于信息增益率离散化，CART基于基尼系数离散化</li><li>m个样本的连续特征A有m个，从小到大排列<spanclass="math inline">\(a_1,...,a_m\)</span>，则CART取相邻两样本值的平均数做划分点，一共取m-1个，其中第i个划分点<spanclass="math inline">\(T_i\)</span>表示为：<spanclass="math inline">\(T_i= (a_i+a_{i+1})/2\)</span>。<ol type="1"><li>分别计算以这m-1个点作为二元分类点时的基尼系数。</li><li>选择基尼系数最小的点为该连续特征的二元离散分类点。</li><li>如取到的基尼系数最小的点为<spanclass="math inline">\(a_t\)</span>，则小于<spanclass="math inline">\(a_t\)</span>的值为类别1；大于<spanclass="math inline">\(a_t\)</span>的值为类别2，这样就做到了连续特征的离散化。</li></ol></li></ul><h4 id="离散值处理">离散值处理</h4><p>CART分类树算法：对离散值的处理，采用不停地二分离散特征。</p><ul><li><p>多叉树：在ID3、C4.5，特征A被选中，如果它有3个取值<spanclass="math inline">\(A_1,A_2,A_3\)</span>，则建立三叉子树</p></li><li><p>二叉树：</p><ul><li>CART将特征A分成<span class="math inline">\(\{A_1\}\)</span>和<spanclass="math inline">\(\{A_2,A_3\}\)</span>、<spanclass="math inline">\(\{A_2\}\)</span>和<spanclass="math inline">\(\{A_1,A_3\}\)</span>、<spanclass="math inline">\(\{A_3\}\)</span>和<spanclass="math inline">\(\{A_1,A_2\}\)</span>三种情况，找到基尼系数最小的组合，比如<spanclass="math inline">\(\{A_2\}\)</span>和<spanclass="math inline">\(\{A_1,A_3\}\)</span>，然后建立二叉树节点。</li><li>由于并没有把特征A的取值完全分开，后面还有机会对子节点继续选择特征A划分<spanclass="math inline">\(A_1\)</span>和<spanclass="math inline">\(A_3\)</span>。</li></ul></li></ul><h4 id="剪枝处理">剪枝处理</h4><p>后剪枝：从完全生长的决策树的底端剪去一些子树，使决策树变小，从而增强泛化能力。</p><ul><li>首先从生成算法产生的决策树<spanclass="math inline">\(T_0\)</span>底端开始不断剪枝，直到<spanclass="math inline">\(T_0\)</span>的根节点，形成一个子序列<spanclass="math inline">\(T_0,...,T_n\)</span></li><li>然后通过交叉验证在独立的验证集上对子树序列进行测试，从中选择最优子树。</li></ul><p>最小化子树的损失函数：<spanclass="math inline">\(C_a(T)=C(T)+a|T|\)</span></p><ul><li>T为任意子树，C(T)为对数据的预测误差（如基尼系数），|T|为子树叶结点个数。超参<spanclass="math inline">\(a\ge0\)</span>，权衡训练数据的拟合程度与模型的复杂度。</li><li>a比较大，则最优子树<span class="math inline">\(T_a\)</span>偏小</li><li>a比较小，则最优子树<span class="math inline">\(T_a\)</span>偏大</li><li>a=0，则最优子树等于未剪枝的<spanclass="math inline">\(T_0\)</span></li><li>a趋近于∞，则最优子树为根结点树</li></ul><h2 id="树学习算法优缺点">树学习算法优缺点</h2><h3 id="优点">优点</h3><ul><li><p>简单直观，可解释性强。</p></li><li><p>基本不需要预处理，也不需要提前归一化和处理缺失值。既可以处理离散值也可以处理连续值。不过很多算法只是专注于离散值或者连续值。</p></li><li><p>可以处理多维度输出的分类问题。</p></li><li><p>使用决策树预测的代价为<spanclass="math inline">\(O(log_2m)\)</span>，m为样本数。</p></li><li><p>可以交叉验证的剪枝来选择模型，从而提高泛化能力。</p></li><li><p>对于异常点的容错能力好，健壮性高。</p></li></ul><h3 id="缺点">缺点</h3><ul><li><p>树算法非常容易过拟合，导致泛化能力不强（设置节点最少样本树、限制树深度）</p></li><li><p>样本的一点变动会导致树结构的剧烈改变（集成学习）</p></li><li><p>寻找最优决策树是NP难题，通过启发式方法容易陷入局部最优（集成学习）</p></li><li><p>比较复杂的关系，决策树很难学习（使用其他学习方法）</p></li><li><p>如果某些特征的样本比例过大，生成决策树比较容易偏向于这些特征（调节样本权重）</p></li></ul><h3 id="延伸">延伸</h3><ul><li><p>BAIR博客地址：https://bair.berkeley.edu/blog/2020/04/23/decisions/</p></li><li><p>论文地址：https://arxiv.org/abs/2004.00221</p></li><li><p>开源项目地址：https://github.com/alvinwan/neu</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_02_无监督学习</title>
    <link href="/2023/09/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="无监督学习">无监督学习</h1><p>20230912</p><p>20:10-21:10</p><p>20230917</p><p>18:30-21:10</p><p>聚类算法 Clustering Algorithm</p><p>聚类的“好坏”不存在绝对标准。</p><h2 id="大纲">大纲</h2><ul><li>相关概念</li><li>距离度量</li><li>聚类准则</li><li>聚类方法</li><li>聚类评价</li></ul><h2 id="相关概念">相关概念</h2><p>聚类：数据对象的集合</p><ul><li>在同一个类里，数据对象是相似的</li><li>不同类的数据对象是不相似的</li></ul><p>聚类算法：根据给定的相似性评判标准，将一个数据集合划分为几个聚类。</p><ul><li><p>数学形式化：</p><p>样本集合：<span class="math inline">\(D=\{x_1,x_2,...,x_m\},x_i\inR^d\)</span></p><p>聚类成k个簇：<span class="math inline">\(\{C_l|l=1,2,...,k\}\)</span></p></li><li><p>好的聚类算法：聚类内部高相似，聚类之间低相似。</p></li></ul><p>聚类的依据：将整个数据集中每个样本的特征向量看成是分布在特征空间中的一些点，点与点之间的距离即可作为相似性度量依据。</p><p>聚类方法目的：寻找数据中潜在的自然分组结构、感兴趣的关系。</p><p>聚类方法的有效性和数据分布形式有很大关系。</p><h2 id="距离度量">距离度量</h2><p>目的：度量同类样本间的相似性或不同样本间的差异性</p><h3 id="度量函数和度量空间">度量函数和度量空间</h3><h3 id="常用度量函数">常用度量函数</h3><p>闵可夫斯基距离</p><h2 id="聚类准则">聚类准则</h2><h3 id="类的定义">类的定义</h3><h3 id="试探方法">试探方法</h3><p>凭直观感觉或方法，针对实际问题定义一种距离度量的阈值，然后按最近邻规则制定某些样本属于一个聚类类别。</p><h3 id="聚类准则函数方法">聚类准则函数方法</h3><h2 id="聚类方法">聚类方法</h2><ul><li>基于试探的聚类搜索算法</li><li>系统聚类法</li><li>动态聚类法</li></ul><h3 id="基于试探的聚类搜索算法">基于试探的聚类搜索算法</h3><h4 id="按最近邻规则的简单试探法">按最近邻规则的简单试探法</h4><p>选用不同的阈值和起始点来试探。</p><p>依赖于以下因素：</p><ul><li>第一个聚类中心的位置</li><li>待分类样本的排序次序</li><li>距离阈值T的大小</li><li>样本分布的几何性质</li></ul><h4 id="最大最小距离算法">最大最小距离算法</h4><p>基本思想：以试探类间欧式距离为最大作为预选出聚类中心的条件。</p><ol type="1"><li>任选一个样本作为第一个聚类中心</li><li>选距离其最远的样本为第二个聚类中心</li><li>逐个计算各样本与两个聚类中心间距离，并选取其中较小值</li><li>在所有较小值中选出最大距离，若该最大值达到一定阈值，则选取相应样本点为迪桑聚类中心</li><li>重复3、4步，若无新聚类中心，进入下一步</li><li>不同样本按最近距离分到最近的聚类中心</li><li>最后，在每一类中计算各样本均值以得到更具代表性的聚类中心。</li></ol><h3 id="系统聚类法">系统聚类法</h3><p>基本思想：</p><p>将数据样本按距离准则逐步分类，类别有多到少，直到获得合适的分类要求为止。</p><h4 id="距离准则函数">距离准则函数</h4><ul><li>最短距离（两个集合所有距离最小值）</li><li>最长距离（两个集合所有距离最大值）</li><li>类平均距离（两个集合所有距离平均值）</li></ul><h3 id="动态聚类法">动态聚类法</h3><p>基本思想：</p><p>首先选择若干个样本点作为聚类中心，再按某种聚类准则使样本点向各中心聚集，从而得到初始聚类；然后判断初始分类是否合理，若不合理，则修改聚类，如此反复，直至合理。</p><p>代表算法：K-means算法和ISODATA算法（迭代自组织数据分析算法）</p><h4 id="k-means算法">K-means算法</h4><ol type="1"><li>选择一个聚类数量k</li><li>初始化聚类中心<ul><li>随机选择k个样本点，设置这些样本点为中心</li></ul></li><li>对每个样本点，计算样本点到k个聚类中心的距离，将样本点分距离它最近的聚类中心所属的聚类</li><li>重新计算聚类中心，聚类中心为属于这一聚类的所有样本的均值</li><li>如果没有发生样本所属的聚类改变的情况则退出，否则，返回第三步重复</li></ol><p>K-means算法的结果影响因素：</p><ul><li>所选聚类数目</li><li>聚类中心的初始分布</li><li>样本分布的几何性质</li></ul><p>在实际应用中，需要试探不同的K值和选择不同的聚类中心的起始值。</p><p>如果数据样本可以形成若干个相距较远的孤立区域分布，一般都能得到较好的收敛效果。</p><ul><li>K-means算法比较适合于分类数目已知的情况。</li></ul><h5 id="k-means">K-means++</h5><p>基本思想：K个初始聚类中心相互之间应该分得越开越好</p><ol type="1"><li>从数据集中随机选取一个样本作为初始聚类中心</li><li>首先计算每个样本与当前已有聚类中心之间的最短距离（即与最近的一个聚类中心的距离），用D(x)表示；接着计算每个样本被选为下一个聚类中心的概率<spanclass="math inline">\(\frac{D(x)^2}{\Sigma_{x\inX}D(x)^2}\)</span>，最后，按轮盘法选择下一个聚类中心</li><li>重复第2步选择出共K个聚类中心</li><li>K-means中第3步至第5步</li></ol><h4 id="迭代自组织数据分析算法-isodata">迭代自组织数据分析算法ISODATA</h4><p>基本步骤与思路：</p><ol type="1"><li>选择某些初始值，可选不同的参数，也可在迭代过程中人为修改，以将N个样本按指标分配到各个聚类中心去</li><li>计算各类中诸样本的距离指标函数</li><li>按给定的要求，将前一次获得的聚类集合进行分裂和合并处理，从而获得新的聚类中心</li><li>重新进行迭代运算，计算各项指标，判断聚类结果是否符合要求。经过多次迭代后，若结果收敛，则运算结束。</li></ol><p>具体过程（运行中能够根据各个类别的实际情况进行分裂和合并来调整聚类中心数）：</p><ol type="1"><li>从数据集中随机选取<spanclass="math inline">\(K_0\)</span>个样本作为聚类中心<spanclass="math inline">\(C=\{c_1,...,c_{K_0}\}\)</span></li><li>针对数据集中每个样本<spanclass="math inline">\(x_i\)</span>，计算它到<spanclass="math inline">\(K_0\)</span>个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中</li><li>判断上述每个类中的元素数目是否小于<spanclass="math inline">\(N_{min}\)</span>。如果小于<spanclass="math inline">\(N_{min}\)</span>则需要丢弃该类，令<spanclass="math inline">\(K=K-1\)</span>，并将该类中的样本重新分配给剩下类中距离最小的类</li><li>针对每个类别<spanclass="math inline">\(c_i\)</span>，重新计算它的聚类中心$c_i=_{xc_i}x</li><li>如果当前<spanclass="math inline">\(K\le\frac{K_0}{2}\)</span>，说明当前类别太少，前往分裂</li><li>如果当前<span class="math inline">\(K\ge2K_0\)</span>，说明当前类别太多，前往合并</li><li>如果达到最大迭代次数则终止，否则返回第2步继续执行</li></ol><p>合并</p><ol type="1"><li><p>计算当前所有类别聚类中心两两之间的距离，用矩阵D表示，其中<spanclass="math inline">\(D(i,i)=0\)</span></p></li><li><p>对于<span class="math inline">\(D(i,j)\lt d_{min}(i\neqj)\)</span>的两个类别需要进行合并操作，变成一个新的类，该类的聚类中心位置为<spanclass="math inline">\(m_{new}=\frac{1}{n_i+n_j}(n_im_i+n_jm_j)\)</span></p><p>上述<span class="math inline">\(n_i\)</span>和<spanclass="math inline">\(n_j\)</span>表示这两个类别中样本的个数，新的聚类中心可以看作对这两个类别进行加权求和。如果其中一个类所包含的样本个数较多，所合成的新类就会更加偏向它。</p></li></ol><ul><li><spanclass="math inline">\(d_{min}\)</span>：两个类别对应聚类中心之间所允许最小距<spanclass="math inline">\(d_{min}\)</span>，是否进行合并的阈值</li></ul><p>分裂</p><ol type="1"><li><p>计算每个类别下所有样本在每个维度下的方差</p></li><li><p>针对每个类别的所有方差挑选出最大的方差<spanclass="math inline">\(\sigma_{max}\)</span></p></li><li><p>如果某个类别的<span class="math inline">\(\sigma_{max}\gtSigma\)</span>并且该类别所包含的样本数量<spanclass="math inline">\(n_i\ge2n_{min}\)</span>，则可以进行分裂操作4，否则退出</p></li><li><p>将满足步骤3中的类分裂成两个子类别并令<spanclass="math inline">\(K=K+1\)</span></p><p><spanclass="math inline">\(m_i^{(+)}=m_i+\sigma_{max},m_i^{-}=m_i-\sigma_{max}\)</span></p></li></ol><ul><li>最大方差Sigma</li></ul><h4 id="两个算法的比较">两个算法的比较</h4><ul><li>K-means算法通常适合于类别数目已知的聚类，而ISODATA算法则更加灵活</li><li>从算法角度看，两者相似，聚类中心都是通过样本均值的迭代计算决定</li><li>ISODATA算法加入了一些试探步骤，并且可以结合人机交互的结构，使其能利用中间结果所取得的经验更好地进行分类</li><li>ISODATA原理直观，但需要更多参数，并且某些参数很难确定，因此ISODATA算法实际过程中并没有很受欢迎</li></ul><h2 id="聚类评价">聚类评价</h2><p>几个评价指标：</p><ul><li>聚类中心之间的距离</li><li>聚类域中的样本数目</li><li>聚类域内样本的距离方差</li></ul><p>聚类目前还没有一种通用的准则，往往需要根据实际应用来选择合适的方法。</p><h3 id="常用评价指标标签未知">常用评价指标（标签未知）</h3><h4 id="紧密度compactnesscp">紧密度（Compactness，CP）</h4><p><spanclass="math inline">\(\overline{CP}=\frac{1}{K}\Sigma_{k=1}^K\overline{CP_k}\)</span></p><p>缺点：没有考虑类间聚类效果。</p><h4 id="间隔度separationsp">间隔度（Separation，SP）</h4><p><spanclass="math inline">\(\overline{SP}=\frac{2}{k^2-k}\Sigma_{i=1}^k\Sigma_{j=i+1}^k||w_i-w_j||_2\)</span></p><p><span class="math inline">\(w_i\)</span>表示第i簇的中心，<spanclass="math inline">\(w_j\)</span>表示第j簇的中心，<spanclass="math inline">\(\overline{SP}\)</span>值越大类间越分散。</p><p>缺点：没有考虑类内聚类效果</p><h4 id="davies-bouldin-indexdbi分类适确性指标">Davies-BouldinIndex(DBI)，分类适确性指标</h4><p><span class="math inline">\(DB=\frac{1}{k}\Sigma_{i=1}^kmax_{j\neqi}(\frac{\overline{C_i}+\overline{C_j}}{||w_i-w_j||_2})\)</span></p><p><spanclass="math inline">\(\overline{C_i}\)</span>表示第i簇的紧密度，<spanclass="math inline">\(w_i\)</span>表示第i簇的中心。</p><p>DB越小，表示类内越紧凑，类间越分散，</p><p>缺点：使用欧式距离，对于环状分布聚类评价很差</p><h4 id="dunn-validity-indexdvi邓恩指数">Dunn ValidityIndex(DVI)，邓恩指数</h4><p>缺点：对离散点的聚类评价高，对环状分布评价效果差</p><h3 id="常用评价指标标签已知">常用评价指标（标签已知）</h3><ul><li>Cluster Accuracy，CA，聚类准确率</li><li>Rand Index，RI，兰德指数</li><li>Adjusted Rand Index，ARI，调整兰德指数</li><li>Mutual Information，MI，互信息</li><li>Normalized Mutual Information，NMI，归一化互信息</li></ul><h2 id="前沿进展">前沿进展</h2><p>监督深度学习：</p><ol type="1"><li>收集大量具有差异性的样本</li><li>对数据进行清洗和精细标注</li><li>采用多块显卡长时间训练</li></ol><p>监督深度学习的困境：</p><ul><li>数据体量大</li><li>数据标注时间长</li><li>数据标注代价高</li></ul><p>现实中，获取原始未标注数据较容易，而典型的监督学习技术不能利用这些数据；</p><p>监督信号有时候会使得深度模型有偏。</p><h3 id="自监督学习">自监督学习</h3><p>无监督学习的一种形式，其中数据没有提供（人类标注的）监督信息。</p><ul><li>通常需要定义一个前置任务让网络学习我们关心的事情。</li><li>对于大部分前置任务，我们需要保留一部分数据，让网络学会预测。</li><li>从前置任务学习到的特征会被用到不同的下游任务（通常包含标注）</li></ul><p>自监督预训练：</p><ul><li>无标注数据</li><li>前置任务预训练</li></ul><p>下游任务迁移：</p><ul><li>有标签数据</li><li>训练测试数据集可不同</li><li>多种下游任务测试</li></ul><h4 id="自监督学习分类">自监督学习分类</h4><ul><li>前置任务学习</li><li>对比学习</li><li>非对比学习</li></ul><h4 id="前置任务学习">前置任务学习</h4><ul><li><p>生成式方法——图像着色</p></li><li><p>生成式方法——图像修复</p></li><li><p>判别式方法——图像拼图</p></li></ul><h4 id="对比学习">对比学习</h4><h4 id="非对比学习">非对比学习</h4>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_01_概率与学习-KNN</title>
    <link href="/2023/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%A6%82%E7%8E%87%E4%B8%8E%E5%AD%A6%E4%B9%A0-KNN/"/>
    <url>/2023/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%A6%82%E7%8E%87%E4%B8%8E%E5%AD%A6%E4%B9%A0-KNN/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="概率与学习-knn">概率与学习-KNN</h1><p>20230912</p><p>18:30-20:10</p><h2 id="大纲">大纲</h2><ol type="1"><li>回顾</li><li>k-近邻分类器</li><li>最近邻分类器</li><li>k-近邻回归</li><li>降低近邻计算</li><li>扩展阅读</li></ol><h2 id="回顾">回顾</h2><p>统计学角度：机器学习的目的是得到映射 <spanclass="math display">\[x\rightarrow y\]</span></p><p>对不同类型的数据用手工/自动的方式进行特征工程，得到特征向量。</p><p>分类问题</p><ul><li>训练集：<spanclass="math display">\[D_{train}=\{(x_1,y_1),(x_2,y_2),...,(x_n,y_n)\}\]</span></li><li>训练样本：<span class="math display">\[x_i\in X\in R^d\]</span></li><li>样本标签：<span class="math display">\[y_i\inY=\{1,2,...,C\}\]</span></li><li>测试集：<spanclass="math display">\[D_test=\{\bar{x}_1,\bar{x}_2...\bar{x}_m\}\]</span></li></ul><p>回归问题</p><ul><li>训练集：<spanclass="math display">\[D_{train}=\{(x_1,y_1),(x_2,y_2),...,(x_n,y_n)\}\]</span></li><li>训练样本：<span class="math display">\[x_i\in X\in R^d\]</span></li><li>样本标签：<span class="math display">\[y_i\in R\]</span></li><li>测试集：<spanclass="math display">\[D_test=\{\bar{x}_1,\bar{x}_2...\bar{x}_m\}\]</span></li></ul><p>距离度量</p><ul><li>欧式距离</li><li>余弦相似性</li><li>曼哈顿距离</li><li>切比雪夫距离</li><li>马氏距离</li></ul><h2 id="k-近邻分类器">k-近邻分类器</h2><p>k-Nearest Neighbor Classfier, k-NN</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择k个最近（距离最小/相似度最大）的训练样本</li><li>采用投票法，将近邻中样本数最多的类别标签分配给<spanclass="math inline">\(\bar{x}\)</span></li></ul><p>k的取值的影响</p><ul><li>k一般取奇数值，避免平局</li><li>k取不同的值，分类结果可能不同</li><li>k值较小时，对噪声敏感，整体模型变得复杂，容易过拟合</li><li>k值较大时，对噪声不敏感，整体模型变得简单，容易欠拟合</li></ul><h2 id="最近邻分类器">最近邻分类器</h2><p>1-Nearest Neighbor Classfier, 1-NN</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择最近（距离最小/相似度最大）的训练样本<spanclass="math inline">\(i^*=argmax d(\bar{x},x_i)\)</span></li><li>采用投票法，将<spanclass="math inline">\(x_{i^*}\)</span>的类别标签分配给<spanclass="math inline">\(\bar{x}\)</span></li></ul><p>泛化错误率</p><ul><li>最近邻分类器的泛化错误率（测试样本x，其最近邻为z）<ul><li><span class="math inline">\(P(error)=1-\Sigma_{c\iny}P(c|x)P(c|z)\)</span></li></ul></li><li>贝叶斯最优分类器的结果：<spanclass="math inline">\(2\times(1-P(c^*|x))\)</span></li></ul><p>最近邻分类器虽然简单，但泛化错误率不超过贝叶斯分类器的两倍。</p><h2 id="k-近邻回归">k-近邻回归</h2><p>k-Nearest Neighbor Regression</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择k个最近（距离最小/相似度最大）的训练样本</li><li>将距离值的倒数作为权重，将k个近邻的标签值加权平均，作为<spanclass="math inline">\(\bar{x}\)</span>的预测值</li></ul><p>近邻平滑：核平滑法（kernel smoother）</p><ul><li>二次核</li><li>次方核</li><li>高斯核</li></ul><h2 id="讨论">讨论</h2><ul><li><p>k-NN是典型的“懒惰学习”。</p><p>训练阶段仅仅是把样本保存起来，训练时间开销为零，待收到测试样本后再进行处理。</p></li><li><p>SVM、CNN等是“急切学习”。</p><p>在训练阶段就对样本进行学习处理的方法，这类方法尝试在训练期间构造一个通用的与输入无关的目标函数。</p></li></ul><p>k-近邻分类器的优缺点</p><ul><li>优点<ul><li>精度高</li><li>对异常值不敏感</li><li>无数据输入假定</li></ul></li><li>缺点<ul><li>计算复杂度高</li><li>空间复杂度高</li></ul></li></ul><p>时间复杂度</p><ul><li>假设<spanclass="math inline">\(d(x_i,x_j)\)</span>是欧式距离，时间复杂度为<spanclass="math inline">\(O(d)\)</span></li><li>训练阶段：0</li><li>测试阶段：<span class="math inline">\(O(nd+nlogk)\)</span><ul><li>从n个数中选择k个最小的，时间复杂度为<spanclass="math inline">\(nlogk\)</span></li></ul></li><li>空间复杂度是？</li></ul><h2 id="降低计算">降低计算</h2><ul><li>特征维度2-5：维诺图</li><li>特征维度6-30：KD-Tree</li><li>特征高维：<ul><li>降维算法，如主成分分析（Principle Component Analysis）PCA</li><li>近似最近邻（approximate nearest neighbor, ANN）</li><li>哈希（hashing）</li></ul></li></ul><h3 id="维诺图">维诺图</h3><p>根据一组给定的目标，将一个平面划分成靠近每一个目标的多个区块。</p><ul><li><p>维诺图由一系列维诺单元组成，每个维诺单元是一个凸多面体</p><ul><li><p>假设X是一个点集，包含K个基点<spanclass="math inline">\((P_k)_{k\in K}\)</span>，那么维诺单元<spanclass="math inline">\(R_k\)</span>定义为：</p><p><span class="math inline">\(R_k=\{x\in X|d(x,P_k)\le d(x,P_j),\forallj\neq k\}\)</span></p></li></ul></li><li><p>查询或测试：给定一个查询<span class="math inline">\(q\inR^d\)</span>，找到<span class="math inline">\(P_k\inX\)</span>，使得<span class="math inline">\(q\in R_k\)</span></p></li><li><p>时间复杂度：</p><ul><li>2维数据：<spanclass="math inline">\(O(nlogn)\)</span>用来计算维诺图；</li><li>d维数据：使用二叉空间分割树进行点的定位，但是时间估计困难，难以量化</li></ul></li><li><p>适用范围：1-NN</p></li><li><p>适合特征维度：2～3维，可能4～5维</p></li></ul><h3 id="kd树">KD树</h3><p>KD树是一种对K维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。</p><p>KD树是二叉树，表示对K维空间的一个划分，构造KD树相当于不断用垂直于坐标轴的超平面将K维空间切分，构成一系列K维超矩形区域。KD树的每个结点对应于一个K维超矩形区域。</p><p>构造流程：</p><ol type="1"><li>确定split域。计算每个特征维度的方差，选定方差最大维度为split域。</li><li>确定Node-data域。</li><li>对剩下的数据点进行划分，确定左右子空间。</li><li>递归。在每个子空间继续进行空间划分，直到空间中只包含一个数据点。</li></ol><p>KD树搜索</p><ol type="1"><li>二叉搜索</li><li>回溯分析</li><li>返回最近邻</li></ol><p>时间复杂度</p><ul><li><p>寻找最近邻的时间复杂度为<spanclass="math inline">\(O(logn)\)</span></p></li><li><p>找到中位数的算法时间复杂度为<spanclass="math inline">\(O(n)\)</span></p></li><li><p>KD树搜索时间复杂度为<spanclass="math inline">\(O(nlogn)\)</span></p></li></ul><h3 id="降维">降维</h3><p>核心思想：通过某种数学变换将原始高维属性空间转变为一个低维子空间，来缓解维数灾难问题。</p><ul><li>多维缩放</li><li>主成分分析</li><li>局部线性潜入</li><li>ISOMAP</li></ul><h3 id="近似最近邻">近似最近邻</h3><p>核心思想：搜索可能是最近邻的数据项而不再只限于返回最可能的数据项，在牺牲可接受范围内的精度的情况下提高检索效率。</p><ul><li>不要求一定是距离最短的k个</li><li>如第k个最近邻，其距离为<spanclass="math inline">\(d_k\)</span>，则ANN要求其选取的所有k个样例的距离<spanclass="math inline">\(\hat{d}\le(1+\varepsilon)d_k\)</span></li><li>可以将k-NN搜索速度提高几个数量级</li></ul><p>FLANN：https://github.com/mariusmuja/flann</p><h3 id="哈希">哈希</h3><p>核心思想：利用哈希函数把任意长度的输入映射为固定长度的输出</p><h2 id="扩展阅读">扩展阅读</h2><h3 id="概率化k-nn">概率化k-NN</h3><p>通过定义似然函数来构造概率化的k-NN。</p><p>https://www.cc.gatech.edu/~afb/classes/CS7616-Spring2014/slides/CS7616-13a-PKNN.pdf</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_6_软件系统</title>
    <link href="/2023/09/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/6_%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/09/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/6_%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第六章-嵌入式软件系统">第六章 嵌入式软件系统</h1><h2 id="概述">1. 概述</h2><h3 id="嵌入式软件与桌面软件的对比">嵌入式软件与桌面软件的对比</h3><p>内存：有限</p><p>CPU：往往只是恰好满足要求</p><p>操作系统：Windows、Linux、RTOS、专有操作系统、裸机</p><p>实时行为：可预测、实时性</p><p>开发流程：资源少，交叉开发；代码需要在特定环境下运行</p><p>执行流程：多数嵌入式设备自开启起就会持续运行某个程序至系统关机</p><ul><li>该程序可能存储在ROM，也可能是从非易失性存储器转移到RAM中执行。</li></ul><p>每个嵌入式设备都不同：</p><ul><li>技术层面：不同的CPU架构、内存、外设、应用程序和操作系统。</li><li>商业运作层面的，比如手机开发、生产的商业模式就和核磁共振扫描仪完全不同。</li></ul><p>软件组件：适合嵌入式环境的库；与硬件交互的接口；网络支持；数据存储；GUI</p><h3 id="软硬件权衡">软硬件权衡</h3><p>软件主导硬件，有关硬件的决策会对软件产生影响。</p><p>软硬件可能是不同团队进行开发。</p><ul><li>微处理器的选择：可能影响软件效率</li><li>内存大小和组合</li><li>包含的外设</li></ul><h3 id="调试">调试</h3><p>在线仿真器ICE（In-Circuit Emulator）</p><ul><li><p>模拟CPU的功能，可以完全仿真芯片的行为</p></li><li><p>价格昂贵，难以普及，没有广泛使用</p></li></ul><p>监控调试器</p><ul><li><p>需要通信通道</p></li><li><p>因为占用系统资源的问题，在一些严格的场合下不适合使用</p></li></ul><p>片上调试</p><ul><li><p>例如，JTAG是边界扫描测试的一个标准协议，SWD（Serial WireDebug）仿真器</p></li><li><p>价格便宜，易于实现</p></li><li><p>广泛使用</p></li></ul><h3 id="自检">自检</h3><p>输入/输出电路</p><p>板载开关：用于配置或模式选择</p><p>状态显示：字符或LED（3种状态：开、关、闪烁）</p><h3 id="软件系统层次结构">软件系统层次结构</h3><figure><img src="/image/嵌入式系统概论/软件系统层次结构.png"alt="软件系统层次结构" /><figcaption aria-hidden="true">软件系统层次结构</figcaption></figure><h3 id="可视化程序模型">可视化程序模型</h3><p>将实时应用视为单个/多个执行线程</p><h4 id="单线程程序模型">单线程程序模型</h4><p>优点：</p><ul><li><p>编程和再编程非常快速简单</p></li><li><p>改变系统响应特性的同时，往模型上添加新功能插件也相当容易</p></li></ul><p>缺点：</p><ul><li><p>在于应用领域的限制</p></li><li><p>难以做到安全地再编程</p></li><li><p>很难应用到不同行为或不同环境的运行系统中去</p></li></ul><h4 id="多线程程序模型">多线程程序模型</h4><p>优点：</p><ul><li><p>允许将系统工作划分为几个逻辑阶段，然后编写相互独立的程序来处理各自的工作</p></li><li><p>所有处理过程并行</p></li><li><p>如果有更高吞吐量的需求，工程师可以在任务中引入新的通信和协作模型</p></li></ul><p>缺点：可能引入资源竞争</p><h4 id="建立模型的好处">建立模型的好处</h4><p>辅助测试和完善最终系统。</p><p>模型利用它所知的系统属性来描述整个系统，并能够被用于对系统特性的进一步研究。</p><p>使用程序模型开发软件和硬件，便于将整个实时系统全盘考虑。</p><p>模型使得工程师能够预测程序的运行，从而满足系统的性能需求和功能需求。</p><h4 id="模型之间的差异">模型之间的差异</h4><p>一些模型易于编写，但调试不易；一些模型难于编写，但调试容易。</p><p>一些模型使得程序运行得更快，但需要付出更多内存资源消耗的代价。</p><p>模型准确性与鲁棒性。</p><h2 id="设计模式">2. 设计模式</h2><h3 id="嵌入式软件架构模式">嵌入式软件架构模式</h3><p>分为业务逻辑与实时依赖硬件的逻辑，抽象层将所需操作的高级请求转换为低级命令。<imgsrc="/image/嵌入式系统概论/嵌入式软件架构.png"alt="嵌入式软件架构" /></p><p>对于基于微控制器的系统来说，最常用的架构模式有：</p><ul><li>非结构化单体架构</li><li>分层架构</li><li>事件驱动架构</li><li>微服务架构</li></ul><h4 id="非结构化单体架构">非结构化单体架构</h4><p>应用和与之相连的多个模块，模块之间也可以相互连接</p><ul><li>容易构建，难以维持规模和移植</li><li>与应用层的应用程序紧密耦合</li></ul><h4 id="分层架构">分层架构</h4><p>将应用程序的逻辑划分为若干独立的层，仅通过定义良好的抽象层进行交互。</p><ul><li><p>试图通过将应用程序分解为独立的层来改善非结构化单体架构的高耦合性。</p></li><li><p>最常用。</p></li><li><p>例：应用层、中间件层、操作系统层、驱动层、硬件层</p></li></ul><h4 id="事件驱动架构">事件驱动架构</h4><p>利用中断来立即响应事件。</p><ul><li>事件驱动的体系结构通常使用消息队列、信号量和事件标志来表示系统中发生了事件。</li><li>对于实时嵌入式应用程序和与能耗相关的应用程序非常有意义。</li><li>优点：可扩展、软件模块高内聚、低耦合。</li><li>缺点：无论何时需要做任何事，都有额外的开销和复杂性。</li></ul><h4 id="微服务架构">微服务架构</h4><p>将应用程序构建为为业务领域开发的小型自治服务的集合。</p><ul><li><p>微服务本质上是低耦合的，这使得它易于维护、可测试，可以快速扩展或移植。</p></li><li><p>微服务是围绕系统的业务逻辑组织的。</p><ul><li>业务逻辑：系统行为的业务规则和用例。</li></ul></li><li><p>缺点：</p><ul><li>在架构上，增加设计的复杂性；</li><li>由于具有其他体系结构中可能不需要的通信特性，它们可能会增加额外的开销和内存需求；</li><li>架构的分散性也意味着实时的、确定性的行为可能更具挑战性，实时和响应可能有额外的抖动；</li><li>可能会增加开发时间和预算。</li></ul></li></ul><h4 id="微内核架构microkernel-architecture">微内核架构，MicrokernelArchitecture</h4><p>也称插件化(Plug-in)架构，是一种面向功能拆分的可扩展架构。</p><ul><li>包含核心系统和插件模块。</li><li>具备模块化解耦、弹性部署的能力以及安全稳定的特性，非常符合物联网的发展。</li><li>进程间通信性能相对较低。</li></ul><h3 id="管理外设数据">管理外设数据</h3><p>轮询、中断、直接存储器访问（DMA）</p><h4 id="外设轮询">外设轮询</h4><p>让应用程序定期轮询外设，查看是否有任何数据可供管理和处理。</p><ul><li>优先级：无，按顺序运行</li><li>响应时间：所有任务的总和</li><li>变化的影响：修改任务的执行时间或添加任务会影响所有其他任务</li><li>优点：简单，没有共享数据问题</li><li>缺点：浪费处理周期；在处理外设时可能会有很多抖动和延迟</li></ul><h4 id="有限状态机">有限状态机</h4><p>只执行当前状态，每个状态决定下一个状态（非顺序执行）。</p><ul><li>优先级：每个状态决定下一个状态的优先级</li><li>响应时间：所有任务的总和</li><li>变化的影响：修改任务的执行时间或添加任务会影响所有其他任务</li><li>同样没有共享数据问题</li></ul><h4 id="中断设计模式">中断设计模式</h4><p>中断应用程序的正常流程，以允许中断处理程序运行代码来处理系统中发生的事件。</p><p>当设计ISR时，我们希望中断尽可能快地运行（最小化中断）。</p><ul><li><p>避免内存分配操作，如声明非静态变量、操作堆栈或使用动态内存</p></li><li><p>尽量减少函数调用，以避免时钟周期开销、不可重入函数或阻塞函数的问题</p></li></ul><h5 id="带有中断的轮询">带有中断的轮询</h5><ul><li><p>优先级：中断优先于主循环，中断的优先级</p></li><li><p>反应时间：所有任务的总和或中断执行时间</p></li><li><p>变更的影响：对中断服务例程的影响较小。与主循环的轮询相同。</p></li><li><p>共享数据：必须处理与中断服务例程共享的数据</p></li><li><p>优势：</p><ul><li><p>不需要浪费CPU周期来检查数据是否准备好</p></li><li><p>获取数据的延迟是确定的</p></li><li><p>抖动被最小化</p></li></ul></li><li><p>缺点：</p><ul><li>中断的设置可能比较复杂</li><li>必须小心不要使用频繁触发的中断</li><li>当使用中断来接收数据时，开发人员必须仔细管理他们在ISR中所做的工作。开发人员经常需要使用ISR来处理所需的即时操作，然后将处理和非紧急的工作卸载给应用程序，从而增加了软件设计的复杂性。</li></ul></li></ul><h5id="数据获取存储相关的中断设计模式">数据获取/存储相关的中断设计模式</h5><ul><li>线性数据存储</li><li>双缓冲区</li><li>环形/循环缓冲区</li><li>带有信号量的循环缓冲区</li><li>带有事件标志的循环缓冲区</li><li>消息队列</li></ul><p>线性数据存储：</p><ul><li><p>中断服务程序可以直接访问共享内存位置</p></li><li><p>线性数据存储可能是危险的：</p><ul><li>线性数据存储是经常遇到竞态条件的地方</li><li>用于存储应用程序和ISR之间的数据的共享变量也需要声明为volatile，以防止编译器优化</li></ul></li><li><p>数据存储必须由互斥锁保护，以防止竞态条件</p></li></ul><p>双缓冲区：可以缓解数据存储的一些竞态条件问题。</p><p>环形缓冲区：</p><p>环形缓冲区（Circular Buffer），也被称为循环缓冲区（CyclicBuffer）或者环形队列（RingBuffer），是一种数据结构类型，它在内存中形成一个环形的存储空间。</p><ul><li><p>特点：终点和起点相连形成一个环状结构。</p></li><li><p>在处理流数据和实现数据缓存等场景中具有广泛的应用。</p></li><li><p>在中断中接收到的实时数据可以从外设中移除并存储在循环缓冲区中。因此，中断可以尽可能快地运行，同时允许应用程序代码自行处理循环缓冲区。使用循环缓冲区有助于确保数据不丢失，中断速度快，合理地处理数据。</p></li></ul><p>带有通知的循环缓冲区：</p><ul><li>应用程序需要轮询缓冲区以查看是否有新的可用数据。<ul><li>信号量和事件标志</li></ul></li><li>在大多数实时操作系统中，使用事件标志比使用信号量更有效。</li></ul><p>消息队列：</p><ul><li><p>类似于使用带有信号量的线性缓冲区。</p></li><li><p>通常需要更多的RAM、ROM和处理能力。</p></li></ul><h4 id="dma">DMA</h4><p>无需CPU的交互情况下在RAM和外设之间以及内部传输数据。</p><ul><li><p>RAM到RAM</p></li><li><p>外设到RAM</p></li><li><p>外设到外设</p></li></ul><p>DMA控制器可以显著提高外设和应用程序之间的数据吞吐量。此外，可以利用DMA控制器减轻CPU运行ISR来传输数据的负担，并最大限度地减少浪费的计算周期。</p><h3 id="实时嵌入式软件常用设计模式">实时嵌入式软件常用设计模式</h3><p>单核</p><p>多核</p><p>发布和订阅模型</p><p>RTOS模式</p><p>处理中断和低功耗设计</p><h4 id="多核架构">多核架构</h4><p>同构多核，对称多核处理具有相同处理器架构的两个核。</p><p>异构多核架构，每个处理核心都有不同的底层架构。</p><h4 id="发布和订阅模型">发布和订阅模型</h4><p>在物联网领域广泛使用，ROS也使用。</p><ul><li>在许多情况下，物联网设备将启动电源，连接到云，然后订阅它想要接收的消息主题。该设备甚至还可以发布特定的主题。</li></ul><p>缺点：会导致应用程序占用更大的内存。</p><h4 id="rtos应用程序设计模式">RTOS应用程序设计模式</h4><p>资源同步：对共享资源的访问是否安全</p><ul><li>确保需要访问资源的多个任务或中断协调进行，避免竞争条件和内存损坏。</li><li>可以通过三种方式处理资源同步：中断锁、抢占锁和互斥锁。<ul><li>中断锁：禁用中断以在任务和中断之间提供资源同步</li><li>抢占锁：在临界区期间临时禁用RTOS内核抢占调度程序</li><li>互斥锁：通过创建一个对象来保护临界区，该对象的状态可以被检查，以确定是否可以安全访问共享资源，其唯一目的是为共享资源提供互斥</li><li>中断锁禁用系统中断，可能导致问题；抢占锁不禁用系统中断，但禁止内核抢占；互斥锁两者都不禁用。</li></ul></li></ul><p>活动同步：决定执行是否已达到特定状态</p><ul><li><p>单向同步（任务对任务）：使用二值信号量或事件标志来同步任务。</p></li><li><p>单向同步（中断到任务）：ISR给出信号量或事件标志后，继续执行直到完成为止。</p></li><li><p>双向同步：两个任务在它们之间的两个方向上进行协调。</p></li></ul><h4 id="广播设计模式">广播设计模式</h4><p>允许多个任务阻塞，直到给定信号量、出现事件标志，甚至将消息放入消息队列。</p><p>任务或ISR可以提供由多个任务使用的二值信号量广播。广播可能无法在所有实时操作系统中实现，必须检查RTOS是否支持。</p><ul><li>如果不支持广播，则可以创建由任务或中断给出的多个信号量。从设计的角度来看，使用多个信号量并不优雅，从实现的角度来看也不高效，但有时在软件中就是这样。</li></ul><h4 id="低功耗应用程序设计模式">低功耗应用程序设计模式</h4><p>关于低功耗设计模式，主要模式是尽可能地保持设备关闭。</p><ul><li>事件驱动中，事件之间没有实际工作要做时，应该将微控制器置于适当的低功耗状态，并关闭任何非必要的电子设备</li><li>除非发生唤醒事件，否则系统处于低功耗状态</li><li>实际工作完成后，系统恢复到低功耗状态</li></ul><p>建议：使用内置tickless模式的RTOS，或者扩展系统tick以使微控制器休眠更长时间</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_5_I/O与总线</title>
    <link href="/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/5_IO%E4%B8%8E%E6%80%BB%E7%BA%BF/"/>
    <url>/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/5_IO%E4%B8%8E%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第五章-io与总线">第五章 I/O与总线</h1><h2 id="设备分类">1. 设备分类</h2><h3 id="按从属分类">按从属分类</h3><p>系统设备：操作系统启动时已注册的标准设备</p><ul><li>操作系统中有设备驱动程序和管理程序，例如闪存，触摸面板</li></ul><p>用户设备：操作系统启动时未注册的非标准设备</p><ul><li>设备驱动程序由用户提供，例如SD卡、U盘</li></ul><h3 id="按使用分类">按使用分类</h3><p>专用设备：同一时间只能被一个进程使用。</p><p>共享设备：可被多个进程同时寻址。</p><p>虚拟设备：通过虚拟技术将一台独占设备虚拟成多台逻辑设备供多个用户进程同时使用。</p><h3 id="按特征分类">按特征分类</h3><p>存储设备</p><p>输入/输出设备</p><ul><li>通常由机械部件和电子部件组成，电子部分称为设备控制器或适配器</li></ul><h3 id="按信息传输单元分类">按信息传输单元分类</h3><p>块设备：以块为单位组织和交换数据，是结构化设备，例如硬盘。</p><p>字符设备：以字符为单位组织和交换数据，是非结构化设备，例如串口、打印机。</p><ul><li>基本特征是传输速率低且不可寻址，执行输入/输出操作时经常使用中断。</li></ul><h2 id="输入输出">2. 输入/输出</h2><p>输入/输出接口需要多个寄存器：</p><ul><li>数据寄存器</li><li>控制寄存器</li><li>状态寄存器</li></ul><h3 id="可编程io">可编程I/O</h3><p>通信过程中选择控制寄存器或数据缓冲区的三种方法：</p><ul><li><p>独立I/O端口</p></li><li><p>内存映射I/O</p></li><li><p>混合解决方案，混合模型包括内存映射I/O数据缓冲区和用于控制寄存器的独立I/O端口</p></li></ul><p>Intel x86提供了in、out指令，大多数其他cpu使用内存映射I/O。</p><h4 id="独立io端口">独立I/O端口</h4><p>优点：</p><ul><li>I/O独立编址，不占用内存</li><li>使用I/O指令，程序清晰，很容易看出是I/O操作还是存储器操作</li><li>译码电路比较简单（I/O端口的地址空间较小，所用地址线较少）</li></ul><p>缺点：只能用专门I/O指令，访问端口办法少</p><h4 id="内存映射io">内存映射I/O</h4><p>优点：</p><ul><li><p>在内存映射I/O模式中，设备控制寄存器只是内存中的变量，可以像其他变量一样在C语言中寻址。因此，I/O设备驱动程序可以完全用C语言编写。</p></li><li><p>在这种模式下，不需要特殊的保护机制来阻止用户进程执行I/O操作。</p></li></ul><p>缺点：</p><ul><li><p>目前大多数嵌入式处理器都支持内存缓存。缓存设备控制寄存器会导致灾难。为了防止这种情况，必须为硬件提供选择性禁用缓存的功能，这将增加嵌入式系统中硬件和软件的复杂性。</p></li><li><p>如果只有一个地址空间，所有内存模块和所有I/O设备必须检查所有内存引用，以决定响应哪一个，这将严重影响系统性能。</p></li></ul><h3 id="忙等io">忙等I/O</h3><p>使用指令测试设备忙闲。</p><p>缺点：低效</p><ul><li>CPU在测试设备时不能做其他工作</li><li>很难同时进行输入/输出</li></ul><h3 id="中断io">中断I/O</h3><p>中断允许设备改变CPU中的控制流，调用子例程来处理设备。</p><ul><li>行为：基于子程序调用机制，强制下一条指令为预定义地址的子程序调用</li></ul><h4 id="中断的物理接口">中断的物理接口</h4><ul><li>CPU与设备通过CPU总线连接</li><li>CPU与设备握手</li><li>设备发出中断请求</li><li>CPU在能够处理中断时确认中断</li></ul><h4 id="优先级与向量">优先级与向量</h4><p>优先级：决定哪些中断首先得到CPU</p><ul><li>屏蔽：在挂起的中断完成之前，不会识别低于当前优先级的中断。</li><li>不可屏蔽中断NMI，最高优先级，不会被屏蔽，通常用于断电。</li></ul><p>向量：决定每种类型的中断调用什么代码</p><ul><li>中断向量表</li></ul><h4 id="中断序列">中断序列</h4><ol type="1"><li>CPU确认请求</li><li>设备发送向量</li><li>CPU调用中断处理程序</li><li>软件处理请求</li><li>CPU恢复前台程序状态</li></ol><h4 id="中断开销">中断开销</h4><p>中断处理程序执行时间</p><p>中断机制开销</p><p>寄存器保存/恢复</p><p>流水线相关的开销</p><p>缓存相关的开销</p><h4 id="中断设计">中断设计</h4><p>中断服务处理，Interrupt Service Routines，ISR</p><p>基本原则是保持处理程序简短（时间上）。</p><ul><li>避免循环和冗长复杂的指令。</li><li>尽快重新启用中断，先做硬件关键和不可重入的事情，然后执行中断启用指令。</li><li>预计花费时间和复杂度。</li></ul><p>C语言和汇编语言：</p><ul><li>汇编语言的花费时间易于估计，C语言难以估计</li><li>但是尽量使用C语言</li></ul><h4 id="调试intinta周期">调试INT/INTA周期</h4><ol type="1"><li><p>设备硬件产生中断脉冲</p></li><li><p>中断控制器(如果有的话)以优先级处理多个同时发生的请求，并向处理器发出单个中断</p></li><li><p>CPU响应一个中断确认周期</p></li><li><p>控制器在总线上发出一个中断向量</p></li><li><p>CPU读取向量并计算向量所指向的内存中的地址，然后获取这个值</p></li></ol><h4 id="查找丢失的中断">查找丢失的中断</h4><p>可以使用单个上行/下行计数器构建一个小电路，该计数器对每个中断进行计数，并减少每个中断确认的计数。如果计数器总是显示0或1的值，则一切正常。</p><p>一个经验法则将帮助最小化丢失的中断：在最早的安全点重新启用ISR中的中断。</p><h4 id="避免nmi">避免NMI</h4><p>NMI（不可屏蔽的中断）用于电源故障、系统关闭和即将发生的灾难，定时器或UART中断不是。</p><p>NMI甚至会破坏编码良好的中断处理程序，因为大多数isr在服务硬件的前几行代码中都是不可重入的。NMI也会阻碍堆栈管理工作。</p><p>NMI与大多数工具的混合效果很差。调试任何ISR-NMI或其他方式都是令人恼火的。很少有工具能很好地在ISR内单步执行和设置断点。</p><h4 id="断点问题">断点问题</h4><p>虽然断点确实是很棒的调试辅助工具，但是对于嵌入式代码是具有不确定性的。</p><p>使用实时trace，这是所有仿真器和一些智能逻辑分析仪都具有的功能。</p><h4 id="可重入">可重入</h4><p>例程必须满足以下条件才能重入:</p><ul><li><p>以原子方式使用所有共享变量，除非将每个共享变量分配给函数的特定实例</p></li><li><p>不调用不可重入的函数</p></li><li><p>不以非原子的方式使用硬件</p></li></ul><p>原子指不能被中断的操作。</p><p>消除不可重入代码的办法：</p><ul><li><p>避免共享变量。</p><p>全局变量是没完没了的调试问题和代码失败的根源。使用自动变量或动态分配内存。</p></li><li><p>在不可重入代码期间禁用中断。</p></li><li><p>信号量。</p></li></ul><h4 id="竞态条件">竞态条件</h4><p>设备或系统出现不恰当的执行时序，而得到不正确的结果。</p><p>参考计算机操作系统：进程的同步和互斥问题。</p><h2 id="总线">2. 总线</h2><p>总线是计算机各种功能部件之间传送信息的公共通信干线。</p><ul><li>一组传送线路 + 相关通信协议</li></ul><h3 id="总线协议">总线协议</h3><p>总线协议决定设备如何通信。</p><ul><li>协议由状态机指定，协议中的每个参与者都有一个状态机。</li><li>总线上的设备经历一系列的状态。</li><li>可包含异步逻辑行为。</li></ul><h3 id="系统总线配置">系统总线配置</h3><p>多总线允许并行：一个总线连接慢速设备，另一个独立总线连接高速设备。</p><p>桥连接两个总线。</p><p>常用总线：</p><figure><img src="/image/嵌入式系统概论/常用总线.png" alt="常用总线" /><figcaption aria-hidden="true">常用总线</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_4_存储器架构</title>
    <link href="/2023/09/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/4_%E5%AD%98%E5%82%A8%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/09/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/4_%E5%AD%98%E5%82%A8%E5%99%A8%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第四章-存储器架构">第四章 存储器架构</h1><h2 id="存储系统">1. 存储系统</h2><h3 id="存储系统-1">存储系统</h3><p>对许多应用来说，存储系统对整个系统性能的影响比对数据流水线的影响更大。</p><p>复杂性：在同一个嵌入式系统中，通常需要组合各种存储技术</p><ul><li>至少需要一些非易失性存储和一些易失性存储</li></ul><p>层次结构往往是必须的。</p><p>处理器架构的地址空间被分解成若干子空间来提供不同类型的存储器访问。</p><h3 id="易失性存储器">易失性存储器</h3><p>断电时内容消失的存储器。</p><p>随机存取存储器，RAM</p><ul><li>静态RAM，SRAM：速度快，面积大</li><li>动态RAM，DRAM：保持数据的时间很短，需要定期刷新；比SRAM更不稳定</li></ul><p>大多数嵌入式系统都包括一个SRAM，许多ES也会包括DRAM。</p><ul><li>只利用SRAM不能提供足够大的存储容量</li></ul><p>影响程序执行时间的因素</p><ul><li><p>被访问的存储器地址是映射到SRAM还是DRAM</p></li><li><p>DRAM可能在忙于刷新时被请求访问，因此DRAM刷新周期会引起访问时间的变化</p></li><li><p>访问历史也会影响存取时间</p></li></ul><h3 id="非易失性存储器">非易失性存储器</h3><p>不需要持续供电来保留存储在计算设备中的数据或程序代码。</p><ul><li><p>只读存储器ROM，或掩模ROM（MashROM）：内容在芯片工厂就已经固定</p></li><li><p>电可擦除可编程ROM，EEPROM</p></li><li><p>快闪存储器（Flash）</p></li><li><p>磁盘存储器</p></li></ul><h3 id="固件">固件</h3><p>固件（firmware）一般存储于设备中的电可擦除只读存储器或FLASH芯片中，一般可由用户通过特定的刷新程序进行升级。</p><p>可固化（ROMable）：可被编程到ROM芯片中的机器语言。作为“只读”芯片不能更新，可固化程序必须使用RAM或磁盘来保存变化的数据。</p><ul><li><p>代码将从ROM正确执行：不需要复制到RAM，但是RAM可能更快</p></li><li><p>代码和数据不能混用，除了常量数据</p></li></ul><h3 id="flash">Flash</h3><p>读取快于一般ROM，慢于RAM。</p><p>写入时间大大超过读取时间，且写入次数有限。</p><ul><li><p>SLC：速度快，存储密度低，稳定性好，成本高，约10万次擦写寿命，多用于高端企业级产品</p></li><li><p>MLC：速度一般，成本一般，约3000—10000次擦写寿命，应用于中高端SSD</p></li><li><p>TLC：速度慢，成本最低，约1000次擦写寿命</p></li></ul><p>类型：</p><ul><li><p>NOR：块擦除；擦除和写入时间较长，但能够像RAM那样访问</p></li><li><p>NAND：以块为单位；擦除和写入速度比较快；按页读取</p></li></ul><figure><img src="/image/嵌入式系统概论/Flash.png" alt="Flash" /><figcaption aria-hidden="true">Flash</figcaption></figure><h2 id="存储器层次结构">2. 存储器层次结构</h2><p>精确的分层机构取决于技术参数，也取决于应用领域</p><ul><li><p>处理器寄存器</p></li><li><p>工作存储器（或主存储器、主存）：实现了处理器存储地址所涵盖的存储器。通常，其容量在几MB到几GB之间，并且是易失的</p></li><li><p>缓冲存储器:高速缓存、地址转换高速缓存（TLB）以及暂存存储器（SPM）。</p></li><li><p>flash、磁盘等非易失性存储，也可基于互联网的存储器解决方案（如云）。</p></li></ul><h3 id="cache">Cache</h3><p>高速缓存的架构对应用程序的执行时间具有很大影响。</p><ul><li>潜在地提高了存储系统的能效。</li><li>设计时预测缓存是否命中很困难，这对实时性能的精确预测也是负担。</li><li>多级Cache</li></ul><h3 id="暂存存储器">暂存存储器</h3><p>SPM，也叫紧耦合内存TCM。</p><ul><li>SPM和主存统一编址，每当某个简单的地址解码器给出一个SPM地址范围内的地址时，SPM就被访问。</li><li>SPM通常和处理器集成在一个芯片上。</li><li>功耗低、速度快。</li></ul><h3 id="存储器访问时间难以预测">存储器访问时间难以预测</h3><p>虚拟存储器：使各种存储技术看起来是一个连续的地址空间</p><p>地址转换：把地址空间的逻辑地址转换成一种存储技术上的物理地址</p><ul><li>转换通常是由转换后备缓冲器（Translation LookasideBuffer，TLB）协助完成</li></ul><p>很难预测或理解访问存储器的时间需要多久，因而嵌入式系统设计人员通常比一般程序员需要更深入地理解存储器系统</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_3_微处理器</title>
    <link href="/2023/09/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/3_%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2023/09/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/3_%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第三章-嵌入式微处理器">第三章 嵌入式微处理器</h1><p>Embedded Microprocessor</p><h2 id="嵌入式系统硬件">1. 嵌入式系统硬件</h2><p>包含CPU、总线、存储器、输入/输出设备</p><p>常见微处理器：</p><ul><li>ARM</li><li>MIPS</li><li>PowerPC</li><li>X86</li></ul><h3 id="冯诺伊曼结构">冯诺伊曼结构</h3><ul><li>将程序指令存储器和数据存储器合并在一起的存储器结构</li><li>程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同</li><li>CPU寄存器: 程序计数器(PC)，指令寄存器(IR)，通用寄存器等。</li></ul><h3 id="哈佛结构">哈佛结构</h3><p>明显的特点：</p><ul><li><p>使用两个独立的存储器模块，分别存储指令和数据</p><p>每个存储模块都不允许指令和数据并存</p></li><li><p>使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，这两条总线之间毫无关联</p></li></ul><p>改进的哈佛结构，其结构特点为：</p><ul><li>使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存;</li><li>具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块(程序存储模块和数据存储模块)，公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输</li><li>两条总线由程序存储器和数据存储器分时共用</li></ul><p>大多数数字信号处理器（DSP）使用哈佛架构来处理流数据：</p><ul><li>更大的内存带宽</li><li>更可预测的带宽</li></ul><h3 id="risc和cisc">RISC和CISC</h3><ul><li>复杂指令集计算机，Complex instruction set computer，CISC<ul><li>多种寻址模式</li></ul></li><li>精简指令集计算机，Reduced instruction set computer，RISC<ul><li>流水线指令</li><li>访存指令只有load/store</li></ul></li></ul><h4 id="risc-v">RISC-V</h4><ul><li>简单、完全开源并且免费</li><li>将基准指令和扩展指令分开，可以通过扩展指令做定制化的模块和扩展<ul><li>RISC-V的基准指令集确定后将不会变化，这是RISC-V稳定性的重要保障</li></ul></li></ul><h4 id="设计系统芯片需要考虑">设计系统芯片需要考虑</h4><ul><li>成本</li><li>生态系统</li><li>碎片化风险</li><li>安全性</li><li>设计保证</li></ul><h3 id="编程模型">编程模型</h3><p>在程序中可以用道德寄存器集合。</p><ul><li>有些寄存器不可见</li></ul><h2 id="嵌入式微处理器分类">2. 嵌入式微处理器分类</h2><p>按位数可分为4、8、16等；</p><p>按功能可分为4种：</p><ul><li>嵌入式微处理单元（MPU）：类似CPU</li><li>嵌入式微控制器（MCU）：包含MPU与存储器、I/O接口和基本控制器</li><li>嵌入式DSP处理器：特殊设计系统和算法，用于信号处理</li><li>嵌入式SoC：集成MPU、存储器、外设控制器、通信功能等<ul><li>MCU通常不支持操作系统，裸机运行程序，快速响应实时任务和控制系统</li><li>SoC适合运行操作系统，性能和可靠性强，往往用于更高端的设备</li></ul></li></ul><h3 id="嵌入式微处理单元mpu">嵌入式微处理单元（MPU）</h3><p>嵌入式微处理器就是和通用计算机的处理器对应的CPU。</p><ul><li><p>功能和微处理器基本一样，具有32位以上，性能较高。</p></li><li><p>体积小、功耗少、成本低、可靠性高，有的可提供工业级应用。</p></li></ul><p>流行的嵌入式微处理器：ARM：Cortex-A系列、Power、MIPS</p><figure><img src="/image/嵌入式系统概论/框图.png" alt="框图" /><figcaption aria-hidden="true">框图</figcaption></figure><h3 id="嵌入式微控制器mcu">嵌入式微控制器（MCU）</h3><p>嵌入式微控制器就是将整个计算机系统的主要硬件集成到一块芯片中，芯片内部集成ROM/EPROM，RAM，总线，总线逻辑，定时/计数器，Watchdog，I/O，串行口等各种必要功能和外设。</p><ul><li>特点：<ul><li>一个系列的微控制器具有多种衍生产品</li><li>单片化，体积大大减小，功耗和成本降低，可靠性提高</li><li>是目前嵌入式工业的主流，约占嵌入式系统50%的份额</li></ul></li></ul><p>流行的嵌入式微控制器：</p><ul><li><p>通用系列：8051，Coldfire的MC683xx（32位），Cortex-M0/3/4/7/M33/M35P</p></li><li><p>半通用系列:支持I2C,CAN BUS及众多专用MCU和兼容系列</p></li></ul><h3 id="嵌入式dsp">嵌入式DSP</h3><p>嵌入式DSP是专门用于信号处理方面的处理器，其在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令执行速度。</p><p>应用领域：数字滤波、频谱分析、FFT</p><p>流行的嵌入式DSP：</p><ul><li>德州仪器（TI），c6000 与 c5000</li><li>模拟器件公司（ADI）</li><li>摩托罗拉（Motorola）公司</li></ul><h3 id="嵌入式soc">嵌入式SoC</h3><p>嵌入式SoC是追求产品系统最大包容的集成器件。绝大多数系统构件都在一个系统芯片内部。</p><p>SoC芯片可以有效地降低电子/信息系统产品开发成本，缩短开发周期，提高产品竞争力。</p><p>特点：</p><ul><li>结构简洁</li><li>体积小、功耗小</li><li>可靠性高</li><li>设计生产效率高</li></ul><p>流行的SoC：高通骁龙（Snapdragon）、海思</p><h3 id="现场可编程门阵列fpga">现场可编程门阵列，FPGA</h3><p>具有可编程特性的集成电路。</p><ul><li>赛灵思、阿尔特拉（被英特尔收购）</li></ul><h4 id="dsp和fpga">DSP和FPGA</h4><figure><img src="/image/嵌入式系统概论/DSP与FPGA.png" alt="DSP与FPGA" /><figcaption aria-hidden="true">DSP与FPGA</figcaption></figure><h2 id="嵌入式微处理器的特点">嵌入式微处理器的特点</h2><p>基础是通用微处理器；与通用微处理器的区别：</p><ul><li>体积小、重量轻、可靠性高、功耗低</li><li>成本低：片上存储、引脚与封装、代码密度</li><li>工作温度、抗电磁干扰、可靠性等方面增强</li></ul><h2 id="arm">ARM</h2><h3 id="arm公司">ARM公司</h3><p>成立于1990年11月，从Acorn电脑公司剥离出来。</p><ul><li><p>设计ARM系列的RISC处理器内核。</p></li><li><p>授权ARM核心设计的半导体合作 伙伴制造和销售给他们的客户。</p></li><li><p>同时开发技术以协助ARM架构的设计。</p><ul><li>软件工具、电路板、调试硬件、应用软件、总线架构、外围设备等。</li></ul></li></ul><h3 id="arm处理器的主要应用领域">ARM处理器的主要应用领域</h3><ul><li><p>消费类电子产品：</p><p>ARM技术在目前流行的数字音频播放器、数字机顶盒和游戏机中得到了广泛采用</p></li><li><p>无线通讯领域：</p><p>目前大部分无线通讯设备采用了ARM技术，ARM以其高性价比和低成本，在该领域的地位日益巩固</p></li><li><p>网络应用：</p><p>随着宽带技术的推广，采用ARM技术的ADSL芯片正逐步获得竞争优势，此外，ARM在语音及视频处理上进行了优化，并获得广泛支持，这也对DSP的应用领域提出了挑战</p></li><li><p>工业控制领域：</p><p>基于ARM核的微控制器芯片不但占据了高端微控制器的大部分市场份额，同时也逐渐向低端微控制器应用领域扩展，Cortex-M系列就是ARM公司推出的典型低功耗、高性价比32位工控微控制器，向传统的8位/16位微控制器提出了挑战</p></li><li><p>成像和安全产品：</p><p>现在流行的数码相机和打印机中绝大部分采用ARM技术，手机中的32位SIM智能卡也采用了ARM技术</p></li></ul><h3 id="arm处理器分类">ARM处理器分类</h3><p>结构体系版本（Architecture）</p><ul><li>ARM v4T</li><li>ARM v5TE</li><li>ARM v6</li><li>ARM Cortex（v7 ，v8）</li></ul><p>按应用特征分类</p><ul><li><p>应用处理器，Application Processor</p></li><li><p>实时控制处理器，Real-time Controller</p></li><li><p>微控制器，Micro-controller</p></li><li><p>SecurCore</p></li></ul><h3 id="arm架构">ARM架构</h3><p>典型的RISC：</p><ul><li>丰富的寄存器</li><li>加载/存储体系结构</li><li>简单寻址模式</li><li>统一和固定长度的指令字段</li></ul><p>增强功能：</p><ul><li>每条指令控制ALU和移位器</li><li>自动递增和自动递减寻址模式</li><li>多个加载/存储</li><li>条件执行</li></ul><p>特点：</p><ul><li>高性能</li><li>低代码</li><li>低功耗</li><li>低硅面积</li></ul><h3 id="流水线">流水线</h3><p>提高速度：大多数指令在一个周期内执行。</p><p>版本：</p><ul><li><p>3级（ARM7TDMI及更早版本）</p></li><li><p>5级（ARMS, ARM9TDMI）</p></li><li><p>6级（ARM10TDMI）</p></li></ul><p>流水线清空，导致执行速度变慢。</p><ul><li>分支指令</li></ul><p>分支预测技术</p><ul><li>静态</li><li>动态</li></ul><h3 id="meltdown-spectre">Meltdown &amp; Spectre</h3><p>近20年的Intel，AMD，Qualcomm厂家和其它ARM的处理器受到影响。</p><p>因为此次CPU漏洞特殊性，包括Linux，Windows，OSX等的操作系统平台参与了修复。</p><p>Firefox，Chrome，Edge等浏览器也发布了相关的安全公告和缓解方案。</p><h2 id="选择微处理器">选择微处理器</h2><h3 id="准则">准则</h3><ul><li>高效、经济<ul><li>速度、尺寸、功耗、易于升级、单位成本</li></ul></li><li>软件开发工具可用性<ul><li>汇编器、C编译器、仿真器</li></ul></li><li>广泛的可用性和可靠的微控制器来源</li></ul><h3 id="步骤">步骤</h3><ol type="1"><li>列出所需的硬件接口</li><li>检查软件架构</li><li>选择体系结构</li><li>确定内存要求</li><li>搜索微控制器</li><li>检查零件可用性</li><li>选择开发工具包</li><li>研究编译器和工具</li><li>开始尝试</li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_2_设计方法</title>
    <link href="/2023/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/2_%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2023/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/2_%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第二章-嵌入式系统设计方法">第二章 嵌入式系统设计方法</h1><h2 id="嵌入式系统设计面临的挑战">1. 嵌入式系统设计面临的挑战</h2><ul><li>硬件需求</li><li>多项功能在时间上的协调一致性、时限要求</li><li>系统功耗</li><li>系统可升级性</li><li>系统可靠性</li></ul><h3 id="设计者要求">设计者要求</h3><ul><li>懂得系统架构</li><li>了解硬件细节</li><li>软件设计满足<ul><li>实时要求</li><li>低功耗</li><li>代码量小</li></ul></li><li>了解领域知识</li></ul><h3 id="设计目标">设计目标</h3><ul><li>成本</li><li>性能</li><li>功耗</li><li>尺寸</li><li>可伸缩性和可重用性</li><li>容错</li><li>……</li></ul><h2 id="嵌入式系统的设计过程">2. 嵌入式系统的设计过程</h2><ul><li><p>问题：功能、性能要求、价格、开发周期等约束</p></li><li><p>设计：选择、折衷、分析比较、计算、评价</p></li></ul><h3 id="简化的设计流">简化的设计流</h3><figure><img src="/image/嵌入式系统概论/简化的设计流.png" alt="简化的设计流" /><figcaption aria-hidden="true">简化的设计流</figcaption></figure><h3id="嵌入式系统的设计过程的基本流程">嵌入式系统的设计过程的基本流程</h3><figure><img src="/image/嵌入式系统概论/基本流程.png" alt="基本流程" /><figcaption aria-hidden="true">基本流程</figcaption></figure><h3 id="v模型的设计流">V模型的设计流</h3><figure><img src="/image/嵌入式系统概论/V模型.png" alt="V模型" /><figcaption aria-hidden="true">V模型</figcaption></figure><h2 id="嵌入式系统设计方法学">3. 嵌入式系统设计方法学</h2><h3 id="体系结构设计">体系结构设计</h3><ul><li>满足规格说明的主要组件<ul><li>硬件：中央处理器、外围设备等</li><li>软件：必要的程序及其运行</li></ul></li><li>功能性和非功能性需求</li></ul><h4 id="硬件和软件组件设计">硬件和软件组件设计</h4><ul><li>开始编码前，必须花时间构建系统</li><li>有些组件是现成的，可以根据现有设计进行修改，还有一些必须从头开始设计</li></ul><h4 id="软硬件的划分">软硬件的划分</h4><p>嵌入式系统的设计涉及硬件与软件部件，设计中必须决定什么功能由硬件实现，什么功能由软件实现。</p><ul><li>硬件和软件具有双重性，这是划分决策的前提</li><li>软硬件变动对系统决策有影响</li><li>划分选择需考虑多种因素</li></ul><h5 id="通常由软件实现的部分">通常由软件实现的部分</h5><ul><li>操作系统功能<ul><li>任务调度</li><li>资源管理</li><li>设备驱动</li></ul></li><li>协议栈<ul><li>TCP/IP</li></ul></li><li>应用软件框架</li><li>除了基本系统、物理接口、基本逻辑电路，许多由硬件实现的功能都可以由软件实现</li></ul><h5 id="双重性部分">双重性部分</h5><ul><li>算法<ul><li>加密/解密</li><li>编码/解码</li><li>压缩/解压</li><li>等等</li></ul></li><li>数学运算<ul><li>浮点运算、FFT、等等</li></ul></li></ul><h4 id="软硬件技术对系统结构影响">软硬件技术对系统结构影响</h4><ul><li>硬软件设计的趋势——融合、渗透<ul><li>硬件设计的软件化：VHDL、Verilog、HANDEL-C</li><li>软件实现的硬件化：各种算法的ASIC</li></ul></li><li>对系统设计的影响——协同设计<ul><li>增加灵活性</li><li>增加了风险</li></ul></li></ul><h3 id="嵌入式系统设计方法的演变">嵌入式系统设计方法的演变</h3><ol type="1"><li>以PCB、CAD和在线仿真器为主要工具</li><li>EDA和EOS为开发平台</li><li>以IP内核库为设计基础，用软硬件协同设计技术的系统级设计方法</li></ol><h4 id="传统嵌入式系统设计过程">传统嵌入式系统设计过程</h4><ul><li>系统在一开始就被划分为软件和硬件两大部分</li><li>软件和硬件独立进行开发设计</li><li>硬件优先</li></ul><p>问题：</p><ul><li>软硬件间交互受很大限制<ul><li>凭经验划分软硬件</li><li>软硬件之间的相互性能影响很难评估</li></ul></li><li>系统集成相对滞后，NRE较大</li></ul><p>导致：</p><ul><li>设计质量差</li><li>设计修改难</li><li>研制周期不能有效保障</li></ul><h4 id="软硬件协同设计hwsw-co-design">软硬件协同设计HW/SW Co-design</h4><p>协同设计是指通过并行设计利用硬件和软件的协同作用来实现系统级目标。</p><p>协同设计试图通过提供分析方法来增加嵌入式系统设计的可预测性，这些分析方法告诉设计师一个系统是否满足其性能、功率和尺寸目标，并提供综合方法让设计师快速评估许多潜在的设计方法。</p><ul><li>它从90年代早期的一个新兴的学科变成了如今的主流技术。</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_1_引言</title>
    <link href="/2023/09/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/1_%E5%BC%95%E8%A8%80/"/>
    <url>/2023/09/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/1_%E5%BC%95%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第一章-引言">第一章 引言</h1><h3 id="几个术语">几个术语</h3><ul><li><p>泛在计算：任何时间、任何地点的计算</p></li><li><p>不可见计算机：计算机被集成到物件中</p></li><li><p>普适计算：计算设备对日常生活的渗透</p></li><li><p>环境智能：生活环境中的计算机技术</p></li></ul><h2 id="嵌入式系统的定义">1. 嵌入式系统的定义</h2><h3 id="嵌入式系统">嵌入式系统</h3><p>以应用为中心，以计算机技术为基础，软硬件可裁减，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统。</p><ul><li><p>嵌入式系统（Emedded System）实际上是嵌入式计算机系统。</p></li><li><p>嵌入式系统就是一个具有特定功能或用途的隐藏在设备中的计算机软硬件集合体。</p></li><li><p>嵌入式系统三要素</p><ul><li>嵌入性：嵌入到对象体系中，有对象环境要求</li><li>专用性：软硬件按对象要求设计、裁减</li><li>计算机：实现对象的智能化功能</li></ul></li></ul><h3 id="信息物理系统">信息物理系统</h3><p>Cyber-Physical System（CPS），是计算进程和物理进程的集成。</p><ul><li><p>强调嵌入式系统和物理学的深度融合</p></li><li><p>深度融合了各类信息技术：传感器、嵌入式计算、云计算、网络通信</p><p>使各种信息化能力高度协同和自治</p></li><li><p>信息化能力：</p><p>3C：计算-Computer、通信-Communication、控制-Control</p></li></ul><h3 id="无线感知网络">无线感知网络</h3><p>Wireless sensornetwork/WSN，是由许多在空间中分布的自动装置组成的一种无线通信计算机网络，这些装置使用传感器协作地监控不同位置的物理或环境状况。</p><h3 id="物联网">物联网</h3><p>Internet ofThings（IoT），通过射频识别（RFID），红外感应器，全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物品与互联网相连接，进行信息交换和通信，以实现智能化识别、定位、跟踪、监控和管理的一种网络概念。</p><ul><li>面向生产的物联网技术开发被称为“工业4.0”。</li></ul><h3 id="发展历程">发展历程</h3><p>1960-1970：出现和兴起</p><p>1971-1989：走向繁荣，软硬件日益完善</p><p>1990-现在：走向纵深</p><h2 id="嵌入式系统的组成">2. 嵌入式系统的组成</h2><p>嵌入式系统一般由嵌入式硬件和软件组成：应用软件+中间件+运行内核+驱动+系统硬件</p><ul><li>硬件以微处理器为核心，集成存储器和系统专用的输入/输出设备</li><li>软件包括初始化代码及驱动、嵌入式操作系统和应用程序等</li></ul><h2 id="嵌入式系统的特点">3. 嵌入式系统的特点</h2><p>形式多样、面向特定应用</p><p>得到多种类型的处理器和处理器体系结构的支持</p><p>通常及其关注成本</p><p>实时性、可靠性</p><p>一般使用适应多种处理器、可剪裁、轻量型、实时可靠、可固化的嵌入式操作系统</p><p>需要专门工具和特殊方法进行开发</p><h2 id="嵌入式系统的分类">4. 嵌入式系统的分类</h2><p>处理器位数：8位、16位、32位、64位</p><p>应用：移动互联网、工业控制、可穿戴设备等</p><p>速度：</p><ul><li>强实时系统：响应时间毫秒或微秒级</li><li>一般实时系统：几秒级</li><li>弱实时系统：数十秒或更长</li></ul><p>确定性：</p><ul><li>硬实时系统：对系统响应时间有严格要求</li><li>软实时系统：系统响应时间不满足，不会导致系统出现致命错误或崩溃</li></ul><p>软件复杂程度：循环轮询、有限状态机、前后台、单/多处理器多任务系统</p><h2 id="嵌入式系统的发展趋势">5. 嵌入式系统的发展趋势</h2><p>嵌入式人工智能</p><p>嵌入式安全性</p><p>高计算需求和复杂性</p><p>软硬件协同设计</p><p>更高集成度</p><p>云计算</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑_提纲</title>
    <link href="/2023/08/05/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E6%8F%90%E7%BA%B2/"/>
    <url>/2023/08/05/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E6%8F%90%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<p>飞流直下三千尺，疑是银河落九天。</p><span id="more"></span><h1 id="提纲">提纲</h1><p>术语缩写：</p><ul><li>“$$”用于表示一个证明的结束。</li><li>“如果···那么···”，即“蕴含”，缩写为“<spanclass="math inline">\(···\Longrightarrow···\)</span>”；“逆蕴含”则为"<spanclass="math inline">\(···\Longleftarrow···\)</span>"。</li><li>“当且仅当”缩写为“<spanclass="math inline">\(iff\)</span>”或符号“<spanclass="math inline">\(\Longleftrightarrow\)</span>”</li><li>“因为”缩写为“<spanclass="math inline">\(\because\)</span>”，因此缩写为“<spanclass="math inline">\(\therefore\)</span>”</li><li>“<span class="math inline">\(x\neq y\)</span>”是“<spanclass="math inline">\(x=y\)</span>”的否定，“<spanclass="math inline">\(x\notin y\)</span>”是“<spanclass="math inline">\(x\in y\)</span>”的否定，类推至其它符号</li></ul><h2 id="一集合基础">一、集合基础</h2><h3 id="集合定义和表示">1. 集合定义和表示</h3><p>对象：人们感觉和思维中确定的某些事物，通常以其名称指代对象本身。</p><p>康托尔：集合是具有某种性质的、确定的、互异的对象所组成的整体。</p><p>表示方法：外延表示方法（列举法）和内涵表示方法</p><p>罗素悖论集合论：不能用更简单的数学概念来给集合下一个确定的定义。</p><h3 id="公理化集合论">2. 公理化集合论</h3><p>外延公理：如果集合<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>有相同元素，则<spanclass="math inline">\(X=Y\)</span>。</p><p>空集公理：存在一个不含任何元素的集合，称为空集，其它集合都称为非空的。</p><p>分离公理：如果<spanclass="math inline">\(\varphi\)</span>是一性质，则对于任意集合A和参数p，存在一个集合<spanclass="math inline">\(B=\{u\in X:\varphi (u,p)\}\)</span>，它包含所有具有这个性质的A中的元素u。</p><h3 id="幂集交集和并集">3. 幂集、交集和并集</h3><p>集合A的幂集<span class="math inline">\(\mathcal PA\)</span>的元素是A的所有子集，即：<span class="math inline">\(\mathcalP A=\{x|x\subseteq A \}\)</span>。</p><p>集合A与B的并集<span class="math inline">\(A\cupB\)</span>是属于A或属于B的元素的集合。</p><p>集合A与B的交集是所有A与B共有的元素的集合。</p><ul><li>A与B不相交，当且仅当二者的交集为空集</li></ul><p>对于非空集合A，其元素也是集合，有</p><ul><li><span class="math inline">\(\bigcupA=\{x|x属于A的某个元素\}\)</span></li><li><span class="math inline">\(\bigcapA=\{x|x属于A的每个元素\}\)</span></li></ul><h3 id="有序对">4. 有序对</h3><p>元素x和y的<strong>有序对</strong><span class="math inline">\(\langx,y\rang\)</span>定义：<span class="math inline">\(\lang x,y\rang=\langu,v\rang\quad iff\quad x=u且y=v\)</span>。</p><p>所有具有上述性质的定义都可以作为有序对的定义。</p><p>其中，一个标准的定义是<span class="math inline">\(\langx,y\rang=\{\{x\},\{x,y\} \}\)</span>。</p><p>一般地，对于<spanclass="math inline">\(n&gt;1\)</span>可以如下递归地定义<spanclass="math inline">\(n\)</span>元组：</p><p><span class="math inline">\(\lang x_1,x_2,...,x_{n+1}\rang=\lang\langx_1,x_2,...,x_n\rang,x_{n+1}\rang\)</span></p><p>为方便起见，对于<spanclass="math inline">\(n=1\)</span>，我们定义<spanclass="math inline">\(\lang x\rang=x\)</span>；这样上式对于<spanclass="math inline">\(n=1\)</span>也是成立的。</p><h4 id="有限序列">有限序列</h4><p>称S是A中元素的有限序列（有限串）当且仅当对某个正整数n，<spanclass="math inline">\(S=&lt;x_1,...,x_n&gt;\)</span>，其中每个<spanclass="math inline">\(x_i\in A\)</span>。</p><p>S的子段指一个有限序列<spanclass="math inline">\(&lt;x_k,x_{k+1},...,x_{m-1},x_m&gt;,1\leq k\leqm\leq n\)</span></p><ul><li>这个子段是初始段当且仅当<spanclass="math inline">\(k=1\)</span></li><li>这个子段是真子段当且仅当该子段与S不同</li></ul><h4 id="笛卡尔积">笛卡尔积</h4><p><span class="math inline">\(A\times B=\{\lang x,y\rang|x\in A,y\in B\}\)</span></p><p><spanclass="math inline">\(A^n\)</span>表示A中元素构成的所有的n元组组成的集合，比如<spanclass="math inline">\(A^3=(A\times A)\times A\)</span>。</p><h3 id="关系">5. 关系</h3><p>关系<span class="math inline">\(R\)</span>：有序对的集合。</p><ul><li>定义域，dom R：指所有满足<span class="math inline">\(\langx,y\rang\in R\)</span>的<spanclass="math inline">\(x\)</span>的集合</li><li>值域，ran R：指所有满足<span class="math inline">\(\lang x,y\rang\inR\)</span>的<span class="math inline">\(y\)</span>的集合</li></ul><h4 id="函数">函数</h4><p>函数是具有单值性质的关系。</p><p>关系<span class="math inline">\(F\)</span>，对于定义域中的每一个<spanclass="math inline">\(x\)</span>，都有唯一的y满足<spanclass="math inline">\(\lang x,y\rang\in F\)</span>，<spanclass="math inline">\(y\)</span>称为<spanclass="math inline">\(F\)</span>在<spanclass="math inline">\(x\)</span>上的值，记作<spanclass="math inline">\(F(x)\)</span>。</p><p>称函数F将定义域A映射到值域B。</p><ul><li><p>F是一个一一映射当且仅当对于B中的每个y，存在唯一的x使得<spanclass="math inline">\(\lang x,y\rang\in F\)</span>。</p></li><li><p>如果<span class="math inline">\(\langx,y\rang\)</span>在定义域dom F中，则记<spanclass="math inline">\(F(x,y)=F(\lang x,y\rang)\)</span>。</p></li><li><p>推广到n元：<spanclass="math inline">\(A\)</span>上的n元运算是一个将<spanclass="math inline">\(A^n\)</span>映射到<spanclass="math inline">\(A\)</span>中的函数。</p></li></ul><h4 id="关系的性质">关系的性质</h4><ol type="1"><li><p>R在A上是自反的，当且仅当对A中每个x都有<spanclass="math inline">\(\lang x,x\rang\in R\)</span>。</p></li><li><p>R是对称的，当且仅当如果<span class="math inline">\(\langx,y\rang\in R\)</span>，则<span class="math inline">\(\lang y,x\rang\inR\)</span>。</p></li><li><p>R是传递的，当且仅当如果<span class="math inline">\(\langx,y\rang\in R,\lang y,z\rang\in R\)</span>，则<spanclass="math inline">\(\lang x,z\rang\in R\)</span>。</p></li><li><p>R在A上满足三分律，当且仅当对A中任意的x和y，如下三种可能有且仅有一种成立：</p><ul><li><p><span class="math inline">\(\lang x,y\rang \inR\)</span></p></li><li><p><span class="math inline">\(x=y\)</span></p></li><li><p><span class="math inline">\(\lang y,z\rang\in R\)</span></p></li></ul></li><li><p>有序对的集合称为二元关系。</p></li><li><p>关系R是A上的等价关系当且仅当R是A上自反、对称和传递的一个二元关系。</p></li><li><p>关系R是A上的一个序关系当且仅当R是传递的且在A上满足三分律。</p></li><li><p>关系R的逆关系记为<spanclass="math inline">\(R^{-1}\)</span>，定义为<spanclass="math inline">\(R^{-1}=\{&lt;x,y&gt;|&lt;y,x&gt;\inR\}\)</span></p></li></ol><h3 id="偏序">6. 偏序</h3><p>设A为一个集合，R是A上的二元关系，称R为A上的<strong>偏序</strong>关系，如果满足如下条件：</p><ul><li><p>R具有自反性</p></li><li><p>R具有反对称性，且对任意<span class="math inline">\(x,y\inR\)</span>，如果<span class="math inline">\(xRy\)</span>且<spanclass="math inline">\(yRx\)</span>，则<spanclass="math inline">\(x=y\)</span></p></li><li><p>R具有传递性</p></li></ul><p>设A为一个集合，R是A上的二元关系，称R为A上的<strong>严格偏序</strong>关系，如果满足如下条件：</p><ul><li><p>R具有禁自反性，即任意x属于A都有非<spanclass="math inline">\(R(x,x)\)</span></p></li><li><p>R具有禁对称性，且对任意<span class="math inline">\(x,y\inA\)</span>，如果<span class="math inline">\(R(x,y)\)</span>，则非<spanclass="math inline">\(R(y,x)\)</span></p></li><li><p>R具有传递性</p></li></ul><p>极小元：</p><p><span class="math inline">\((A,\leq)\)</span>是偏序集，<spanclass="math inline">\(B\subseteq A,b\in B\)</span>，如果不存在<spanclass="math inline">\(x\in B\)</span>，使得<spanclass="math inline">\(x\neq b\)</span>且<spanclass="math inline">\(x\leq b\)</span>，则称b为B的关于<spanclass="math inline">\(\leq\)</span>关系的极小元。</p><h4 id="线序">线序</h4><p><spanclass="math inline">\((A,\leq)\)</span>是偏序集，如果A中任意两个元素x，y都在偏序关系<spanclass="math inline">\(\leq\)</span>下可以比较，则称<spanclass="math inline">\(\leq\)</span>关系是线序关系或全序关系。相应地称<spanclass="math inline">\((A,\leq)\)</span>为线序集或全序集。</p><ul><li>如果<span class="math inline">\(\leq\)</span>为A上的线序，则称<spanclass="math inline">\(&lt;\)</span>为A上的严格线序。</li></ul><h4 id="良序">良序</h4><p>设<spanclass="math inline">\((A,\le)\)</span>是线序集，如果A的任意非空子集都有<spanclass="math inline">\(\le\)</span>极小元，则称<spanclass="math inline">\((A,\le)\)</span>为良序集，且称<spanclass="math inline">\(\le\)</span>为A上的良序，或A被<spanclass="math inline">\(\le\)</span>良序。</p><ul><li>有穷的线序集都是良序集。</li></ul><p>良基偏序：</p><p>设<spanclass="math inline">\((A,\le)\)</span>是偏序集，如果A的任意非空子集都有<spanclass="math inline">\(\le\)</span>极小元，则称<spanclass="math inline">\((A,\le)\)</span>为良序集，且称<spanclass="math inline">\(\le\)</span>为A上的良序，或A被<spanclass="math inline">\(\le\)</span>良序。</p><h4 id="选择公理">选择公理</h4><p>对任意非空集合X，如果X中的元素均为非空集合，则存在映射f使得<spanclass="math inline">\(dom(f)=X\)</span>，且<spanclass="math inline">\(\forall x\in X\)</span>都有<spanclass="math inline">\(f(x)\in x\)</span>（称f为X上的选择函数）。</p><h4 id="乘积公理">乘积公理</h4><p>对任意集族<span class="math inline">\((X_i)_{i\inI}\)</span>，如果<spanclass="math inline">\(I\)</span>为非空集合，且对任意<spanclass="math inline">\(i\in I\)</span>，集合<spanclass="math inline">\(X_i\)</span>非空，则<spanclass="math inline">\(\prod_{i\in I}X_i\)</span>非空。</p><h4 id="可数">可数</h4><p>集合A是可数的，当且仅当存在某个函数将A一对一映射到自然数N中。</p><ul><li>设A是一个可数集，则所有由A的元素构成的有限序列的集合也可数。</li></ul><h3 id="自然数的定义">7. 自然数的定义</h3><ol type="1"><li><span class="math inline">\(0=\empty\)</span></li><li><span class="math inline">\(1=0^+=\{0\}\)</span></li><li><span class="math inline">\(2=1^+=\{0,1\}\)</span></li><li>假设我们已经定义了<spanclass="math inline">\(n=\{0,1,...,n-1\}\)</span>，则定义<spanclass="math inline">\(n+1=n^+=n\cup\{n\}=\{0,1,...,n-1,n\}\)</span></li><li>每个自然数都是从0开始经过有穷步后继运算的结果</li></ol><p>集合的后继运算：</p><p>设任意集合<span class="math inline">\(A\)</span>，称集合<spanclass="math inline">\(A\cup \{A\}\)</span>为<spanclass="math inline">\(A\)</span>的后继集合，简称<spanclass="math inline">\(A\)</span>的后继，记作<spanclass="math inline">\(A^+\)</span>，称<spanclass="math inline">\(A\)</span>为<spanclass="math inline">\(A^+\)</span>的前趋。</p><h4 id="无穷公理">无穷公理</h4><p>所有自然数组成的集合的整体是集合，记为<spanclass="math inline">\(\omega\)</span>。</p><h4 id="佐恩引理极大原则">佐恩引理/极大原则</h4><p>设A是一个集合，且满足对于任意的链<spanclass="math inline">\(C\subseteq A\)</span>，有集合<spanclass="math inline">\(\bigcupC\)</span>在A中，那么A中存在极大元m，即m不是A中其他任意元素的子集。</p><ul><li>一组集合C是一个链，当且仅当对于C中任意元素x和y，要么<spanclass="math inline">\(x\subseteq y\)</span>要么<spanclass="math inline">\(y\subseteq x\)</span></li></ul><h4 id="正则公理">正则公理</h4><p>每个非空集合A中总存在元素x使得<span class="math inline">\(x\capA=\empty\)</span>（此时称x为A的<span class="math inline">\(\in-\)</span>极小元）。</p><ul><li>不存在集合<span class="math inline">\(x\in x\)</span></li><li>不存在集合<span class="math inline">\(x,y\)</span>使得<spanclass="math inline">\(x\in y\)</span>且<span class="math inline">\(y\inx\)</span>。</li></ul><h4 id="数学归纳法">数学归纳法</h4><p>集合形式：</p><p>设S为一个集合，如果S满足如下两个条件：</p><ul><li><span class="math inline">\(0\in S\)</span></li><li>对任何自然数n，如果<span class="math inline">\(n\inS\)</span>，则<span class="math inline">\(n+1\in S\)</span></li></ul><p>则<span class="math inline">\(\omega \subseteqS\)</span>，即每个自然数都属于S。</p><p>性质形式：</p><p>设<span class="math inline">\(R\)</span>是性质，如果有</p><ol type="1"><li><span class="math inline">\(R(0)\)</span>成立，且</li><li>对任意自然数n，若<spanclass="math inline">\(R(n)\)</span>成立，<spanclass="math inline">\(R(n+1)\)</span>也成立</li></ol><p>则对任意自然数n都有<spanclass="math inline">\(R(n)\)</span>成立。</p><h4 id="传递集合">传递集合</h4><p>如果集合A的任意元素都是A的子集，则称A是传递集合。</p><ul><li><p>A为传递集合，则<span class="math inline">\(\forall x\in A,y\inx,y\in A\)</span>。</p></li><li><p>任意自然数、<spanclass="math inline">\(\omega\)</span>是传递集合</p></li></ul><h5 id="in三歧性"><span class="math inline">\(\in\)</span>三歧性</h5><p><span class="math inline">\(\forall x,y\in A有x\in y或x=y或y\inx\)</span></p><ul><li><span class="math inline">\(\omega\)</span>具有三歧性</li></ul><p>任意自然数n、m，定义</p><ul><li><span class="math inline">\(m&lt;n当且仅当m\in n\)</span></li><li><span class="math inline">\(m\le n当且仅当m&lt;n或m=n\)</span></li></ul><h3 id="有穷和无穷集合">8. 有穷和无穷集合</h3><h4 id="等势集合">等势集合</h4><p>设A、B为两个集合，如果存在A到B上的双射，则称A与B等势，或称A与B对等，记为<spanclass="math inline">\(A\sim B\)</span>。</p><ul><li>等势关系为等价关系。</li></ul><p>如果存在A到B的单射，则称A的势不超过B的势，记为<spanclass="math inline">\(A\preceq B\)</span>。</p><p>如果<span class="math inline">\(A\preceqB\)</span>但A与B不等势，则记作<span class="math inline">\(A\precB\)</span>。</p><h5 id="康托尔伯恩斯坦定理">康托尔伯恩斯坦定理</h5><p>设A、B为两个集合，假设<span class="math inline">\(A\preceq B,B\preceqA\)</span>，则<span class="math inline">\(A\sim B\)</span>。</p><h4 id="有穷与无穷集合">有穷与无穷集合</h4><p>和某个自然数等势的集合为有穷集合，否则为无穷集合。</p><ul><li>抽屉原理：集合A为有穷集合，当且仅当它不与它的任何真子集等势</li></ul><p>每一个无穷集合都有无数无穷子集。</p><ul><li>如果A是无穷集合，则<span class="math inline">\(\omega\preceqA\)</span>。</li><li>A是无穷集合当且仅当它与自身的一个真子集等势。</li><li>引理：假设A是非空集合且<span class="math inline">\(\bigcupA=A\)</span>，则A是无穷集合。</li></ul><h4 id="可数与不可数集合">可数与不可数集合</h4><p>若集合<span class="math inline">\(A\preceq\omega\)</span>，即存在A到<spanclass="math inline">\(\omega\)</span>的单射，则称A可数，否则为不可数。</p><ul><li>若<spanclass="math inline">\(A\sim\omega\)</span>，则称A为可数的无穷集合。</li><li>可数多个可数集合的并集可数。</li></ul><p>不可数集的构造：</p><ol type="1"><li><p>康托尔定理：<span class="math inline">\(\forall A,A\prec \mathcalP(A)\)</span></p></li><li><p>对角线方法证明(0,1)不可数。</p></li></ol><p>连通性假设：<span class="math inline">\(\forall A,\omega\preceqA\)</span>且<span class="math inline">\(A\preceq\R\)</span>，则要么<spanclass="math inline">\(A\sim\omega\)</span>，要么<spanclass="math inline">\(A\sim\R\)</span>。</p><ul><li>换言之，不存在集合<span class="math inline">\(A\)</span>使得<spanclass="math inline">\(\omega\preceq A\)</span>且<spanclass="math inline">\(A\preceq\R。\)</span></li></ul><h3 id="序数">9. 序数</h3><p>序数：具有三歧性的传递集合。</p><ul><li><p>如果<span class="math inline">\(\alpha\)</span>是序数，<spanclass="math inline">\(\alpha^+\)</span>也是序数；序数的每个元素也是序数。</p></li><li><p>对任意两个序数<spanclass="math inline">\(\alpha、\beta\)</span>都有<spanclass="math inline">\(\alpha\in\beta\)</span>，或者<spanclass="math inline">\(\alpha=\beta\)</span>，或者<spanclass="math inline">\(\beta\in\alpha\)</span>。</p></li></ul><p>对于自然数n，归纳定义<spanclass="math inline">\(\omega+n\)</span>：</p><ol type="1"><li><span class="math inline">\(\omega+0=\omega\)</span></li><li><span class="math inline">\(\omega+(n+1)=(\omega+n)^+\)</span></li></ol><p>对任意自然数有<spanclass="math inline">\(\omega+n\)</span>为序数。</p><p>用<span class="math inline">\(O_n\)</span>表示所有序数的类。</p><ul><li><p><span class="math inline">\(O_n\)</span>不是集合，否则<spanclass="math inline">\(O_n\)</span>是序数，<spanclass="math inline">\(O_n\subseteqO_n\)</span>，与正则公理矛盾。</p></li><li><p>任何序数在属于关系上是良序集，我们用&lt;表示序数的属于关系。</p></li></ul><h4 id="替换公理">替换公理</h4><p>设<spanclass="math inline">\(P(x,y)\)</span>为类关系，A是一个集合，如果<spanclass="math inline">\(\forall x\in A\)</span>，有唯一<spanclass="math inline">\(y_x\)</span>，使得<spanclass="math inline">\(P(x,y_x)\)</span>成立，则<spanclass="math inline">\(\{y_x|x\in A\}\)</span>是集合。</p><h4 id="同构定理">同构定理</h4><p>设<spanclass="math inline">\((A,\le_A)\)</span>是良序集，则存在唯一的序数<spanclass="math inline">\(\alpha\)</span>，使得<spanclass="math inline">\((A,\le_A)\)</span>和<spanclass="math inline">\((\alpha,\le)\)</span>序同构。</p><ul><li>序同构：存在双射<spanclass="math inline">\(f:A\rightarrow\alpha\)</span>，对<spanclass="math inline">\(\forall x,y\in A\)</span>，<spanclass="math inline">\(x\le_A y\)</span>当且仅当<spanclass="math inline">\(f(x)\le f(y)\)</span>。</li></ul><h4 id="极限序数">极限序数</h4><p>不是后继序数的非零序数称为极限序数。</p><ul><li><p>后继序数：设<spanclass="math inline">\(\alpha\)</span>为序数，如果存在序数<spanclass="math inline">\(\beta\)</span>使得<spanclass="math inline">\(\alpha=\beta^+\)</span>，则称<spanclass="math inline">\(\alpha\)</span>为后继序数。</p></li><li><p>大于0的自然数都是后继序数，<spanclass="math inline">\(\omega\)</span>是最小的极限序数。</p></li></ul><p><span class="math inline">\(\alpha\)</span>为极限序数当且仅当：</p><ul><li><p>对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都有<spanclass="math inline">\(\beta^+\lt\alpha\)</span>。</p></li><li><p><spanclass="math inline">\(\alpha\)</span>中无最大元，即对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都存在<spanclass="math inline">\(\gamma\lt\alpha\)</span>，使得<spanclass="math inline">\(\beta\lt\gamma\)</span>。</p></li></ul><h4 id="可数序数">可数序数</h4><p>如果序数是可数集合，则称它为可数序数。</p><ol type="1"><li>定义<spanclass="math inline">\(\omega_1=\{\alpha|\alpha是可数序数\}\)</span>。<ul><li><span class="math inline">\(\omega_1\)</span>是不可数序数。</li></ul></li><li>定义<spanclass="math inline">\(\omega_{\alpha+1}=\{\beta|\beta是序数且\beta\preceq\omega_\alpha\}\)</span>。</li><li>定义<spanclass="math inline">\(\omega_\lambda=\bigcup\{\omega_\alpha|\alpha\lt\lambda\}\)</span>。</li></ol><p>对任意序数<spanclass="math inline">\(\alpha,\beta\)</span>，如果<spanclass="math inline">\(\beta\lt\alpha\)</span>，则<spanclass="math inline">\(\omega_\beta\prec\omega_\alpha\)</span>。</p><h3 id="超穷归纳法">10. 超穷归纳法</h3><p>扩展数学归纳法：</p><p>设<span class="math inline">\(R(x)\)</span>为一个性质，假设</p><ol type="1"><li><p><span class="math inline">\(R(0)\)</span>成立</p></li><li><p>对任意的序数<spanclass="math inline">\(\alpha\)</span>，如果<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\alpha+1)\)</span>也成立</p></li><li><p>对于任意的极限序数<spanclass="math inline">\(\lambda\)</span>，如果<spanclass="math inline">\(\forall\alpha\lt\lambda\)</span>，<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\lambda)\)</span>成立</p></li></ol><p>那么对于任意的序数<spanclass="math inline">\(\alpha\)</span>都有<spanclass="math inline">\(R(\alpha)\)</span>成立。</p><p>超穷归纳法定义序数加法<spanclass="math inline">\(\alpha+\beta\)</span>：</p><ol type="1"><li><span class="math inline">\(\alpha+0=\alpha\)</span></li><li><spanclass="math inline">\(\alpha+\beta^+=(\alpha+\beta)^+\)</span></li><li><spanclass="math inline">\(\alpha+\lambda=\bigcup_{\beta\lt\lambda}(\alpha+\beta)\)</span>，<spanclass="math inline">\(\lambda\)</span>为极限序数</li></ol><p>超穷归纳法定义序数乘法<spanclass="math inline">\(\alpha·\beta\)</span>：</p><ol type="1"><li><span class="math inline">\(\alpha·0=0\)</span></li><li><spanclass="math inline">\(\alpha·\beta^+=(\alpha·\beta)+\alpha\)</span></li><li><spanclass="math inline">\(\alpha·\lambda=\bigcup_{\beta\lt\lambda}(\alpha·\beta)\)</span>，<spanclass="math inline">\(\lambda\)</span>为极限序数</li></ol><p>序数加法和乘法都满足结合律。</p><p>超穷归纳定义<span class="math inline">\(V_\alpha\)</span>：</p><ol type="1"><li><span class="math inline">\(V_0=\empty\)</span></li><li><span class="math inline">\(V_{\alpha+1}=V_\alpha\cup\mathcalP(V_\alpha)\)</span></li><li><spanclass="math inline">\(V_\lambda=\bigcup_{\alpha\lt\lambda}V_\alpha\)</span>，<spanclass="math inline">\(\lambda\)</span>为极限序数</li></ol><h3 id="基数">11. 基数</h3><p>用来衡量集合中元素的多少。</p><p>设<spanclass="math inline">\(\alpha\)</span>是一个序数，如果对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>都有<spanclass="math inline">\(\beta\prec\alpha\)</span>，则称<spanclass="math inline">\(\alpha\)</span>是基数。</p><ul><li>每个自然数都是基数，<spanclass="math inline">\(\omega\)</span>也是基数，当把它作为基数时，通常写作<spanclass="math inline">\(\omega_0\)</span>。</li><li><span class="math inline">\(\omega_\alpha\)</span>是基数。</li></ul><p>定义<spanclass="math inline">\(Card=\omega\cup\{\omega_\alpha|\alpha\inO_n\}\)</span>，它是所有基数组成的类。</p><p>对任意集合<spanclass="math inline">\(A\)</span>，都存在唯一的基数与它等势，称作它的基数或势，记作<spanclass="math inline">\(|A|\)</span>。</p><p>后续内容暂略，详见0927.p48</p><h2 id="二命题逻辑">二、命题逻辑</h2><p>形式语言：符号集、语法规则、与自然语言间的翻译。</p><h3 id="语言">1. 语言</h3><p>命题逻辑的符号集：</p><ol type="1"><li>逻辑符号：<ul><li>命题联结符：<spanclass="math inline">\(\neg,\and,\or,\rightarrow,\leftarrow\)</span></li><li>括号</li></ul></li><li>参数：命题符号，例如<spanclass="math inline">\(A_1,A_2,...\)</span></li></ol><p>表达式是符号的有限序列，合式公式是语法正确的表达式。</p><p>5种命题联结符对应5种公式构造运算，合式公式由这5种公式构造运算和命题符号构造。</p><ul><li><span class="math inline">\(\mathcalD_\neg(\alpha)=(\neg\alpha)\)</span></li><li><span class="math inline">\(\mathcalD_\or(\alpha,\beta)=(\alpha\or\beta)\)</span></li><li><span class="math inline">\(\mathcalD_\and(\alpha,\beta)=(\alpha\and\beta)\)</span></li><li><span class="math inline">\(\mathcalD_\rightarrow(\alpha,\beta)=(\alpha\rightarrow\beta)\)</span></li><li><span class="math inline">\(\mathcalD_\leftrightarrow(\alpha,\beta)=(\alpha\leftrightarrow\beta)\)</span></li></ul><h4 id="归纳法则二元">归纳法则(二元)</h4><p>称集合S在二元函数f作用下是封闭的，当且仅当<spanclass="math inline">\(\forall x,y\in S,f(x,y)\in S\)</span>。</p><p>如果S是包含所有命题符号的合式公式的集合且在5种运算下封闭，那么S是所有合式公式的集合。</p><h3 id="真值指派">2. 真值指派</h3><p>对于命题符号集合<spanclass="math inline">\(S\)</span>，一个真值指派<spanclass="math inline">\(v\)</span>是指函数<spanclass="math inline">\(v:S\rightarrow\{F,T\}\)</span>，这个函数给<spanclass="math inline">\(S\)</span>中的每个符号指定了一个真值<spanclass="math inline">\(T\)</span>或<spanclass="math inline">\(F\)</span>。</p><p><spanclass="math inline">\(S\)</span>通过5种公式构造运算得到合式公式集合<spanclass="math inline">\(\overline S\)</span>，对应地将<spanclass="math inline">\(v\)</span>扩展到<spanclass="math inline">\(\overline v\)</span>，<spanclass="math inline">\(\overline v\)</span>根据命题联结符的规则给<spanclass="math inline">\(\overlineS\)</span>中每个合式公式指派一个真值<spanclass="math inline">\(T\)</span>或<spanclass="math inline">\(F\)</span>。</p><ul><li>对于S的任意真值指派v，通过5种运算构造出的<spanclass="math inline">\(\overline v\)</span>是唯一的。</li></ul><p>称一个真值指派v满足合式公式<spanclass="math inline">\(\varphi\)</span>当且仅当<spanclass="math inline">\(\overline v(\varphi)=T\)</span>。</p><h4 id="重言蕴涵">重言蕴涵</h4><p>合式公式集合<spanclass="math inline">\(\Sigma\)</span>，合式公式<spanclass="math inline">\(\tau\)</span>：</p><p><span class="math inline">\(\Sigma\)</span>重言蕴涵<spanclass="math inline">\(\tau\)</span>，记作<spanclass="math inline">\(\Sigma\models\tau\)</span>，当且仅当满足<spanclass="math inline">\(\Sigma\)</span>中每个公式的真值指派也满足<spanclass="math inline">\(\tau\)</span>。</p><ul><li><spanclass="math inline">\(\Sigma=\varnothing\)</span>，则任意真值指派能满足<spanclass="math inline">\(\tau\)</span>，这时称<spanclass="math inline">\(\tau\)</span>为重言式，记作<spanclass="math inline">\(\models\tau\)</span>。</li><li>如果没有真值指派能满足<spanclass="math inline">\(\Sigma\)</span>中每个公式，那么<spanclass="math inline">\(\Sigma\models\tau\)</span>恒真。</li></ul><p>如果<span class="math inline">\(\Sigma\)</span>中只有一个元素<spanclass="math inline">\(\sigma\)</span>，用<spanclass="math inline">\(\sigma\models\tau\)</span>取代<spanclass="math inline">\(\{\sigma\}\models\tau\)</span>。</p><ul><li>如果<span class="math inline">\(\sigma\models\tau\)</span>且<spanclass="math inline">\(\tau\models\sigma\)</span>，则称<spanclass="math inline">\(\sigma\)</span>和<spanclass="math inline">\(\tau\)</span>重言等价。</li></ul><h4 id="紧致性定理">紧致性定理</h4><p>设<spanclass="math inline">\(\Sigma\)</span>是合式公式的无限集合，如果对<spanclass="math inline">\(\Sigma\)</span>的任意有限子集<spanclass="math inline">\(\Sigma_0\)</span>，都存在一个真值指派能满足<spanclass="math inline">\(\Sigma_0\)</span>中的每个合式公式，那么就存在一个真值指派能满足<spanclass="math inline">\(\Sigma\)</span>的所有合式公式。</p><ul><li>另见第6节。</li></ul><h4 id="典型重言式">典型重言式</h4><ol type="1"><li><p><spanclass="math inline">\(\and,\or,\leftrightarrow\)</span>的交换律和结合律</p></li><li><p>分配律：</p><p><span class="math inline">\((A\and(B\or C))\leftrightarrow((A\andB)\or(A\and C))\)</span></p><p><span class="math inline">\((A\or(B\and C))\leftrightarrow((A\orB)\and(A\or C))\)</span></p></li><li><p>否定：</p><p><span class="math inline">\((\neg(\neg A))\leftrightarrowA\)</span></p><p><span class="math inline">\((\neg(A\rightarrowB))\leftrightarrow(A\or(\neg B))\)</span></p><p><span class="math inline">\((\neg(A\leftrightarrowB))\leftrightarrow((A\and(\neg B)\or((\neg A)\or B))\)</span></p><p>德摩根律：</p><p><span class="math inline">\((\neg(A\and B))\leftrightarrow((\negA)\or(\neg B))\)</span></p><p><span class="math inline">\((\neg(A\or B))\leftrightarrow((\negA)\and(\neg B))\)</span></p></li><li><p>其他：</p><p>排中律：<span class="math inline">\(A\or(\neg A)\)</span></p><p>矛盾律：<span class="math inline">\(\neg(A\and(\neg A))\)</span></p><p>逆否律：<span class="math inline">\((A\rightarrowB)\leftrightarrow((\neg B)\rightarrow(\neg A))\)</span></p><p>输出律：<span class="math inline">\(((A\and B)\rightarrowC)\leftrightarrow(A\rightarrow(B\rightarrow C))\)</span></p></li></ol><h3 id="解析算法">3. 解析算法</h3><p>证明使用括号可以消除语义模糊。</p><ul><li>每个合式公式具有同样多的左右括号。</li><li>合式公式的任意一个真的初始段含有的左括号多于右括号。</li></ul><p>解析算法过程：将给定表达式转化为一棵确定的树。</p><ol type="1"><li>树底只有命题符号时，过程结束；否则，选择其中一个非命题符号的表达式继续进行</li><li>第一个符号必定是<spanclass="math inline">\((\)</span>，第二个符号如果是<spanclass="math inline">\(\neg\)</span>则到4，否则到3</li><li>从左开始扫描表达式，直到遇见<spanclass="math inline">\((\alpha\)</span>，这里<spanclass="math inline">\(\alpha\)</span>是一个非空的左右括号平衡的表达式，下一个符号必是<spanclass="math inline">\(\or,\and,\rightarrow,\leftrightarrow\)</span>中的一个，剩下的部分是<spanclass="math inline">\(\beta)\)</span>。在当前树下添加两个新结点<spanclass="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>，返回1</li><li>表达式的前两个符号为<spanclass="math inline">\((\neg\)</span>，剩余的部分为<spanclass="math inline">\(\beta)\)</span>，在当前树下添加新结点<spanclass="math inline">\(\beta\)</span>，返回1</li></ol><h4 id="波兰记法">波兰记法</h4><p>5种构造运算改为：</p><ul><li><span class="math inline">\(\mathcalD_\neg(\alpha)=\neg\alpha\)</span></li><li><span class="math inline">\(\mathcalD_\or(\alpha,\beta)=\or\alpha\beta\)</span></li><li><span class="math inline">\(\mathcalD_\and(\alpha,\beta)=\and\alpha\beta\)</span></li><li><span class="math inline">\(\mathcalD_\rightarrow(\alpha,\beta)=\rightarrow\alpha\beta\)</span></li><li><span class="math inline">\(\mathcalD_\leftrightarrow(\alpha,\beta)=\leftrightarrow\alpha\beta\)</span></li></ul><h4 id="省略括号">省略括号</h4><ol type="1"><li>最外层括号可省略</li><li>否定符号外的括号可省略</li><li>应用析取和合取符号时尽量保持公式的简短</li><li>重复使用相同连接符号，先计算右边</li></ol><h3 id="归纳和递归">4. 归纳和递归</h3><h4 id="归纳法则">归纳法则</h4><p>假设<span class="math inline">\(C\)</span>是由<spanclass="math inline">\(B\)</span>中的元素通过<spanclass="math inline">\(\mathcal F\)</span>中的函数生成的，若<spanclass="math inline">\(S\)</span>是<spanclass="math inline">\(C\)</span>的子集，<spanclass="math inline">\(S\)</span>包含<spanclass="math inline">\(B\)</span>并且在<spanclass="math inline">\(\mathcal F\)</span>中的运算下是封闭的，那么<spanclass="math inline">\(S=C\)</span>。</p><h4 id="自由生成">自由生成</h4><p>称C是由B在<span class="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>的作用下自由生成的，当且仅当<spanclass="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>在C上的限制<spanclass="math inline">\(f_c\)</span>和<spanclass="math inline">\(g_c\)</span>满足以下条件：</p><ol type="1"><li><span class="math inline">\(f_c\)</span>和<spanclass="math inline">\(g_c\)</span>是一对一的</li><li><span class="math inline">\(f_c\)</span>的值域、<spanclass="math inline">\(g_c\)</span>的值域与集合B两两不交</li></ol><h4 id="递归定理">递归定理</h4><p>设U的子集C是由B在<span class="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>的作用下自由生成的，其中<spanclass="math inline">\(f:U\times U\rightarrow U,g:U\rightarrowU\)</span>。</p><p>设V是集合，函数F、G和h满足<span class="math inline">\(F:V\timesV\rightarrow V,G:V\rightarrow V,h:B\rightarrow V\)</span>。</p><p>那么存在<strong>唯一</strong>的函数<spanclass="math inline">\(\overline h:C\rightarrow V\)</span>使得：</p><ol type="1"><li>对B中的x，<span class="math inline">\(\overlineh(x)=h(x)\)</span></li><li>对C中的x，y，<span class="math inline">\(\overlineh(f(x,y))=F(\overline h(x),\overline h(y))\)</span>，<spanclass="math inline">\(\overline h(g(x))=G(\overline h(x))\)</span></li></ol><p>含义：只要我们正确地定义了基础情况（对应于B集合和h函数）和递归步骤（对应于f、g、F和G），那么递归扩展的过程是唯一和确定的。</p><h4 id="唯一可读性定理">唯一可读性定理</h4><p>合式公式的集合是由命题符号集在5种运算的作用下自由生成的，于是是真值指派的扩展是唯一的。</p><h3 id="命题联结符">5. 命题联结符</h3><h4 id="布尔函数">布尔函数</h4><p>k元布尔函数是指从<spanclass="math inline">\(\{F,T\}^k\)</span>到<spanclass="math inline">\(\{F,T\}\)</span>的函数。</p><p><span class="math inline">\(B_\alpha^n\)</span>(简写为<spanclass="math inline">\(B_\alpha\)</span>)定义为<spanclass="math inline">\(B_\alpha^n(X_1,...,X_n)=\alpha\)</span>的真值，当<spanclass="math inline">\(A_1=X_1,...,A_n=X_n\)</span>，</p><p>称为含有n个不同命题符号<spanclass="math inline">\(A_1,...,A_n\)</span>的合式公式<spanclass="math inline">\(\alpha\)</span><strong>实现</strong>的n元布尔函数。</p><ul><li>设G是一个n元布尔函数，<spanclass="math inline">\(n\ge1\)</span>，可以找到合式公式<spanclass="math inline">\(\alpha\)</span>实现G。</li></ul><p>设<span class="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>是合式公式，它们的命题符号在<spanclass="math inline">\(A_1,...,A_n\)</span>中，那么</p><ol type="1"><li><spanclass="math inline">\(\alpha\models\beta\)</span>当且仅当对所有的<spanclass="math inline">\(\vec X\in\{F,T\}^n,B_\alpha(\vec X)\leB_\beta(\vec X)\)</span>。</li><li><span class="math inline">\(\alpha\)</span>重言等价于<spanclass="math inline">\(\beta\)</span>当且仅当<spanclass="math inline">\(。B_\alpha=B_\beta\)</span></li><li><span class="math inline">\(\models\alpha\)</span>当且仅当<spanclass="math inline">\(B_\alpha\)</span>是具有真值T的常函数。</li></ol><h4 id="析取范式">析取范式</h4><p>显式给出了满足公式的真值指派。</p><p><spanclass="math inline">\(\alpha=\gamma_1\or...\or\gamma_k\)</span>，其中每个<spanclass="math inline">\(\gamma_i\)</span>是合取式<spanclass="math inline">\(\gamma_i=\beta_1\and...\and\beta_n\)</span>。</p><ul><li><p>对于任意可满足的合式公式，可以找到一个与其重言等价的析取范式。</p><p><spanclass="math inline">\(\{\and,\or,\neg\}\)</span>是完备的，每个布尔函数都可以由只使用<spanclass="math inline">\(\{\and,\or,\neg\}\)</span>中的联结词的合式公式实现。</p></li><li><p><span class="math inline">\(\{\neg,\and\}\)</span>和<spanclass="math inline">\(\{\neg,\or\}\)</span>都是完备的。</p></li></ul><h4 id="零元联结词">零元联结词</h4><p>两个0元布尔函数F和T，对应联结真值总为F的符号<spanclass="math inline">\(\bot\)</span>真值总为T的符号<spanclass="math inline">\(\top\)</span>。</p><h4 id="一元联结词">一元联结词</h4><p>否定联结词<spanclass="math inline">\(\neg\)</span>，恒等函数，上述的两个常值函数。</p><h4 id="二元联结词">二元联结词</h4><p><spanclass="math inline">\(\or,\and,\rightarrow,\leftarrow,\leftrightarrow\)</span></p><p><span class="math inline">\(+\)</span>：排他或，<spanclass="math inline">\((A\or B)\and\neg(A\and B)\)</span></p><p><span class="math inline">\(|\)</span>：与非，<spanclass="math inline">\(\neg(A\and B)\)</span></p><p><span class="math inline">\(\gt\)</span>：<spanclass="math inline">\(F\lt T\)</span>的排序，<spanclass="math inline">\(A\and(\neg B)\)</span></p><p><span class="math inline">\(&lt;\)</span>：<spanclass="math inline">\(F\lt T\)</span>的排序，<spanclass="math inline">\((\neg A)\and B\)</span></p><p><span class="math inline">\(\downarrow\)</span>：或非，<spanclass="math inline">\(\neg(A\or B)\)</span></p><p><span class="math inline">\(|\)</span>和<spanclass="math inline">\(\downarrow\)</span>是完备的。（<spanclass="math inline">\(\neg\alpha\)</span>等价于<spanclass="math inline">\(\alpha|\alpha\)</span>和<spanclass="math inline">\(\alpha\downarrow\alpha\)</span>）</p><h3 id="紧致性和能行性">6. 紧致性和能行性</h3><h4 id="紧致性定理-1">紧致性定理</h4><p>合式公式的集合是可满足的当且仅当它的每个有限子集是可满足的（有限可满足的）。</p><h4 id="能行性">能行性</h4><p>对于给定的表达式，存在一个能行的判定过程用来确定它是否是合式公式。</p><ul><li>即解析算法。</li></ul><h4 id="可判定性">可判定性</h4><p>表达式集合<spanclass="math inline">\(\Sigma\)</span>是可判定的当且仅当对于给定的表达式<spanclass="math inline">\(\alpha\)</span>，存在能行的过程判定<spanclass="math inline">\(\alpha\)</span>是否属于<spanclass="math inline">\(\Sigma\)</span>。</p><p>对于给定的有限多个合式公式的集合<spanclass="math inline">\(\Sigma;\tau\)</span>，存在能行的判定过程判定<spanclass="math inline">\(\Sigma\models\tau\)</span>是否成立。</p><ul><li>真值表。</li></ul><p>对于有限集合<spanclass="math inline">\(\Sigma\)</span>，它的重言推论集合是可判定的。特别地，重言式的集合是可判定的。</p><h4 id="能行可枚举">能行可枚举</h4><p>表达式集合A是能行可枚举的，当且仅当对于任意给定的表达式<spanclass="math inline">\(\varepsilon\)</span>，存在一个能行的判定过程，当<spanclass="math inline">\(\varepsilon\inA\)</span>成立时，返回判定结果。</p><ul><li>也称为半可判定的，区别在于，如果还没有得到<spanclass="math inline">\(\varepsilon\inA\)</span>，这个过程可能不停地运行下去。</li></ul><h4 id="kleene定理">Kleene定理</h4><p>表达式组成的一个集合是可判定的当且仅当它和它的补集都是能行可枚举的。</p><p>如果<spanclass="math inline">\(\Sigma\)</span>是合式公式的可判定集合，那么它的重言推论的集合是能行可枚举的。</p><h2 id="三一阶逻辑">三、一阶逻辑</h2><h3 id="语言-1">1. 语言</h3><p>一阶语言的符号集：</p><ol type="1"><li>逻辑符号<ul><li>括号</li><li>命题联结符号</li><li>变量</li><li>等于符号（可选）</li></ul></li><li>参数<ul><li>量词符号</li><li>谓词符号</li><li>常数符号</li><li>函数符号</li></ul></li></ol><p>表达式是符号的任意有限序列。</p><p>项是常数符号和变量通过使用0次或多次函数运算构成的表达式。</p><p>原子公式是项与谓词符号构成的表达式，相当于命题逻辑中的命题符号。</p><p>合式公式是原子公式通过0次或多次使用命题联结符和量词符号构成的表达式。</p><p>可以用显式书写每一个符号的方式来指定一个合式公式。</p><p>简化：</p><ul><li><p><span class="math inline">\((\alpha\or\beta)\)</span>简化<spanclass="math inline">\(((\neg\alpha)\rightarrow\beta)\)</span></p></li><li><p><span class="math inline">\((\alpha\and\beta)\)</span>简化<spanclass="math inline">\((\neg(\alpha\rightarrow(\neg\beta)))\)</span></p></li><li><p><spanclass="math inline">\((\alpha\leftrightarrow\beta)\)</span>简化<spanclass="math inline">\(((\alpha\rightarrow\beta)\and(\beta\rightarrow\alpha))\)</span></p></li><li><p><span class="math inline">\(\exist x\alpha\)</span>简化<spanclass="math inline">\((\neg\forall x(\neg\alpha))\)</span></p></li></ul><p>缩写和记法：</p><ul><li><p>最外层的括号可以省略</p></li><li><p>尽量少使用<spanclass="math inline">\(\neg,\or,\and,\rightarrow,\exist\)</span></p></li><li><p>当联结符号重复出现，表达式从右边开始分组</p></li></ul><h4 id="自由变量">自由变量</h4><p>考虑任意变量x，对每一个合式公式<spanclass="math inline">\(\alpha\)</span>，x在<spanclass="math inline">\(\alpha\)</span>中自由出现的递归定义：</p><ol type="1"><li>对原子公式<span class="math inline">\(\alpha\)</span>，x在<spanclass="math inline">\(\alpha\)</span>中自由出现当且仅当x出现在<spanclass="math inline">\(\alpha\)</span>中</li><li>x在<spanclass="math inline">\((\neg\alpha)\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>中自由出现</li><li>x在<spanclass="math inline">\((\alpha\rightarrow\beta)\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>或<spanclass="math inline">\(\beta\)</span>中自由出现</li><li>x在<span class="math inline">\(\forallv_i\alpha\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>中自由出现且<spanclass="math inline">\(x\neq v_i\)</span></li></ol><p>如果合式公式<spanclass="math inline">\(\alpha\)</span>中没有自由变量出现，那么<spanclass="math inline">\(\alpha\)</span>就是一个句子。</p><h3 id="真值与模型">2. 真值与模型</h3><p>一阶语言的<strong>结构</strong>指明：</p><ul><li><p>全称量词所指的事物集合</p></li><li><p>其他参数（谓词和函数符号）的含义</p></li></ul><p>形式上，一阶语言的一个<strong>结构</strong><spanclass="math inline">\(\mathfrak{A}\)</span>是一个函数，其定义域为参数的集合，且满足</p><ol type="1"><li><span class="math inline">\(\mathfrak{A}\)</span>为全称量词<spanclass="math inline">\(\forall\)</span>指派一个<strong>非空</strong>集合<spanclass="math inline">\(|\mathfrak{A}|\)</span>，称为<spanclass="math inline">\(\mathfrak{A}\)</span>的论域或者定义域</li><li><spanclass="math inline">\(\mathfrak{A}\)</span>为每一个n元谓词符号P指派一个n元关系，<spanclass="math inline">\(P^\mathfrak{A}\subseteq|\mathfrak{A}|^n\)</span>，即<spanclass="math inline">\(P^\mathfrak{A}\)</span>是P上一个n元组的集合</li><li><spanclass="math inline">\(\mathfrak{A}\)</span>给每个常数符号c指派一个论域<spanclass="math inline">\(|\mathfrak{A}|\)</span>中的元素<spanclass="math inline">\(c^\mathfrak{A}\)</span></li><li><spanclass="math inline">\(\mathfrak{A}\)</span>给每个n元函数符号f指派一个<spanclass="math inline">\(|\mathfrak{A}|\)</span>上的n元运算<spanclass="math inline">\(f^\mathfrak{A}:|\mathfrak{A}|^n\rightarrow|\mathfrak{A}|\)</span></li></ol><p>称一个结构是这个句子的<strong>模型</strong>，当使用该结构可以将形式语言的句子翻译为真的自然语言。</p><p>令：</p><ul><li><span class="math inline">\(\varphi\)</span>是语言中的合式公式</li><li><span class="math inline">\(\mathfrak{A}\)</span>是语言的结构</li><li><spanclass="math inline">\(s:V\rightarrow|\mathfrak{A}|\)</span>是从集合V的所有变量到A的论域<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数。</li></ul><p>由<span class="math inline">\(\mathfrak A\)</span>确定的<spanclass="math inline">\(\varphi\)</span>的翻译是真的，则称对于<spanclass="math inline">\(\mathfrak{A}\)</span>，s满足<spanclass="math inline">\(\varphi\)</span>的含义为<spanclass="math inline">\(\models_\mathfrak{A} \varphi[s]\)</span>。</p><p>对于每个句子<span class="math inline">\(\sigma\)</span>，如果<spanclass="math inline">\(\mathfrak{A}\)</span>以每个从V到<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数s满足<spanclass="math inline">\(\sigma\)</span>，那么称<spanclass="math inline">\(\sigma\)</span>在<spanclass="math inline">\(\mathfrak{A}\)</span>中是真的，<spanclass="math inline">\(\mathfrak{A}\)</span>是<spanclass="math inline">\(\sigma\)</span>的模型。</p><ul><li><spanclass="math inline">\(\mathfrak{A}\)</span>是句子集合的模型当且仅当<spanclass="math inline">\(\mathfrak{A}\)</span>是句子集合中每个句子的模型。</li></ul><p>模型刻画：</p><ol type="1"><li><span class="math inline">\(\models_\mathfrakA(\alpha\and\beta)[s]\)</span>当且仅当<spanclass="math inline">\(\models_\mathfrak A\alpha[s],\models_\mathfrak A\beta[s]\)</span>，<span class="math inline">\(\forall\)</span>和<spanclass="math inline">\(\leftrightarrow\)</span>类似</li><li><span class="math inline">\(\models_\mathfrak A\existx\alpha[s]\)</span>当且仅当存在某个<spanclass="math inline">\(d\in|\mathfrak A|\)</span>，具有属性<spanclass="math inline">\(\models_\mathfrak A\alpha[s(x|d)]\)</span></li></ol><h4 id="逻辑蕴涵">逻辑蕴涵</h4><p>设<span class="math inline">\(\Gamma\)</span>是合式公式的集合，<spanclass="math inline">\(\varphi\)</span>是一个合式公式：</p><p><span class="math inline">\(\Gamma\)</span>逻辑蕴涵<spanclass="math inline">\(\varphi\)</span>，记作<spanclass="math inline">\(\Gamma\models\varphi\)</span>，当且仅当对语言的每个结构<spanclass="math inline">\(\mathfrak{A}\)</span>和每个函数<spanclass="math inline">\(s:V\rightarrow|\mathfrak{A}|\)</span>，如果<spanclass="math inline">\(\mathfrak{A}\)</span>以s满足<spanclass="math inline">\(\Gamma\)</span>的每个元素，那么<spanclass="math inline">\(\mathfrak{A}\)</span>也以s满足<spanclass="math inline">\(\varphi\)</span>。</p><ul><li>恒真公式：<spanclass="math inline">\(\varnothing\models\varphi\)</span>，简写为<spanclass="math inline">\(\models\varphi\)</span>，对每个结构<spanclass="math inline">\(\mathfrak{A}\)</span>和每个函数s，<spanclass="math inline">\(\mathfrak{A}\)</span>以s满足<spanclass="math inline">\(\varphi\)</span>。</li></ul><h4 id="可定义性">可定义性</h4><p>考虑结构<spanclass="math inline">\(\mathfrak{A}\)</span>和合式公式<spanclass="math inline">\(\varphi\)</span>，其自由变元在<spanclass="math inline">\(v_1,...,v_k\)</span>中，可以构建<spanclass="math inline">\(\mathfrak{A}\)</span>上的k元关系</p><p><span class="math inline">\(\{\langa_1,...,a_k\rang|\models_\mathfrak A\varphi(a_1,...,a_k) \}\)</span></p><p>称此k元关系是在<spanclass="math inline">\(\mathfrak{A}\)</span>由<spanclass="math inline">\(\varphi\)</span>定义的。</p><p><span class="math inline">\(|\mathfrak{A}|\)</span>上的k元关系在<spanclass="math inline">\(\mathfrak{A}\)</span>中是可定义的当且仅当存在能够定义它的一个公式。</p><h4 id="结构类">结构类</h4><p>对句子集<span class="math inline">\(\Sigma\)</span>，用<spanclass="math inline">\(Mod\;\Sigma\)</span>表示<spanclass="math inline">\(\Sigma\)</span>的所有模型组成的类，即某种语言的所有结构的类，在这种语言中<spanclass="math inline">\(\Sigma\)</span>的每个元素都是真的。</p><ul><li>对单个句子<spanclass="math inline">\(\tau\)</span>，我们简单记作<spanclass="math inline">\(Mod\;\tau\)</span>，而不用<spanclass="math inline">\(Mod\{\tau\}\)</span>。</li></ul><p>语言的结构类<span class="math inline">\(\mathcalK\)</span>是<strong>初等类</strong>（<spanclass="math inline">\(EC\)</span>），当且仅当对某个句子<spanclass="math inline">\(\tau\)</span>，<spanclass="math inline">\(\mathcal K=Mod\;\tau\)</span>。</p><p><span class="math inline">\(\mathcal K\)</span>是广义初等类（<spanclass="math inline">\(EC_\Delta\)</span>）当且仅当对某个句子集合<spanclass="math inline">\(\Sigma\)</span>，<spanclass="math inline">\(\mathcal K=Mod\;\Sigma\)</span>。</p><h4 id="同态">同态</h4><p>从<span class="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>的一个<strong>同态</strong>是一个函数<spanclass="math inline">\(h:|\mathfrak{A}|\rightarrow|\mathfrak{B}|\)</span>，具有下列性质：</p><ul><li><p>对每个n元谓词参数<span class="math inline">\(P\)</span>和<spanclass="math inline">\(|\mathfrak{A}|\)</span>中元素的任意n元组<spanclass="math inline">\(\lang a_1,...,a_n\rang\)</span></p><p><span class="math inline">\(\lang a_1,...,a_n\rang\inP^\mathfrak{A}\; iff\;\lang h(a_1),...,h(a_n)\rang\inP^\mathfrak{B}\)</span></p></li><li><p>对每个n元函数符号f和任意n元组</p><p><spanclass="math inline">\(h(f^\mathfrak{A}(a_1,...,a_n))=f^\mathfrak{B}(h(a_1),...,h(a_n))\)</span></p></li><li><p>对于常数符号c，<span class="math inline">\(h(c^\mathfrakA)=c^\mathfrak{B}\)</span></p></li></ul><p>如果h是一对一的，那么这种同态称为<spanclass="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>中的<strong>同构</strong>。</p><p>如果存在<span class="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>上的同构，那么<spanclass="math inline">\(\mathfrak{A}\)</span>和<spanclass="math inline">\(\mathfrak{B}\)</span>称作是同构的，记作<spanclass="math inline">\(\mathfrak A\cong \mathfrak{B}\)</span>。</p><p>称两个结构<span class="math inline">\(\mathfrak{A}\)</span>和<spanclass="math inline">\(\mathfrak{B}\)</span>是初等等价的，记作<spanclass="math inline">\(\mathfrak{A}\equiv\mathfrak{B}\)</span>，当且仅当对任意的句子<spanclass="math inline">\(\sigma\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\sigma\Leftrightarrow\models_\mathfrak{B}\sigma\)</span>。</p><ul><li>同构的结构是初等等价的。</li></ul><p>同态定理：设h是从<spanclass="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>中的同态，s将变量的集合映射到<spanclass="math inline">\(|\mathfrak{B}|\)</span>中。</p><ul><li><p>对每个项t，我们有<spanclass="math inline">\(h(\overline{s}(t))=h\overline{\circ}s(t)\)</span>，其中<spanclass="math inline">\(\overline{s}(t)\)</span>是在<spanclass="math inline">\(\mathfrak{B}\)</span>中计算的，而<spanclass="math inline">\(h\overline{\circ}s(t)\)</span>是在<spanclass="math inline">\(\mathfrak{B}\)</span>中计算的。</p></li><li><p>对每个不包含等于符号的无量词的公式<spanclass="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\alpha[s]\;iff\;\models_\mathfrak{B}\alpha[h\circs]\)</span></p></li><li><p>如果h是一对一的，那么对每个无量词的公式<spanclass="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\alpha[s]\;iff\;\models_\mathfrak{B}\alpha[h\circs]\)</span></p></li><li><p>第二、三条可以删去无量词</p></li></ul><h3 id="演绎计算">3. 演绎计算</h3><p>证明应该是：</p><ul><li><p>有限长的；</p></li><li><p>能够进行验证的；</p></li></ul><p>无假设条件的可证明的公式集合必须是能行可枚举的。</p><h4 id="形式演绎">形式演绎</h4><p>选择一个有限的公式集合<spanclass="math inline">\(\Lambda\)</span>，称之为逻辑公理；使用假言推理的推理规则。</p><ul><li>假言推理：从公式<span class="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\alpha\rightarrow\beta\)</span>，可以得到<spanclass="math inline">\(\beta\)</span>。</li></ul><p>从<span class="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的一个<strong>演绎</strong>是一个有限的公式序列<spanclass="math inline">\(\lang \alpha_0,...,\alpha_n\rang\)</span>使得<spanclass="math inline">\(\alpha_n=\varphi\)</span>，对每个<spanclass="math inline">\(k\le n\)</span>有：</p><ol type="1"><li><spanclass="math inline">\(\alpha_k\in(\Gamma\cup\Lambda)\)</span>，或者</li><li><spanclass="math inline">\(\alpha_k\)</span>可以由出现在该公式前的两个公式通过假言推理得到。</li></ol><p>如果存在这样的演绎，则称<spanclass="math inline">\(\varphi\)</span>是由<spanclass="math inline">\(\Gamma\)</span>可演绎推出的，或者<spanclass="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\Gamma\)</span>的<strong>定理</strong>，记作<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>。</p><ul><li><p>从<span class="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的一个演绎可以看作是一个构造序列。</p></li><li><p>一个定理不只有一个唯一的演绎。</p></li></ul><p>归纳：设S是包含<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>的合式公式的集合，并且在假言推理下封闭，那么S包含<spanclass="math inline">\(\Gamma\)</span>的所有定理。</p><h4 id="逻辑公理">逻辑公理</h4><p>任意合式公式都是其自身的一个概化，逻辑公理都是如下形式合式公式的概化，其中x和y都是变量，<spanclass="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>都是合式公式。</p><ol type="1"><li>重言式</li><li><span class="math inline">\(\forallx\alpha\rightarrow\alpha_t^x\)</span>，其中t为x在<spanclass="math inline">\(\alpha\)</span>中的替换</li><li><span class="math inline">\(\forallx(\alpha\rightarrow\beta)\rightarrow(\forall x\alpha\rightarrow\forallx\beta)\)</span></li><li><span class="math inline">\(\alpha\rightarrow\forallx\alpha\)</span>，其中x在<spanclass="math inline">\(\alpha\)</span>中不是自由出现的</li></ol><p>如果语言包含相等符号则还要加上两组：</p><ol start="5" type="1"><li><span class="math inline">\(x=x\)</span></li><li><spanclass="math inline">\(x=y\rightarrow(\alpha\rightarrow\alpha&#39;)\)</span>，其中<spanclass="math inline">\(\alpha\)</span>是原子的且<spanclass="math inline">\(\alpha&#39;\)</span>是有限次的将<spanclass="math inline">\(\alpha\)</span>中的x替换为y的到的。</li></ol><p>合式公式<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\psi\)</span>的<strong>概化</strong>当且仅当对某个<spanclass="math inline">\(n\ge0\)</span>和某些变量<spanclass="math inline">\(x_1,...,x_n\)</span>，<spanclass="math inline">\(\varphi=\forall x_1...\forallx_n\psi\)</span>。</p><h5 id="替换">替换</h5><p>替换的递归定义：</p><ol type="1"><li>对原子公式<span class="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\alpha_t^x\)</span>是将公式<spanclass="math inline">\(\alpha\)</span>中自由出现的变量x都替换为t所得到的表达式。</li><li><spanclass="math inline">\((\neg\alpha)_t^x=(\neg\alpha_t^x)\)</span></li><li><spanclass="math inline">\((\alpha\rightarrow\beta)_t^x=(\alpha_t^x\rightarrow\beta_t^x)\)</span></li><li><span class="math inline">\((\forall y\alpha)_t^x=\begin{cases}\forall y\alpha\quad 如果x=y\\ \forall y(\alpha_t^x)\quad 如果x\neq y\end{cases}\)</span></li></ol><p>可替换性可以类似地递归定义。</p><h5 id="重言式">重言式</h5><p>基本公式：原子公式和形式为<span class="math inline">\(\forallx\alpha\)</span>的公式。</p><ul><li>任何公式都可以由基本公式通过<spanclass="math inline">\(\epsilon_\neg\)</span>和<spanclass="math inline">\(\epsilon_\rightarrow\)</span>的运算构造。</li><li>第一组公理都是命题逻辑重言式的概化。</li></ul><p><span class="math inline">\(\Gamma\vdash\varphi\)</span>当且仅当<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>重言蕴涵<spanclass="math inline">\(\varphi\)</span>。</p><h4 id="演绎和元定理">演绎和元定理</h4><p>自然语言中的定理称为<strong>元定理</strong>。</p><h5 id="概化定理">概化定理</h5><p>如果<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>且x不在<spanclass="math inline">\(\Gamma\)</span>的任何公式中自由出现，那么<spanclass="math inline">\(\Gamma\vdash\forall x\varphi\)</span>。</p><ul><li>规则T：如果<spanclass="math inline">\(\Gamma\vdash\alpha_1,...,\Gamma\vdash\alpha_n\)</span>，且<spanclass="math inline">\(\{\alpha_1,...,\alpha_n\}\)</span>重言蕴涵<spanclass="math inline">\(\beta\)</span>，那么<spanclass="math inline">\(\Gamma\vdash\beta\)</span>。</li></ul><h5 id="演绎定理">演绎定理</h5><p>如果<spanclass="math inline">\(\Gamma;\gamma\vdash\varphi\)</span>，那么<spanclass="math inline">\(\Gamma\vdash(\gamma\rightarrow\varphi)\)</span>。</p><ul><li>逆定理也成立，实际上逆定理就是假言推理。</li></ul><h5 id="不和谐">不和谐</h5><p>称一个公式集合是不和谐的当且仅当对某个<spanclass="math inline">\(\beta\)</span>，<spanclass="math inline">\(\beta\)</span>与<spanclass="math inline">\(\neg\beta\)</span>都是这个集合的定理。</p><ul><li>此时任意公式都是该集合的定理，<spanclass="math inline">\(\beta\rightarrow\neg\beta\rightarrow\alpha\)</span>是重言式。</li></ul><h5 id="逆否律">逆否律</h5><p><spanclass="math inline">\(\Gamma;\varphi\vdash\neg\psi\)</span>当且仅当<spanclass="math inline">\(\Gamma;\psi\vdash\neg\varphi\)</span>。</p><h5 id="归谬法">归谬法</h5><p><spanclass="math inline">\(\Gamma;\varphi\)</span>是不和谐的，那么<spanclass="math inline">\(\Gamma\vdash\neg\varphi\)</span>。</p><h3 id="可靠性和完备性理论">4. 可靠性和完备性理论</h3><p>可靠性定理：<spanclass="math inline">\(\Gamma\vdash\varphi\Rightarrow\Gamma\models\varphi\)</span>，可满足的公式集是和谐的。</p><p>完备性定理：<span class="math inline">\(\Gamma\models\varphi\Rightarrow\Gamma\vdash\varphi\)</span>，和谐的公式集是可满足的。</p><h4 id="紧致性定理-2">紧致性定理</h4><ol type="1"><li>如果<spanclass="math inline">\(\Gamma\models\varphi\)</span>，那么存在某个有限的<spanclass="math inline">\(\Gamma_0\subseteq\Gamma\)</span>，有<spanclass="math inline">\(\Gamma_0\models\varphi\)</span>。</li><li>如果<span class="math inline">\(\Gamma\)</span>的每个有限子集<spanclass="math inline">\(\Gamma_0\)</span>都是有限可满足的，那么<spanclass="math inline">\(\Gamma\)</span>是可满足的。</li></ol><p>特别地，句子集<spanclass="math inline">\(\Sigma\)</span>有模型当且仅当其每个有限子集有模型。</p><h4 id="可枚举定理">可枚举定理</h4><p>对合理的语言，恒真合式公式集合是能行可枚举的。</p><ul><li>合理的语言指其参数集合能行可枚举。</li></ul><h3 id="理论的模型">5. 理论的模型</h3><p>理论是逻辑蕴涵意义下封闭的句子集合。</p><p>结构<span class="math inline">\(\mathfrak A\)</span>的理论，记作<spanclass="math inline">\(Th\;\mathfrak A\)</span>，是<spanclass="math inline">\(\mathfrak A\)</span>中为真的所有句子的集合。</p><p>句子集合<spanclass="math inline">\(\Sigma\)</span>逻辑蕴涵的所有句子的集合是它的推论集，记作<spanclass="math inline">\(Cn\Sigma=\{\sigma|\Sigma\models\sigma\}=Th\;Mod\;\Sigma\)</span>。</p><p>理论T称为是完备的，当且仅当对每个句子<spanclass="math inline">\(\sigma\)</span>，<spanclass="math inline">\(\sigma\in T\)</span>或者<spanclass="math inline">\(\neg\sigma\in T\)</span>。</p><p>理论T是可公理化的，当且仅当存在可判定的句子集合<spanclass="math inline">\(\Sigma\)</span>，使得<spanclass="math inline">\(T=Cn\Sigma\)</span>。</p><p>理论T是有限可公理化的，当且仅当存在可判定的有限句子集合<spanclass="math inline">\(\Sigma\)</span>，使得<spanclass="math inline">\(T=Cn\Sigma\)</span>。</p><p>一个可公理化的理论是能行可枚举的。</p><p>完备的可公理化理论是可判定的。</p><h2 id="四不可判定性">四、不可判定性</h2><p>数论语言是包含=和以下参数的一阶语言：</p><ul><li><span class="math inline">\(\forall\)</span>：对任意自然数</li><li><span class="math inline">\(\mathbf 0\)</span>：常数符号</li><li><span class="math inline">\(S\)</span>：后继函数</li><li><span class="math inline">\(\lt\)</span>：二元谓词符号</li><li><span class="math inline">\(+,·,E\)</span>：加法、乘法和幂乘</li></ul><p>数论的结构可以写作<span class="math inline">\(\mathfrakN=(\N;0,S,\lt,+,·,E)\)</span></p><p>这个模型的理论<span class="math inline">\(Th\;\mathfrakN\)</span>就是数论。</p><h3 id="可表示性">1. 可表示性</h3><p>一个关系在T中是可表示的，当且仅当存在一个公式，它在T中表示该关系。</p><h4 id="丘奇论题">丘奇论题</h4><p>设T是一个可公理化的和谐理论，R在T中可表示，则R是可判定的。</p><p>丘奇论题：自然数上的关系R是递归的，当且仅当R在某个有限可公理化的和谐理论中可表示。</p><ul><li>一个关系是可判定的当且仅当它是递归的。</li></ul><h4 id="可计算性">可计算性</h4><p>函数<spanclass="math inline">\(f:\N^k\rightarrow\N\)</span>是可计算的，当且仅当对于给定的k元自然数组<spanclass="math inline">\(\vec a\)</span>，存在一个能行的过程给出<spanclass="math inline">\(f(\vec a)\)</span>的值。</p><ul><li><p>对于函数<spanclass="math inline">\(f:\N^k\rightarrow\N\)</span>，以下三个论述等价</p><ol type="a"><li><p>f是可计算的</p></li><li><p>f是可判定的</p></li><li><p>f是能行可枚举的</p></li></ol></li></ul><h4 id="可表示函数">可表示函数</h4><p>设<span class="math inline">\(g\)</span>是n元函数，<spanclass="math inline">\(h_1,...,h_n\)</span>是m元函数，<spanclass="math inline">\(f\)</span>由下式定义：</p><p><spanclass="math inline">\(f(a_1,...,a_m)=g(h_1(a_1,...,a_m),...,h_n(a_1,...,a_m))\)</span></p><p>如果<spanclass="math inline">\(g,h_1,...,h_n\)</span>是可函数表示的，那么可以找到一个公式函数表示<spanclass="math inline">\(f\)</span>。</p><h3 id="不完全性和不可判定性">2. 不完全性和不可判定性</h3><h4 id="不动点引理">不动点引理</h4><p>对于只含有自由变元<span class="math inline">\(v_1\)</span>的公式<spanclass="math inline">\(\beta\)</span>，可以找到句子<spanclass="math inline">\(\sigma\)</span>使得<spanclass="math inline">\(\vdash[\sigma\leftrightarrow\beta(S^{\#\sigma}0)]\)</span>。</p><p>塔斯基不可定义定理：集合<span class="math inline">\(\#Th\;\mathfrakN\)</span>在<span class="math inline">\(\mathfrakN\)</span>中是不可定义的。</p><h4 id="哥德尔不完全性定理">哥德尔不完全性定理</h4><p>如果<span class="math inline">\(A\in Th\;\mathfrakN\)</span>，并且<spanclass="math inline">\(\#A\)</span>是递归的，则<spanclass="math inline">\(Cn\;A\)</span>不是一个完全理论。</p><h4 id="丘奇定理">丘奇定理</h4><p>在数论语言中，取值为真的句子的哥德尔数的集合不是递归的。</p><h4 id="递归可枚举">递归可枚举</h4><p>自然数上的一个关系是递归可枚举的，当且仅当它具有形式<spanclass="math inline">\(\{\vec a|\exist b\lang\vec a,b\rang\inQ\}\)</span>，其中Q是递归的。</p><ul><li>以下关于m元关系R的结论等价：<ul><li>R是递归可枚举的</li><li>R是某个递归函数Q的定义域</li><li>对于某个递归的(m+1)元关系Q，<span class="math inline">\(R=\{\langa_1,...,a_m\rang|\exist b_1,...,b_n\lang a_1,...,a_m,b_1,...,b_n\rang\inQ\}\)</span></li></ul></li></ul><h3 id="递归函数">3. 递归函数</h3><h4 id="部分函数和全函数">部分函数和全函数</h4><p>m元部分函数是指<spanclass="math inline">\(dom\;f\subseteq\N^m\)</span>且<spanclass="math inline">\(ran\;f\subseteq\N\)</span>的函数<spanclass="math inline">\(f\)</span>，对<span class="math inline">\(\veca\notin dom\;f\)</span>，称<span class="math inline">\(f(\veca)\)</span>无定义。</p><p>如果<span class="math inline">\(dom\;f=\N^m\)</span>，称<spanclass="math inline">\(f\)</span>为全函数。</p><p>m元部分函数<spanclass="math inline">\(f\)</span>是<strong>可计算的</strong>当且仅当存在一个可行的过程使得：</p><ol type="1"><li>对于<span class="math inline">\(dom\;f\)</span>中的m元组<spanclass="math inline">\(\vec a\)</span>，这个过程能够得出<spanclass="math inline">\(f(\vec a)\)</span>，并且</li><li>对于不在<span class="math inline">\(dom\;f\)</span>中的<spanclass="math inline">\(\vec a\)</span>，这个过程没有输出值。</li></ol><p>m元部分函数<spanclass="math inline">\(f\)</span>是可计算的当且仅当<spanclass="math inline">\(f\)</span>作为关系是能行可枚举的。</p><h4 id="范式定理">范式定理</h4><p>在<span class="math inline">\(\lange,a_1,...,a_m\rang\)</span>的值是<spanclass="math inline">\([[e]]_m(a_1,...,a_m)\)</span>的m+1元部分函数是部分递归函数。</p><ul><li>对于每个<span class="math inline">\(e\ge0\)</span>，<spanclass="math inline">\([[e]]_m\)</span>是部分递归函数。</li><li>对于任意m元部分递归函数，都存在某个e，使得这个部分递归函数等于<spanclass="math inline">\([[e]]_m\)</span>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数理逻辑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑_2_一阶逻辑</title>
    <link href="/2023/08/03/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/2_%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91/"/>
    <url>/2023/08/03/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/2_%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<p>飞流直下三千尺，疑是银河落九天。</p><span id="more"></span><h1 id="第二章-一阶逻辑">第二章 一阶逻辑</h1><h2 id="一阶语言">2.1 一阶语言</h2><h3 id="公式">公式</h3><p>表达式是符号的任意有限序列。</p><ul><li>大多数表达式是没有意义的，但是项和合式公式是具有特定意义的表达式。</li></ul><p>项是语言中的名词和代词，是可以翻译成对象名称的表达式。</p><ul><li>项定义为在常数符号和变量之前加上函数符号构成的表达式。<ul><li>如果没有函数符号，那么项就是常数符号和变量。</li></ul></li><li>项的集合是由常数符号和变量通过使用0次和多次运算<spanclass="math inline">\(F_f\)</span>得到的表达式的集合。</li></ul><p>原子公式是指那些没有使用联结符号和量词符号的合式公式。</p><ul><li>原子公式由n元谓词符号和n个项组成。</li></ul><p>合式公式的集合是由原子公式通过0次或多次使用<spanclass="math inline">\(\varepsilon_\neg,\varepsilon_\rightarrow\)</span>和<spanclass="math inline">\(Q_i(i=1,2,...)\)</span>运算构成的表达式的集合。</p><h3 id="自由变量">自由变量</h3><p>考虑任意变量x，对每一个合式公式<spanclass="math inline">\(\alpha\)</span>，x在<spanclass="math inline">\(\alpha\)</span>中自由出现的递归定义：</p><ol type="1"><li>对原子公式<span class="math inline">\(\alpha\)</span>，x在<spanclass="math inline">\(\alpha\)</span>中自由出现当且仅当x出现在<spanclass="math inline">\(\alpha\)</span>中</li><li>x在<spanclass="math inline">\((\neg\alpha)\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>中自由出现</li><li>x在<spanclass="math inline">\((\alpha\rightarrow\beta)\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>或<spanclass="math inline">\(\beta\)</span>中自由出现</li><li>x在<span class="math inline">\(\forallv_i\alpha\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>中自由出现且<spanclass="math inline">\(x\neq v_i\)</span></li></ol><p>如果合式公式<spanclass="math inline">\(\alpha\)</span>中没有自由变量出现，那么<spanclass="math inline">\(\alpha\)</span>就是一个句子。</p><h3 id="符号">符号</h3><p>可以用显式书写每一个符号的方式来指定一个合式公式。</p><p>惯用的缩写和记法：</p><ul><li><p><span class="math inline">\((\alpha\or\beta)\)</span>简化<spanclass="math inline">\(((\neg\alpha)\rightarrow\beta)\)</span></p></li><li><p><span class="math inline">\((\alpha\and\beta)\)</span>简化<spanclass="math inline">\((\neg(\alpha\rightarrow(\neg\beta)))\)</span></p></li><li><p><spanclass="math inline">\((\alpha\leftrightarrow\beta)\)</span>简化<spanclass="math inline">\(((\alpha\rightarrow\beta)\and(\beta\rightarrow\alpha))\)</span></p></li><li><p><span class="math inline">\(\exist x\alpha\)</span>简化<spanclass="math inline">\((\neg\forall x(\neg\alpha))\)</span></p></li><li><p>最外层的括号可以省略</p></li><li><p>尽量少使用<spanclass="math inline">\(\neg，\rightarrow\)</span>和<spanclass="math inline">\(\exist，\or，\and\)</span></p></li><li><p>当联结符号重复出现，表达式从右边开始分组</p></li></ul><h2 id="真值与模型">2.2 真值与模型</h2><p>一阶语言的结构指明：</p><ul><li><p>全称量词所指的事物集合</p></li><li><p>其他参数（谓词和函数符号）的含义</p></li></ul><p>形式上，一阶语言的一个<strong>结构</strong><spanclass="math inline">\(\mathfrak{A}\)</span>是一个函数，其定义域为参数的集合，且满足</p><ol type="1"><li><span class="math inline">\(\mathfrak{A}\)</span>为全称量词<spanclass="math inline">\(\forall\)</span>指派一个非空集合<spanclass="math inline">\(|\mathfrak{A}|\)</span>，称为<spanclass="math inline">\(\mathfrak{A}\)</span>的论域或者定义域</li><li><spanclass="math inline">\(\mathfrak{A}\)</span>为每一个n元谓词符号P指派一个n元关系，<spanclass="math inline">\(P^\mathfrak{A}\subseteq|\mathfrak{A}|^n\)</span>，即<spanclass="math inline">\(P^\mathfrak{A}\)</span>是P上一个n元组的集合</li><li><spanclass="math inline">\(\mathfrak{A}\)</span>给每个常数符号c指派一个论域<spanclass="math inline">\(|\mathfrak{A}|\)</span>中的元素<spanclass="math inline">\(c^\mathfrak{A}\)</span></li><li><spanclass="math inline">\(\mathfrak{A}\)</span>给每个n元函数符号f指派一个<spanclass="math inline">\(|\mathfrak{A}|\)</span>上的n元运算<spanclass="math inline">\(f^\mathfrak{A}:|\mathfrak{A}|^n\rightarrow|\mathfrak{A}|\)</span></li></ol><p>称一个结构是这个句子的<strong>模型</strong>，当使用该结构可以将形式语言的句子翻译为真的自然语言。</p><p><spanclass="math inline">\(\models_\mathfrak{A}\sigma\)</span>（句子<spanclass="math inline">\(\sigma\)</span>在结构<spanclass="math inline">\(\mathfrak{A}\)</span>中是真的）的定义：</p><p>令<spanclass="math inline">\(\varphi\)</span>是语言中的合式公式，<spanclass="math inline">\(\mathfrak{A}\)</span>是语言的结构，<spanclass="math inline">\(s:V\rightarrow|\mathfrak{A}|\)</span>是从集合V的所有变量到A的论域<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数。那么定义对于<spanclass="math inline">\(\mathfrak{A}\)</span>，s满足<spanclass="math inline">\(\varphi\)</span>的含义为<spanclass="math inline">\(\models_\mathfrak{A} \varphi[s]\)</span>。</p><ul><li><p>假定<span class="math inline">\(s_1\)</span>和<spanclass="math inline">\(s_2\)</span>是从<spanclass="math inline">\(V\)</span>到<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数，它们在合式公式<spanclass="math inline">\(\varphi\)</span>中自由出现的所有变量上取值相同，那么<spanclass="math inline">\(\models_\mathfrak{A} \varphi[s_1]\quad iff\quad\models_\mathfrak{A}\varphi[s_2]\)</span></p></li><li><p>对每个句子<spanclass="math inline">\(\sigma\)</span>，以下必有一条被满足：</p><ul><li><span class="math inline">\(\mathfrak{A}\)</span>以每个从V到<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数S满足<spanclass="math inline">\(\sigma\)</span></li><li><spanclass="math inline">\(\mathfrak{A}\)</span>无法以任何一个从V到<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数满足<spanclass="math inline">\(\sigma\)</span></li></ul><p>如果前者成立，称<span class="math inline">\(\sigma\)</span>在<spanclass="math inline">\(\mathfrak{A}\)</span>中是真的，即<spanclass="math inline">\(\mathfrak{A}\)</span>是<spanclass="math inline">\(\sigma\)</span>的模型，反之则是假的。</p></li><li><p><spanclass="math inline">\(\mathfrak{A}\)</span>是句子集合的模型当且仅当<spanclass="math inline">\(\mathfrak{A}\)</span>是句子集合中每个句子的模型。</p></li></ul><h3 id="逻辑蕴涵">逻辑蕴涵</h3><p>设<span class="math inline">\(\Gamma\)</span>是合式公式的集合，<spanclass="math inline">\(\varphi\)</span>是一个合式公式，那么<spanclass="math inline">\(\Gamma\)</span>逻辑蕴涵<spanclass="math inline">\(\varphi\)</span>，记作<spanclass="math inline">\(\Gamma\models\varphi\)</span>，当且仅当对语言的每个结构<spanclass="math inline">\(\mathfrak{A}\)</span>和每个函数<spanclass="math inline">\(s:V\rightarrow|\mathfrak{A}|\)</span>，使得<spanclass="math inline">\(\mathfrak{A}\)</span>以s满足<spanclass="math inline">\(\Gamma\)</span>的每个元素，<spanclass="math inline">\(\mathfrak{A}\)</span>也以s满足<spanclass="math inline">\(\varphi\)</span>。</p><ul><li>对句子集合<spanclass="math inline">\(\Sigma;\tau,\Sigma\models\tau\)</span>当且仅当<spanclass="math inline">\(\Sigma\)</span>的每个模型也是<spanclass="math inline">\(\tau\)</span>中的模型。句子<spanclass="math inline">\(\tau\)</span>是恒真的当且仅当其在每个结构下都是真的。</li></ul><h3 id="结构的可定义性">结构的可定义性</h3><p>论域上子集的可定义性：</p><p>结构<span class="math inline">\(\mathfrak{A}\)</span>和合式公式<spanclass="math inline">\(\varphi\)</span>，其自由变元在<spanclass="math inline">\(v_1,...,v_k\)</span>之中，那么可以构建<spanclass="math inline">\(|\mathfrak{A}|\)</span>上的k元关系<spanclass="math inline">\(\{|&lt;a_1,...,a_k&gt;|\models_\mathfrak{A}\varphi[a_1,...,a_k]\}\)</span>，称此k元关系是在<spanclass="math inline">\(\mathfrak{A}\)</span>中由<spanclass="math inline">\(\varphi\)</span>定义的。</p><ul><li>一般地，<spanclass="math inline">\(|\mathfrak{A}|\)</span>上的k元关系在<spanclass="math inline">\(\mathfrak{A}\)</span>中是可定义的当且仅当存在能够定义它的一个公式。</li></ul><p>对句子集<span class="math inline">\(\Sigma\)</span>，用<spanclass="math inline">\(Mod\;\Sigma\)</span>表示<spanclass="math inline">\(\Sigma\)</span>的所有模型组成的类，即某种语言的所有结构的类，在这种语言中<spanclass="math inline">\(\Sigma\)</span>的每个元素都是真的。对单个句子<spanclass="math inline">\(\tau\)</span>，我们简单记作<spanclass="math inline">\(Mod\;\tau\)</span>，而不用<spanclass="math inline">\(Mod\{\tau\}\)</span>。</p><p>语言的结构类K是<strong>初等类</strong>(elementary class，<spanclass="math inline">\(EC\)</span>)，当且仅当对某个句子<spanclass="math inline">\(\tau\)</span>，<spanclass="math inline">\(K=Mod\;\tau\)</span>。K是广义初等类(elementaryclass in wider sense，<spanclass="math inline">\(EC_\Delta\)</span>)当且仅当对某个句子集合<spanclass="math inline">\(\Sigma\)</span>，<spanclass="math inline">\(K=Mod\;\Sigma\)</span>。</p><h3 id="同态">同态</h3><p>从<span class="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>的一个<strong>同态</strong>是一个函数<spanclass="math inline">\(h:|\mathfrak{A}|\rightarrow|\mathfrak{B}|\)</span>，具有下列性质：</p><ul><li><p>对每个n元谓词参数<span class="math inline">\(P\)</span>和<spanclass="math inline">\(|\mathfrak{A}|\)</span>中元素的任意n元组<spanclass="math inline">\(&lt;a_1,...,a_n&gt;\)</span></p><p><span class="math inline">\(&lt;a_1,...,a_n&gt;\in P^\mathfrak{A}\;iff\;&lt;h(a_1),...,h(a_n)&gt;\in P^\mathfrak{B}\)</span></p></li><li><p>对每个n元函数符号f和任意n元组</p><p><spanclass="math inline">\(h(f^\mathfrak{A}(a_1,...,a_n))=f^\mathfrak{B}(h(a_1),...,h(a_n))\)</span></p></li><li><p>对于常数符号c，<spanclass="math inline">\(h(c^A)=c^\mathfrak{B}\)</span></p></li></ul><p>如果h是一对一的，那么这种同态称为<spanclass="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>中的<strong>同构</strong>。</p><p>如果存在<span class="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>上的同构，那么<spanclass="math inline">\(\mathfrak{A}\)</span>和<spanclass="math inline">\(\mathfrak{B}\)</span>称作是同构的，记作<spanclass="math inline">\(A\cong \mathfrak{B}\)</span>。</p><h4 id="同态定理">同态定理</h4><p>同态定理：设h是从<spanclass="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>中的同态，s将变量的集合映射到<spanclass="math inline">\(|\mathfrak{B}|\)</span>中。</p><ul><li><p>对每个项t，我们有<spanclass="math inline">\(h(\overline{s}(t))=h\overline{\circ}s(t)\)</span>，其中<spanclass="math inline">\(\overline{s}(t)\)</span>是在<spanclass="math inline">\(\mathfrak{B}\)</span>中计算的，而<spanclass="math inline">\(h\overline{\circ}s(t)\)</span>是在<spanclass="math inline">\(\mathfrak{B}\)</span>中计算的。</p></li><li><p>对每个不包含等于符号的无量词的公式<spanclass="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\alpha[s]\;iff\;\models_\mathfrak{B}\alpha[h\circs]\)</span></p></li><li><p>如果h是一对一的，那么对每个无量词的公式<spanclass="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\alpha[s]\;iff\;\models_\mathfrak{B}\alpha[h\circs]\)</span></p></li><li><p>第二、三条可以删去无量词</p></li></ul><p>称两个结构<span class="math inline">\(\mathfrak{A}\)</span>和<spanclass="math inline">\(\mathfrak{B}\)</span>是初等等价的，记作<spanclass="math inline">\(\mathfrak{A}\equiv\mathfrak{B}\)</span>，当且仅当对任意的句子<spanclass="math inline">\(\sigma\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\sigma\Leftrightarrow\models_\mathfrak{B}\sigma\)</span>。</p><ul><li>同构的结构是初等等价的。</li></ul><p>设h是A的自同构，R是|A|上的n元关系，那么对|A|中任意的<spanclass="math inline">\(a_1,...,a_n\)</span>，<spanclass="math inline">\(&lt;a_1,...,a_n&gt;\inR\Leftrightarrow&lt;h(a_1),...,h(a_n)&gt;\in R\)</span>。</p><h2 id="解析算法">2.3 解析算法</h2><h3 id="项的解析">项的解析</h3><p>定义符号函数K，使得对符号s，<spanclass="math inline">\(K(s)=1-n\)</span>，其中n是项的个数。</p><p><span class="math inline">\(K(x)=1-0=1\)</span>，对变量x；</p><p><span class="math inline">\(K(c)=1-0=1\)</span>，对常数符号c；</p><p><span class="math inline">\(K(f)=1-n\)</span>，对n元函数符号f；</p><p>通过如下方式将K扩充到表达式的集合：<spanclass="math inline">\(K(s_1s_2...s_n)=K(s_1)+...+K(s_n)\)</span></p><ul><li><p>对于任意项t，<span class="math inline">\(K(t)=1\)</span></p></li><li><p>项的任意终段是一个或者多个项的连接</p></li><li><p>一个项的任意真的初始段都不是项，如果<spanclass="math inline">\(t_1\)</span>是<spanclass="math inline">\(t\)</span>的真的初始段，那么<spanclass="math inline">\(K(t_1)\lt 1\)</span></p></li></ul><p>项的唯一可解释性定理：项集是由变量集和常数符号通过<spanclass="math inline">\(F_f\)</span>运算自由生成的。</p><h3 id="公式解析">公式解析</h3><p><span class="math inline">\(K(()=-1\)</span>；</p><p><span class="math inline">\(K())=1\)</span>；</p><p><span class="math inline">\(K(\forall)=-1\)</span>；</p><p><span class="math inline">\(K(\neg)=0\)</span>；</p><p><span class="math inline">\(K(\rightarrow)=-1\)</span>；</p><p><span class="math inline">\(K(=)=-1\)</span>；</p><p><span class="math inline">\(K(P)=1-n\)</span>，对n元谓词符号P。</p><p>对于任意合式公式<span class="math inline">\(\alpha\)</span>，<spanclass="math inline">\(K(\alpha)=1\)</span></p><ul><li><p>对于合式公式<spanclass="math inline">\(\alpha\)</span>的任意真的初始段<spanclass="math inline">\(\alpha&#39;\)</span>，<spanclass="math inline">\(K(\alpha&#39;)\lt 1\)</span></p></li><li><p>公式的任何真的初始段都不是公式</p></li></ul><p>公式的唯一可解释性定理：合式公式的结合是由原子公式通过<spanclass="math inline">\(\varepsilon_\neg,\varepsilon_\rightarrow,Q_i\)</span>运算自由生成的</p><h2 id="演绎计算">2.4 演绎计算</h2><p>证明应该是：</p><ul><li><p>有限长的；</p></li><li><p>能够进行验证的；</p></li></ul><p>无假设条件的可证明的公式集合必须是能行可枚举的。</p><h3 id="形式演绎">2.4.1 形式演绎</h3><p>选择一个有限的公式集合<spanclass="math inline">\(\Lambda\)</span>，称之为逻辑公理；</p><p>制定推理规则，这些规则可以使我们从某些公式获得新的公式。</p><p>对于公式集合<span class="math inline">\(\Gamma\)</span>，<spanclass="math inline">\(\Gamma\)</span>的<strong>定理</strong>是指由<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>中的公式通过有限次使用推理规则得到的公式。</p><ul><li><p>公式<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\Gamma\)</span>的定理，记作<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>。</p><p>为了得到公式<span class="math inline">\(\varphi\)</span>，由<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>使用推理规则的公式序列称为从<spanclass="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的一个演绎。</p></li></ul><p>我们选择的推理规则是假言推理。</p><h4 id="假言推理">假言推理</h4><p>从公式<span class="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\alpha\rightarrow\beta\)</span>，可以得到<spanclass="math inline">\(\beta\)</span>：<spanclass="math inline">\(\frac{\alpha,\alpha\rightarrow\beta}{\beta}\)</span>。</p><h4 id="演绎">演绎</h4><p>从<span class="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的一个演绎是一个有限的公式序列<spanclass="math inline">\(&lt;\alpha_0,...,\alpha_n&gt;\)</span>，使得<spanclass="math inline">\(\alpha_n=\varphi\)</span>，且对每个<spanclass="math inline">\(k\le n\)</span>，或者</p><ul><li><p><span class="math inline">\(\alpha_k\)</span>在<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>中</p></li><li><p><spanclass="math inline">\(\alpha_k\)</span>可以由序列中出现在该公式之前的两个公式通过假言推理得到，即：</p><p>对于小于k的i和j，<span class="math inline">\(\alpha_j\)</span>是<spanclass="math inline">\(\alpha_i\rightarrow\alpha_k\)</span>。</p></li></ul><p>如果存在这样的演绎，则称<spanclass="math inline">\(\varphi\)</span>是由<spanclass="math inline">\(\Gamma\)</span>可演绎推出的，或者<spanclass="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\Gamma\)</span>的定理，记作<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>。</p><ul><li><p>从<span class="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的一个演绎可以看作是一个构造序列。</p></li><li><p>一个定理不只有一个唯一的演绎。</p></li></ul><h4 id="归纳原理">归纳原理</h4><p>设S是包含<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>的合式公式的集合，并且在假言推理下封闭，那么S包含<spanclass="math inline">\(\Gamma\)</span>的所有定理。</p><h4 id="逻辑公理">逻辑公理</h4><p>任意合式公式都是其自身的一个概化，逻辑公理都是如下形式合式公式的概化，其中x和y都是变量，<spanclass="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>都是合式公式。</p><ol type="1"><li>重言式</li><li><span class="math inline">\(\forallx\alpha\rightarrow\alpha_t^x\)</span>，其中t为x在<spanclass="math inline">\(\alpha\)</span>中的替换</li><li><span class="math inline">\(\forallx(\alpha\rightarrow\beta)\rightarrow(\forall x\alpha\rightarrow\forallx\beta)\)</span></li><li><span class="math inline">\(\alpha\rightarrow\forallx\alpha\)</span>，其中x在<spanclass="math inline">\(\alpha\)</span>中不是自由出现的</li></ol><p>如果语言包含相等符号则还要加上两组：</p><ol start="5" type="1"><li><span class="math inline">\(x=x\)</span></li><li><spanclass="math inline">\(x=y\rightarrow(\alpha\rightarrow\alpha&#39;)\)</span>，其中<spanclass="math inline">\(\alpha\)</span>是原子的且<spanclass="math inline">\(\alpha&#39;\)</span>是有限次的将<spanclass="math inline">\(\alpha\)</span>中的x替换为y的到的。</li></ol><p>合式公式<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\psi\)</span>的<strong>概化</strong>当且仅当对某个<spanclass="math inline">\(n\ge0\)</span>和某些变量<spanclass="math inline">\(x_1,...,x_n\)</span>，<spanclass="math inline">\(\varphi=\forall x_1...\forallx_n\psi\)</span>。</p><h4 id="替换">替换</h4><p>替换的递归定义：</p><ol type="1"><li>对原子公式<span class="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\alpha_t^x\)</span>是将公式<spanclass="math inline">\(\alpha\)</span>中自由出现的变量x都替换为t所得到的表达式。</li><li><spanclass="math inline">\((\neg\alpha)_t^x=(\neg\alpha_t^x)\)</span></li><li><spanclass="math inline">\((\alpha\rightarrow\beta)_t^x=(\alpha_t^x\rightarrow\beta_t^x)\)</span></li><li><span class="math inline">\((\forall y\alpha)_t^x=\begin{cases}\forall y\alpha\quad 如果x=y\\ \forall y(\alpha_t^x)\quad 如果x\neq y\end{cases}\)</span></li></ol><p>可替换的递归定义</p><ol type="1"><li><p>对原子公式<span class="math inline">\(\alpha\)</span>，在<spanclass="math inline">\(\alpha\)</span>中t可以替换x。</p></li><li><p>在<spanclass="math inline">\((\neg\alpha)\)</span>中t可以替换x当且仅当在<spanclass="math inline">\(\alpha\)</span>中t可以替换x。在<spanclass="math inline">\((\alpha\rightarrow\beta)\)</span>中t可以替换x当且仅当在<spanclass="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>中t都可以替换x。</p></li><li><p>在<span class="math inline">\(\forally\alpha\)</span>中t可以替换x当且仅当</p><ul><li>x在<span class="math inline">\(\forally\alpha\)</span>中不是自由出现的；或</li><li>y在t中不出现且在<spanclass="math inline">\(\alpha\)</span>中t可以替换x。</li></ul></li></ol><h4 id="重言式">重言式</h4><p>基本公式：原子公式和形式为<span class="math inline">\(\forallx\alpha\)</span>的公式。</p><ul><li>任何公式都可以由基本公式通过<spanclass="math inline">\(\epsilon_\neg\)</span>和<spanclass="math inline">\(\epsilon_\rightarrow\)</span>的运算构造。</li><li>第一组公理都是命题逻辑重言式的概化。</li></ul><p>定理：<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>当且仅当<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>重言蕴涵<spanclass="math inline">\(\varphi\)</span>。</p><h3 id="演绎与元定理">2.4.2 演绎与元定理</h3><p>自然语言中的定理称为<strong>元定理</strong>。</p><h4 id="概化定理">概化定理</h4><p>如果<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>且x不在<spanclass="math inline">\(\Gamma\)</span>的任何公式中自由出现，那么<spanclass="math inline">\(\Gamma\vdash\forall x\varphi\)</span>。</p><p>引理（规则T）：如果<spanclass="math inline">\(\Gamma\vdash\alpha_1,...,\Gamma\vdash\alpha_n\)</span>，且<spanclass="math inline">\(\{\alpha_1,...,\alpha_n\}\)</span>重言蕴涵<spanclass="math inline">\(\beta\)</span>，那么<spanclass="math inline">\(\Gamma\vdash\beta\)</span>。</p><h4 id="演绎定理">演绎定理</h4><p>如果<spanclass="math inline">\(\Gamma;\gamma\vdash\varphi\)</span>，那么<spanclass="math inline">\(\Gamma\vdash(\gamma\rightarrow\varphi)\)</span>。</p><ul><li>逆定理也成立，实际上逆定理就是假言推理。</li></ul><h5 id="逆否律">逆否律</h5><p><spanclass="math inline">\(\Gamma;\varphi\vdash\neg\psi\)</span>当且仅当<spanclass="math inline">\(\Gamma;\psi\vdash\neg\varphi\)</span>。</p><ul><li>证明：<ul><li>由演绎定理，<spanclass="math inline">\(\Gamma;\varphi\vdash\neg\psi\Rightarrow\Gamma\vdash\varphi\rightarrow\neg\psi\)</span></li><li>由规则T，又<spanclass="math inline">\(\varphi\rightarrow\neg\psi\)</span>重言蕴涵<spanclass="math inline">\(\psi\rightarrow\neg\varphi\)</span>，上式<spanclass="math inline">\(\Rightarrow\Gamma\vdash\psi\rightarrow\neg\varphi\)</span></li><li>由假言推理，上式<spanclass="math inline">\(\Rightarrow\Gamma;\psi\vdash\neg\varphi\)</span></li></ul></li></ul><h5 id="不和谐">不和谐</h5><p>称一个公式集合是不和谐的当且仅当对某个<spanclass="math inline">\(\beta\)</span>，<spanclass="math inline">\(\beta\)</span>与<spanclass="math inline">\(\neg\beta\)</span>都是这个集合的定理。</p><ul><li>此时任意公式都是该集合的定理，<spanclass="math inline">\(\beta\rightarrow\neg\beta\rightarrow\alpha\)</span>是重言式。</li></ul><h5 id="归谬法">归谬法</h5><p><spanclass="math inline">\(\Gamma;\varphi\)</span>是不和谐的，那么<spanclass="math inline">\(\Gamma\vdash\neg\varphi\)</span>。</p><h3 id="策略">2.4.3 策略</h3><p>对于给定的<span class="math inline">\(\Gamma\)</span>和<spanclass="math inline">\(\varphi\)</span>，证明<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>的策略：</p><ul><li>穷举合式公式的有限序列直到发现一个<spanclass="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的演绎</li><li>在自然语言中给出<spanclass="math inline">\(\Gamma\)</span>的真值蕴涵<spanclass="math inline">\(\varphi\)</span>的真值的证明，再形式化为形式语言</li><li>仅基于<span class="math inline">\(\varphi\)</span>的语法形式：<ul><li>设<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\((\psi\rightarrow\theta)\)</span>，那么可以证明<spanclass="math inline">\(\Gamma;\psi\vdash\theta\)</span>。</li><li>设<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\forall x\psi\)</span>，如果x在<spanclass="math inline">\(\Gamma\)</span>中不是自由出现的，那么可以证明<spanclass="math inline">\(\Gamma\vdash\psi\)</span>。</li><li>设<span class="math inline">\(\varphi\)</span>是某个公式的否定：<ul><li>如果<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\neg(\psi\rightarrow\theta)\)</span>，那么可以证明<spanclass="math inline">\(\Gamma\vdash\psi\)</span>和<spanclass="math inline">\(\Gamma\vdash\neg\theta\)</span></li><li>如果<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\neg\neg\psi\)</span>，那么可以证明<spanclass="math inline">\(\Gamma\vdash\psi\)</span></li><li>如果<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\neg\forall x\psi\)</span>，可以证明<spanclass="math inline">\(\Gamma\vdash\neg\psi_t^x\)</span>，其中t是在<spanclass="math inline">\(\psi\)</span>中可替换x的某个项。<ul><li>这并非总是可行的，有可能会出现<spanclass="math inline">\(\Gamma\vdash\neg\forallx\psi\)</span>但对每个项t，<spanclass="math inline">\(\neg(\Gamma\vdash\neg\psi_{t}^x)\)</span></li></ul></li></ul></li></ul></li></ul><h4 id="常数的概化">常数的概化</h4><p>设<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>，且c是不在<spanclass="math inline">\(\Gamma\)</span>中出现的常数符号，那么存在变量y(不出现在<spanclass="math inline">\(\varphi\)</span>)使得<spanclass="math inline">\(\Gamma\vdash\forally\varphi_y^c\)</span>。另外，存在从<spanclass="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\forally\varphi_y^c\)</span>的演绎，在此演绎中不出现c。</p><ul><li><p>推论：设<spanclass="math inline">\(\Gamma\vdash\varphi_c^x\)</span>，其中常数符号c不在<spanclass="math inline">\(\Gamma\)</span>或<spanclass="math inline">\(\varphi\)</span>中出现，那么<spanclass="math inline">\(\Gamma\vdash\forallx\varphi\)</span>，并且存在从<spanclass="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\forall x\varphi\)</span>的演绎，<spanclass="math inline">\(\Gamma\)</span>中不出现c。</p></li><li><p><span class="math inline">\(EI\)</span>规则：设常数符号c不在<spanclass="math inline">\(\varphi、\psi\)</span>或者<spanclass="math inline">\(\Gamma\)</span>中出现，且<spanclass="math inline">\(\Gamma;\varphi_c^x\vdash\psi\)</span>，那么<spanclass="math inline">\(\Gamma;\existx\varphi\vdash\psi\)</span>，即存在从<spanclass="math inline">\(\Gamma;\exist x\varphi\)</span>到<spanclass="math inline">\(\psi\)</span>的演绎，其中不出现c。</p></li></ul><h4 id="字母变换式的存在性">字母变换式的存在性</h4><p>设<spanclass="math inline">\(\varphi\)</span>是公式，t是项，x是变量，那么可以找到一个公式<spanclass="math inline">\(\varphi&#39;\)</span>(与<spanclass="math inline">\(\varphi\)</span>的不同之处仅在于约束变量的选择)使得：</p><ol type="1"><li><spanclass="math inline">\(\varphi\vdash\varphi&#39;\)</span>且<spanclass="math inline">\(\varphi&#39;\vdash\varphi\)</span></li><li>在<spanclass="math inline">\(\varphi&#39;\)</span>中用t可以替换x</li></ol><p>该公式<span class="math inline">\(\varphi&#39;\)</span>称为<spanclass="math inline">\(\varphi\)</span>的字母变换式。</p><h4 id="相等">相等</h4><p>由<spanclass="math inline">\(v_1=v_2\)</span>给出的关系是自反的、对称的和传递的（也就是等价关系）。</p><h2 id="可靠性与完备性理论">2.5 可靠性与完备性理论</h2><h3 id="演绎计算的可靠性与完备性">演绎计算的可靠性与完备性</h3><p>可靠性定理：<spanclass="math inline">\(\Gamma\vdash\varphi\Rightarrow\Gamma\models\varphi\)</span>。</p><ul><li>引理：逻辑公理都是恒真的。</li></ul><p>完备性定理：<span class="math inline">\(\Gamma\models\varphi\Rightarrow\Gamma\vdash\varphi\)</span>。</p><h4 id="替换引理">替换引理</h4><p>替换<spanclass="math inline">\(\varphi\)</span>和s中的执行结果是等价的。</p><h3 id="完备性定理哥德尔1930">完备性定理（哥德尔，1930）</h3><ol type="a"><li><p>如果<spanclass="math inline">\(\Gamma\models\varphi\)</span>，那么<spanclass="math inline">\(\Gamma\vdash\varphi\)</span></p></li><li><p>任意和谐的公式集都是可满足的</p></li></ol><h3 id="紧致性定理">紧致性定理</h3><ol type="1"><li>如果<spanclass="math inline">\(\Gamma\models\varphi\)</span>，那么存在某个有限的<spanclass="math inline">\(\Gamma_0\subseteq\Gamma\)</span>，有<spanclass="math inline">\(\Gamma_0\models\varphi\)</span>。</li><li>如果<span class="math inline">\(\Gamma\)</span>的每个有限子集<spanclass="math inline">\(\Gamma_0\)</span>都是有限可满足的，那么<spanclass="math inline">\(\Gamma\)</span>是可满足的。</li></ol><p>特别地，句子集<spanclass="math inline">\(\Sigma\)</span>有模型当且仅当其每个有限子集有模型。</p><h3 id="可枚举定理">可枚举定理</h3><p>对合理的语言，恒真合式公式集合是能行可枚举的。</p><p>推论：设<spanclass="math inline">\(\Gamma\)</span>是合理语言的合式公式的可判定集。</p><ol type="1"><li><p><spanclass="math inline">\(\Gamma\)</span>的定理集是能行可枚举的；</p></li><li><p>由<spanclass="math inline">\(\Gamma\)</span>逻辑蕴涵的公式集<spanclass="math inline">\(\{\varphi|\Gamma\models\varphi\}\)</span>是能行可枚举的。</p></li></ol><h2 id="理论的模型">2.6 理论的模型</h2><p>理论是逻辑蕴涵意义下封闭的句子集合。</p><p>结构<span class="math inline">\(\mathfrak A\)</span>的理论，记作<spanclass="math inline">\(Th\;\mathfrak A\)</span>，是<spanclass="math inline">\(\mathfrak A\)</span>中为真的所有句子的集合。</p><p><spanclass="math inline">\(\Sigma\)</span>逻辑蕴涵的所有句子的集合称为它的推论集，记作<spanclass="math inline">\(Cn\Sigma=\{\sigma|\Sigma\models\sigma\}=Th\;Mod\;\Sigma\)</span>。</p><p>理论T称为是完备的，当且仅当对每个句子<spanclass="math inline">\(\sigma\)</span>，<spanclass="math inline">\(\sigma\in T\)</span>或者<spanclass="math inline">\(\neg\sigma\in T\)</span>。</p><p>理论T是可公理化的，当且仅当存在可判定的句子集合<spanclass="math inline">\(\Sigma\)</span>，使得<spanclass="math inline">\(T=Cn\Sigma\)</span>。</p><p>理论T是有限可公理化的，当且仅当存在可判定的有限句子集合<spanclass="math inline">\(\Sigma\)</span>，使得<spanclass="math inline">\(T=Cn\Sigma\)</span>。</p><p>一个可公理化的理论是能行可枚举的。</p><p>完备的可公理化理论是可判定的。</p>]]></content>
    
    
    <categories>
      
      <category>数理逻辑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑_0_集合基础</title>
    <link href="/2023/08/01/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/0_%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/08/01/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/0_%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>飞流直下三千尺，疑是银河落九天。</p><span id="more"></span><h1 id="第零章-集合基础">第零章 集合基础</h1><h2 id="集合论符号">集合论符号</h2><ul><li>“$$”用于表示一个证明的结束。</li><li>“如果···那么···”，即“蕴含”，缩写为“<spanclass="math inline">\(···\Longrightarrow···\)</span>”；“逆蕴含”则为"<spanclass="math inline">\(···\Longleftarrow···\)</span>"。</li><li>“当且仅当”缩写为“<spanclass="math inline">\(iff\)</span>”或符号“<spanclass="math inline">\(\Longleftrightarrow\)</span>”</li><li>“因为”缩写为“<spanclass="math inline">\(\because\)</span>”，因此缩写为“<spanclass="math inline">\(\therefore\)</span>”</li><li>“<span class="math inline">\(x\neq y\)</span>”是“<spanclass="math inline">\(x=y\)</span>”的否定，“<spanclass="math inline">\(x\notin y\)</span>”是“<spanclass="math inline">\(x\in y\)</span>”的否定，类似符号可推广</li></ul><p>集合是指一些对象的全体，这些对象称为集合的元素或成员。</p><ul><li><p><span class="math inline">\(t\in A\)</span>表示t是A的元素，<spanclass="math inline">\(x=y\)</span>表示x和y是同一个元素</p></li><li><p>如果A和B是两个集合，且对于任意元素t都有</p><p><span class="math inline">\(t\in A\quad iff\quad t\in B\)</span></p><p>那么<span class="math inline">\(A=B\)</span>。</p></li></ul><p>集合论的基本思想：集合是由其元素所确定的。</p><p>对于集合A，<spanclass="math inline">\(A;t\)</span>表示一个新的集合，其元素包括A的元素和元素t（可能是新的），即：</p><p><span class="math inline">\(A;t=A\cup \{t\}\)</span></p><p>集合的表示方法：</p><ul><li>列举法，也称为外延表示方法。</li><li>内涵表示方法，即这个集合由具有某些性质P的对象构成</li></ul><p>如果集合A的所有元素都是集合B的元素，我们称A是B的子集，记作<spanclass="math inline">\(A\subseteq B\)</span>。</p><ul><li>任何集合都是其自身的子集，空集是每个集合的子集</li></ul><h2 id="集合">集合</h2><p>对象是人们感觉和思维中确定的某些事物。我们总是使用对象的名来谈论它。</p><ul><li>对象的名称也可以作为对象，这时候我们通常加引号用以区别</li></ul><h3 id="集合的定义">集合的定义</h3><p>康托尔的集合定义：具有某种性质的、确定的、互异的对象所组成的整体。</p><ul><li>确定性：对于任意集合A和任意元素a，a是否是A的元素是客观确定的</li><li>互异性：一个集合中任意两个对象是不相等的</li></ul><p>罗素悖论集合论：不能用更简单的数学概念来给集合下一个确定的定义</p><ul><li>集合的概念是不能定义的</li><li>康托尔的集合定义只是对集合的一个描述</li></ul><p>罗素悖论：<span class="math inline">\(A=\{A:A\notinA\}\)</span>，可以推导出<span class="math inline">\(A\inA\)</span>当且仅当<span class="math inline">\(A\notin A\)</span>。</p><p>这说明弗雷格根据康托尔的表述引入的概括原则（对任意确定的性质P，所有基于性质P的对象组成的群体就是集合）是有问题的。</p><h3 id="公理化">公理化</h3><h4 id="外延公理-extensionality">外延公理 Extensionality</h4><p>如果X和Y有相同元素，则<spanclass="math inline">\(X=Y\)</span>。即</p><p><span class="math inline">\(A=B\quad iff\quad \forall x(x\in A\quadiff\quad x\in B)\)</span></p><h4 id="空集公理">空集公理</h4><p>存在一个集合，它不含任何元素，除此之外的其他集合都称为非空的。</p><p>空集是每个集合的子集。</p><h4 id="分离公理-separation">分离公理 Separation</h4><p>如果<spanclass="math inline">\(\varphi\)</span>是一性质，则对于任意集合A和参数p，存在一个集合<spanclass="math inline">\(B=\{u\in X:\varphi (u,p)\}\)</span>，它包含所有具有这个性质的A中的元素u。</p><ul><li>由外延公理，分离公理中的集合B是唯一确定的。</li></ul><p>Paring无序对公理：对任意a，b，存在一个集合<spanclass="math inline">\(\{a,b\}\)</span>，恰好含有元素a，b。</p><h2 id="关系">关系</h2><h3 id="幂集交集并集">幂集、交集、并集</h3><ul><li><p>集合A的幂集<span class="math inline">\(\RhoA\)</span>的元素是A的所有子集，即：</p><p><span class="math inline">\(\Rho A=\{x|x\subseteq A\}\)</span></p></li><li><p>集合A与B的并集<span class="math inline">\(A\cupB\)</span>是属于A或属于B的元素的集合</p></li><li><p>集合A与B的交集是所有A与B共有的元素的集合</p><ul><li>A与B不相交，当且仅当二者的交集为空集</li></ul></li></ul><p>对于非空集合A，其元素也是集合，有</p><ul><li><span class="math inline">\(\bigcupA=\{x|x属于A的某个元素\}\)</span></li><li><span class="math inline">\(\bigcapA=\{x|x属于A的每个元素\}\)</span></li></ul><h3 id="有序对">有序对</h3><h4 id="有序对的定义">有序对的定义</h4><p>元素x和y的有序对<spanclass="math inline">\(&lt;x,y&gt;\)</span>定义如下：</p><p><span class="math inline">\(&lt;x,y&gt;=&lt;u,v&gt;\quad iff\quadx=u且y=v\)</span></p><p>所有具有上述性质的定义都可以作为有序对的定义。</p><p>其中，一个标准的定义是<spanclass="math inline">\(&lt;x,y&gt;=\{\{x\},\{x,y\} \}\)</span></p><p>有序三元组可以定义为<spanclass="math inline">\(&lt;x,y,z&gt;=&lt;&lt;x,y&gt;,z&gt;\)</span></p><p>更一般地，对于<spanclass="math inline">\(n&gt;1\)</span>可以如下递归地定义n元组：</p><p><spanclass="math inline">\(&lt;x_1,x_2,...,x_{n+1}&gt;=&lt;&lt;x_1,x_2,...,x_n&gt;,x_{n+1}&gt;\)</span></p><p>为方便起见，对于<spanclass="math inline">\(n=1\)</span>，我们定义<spanclass="math inline">\(&lt;x&gt;=x\)</span>；这样上式对于<spanclass="math inline">\(n=1\)</span>也是成立的。</p><h4 id="有限序列">有限序列</h4><p>称S是A中元素的有限序列（有限串）当且仅当对某个正整数n，<spanclass="math inline">\(S=&lt;x_1,...,x_n&gt;\)</span>，其中每个<spanclass="math inline">\(x_i\in A\)</span>。</p><p>S的子段指一个有限序列<spanclass="math inline">\(&lt;x_k,x_{k+1},...,x_{m-1},x_m&gt;,1\leq k\leqm\leq n\)</span></p><ul><li>这个子段是初始段当且仅当<spanclass="math inline">\(k=1\)</span></li><li>这个子段是真子段当且仅当该子段与S不同</li></ul><p>如果<spanclass="math inline">\(&lt;x_1,...,x_n&gt;=&lt;y_1,...,y_n&gt;\)</span>，易证<spanclass="math inline">\(x_i=y_i,1\leq i\leq n\)</span></p><p>如果<spanclass="math inline">\(&lt;x_1,...,x_m&gt;=&lt;y_1,...y_n&gt;\)</span>，未必有<spanclass="math inline">\(m=n\)</span>，因为每个有序三元组也是一个有序对。</p><ul><li>只有当某个<span class="math inline">\(x_i\)</span>本身是<spanclass="math inline">\(y_i\)</span>的一个有限序列，或某个<spanclass="math inline">\(y_i\)</span>本身是<spanclass="math inline">\(x_i\)</span>的一个有限序列时，m和n才不相等。</li></ul><p>引理：如果<spanclass="math inline">\(&lt;x_1,...,x_m&gt;=&lt;y_1,...,y_m,...,y_{m+k}&gt;\)</span>，那么<spanclass="math inline">\(x_1=&lt;y_1,...,y_{k+1}&gt;\)</span></p><h4 id="笛卡尔积">笛卡尔积</h4><p>笛卡尔积<span class="math inline">\(A\times B\)</span>是所有序对<spanclass="math inline">\(&lt;x,y&gt;\)</span>的集合，其中<spanclass="math inline">\(x\in A,y\in B\)</span>，即<spanclass="math inline">\(A\times B=\{&lt;x,y&gt;|x\in A,y\in B\}\)</span></p><p><spanclass="math inline">\(A^n\)</span>表示A中元素构成的所有的n元组组成的集合，比如<spanclass="math inline">\(A^3=(A\times A)\times A\)</span></p><h3 id="关系-1">关系</h3><p>关系是有序对的集合。</p><ul><li>关系R的定义域记为dom R，是所有满足<spanclass="math inline">\(&lt;x,y&gt;\in R\)</span>的元素x的集合</li><li>关系R的值域记作ran R，是所有满足<spanclass="math inline">\(&lt;x,y&gt;\in R\)</span>的元素y的集合</li><li>dom R和ran R并称为R的域，记作fld R</li></ul><p>A上的n元关系是<span class="math inline">\(A_n\)</span>的子集，若<spanclass="math inline">\(n&gt;1\)</span>，它就是一个关系；<spanclass="math inline">\(n=1\)</span>，A上的一元关系只是A的一个子集。</p><ul><li><p>A上的一个特殊的二元关系是恒等关系<spanclass="math inline">\(\{&lt;x,x&gt;|x\in A \}\)</span></p></li><li><p>对于A上的二元关系R和A的一个子集B，R对B的限制指交集<spanclass="math inline">\(R\cap B^n\)</span></p></li></ul><p>对于关系R，定义：</p><ul><li><p>R在A上是自反的，当且仅当对A中每个x都有<spanclass="math inline">\(&lt;x,x&gt;\in R\)</span></p></li><li><p>R是对称的，当且仅当如果<span class="math inline">\(&lt;x,y&gt;\inR\)</span>，则<span class="math inline">\(&lt;y,x&gt;\inR\)</span></p></li><li><p>R是传递的，当且仅当如果<span class="math inline">\(&lt;x,y&gt;\inR,&lt;y,z&gt;\in R\)</span>，则<spanclass="math inline">\(&lt;x,z&gt;\in R\)</span></p></li></ul><p>R在A上满足三分律，当且仅当对A中任意的x和y，如下三种可能有且仅有一种成立：</p><ul><li><span class="math inline">\(&lt;x,y&gt;\in R\)</span></li><li><span class="math inline">\(x=y\)</span></li><li><span class="math inline">\(&lt;y,z&gt;\in R\)</span></li></ul><p>关系R是A上的一个等价关系当且仅当R是A上自反、对称和传递的一个二元关系；</p><p>关系R是A上的一个序关系当且仅当R是传递的且在A上满足三分律。</p><ul><li><p>对于A上的等价关系R盒<span class="math inline">\(x\inA\)</span>，定义x的等价类为<spanclass="math inline">\(\{y|&lt;x,y&gt;\in R\}\)</span></p><p>等价类划分了A，每个等价类都是A的子集，A的每个元素恰好只属于一个等价类。</p></li></ul><p>关系R的逆关系记为<spanclass="math inline">\(R^{-1}\)</span>，定义为<spanclass="math inline">\(R^{-1}=\{&lt;x,y&gt;|&lt;y,x&gt;\inR\}\)</span></p><h3 id="函数">函数</h3><p>一个具有单值性质的关系F，对于定义域domF中的每一个x，都有唯一的y满足<span class="math inline">\(&lt;x,y&gt;\inF\)</span>。通常，这个唯一的y称F在x上的值F(x)。</p><p>我们称F将定义域A映射到值域B，F是一个函数。</p><ul><li><p>F是一个一一映射当且仅当对于B中的每个y，存在唯一的x使得<spanclass="math inline">\(&lt;x,y&gt;\in F\)</span></p></li><li><p>如果<span class="math inline">\(&lt;x,y&gt;\)</span>在定义域domF中，则记<spanclass="math inline">\(F(x,y)=F(&lt;x,y&gt;)\)</span></p></li><li><p>这个记法可以推广到n元</p></li></ul><p>A上的n元运算是一个将<spanclass="math inline">\(A^n\)</span>映射到A中的函数。</p><h3 id="偏序关系">偏序关系</h3><p>序的一般理论：</p><p>设A为一个集合，R是A上的二元关系，称R为A上的偏序关系，如果满足如下条件：</p><ul><li><p>R具有自反性</p></li><li><p>R具有反对称性，且对任意<span class="math inline">\(x,y\inR\)</span>，如果<span class="math inline">\(xRy\)</span>且<spanclass="math inline">\(yRx\)</span>，则<spanclass="math inline">\(x=y\)</span></p></li><li><p>R具有传递性</p></li></ul><p>设A为一个集合，R是A上的二元关系，称R为A上的严格偏序关系，如果满足如下条件：</p><ul><li><p>R具有禁自反性，即任意x属于A都有非<spanclass="math inline">\(R(x,x)\)</span></p></li><li><p>R具有禁对称性，且对任意<span class="math inline">\(x,y\inA\)</span>，如果<span class="math inline">\(R(x,y)\)</span>，则非<spanclass="math inline">\(R(y,x)\)</span></p></li><li><p>R具有传递性</p></li></ul><p>自然数集N上面的小于关系就是严格的偏序关系。</p><p>极小元的定义：</p><p>如果<spanclass="math inline">\((A,\leq)\)</span>是偏序集，B包含于A，b属于B，称b为B的关于<spanclass="math inline">\(\leq\)</span>关系的极小元，如果不存在x属于B，使得<spanclass="math inline">\(x\neq b\)</span>且<spanclass="math inline">\(x\leq b\)</span>。</p><h3 id="良序关系">良序关系</h3><p>线序的定义：</p><p>如果<spanclass="math inline">\((A,\leq)\)</span>是偏序集，A中任意两个元素x，y都在偏序关系<spanclass="math inline">\(\leq\)</span>下可以比较，即要么<spanclass="math inline">\(x\leq y\)</span>，要么<spanclass="math inline">\(y\leq x\)</span>，则称<spanclass="math inline">\(\leq\)</span>关系是线序关系或全序关系。相应地称<spanclass="math inline">\((A,\leq)\)</span>为线序集或全序集。</p><p>如果<span class="math inline">\(\leq\)</span>为A上的线序，则称<spanclass="math inline">\(&lt;\)</span>为A上的严格线序。</p><p>良序的定义：</p><p>设<spanclass="math inline">\((A,\le)\)</span>是线序集，如果A的任意非空子集都有<spanclass="math inline">\(\le-\)</span>极小元，则称<spanclass="math inline">\((A,\le)\)</span>为良序集，且称<spanclass="math inline">\(\le\)</span>为A上的良序，或称A被<spanclass="math inline">\(\le\)</span>良序。</p><p>如果<spanclass="math inline">\(\le\)</span>是R上的良序，有时也称<spanclass="math inline">\(&lt;\)</span>是A上的良序。</p><ul><li>有穷的线序集都是良序集。</li><li>在定义中如果只要求偏序而不是线序，就称为良基偏序。</li></ul><h4 id="良序问题">良序问题</h4><p>是否对任意的集合A，都存在A上的良序关系？</p><p>良序原则：任意的集合都可以被良序</p><ul><li>良序原则和Zorn引理等价</li></ul><h3 id="乘积公理">乘积公理</h3><p>对任意集族<span class="math inline">\((X_i)_{i\inI}\)</span>，如果I为非空集合，且对任意<span class="math inline">\(i\inI\)</span>，集合<span class="math inline">\(X_i\)</span>非空，则<spanclass="math inline">\(\prod_{i\in I}X_i\)</span>非空。</p><h3 id="选择公理">选择公理</h3><p>对任意非空集合X，如果X中的元素均为非空集合，则存在映射f使得<spanclass="math inline">\(dom(f)=X\)</span>，且<spanclass="math inline">\(\forall x\in X\)</span>都有<spanclass="math inline">\(f(x)\in x\)</span>（称f为X上的选择函数）。</p><h3 id="可数">可数</h3><p>集合A是可数的，当且仅当存在某个函数将A一对一映射到自然数N中。</p><ul><li>设A是一个可数集，则所有由A的元素构成的有限序列的集合也可数</li></ul><h2 id="有穷与无穷集合">有穷与无穷集合</h2><h3 id="自然数的定义">自然数的定义</h3><p>集合的后继：</p><p>设A为任意的集合，我们称集合<span class="math inline">\(A\cup\{A\}\)</span>为A的后继集合，简称A的后继，记作<spanclass="math inline">\(A^+\)</span>，而A为<spanclass="math inline">\(A^+\)</span>的前趋。</p><p>自然数的定义：</p><ol type="1"><li><span class="math inline">\(0=\empty\)</span></li><li><span class="math inline">\(1=0^+=\{0\}\)</span></li><li><span class="math inline">\(2=1^+=\{0,1\}\)</span></li><li>假设我们已经定义了<spanclass="math inline">\(n=\{0,1,...,n-1\}\)</span>，则定义<spanclass="math inline">\(n+1=n^+=n\cup\{n\}=\{0,1,...,n-1,n\}\)</span></li><li>每个自然数都是从0开始经过有穷步后继运算的结果</li></ol><h3 id="无穷公理">无穷公理</h3><p>所有自然数组成的集合的整体是集合，记为<spanclass="math inline">\(\omega\)</span>。</p><h3 id="佐恩引理或极大原则">佐恩引理或极大原则</h3><p>设A是一个集合，且满足对于任意的链<spanclass="math inline">\(C\subseteq A\)</span>，有集合<spanclass="math inline">\(\bigcupC\)</span>在A中，那么A中存在极大元m，即m不是A中其他任意元素的子集。</p><ul><li>我们说一组集合C是一个链，当且仅当对于C中任意元素x和y，要么<spanclass="math inline">\(x\subseteq y\)</span>要么<spanclass="math inline">\(y\subseteq x\)</span></li></ul><h3 id="数学归纳法">数学归纳法</h3><p>集合形式的数学归纳法：</p><p>设S为一个集合，如果S满足如下两个条件：</p><ul><li><span class="math inline">\(0\in S\)</span></li><li>对任何自然数n，如果<span class="math inline">\(n\inS\)</span>，则<span class="math inline">\(n+1\in S\)</span></li></ul><p>则<span class="math inline">\(\omega \subseteqS\)</span>，即每个自然数对属于S。</p><h4 id="正则公理">正则公理</h4><p>每个非空集合A中总存在元素x使得<span class="math inline">\(x\capA=\empty\)</span>（此时称x为A的<span class="math inline">\(\in-\)</span>极小元）。</p><p>正则公理的蕴含：</p><ul><li><p>不存在集合<span class="math inline">\(x\in x\)</span></p></li><li><p>不存在集合x,y使得<span class="math inline">\(x\iny\)</span>且<span class="math inline">\(y\inx\)</span>。一般地，不存在集合<spanclass="math inline">\(x_1,...,x_n\)</span>使得<spanclass="math inline">\(x_1\in x_2,...,x_{n-1}\in x_n,x_n\inx_1\)</span>。</p><p>不存在集合<span class="math inline">\(\{x_n|n\in \omega使得每个n\in\omega 都有x_{n+1}\in x_n\}\)</span></p></li></ul><p>集合形式的数学归纳法证明：暂略，20230912，P30</p><p>性质形式的数学归纳原理：</p><p>设R是性质，如果有</p><ol type="1"><li>R(0)成立，且</li><li>对任意自然数n，若R(n)成立，R(n+1)也成立</li></ol><p>则对任意自然数n都有R(n)成立。</p><h4 id="传递集合">传递集合</h4><p>设A是一个集合，如果A的任意元素都是A的子集，则称A是传递集合。</p><ul><li><p>A为传递集合，则<span class="math inline">\(\forall x\in A,y\inx,y\in A\)</span>。</p></li><li><p>每个自然数都是传递集合</p></li><li><p><spanclass="math inline">\(\omega\)</span>是传递集合，即对任意自然数n都有n是<spanclass="math inline">\(\omega\)</span>的传递集合</p></li><li><p>引理：<span class="math inline">\(\forall n,m\in N,如果n\subseteqm,有n=m或者n\in m\)</span></p></li></ul><p>$<span class="math inline">\(-三歧性：\)</span>x,yA有xy或x=y或yx$</p><ul><li><span class="math inline">\(\omega\)</span>具有三歧性</li></ul><p>任意自然数n、m，定义</p><ul><li><span class="math inline">\(m&lt;n当且仅当m\in n\)</span></li><li><span class="math inline">\(m\le n当且仅当m&lt;n或m=n\)</span></li></ul><h3 id="有穷集合和无穷集合">有穷集合和无穷集合</h3><h4 id="等势集合">等势集合</h4><p>设A、B为两个集合，如果存在A到B上的双射，则称A与B等势，或称A与B对等，记为<spanclass="math inline">\(A～B\)</span></p><ul><li>直观上，A与B等势，则A和B有同样多的元素。</li></ul><p>等势关系是等价关系，即</p><ul><li><span class="math inline">\(\forall A,A～A\)</span></li><li><span class="math inline">\(\forallA,B,如果A～B,则B～A\)</span></li><li><span class="math inline">\(\forallA,B,C,如果A～B,B～C,则A～C\)</span></li></ul><h4 id="康托尔伯恩斯坦定理">康托尔伯恩斯坦定理</h4><p>设A、B为两个集合，假设<span class="math inline">\(A\preceq B,B\preceqA\)</span>，则<span class="math inline">\(A～B\)</span></p><h4 id="有穷集合">有穷集合</h4><p>和某个自然数等势的集合为有穷集合，否则为无穷集合。</p><ul><li><p>每个自然数都是有穷集合</p></li><li><p>引理：假设A是有穷集合，x不属于A，则<spanclass="math inline">\(A\cup \{x\}\)</span>是有穷集合</p></li><li><p>引理：集合A是有穷集合，当且仅当存在自然数n，使得<spanclass="math inline">\(A\preceq n\)</span></p></li><li><p>对任意的自然数n，n的每个真子集都不与n等势</p><ul><li>抽屉原理：集合A为有穷集合，当且仅当它不与它的任何真子集等势</li></ul></li></ul><h4 id="可数集合">可数集合</h4><p>若集合<span class="math inline">\(A\preceq\omega\)</span>，即存在A到<spanclass="math inline">\(\omega\)</span>的单射，则称A可数</p><ul><li>若<spanclass="math inline">\(A～\omega\)</span>，则称A为可数的无穷集合</li><li>定理：可数多个可数集合的并集可数</li></ul><h4 id="无穷集合">无穷集合</h4><p>每一个无穷集合都有无数无穷子集。</p><ul><li>如果A是无穷集合，则<span class="math inline">\(\omega\preceqA\)</span></li><li>A是无穷集合当且仅当它与自身的一个真子集等势</li><li>引理：假设A是非空集合且<span class="math inline">\(\bigcupA=A\)</span>，则A是无穷集合</li></ul><h4 id="不可数集合">不可数集合</h4><p>不是可数集合的无穷集合为不可数元集合。</p><ul><li><p>康托尔定理：<span class="math inline">\(\forall A,A\prec\Rho(A)\)</span></p></li><li><p>区间(0,1)不可数</p></li><li><p>连通性假设：<span class="math inline">\(\forall A,\omega\preceqA且A\preceq R，则要么A～\omega，要么A～R。\)</span></p><p><span class="math inline">\(换言之，不存在集合A使得\omega\preceqA且A\preceq R。\)</span></p></li></ul><h4 id="序数">序数</h4><p>每一个良序集合都与一个自然数序同构。</p><ul><li>设<spanclass="math inline">\((A,\le_A)\)</span>为一个良序集，A有穷，则存在一个自然数n，使得<spanclass="math inline">\((A,\le_A)\)</span>与<spanclass="math inline">\((n,\le)\)</span>序同构</li></ul><p>具有三歧性的传递集合叫做序数</p><ul><li>0是序数</li><li>每个自然数都是序数</li><li><span class="math inline">\(\omega\)</span>是序数</li></ul><p>引理：如果<span class="math inline">\(\alpha\)</span>是序数，<spanclass="math inline">\(\alpha^+\)</span>也是序数；序数的每个元素也是序数。</p><p>对于自然数n，归纳定义<spanclass="math inline">\(\omega+n\)</span>：</p><ol type="1"><li><span class="math inline">\(\omega+0=\omega\)</span></li><li><span class="math inline">\(\omega+(n+1)=(\omega+n)^+\)</span></li></ol><p>对任意自然数有<spanclass="math inline">\(\omega+n\)</span>为序数。</p><p>定理：对任意两个序数<spanclass="math inline">\(\alpha、\beta\)</span>都有<spanclass="math inline">\(\alpha\in\beta\)</span>，或者<spanclass="math inline">\(\alpha=\beta\)</span>，或者<spanclass="math inline">\(\beta\in\alpha\)</span>。</p><ul><li>证明：0912 P42</li></ul><p>用<span class="math inline">\(O_n\)</span>表示所有序数的类。</p><ul><li><p><span class="math inline">\(O_n\)</span>不是集合，否则<spanclass="math inline">\(O_n是序数，O_N\subseteqO_n\)</span>，与正则公理矛盾。</p></li><li><p>任何序数在属于关系上是良序集，我们用&lt;表示序数的属于关系</p></li></ul><p>定理：假设S中每个元素都是序数，那么<spanclass="math inline">\(\bigcup S\)</span>也是序数。</p><ul><li><span class="math inline">\(\omega\)</span>是序数</li><li>设<spanclass="math inline">\(S_0=\{\omega,\omega+1,...,\omega+n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega+\omega\)</span>或<spanclass="math inline">\(\omega·2\)</span><ul><li>类似地，可以定义<spanclass="math inline">\(\omega·3,...,\omega·n,...\)</span></li></ul></li><li>设<spanclass="math inline">\(S_1=\{\omega,\omega·2,...,\omega·n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega·\omega\)</span>或<spanclass="math inline">\(\omega^2\)</span><ul><li>类似地，可以定义<spanclass="math inline">\(\omega^3,...,\omega^n,...\)</span></li></ul></li><li>设<spanclass="math inline">\(S_2=\{\omega,\omega^2,...,\omega^n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega^\omega\)</span></li></ul><p>上述<span class="math inline">\(\omega^n\)</span>和<spanclass="math inline">\(\omega^\omega\)</span>为序数算数，不是笛卡尔积。</p><p>替换公理：设<spanclass="math inline">\(P(x,y)\)</span>为类关系，A是一个集合，如果<spanclass="math inline">\(\forall x\in A\)</span>，有唯一<spanclass="math inline">\(y_x\)</span>，使得<spanclass="math inline">\(P(x,y_x)\)</span>成立，则<spanclass="math inline">\(\{y_x|x\in A\}\)</span>是集合。</p><h4 id="超穷归纳法">超穷归纳法</h4><p>设<span class="math inline">\(\alpha\)</span>为序数</p><ul><li>如果存在序数<span class="math inline">\(\beta\)</span>使得<spanclass="math inline">\(\alpha=\beta^+\)</span>，则称<spanclass="math inline">\(\alpha\)</span>为后继序数</li><li>不是后继序数的非零序数称为极限序数</li></ul><p>设<span class="math inline">\(\alpha\neq 0\)</span>为序数，则</p><ul><li><spanclass="math inline">\(\alpha\)</span>为极限序数当且仅当对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都有<spanclass="math inline">\(\beta^+\lt\alpha\)</span></li><li><span class="math inline">\(\alpha\)</span>是极限序数当且仅当<spanclass="math inline">\(\alpha\)</span>中无最大元，即对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都存在<spanclass="math inline">\(\gamma\lt\alpha\)</span>，使得<spanclass="math inline">\(\beta\lt\gamma\)</span></li></ul><p>超穷归纳法原理：</p><p>设<span class="math inline">\(R(x)\)</span>为一个性质</p><ol type="1"><li><p>假设<span class="math inline">\(R(0)\)</span>成立</p></li><li><p>对任意的序数<spanclass="math inline">\(\alpha\)</span>，如果<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\alpha+1)\)</span>也成立</p></li><li><p>对于任意的极限序数<spanclass="math inline">\(\lambda\)</span>，如果对每一<spanclass="math inline">\(\alpha\lt\lambda\)</span>都有<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\lambda)\)</span>成立</p><p>那么对于任意的序数<spanclass="math inline">\(\alpha\)</span>都有<spanclass="math inline">\(R(\alpha)\)</span>成立</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数理逻辑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>毛概_期末复习</title>
    <link href="/2023/06/15/%E6%94%BF%E6%B2%BB/%E6%AF%9B%E6%A6%82%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/15/%E6%94%BF%E6%B2%BB/%E6%AF%9B%E6%A6%82%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>今客沧桑登舞榭，万灵且待命无疆！</p><span id="more"></span><h1id="毛泽东思想和中国特色社会主义理论体系概论-期末复习">毛泽东思想和中国特色社会主义理论体系概论期末复习</h1><!-- more --><p>任课教师：武海宝</p><h3 id="科学社会主义">科学社会主义</h3><ul><li>科学社会主义确认金融资本是现代社会各种病症的根源。</li><li>共产主义不是对财产的否定，而是对社会财产的私人垄断的否定。</li></ul><p>伦理社会主义：</p><p>伦理社会主义是在自然经济时代发展起来的，它强调人与人之间的和谐，与宗教、大同理想、家族文化等各种形态相结合，以一种改良的身份去批评资本主义，但它无法改变资本主义的基本逻辑</p><h2 id="新民主主义革命">新民主主义革命</h2><h3 id="中国社会主义革命道路探索">中国社会主义革命道路探索</h3><h4 id="中国的两步走">中国的两步走</h4><p>中国革命必须分为两个步骤。第一步，改变这个殖民地、半殖民地、半封建的社会形态，使之变成一个独立的民主主义的社会，第二部，使这个革命向前发展，建立一个社会主义的社会。——毛泽东《新民主主义论》</p><h4 id="三湾改编">三湾改编</h4><p>1927年9月至10月，毛泽东在江西省永新县三湾村领导了三湾改编。</p><p>毛泽东创造性地确立了支部建在连上、官兵平等等一系列治军方略。三湾改编是中国共产党建设新型人民军队最早的一次成功探索和实践。</p><p>意义：</p><ul><li>从政治上和组织上保证了党对军队的绝对领导，是我党建设新型人民军队最早的一次成功探索和实践，标志着毛泽东建设人民军队思想的开始形成</li><li>初步解决了如何把以农民和旧军人为主要成分的革命军队建设成为一支无产阶级新型人民军队的问题，奠定了政治强军的基础</li><li>实现民主主义，对团结广大士兵群众、瓦解敌军起到巨大作用</li></ul><h4 id="新民主主义革命的基本纲领">新民主主义革命的基本纲领</h4><ul><li>没收封建地主阶级的土地归农民所有；没收官僚资本主义的垄断资本归国家所有；保护民族工商业</li><li>建立无产阶级领导下的一切反帝反封建的人民联合专政的民主共和国，这就是新民主主义的共和国</li><li>实行人民大众的反帝反封建的文化，即民族的、科学的、大众的文化</li></ul><h4 id="新旧民主主义革命的异同">新旧民主主义革命的异同</h4><ul><li>相同点：<ul><li>社会性质：都发生在半殖民地半封建社会</li><li>革命任务：都是反对外国资本主义侵略和本国封建统治</li><li>革命性质：都属于资产阶级民主革命的范畴</li></ul></li><li>不同点：<ul><li>领导力量：旧民主主义革命的领导是资产阶级，新民主主义革命的领导是无产阶级</li><li>指导思想：旧民主主义革命是资产阶级的平等、自由思想和民族观念，新民主主义革命是马克思主义</li><li>革命前途：旧民主主义革命是建立资产阶级民主共和国，新民主主义革命在完成民主革命任务后，还要进入社会主义社会</li><li>革命发展和群众发动的深度、广度：旧民主主义革命的纲领不彻底，群众发动不充分，土地问题不能彻底解决；新民主主义革命提出了彻底的革命纲领，广泛发动群众，解决了民主革命的中心问题，即土地问题</li><li>结果不同：旧民主主义革命有胜利的一面，但最终果实被窃取，革命任务没有完成，社会性质没有改变，在这一意义讲是最终遭到了失败；新民主主义革命的胜利成为了社会主义的必要准备，社会主义是新民主主义革命的必然结果</li><li>旧民主主义革命属于世界资产阶级革命的一部分，新民主主义革命属于无产阶级世界革命的一部分</li></ul></li></ul><h3 id="新民主主义社会">新民主主义社会</h3><ul><li>政治上，新民主主义的国家实行工人阶级领导的、工农联盟为基础的、团结各民主阶级和国内各民族的人民民主专政。</li><li>经济上：</li></ul><table><thead><tr class="header"><th>成分</th><th>来源</th><th>性质</th><th>地位</th></tr></thead><tbody><tr class="odd"><td>国营经济</td><td>没收官僚资本</td><td>社会主义</td><td>领导地位</td></tr><tr class="even"><td>合作社经济</td><td>个体向社会主义集体经济过渡</td><td>半社会主义</td><td></td></tr><tr class="odd"><td>个体经济</td><td>个体农业、手工业</td><td>个体经济</td><td>绝对优势</td></tr><tr class="even"><td>私人资本主义经济</td><td>民族资本主义</td><td>资本主义</td><td></td></tr><tr class="odd"><td>国家资本主义经济</td><td>私人资本主义经济向社会主义国营经济过渡</td><td>半社会主义</td><td></td></tr></tbody></table><p>新民主主义社会，是指在新民主主义革命胜利的基础上，建立起来的既不是资产阶级共和国也不是无产阶级共和国的的各个革命阶级联合专政的共和国，是落后国家进行革命的特有社会形态。</p><ul><li>性质：过渡性社会形态，隶属于社会主义体系</li><li>特点：既有社会主义因素，也有资本主义因素</li><li>从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期</li><li>过渡时期的时间，中央领导估计大约需要10年、15年或者更久</li></ul><h4 id="过渡时期总路线">过渡时期总路线</h4><p>从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造。</p><h4id="中国社会主义改造道路三大改造">中国社会主义改造道路：三大改造</h4><ul><li>农业合作化，将小农经济改造为农业集体主义经济</li><li>手工业社会主义改造，通过合作化道路，把个体手工业转变为社会主义劳动群众集体所有制经济</li><li>资本主义工商业社会主义改造，通过国家资本主义的形式，采取和平赎买的政策，将民族资本主义经济改造成社会主义公有制企业，而且将所有制改造与人的改造相结合，努力使剥削者成为自食其力的劳动者</li></ul><p>社会主义改造时期，把实现国家的工业化作为党在过渡时期总路线的主体，受苏联的影响，一度过多强调重工业和基础设施的发展，促使党思考如何走中国工业化道路的问题。</p><h4 id="中国工业化道路的目标和方针">中国工业化道路的目标和方针</h4><ul><li>总方针：以农业为基础，以工业为主导，以农、轻、重为序发展国民经济</li><li>农业为重工业提供积累资金和原料，同时提供市场</li><li>目标：逐步建立独立的比较完整的基础工业体系和国防工业体系</li></ul><h3 id="中国无产阶级的主要优点">中国无产阶级的主要优点</h3><ol type="1"><li>革命性强。深受帝国主义、封建主义、资本主义的三重压迫，具有强烈的反抗意识</li><li>和广大农民有着天然联系，容易和农民结成亲密的联盟</li><li>集中在沿海、沿江大中城市，便于组织</li></ol><p>新民主主义革命的动力：农民</p><h2 id="改革开放">改革开放</h2><h3 id="家庭联产承包责任制和土地流转">家庭联产承包责任制和土地流转</h3><p>家庭联产承包责任制和统分结合的双层经营体制：</p><p>所有权、承包权和经营权三权分置，经营权流转的格局。农业用地在土地承包期限内，可以通过转包、转让、入股、合作、租赁、互换等方式出让经营权。</p><h3id="中国社会主义农业改革和发展的两个飞跃">中国社会主义农业改革和发展的两个飞跃</h3><p>两个飞跃是邓小平晚年关于我国农业改革和发展的重要思考</p><ol type="1"><li>废除人民公社，实行家庭联产承保责任制</li><li>适应科学生产、生产社会化的需要，再度发展集体经济</li></ol><h3id="中国特色社会主义市场经济制度的体制优势">中国特色社会主义市场经济制度的体制优势</h3><ul><li>从落后国家率先取得胜利的社会主义，还不能一下子排除掉资本。中国从新民主主义社会到改革开放，基本探索出一个相对稳定的制度形式，也就是公有制主导下的市场经济</li><li>以公有制为主体的社会主义市场经济制度既能充分利用市场、充分利用一般职能资本的积极作用来推动社会发展，又能避免金融资本的剥削性、寄生性、投机性积累及其所导致的一系列问题，创造了一条不同于西方的现代化道路</li></ul><h2 id="社会主义">社会主义</h2><h3 id="社会主义的本质">社会主义的本质</h3><ul><li>解放和发展生产力——基本经济制度的内在属性</li><li>消灭剥削，消除两极分化——基本经济制度的内在张力</li><li>最终达到共同富裕</li></ul><h3 id="三个代表">三个代表</h3><p>三个代表是建党理论。</p><p>中国共产党始终代表</p><ul><li>中国先进生产力的发展要求</li><li>中国先进文化的前进方向</li><li>中国最广大人民的根本利益</li></ul><h3 id="科学发展观">科学发展观</h3><ul><li>第一要义是发展</li><li>核心是以人为本</li><li>基本要求是全面协调可持续发展</li><li>根本方法是统筹兼顾</li></ul><h3 id="十个坚持">十个坚持</h3><ul><li>坚持党的领导</li><li>坚持人民至上</li><li>坚持理论创新</li><li>坚持独立自主</li><li>坚持中国道路</li><li>坚持胸怀天下</li><li>坚持开拓创新</li><li>坚持敢于斗争</li><li>坚持统一战线</li><li>坚持自我革命</li></ul><h2 id="使命型政党">使命型政党</h2><h3 id="理论渊源">理论渊源</h3><p>⻢克思：过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的，为绝大多数人谋利益的独立的运动。在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。</p><h3 id="人民利益的统一性完整性">人民利益的统一性、完整性</h3><ul><li>区别公意和众意：<ul><li>卢梭在《社会契约论》中说：“公意和众意之间经常有着很大的差别。公意总是着眼于公共利益，而众意则着眼于私利，它只是个体意志的总和。”</li></ul></li></ul><h3 id="中国共产党是使命型政党">中国共产党是使命型政党</h3><ul><li>把国家从金融资本、金融寡头的工具变成社会利益的集中代表，这是社会主义国家的国体概念。作为社会联合所有制的代理人来执行职能的国家，这是一种和新自由主义消极国家不一样的积极国家，这种积极国家又要依赖一个先锋队、依赖一个使命型政党。</li><li>这种政党不同于⻄方那样一种选举型政党。选举型政党容易分裂人⺠的意志，而人⺠意志的分裂有利于金融寡头对经济、政治的支配。</li><li>共产党作为先锋队的组织，作为人⺠意志的集中表现，作为一个没有自己特殊私利的政党，共产党的合法性依据先进的纲领、依据人⺠⺠主、依据自我革命。社会主义政权的一系列的组织形式不同于⻄方三权分立的政治制度。</li></ul><h4id="使命型政党和西方选举型政党的区别">使命型政党和西方选举型政党的区别</h4><ul><li>基于全心全意为人民服务的马克思主义政党；建立在人性恶和权力恶的双重不信任文化基础上的政党</li><li>作为整体的部分而服务于本体的政党；割裂于整体而利用本体牟利的政党</li></ul><h2 id="我国的政治制度">我国的政治制度</h2><h4 id="人民民主专政国体">人民民主专政——国体</h4><p>中国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家。</p><p>人民民主专政是中国的国家根本性质</p><p>只有人民民主专政才能终结国外列强操控的军阀割据。</p><p>军阀割据的社会根源：</p><ul><li>中国社会的半封建性，中国具有分散性的封建地主经济的必然产物</li><li>中国社会的半殖民性，帝国主义分而治之的侵略政策必然导致军阀割据</li></ul><h4 id="人民代表大会制度政体">人民代表大会制度——政体</h4><ul><li>人民通过人民代表大会有效行使国家权力</li><li>全国人民代表大会是最高国家权力机关，地方人民代表大会是地方国家权力机关</li><li>各级国家行政机关、监察机关、审判机关、检察机关都由人民代表大会产生，对人大负责，受人大监督。人民代表大会有立法权、监督权、决定权、任免权</li><li>人大代表来自人民，横向上，来自各地区、各民族、各方面、各阶层；纵向上，全国、省、市、县、乡五级都有人民代表大会，具有广泛代表性</li></ul><h4id="中国共产党领导的多党合作和政治协商制度">中国共产党领导的多党合作和政治协商制度</h4><p>中国共产党是执政党，八个民主党派是接受中国共产党领导、同中国共产党亲密合作的参政党。</p><ul><li>在中国，没有反对党，也没有在野党。中国既不是一党专政，也不是多党竞争、轮流执政，而是“共产党领导、多党派合作，共产党执政、多党派参政”。</li></ul><h4 id="民主实践选举民主">民主实践：选举民主</h4><ul><li><p>人⺠通过选举、投票行使权利，选出代表自己意愿的人来掌握并行使权力，是中国⺠主的一种主要形式，是人⺠实现当家作主的主要体现。</p></li><li><p>中国的选举是广泛的，有国家机构选举、村(居)委会选举、企事业单位职工代表大会选举等，涵盖了国家政治生活和社会生活的各个方面。</p></li><li><p>中国的选举是平等的，人⺠的选举权和被选举权得到充分保障，一人一票、票票等值</p></li><li><p>中国的选举是真实的，不受金钱操控，选⺠按照自己的意愿选出自己信任的人。</p></li><li><p>国家机构选举：从全国人大到乡级人大，五级人⺠代表大会代表均由⺠主选举产生，每届任期5年。选⺠直接选举产生县乡两级人大代表，县级以上人大代表由下一级人大选举产生。各级国家机关领导人员均由同级人大选举产生或者决定任命。</p></li><li><p>基层选举：村(居)⺠委员会选举和企事业单位职工代表大会选举。村(居)⺠依法定期选举产生村(居)⺠委员会成员。在企事业单位中，职工代表大会是职工当家作主、行使⺠主管理权力的机构。</p></li></ul><h4 id="民主实践协商民主">民主实践：协商民主</h4><ul><li><p>人⺠在通过选举、投票行使权利的同时，在重大决策前和决策过程中进行充分协商，尽可能就共同性问题取得一致意⻅。协商⺠主是中国⺠主独特的、独有的、独到的⺠主形式。</p></li><li><p>协商⺠主形式:提案、会议、座谈、论证、听证、评估、咨询、网络、⺠意调查等多种途径和方式，在决策之前和决策实施之中开展广泛协商。</p></li></ul><p>缺乏协商民主：英国脱欧</p><p>票决至上：一人一票是民主的一种形式，但绝非其唯一和全部</p><h4 id="政党和民主">政党和民主</h4><ul><li>中国共产党的领导，是中国发展全过程人⺠⺠主的根本保证。</li><li>把中国14亿多人⺠的意愿表达好、实现好，必须有坚强有力的统一领导。</li><li>中国共产党始终坚持以人⺠为中心、坚持人⺠主体地位，真正为人⺠执政、靠人⺠执政；充分发挥总揽全局、协调各方的领导核心作用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>大学政治</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-目标代码生成</title>
    <link href="/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
    <url>/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>子不语</p><span id="more"></span><h1 id="目标代码生成">目标代码生成</h1><h2 id="risc-v">RISC-V</h2><h3 id="寄存器">寄存器</h3><ul><li><p>zero：存放常数0，不允许修改</p></li><li><p>ra：存放返回地址</p></li><li><p>t0~t6：保存临时变量</p></li><li><p>pc：保存下一条指令的地址</p></li></ul><h3 id="指令">指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">t0</span>, <span class="hljs-number">20</span><span class="hljs-comment"># li: load immediate</span><br>li <span class="hljs-built_in">t1</span>, <span class="hljs-number">22</span><br><span class="hljs-keyword">add </span><span class="hljs-built_in">t2</span>, <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">t1</span><br></code></pre></td></tr></table></figure><p>li指令是一条伪指令，最终会翻译为addi t0, zero, 20的形式</p><ul><li>负数则为addi t0, zero, -20</li><li>没有subi指令</li></ul><h3 id="系统调用">系统调用</h3><ol type="1"><li>把服务号写入a7寄存器</li><li>把参数写入a0、a1、a2、a3、fa0、...</li><li><code>ecall</code></li><li>从结果寄存器中获得返回值</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">1</span><span class="hljs-comment"># service 1 is print integer</span><br><span class="hljs-keyword">add </span><span class="hljs-built_in">a0</span>, <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">zero</span><span class="hljs-comment"># load desired int into a0</span><br>ecall<br></code></pre></td></tr></table></figure><h3 id="代码段">代码段</h3><ul><li><p>.开始的指令是写给汇编器的指令</p></li><li><p>.data存储全局变量</p><ul><li><code>g: .word 0</code></li><li><code>msg: .string "sss"</code>以\0结尾的string</li><li><code>msg: .ascii "sds"</code>的string不以\0结尾</li></ul></li><li><p>.text存储运行代码</p><ul><li><code>la t0, g      # la: load address</code></li><li><code>lw t0, 0(t0) # lw: load word</code></li><li><code>sw t6, 0(t0) #sw: store word</code></li></ul></li></ul><p>默认在程序开始添加.text</p><ul><li>打印字符串：</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">4</span><br>la <span class="hljs-built_in">a0</span>, msg<br>ecall<br></code></pre></td></tr></table></figure><ul><li>mv</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">1</span><br>mv <span class="hljs-built_in">a0</span>, <span class="hljs-built_in">t6</span> <span class="hljs-comment">#add a0, t6, zero</span><br>ecall<br></code></pre></td></tr></table></figure><ul><li>数组：偏移地址</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br><span class="hljs-symbol">numbers:</span> <span class="hljs-meta">.word</span> -<span class="hljs-number">30</span>, <span class="hljs-number">30</span>, -<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span><br><br><span class="hljs-meta">.text</span><br>la <span class="hljs-built_in">t0</span>, numbers<br><span class="hljs-keyword">lw </span><span class="hljs-built_in">t1</span>, <span class="hljs-number">12</span>(<span class="hljs-built_in">t0</span>)<span class="hljs-comment"># 偏移12个字节，到20</span><br><span class="hljs-keyword">addi </span><span class="hljs-built_in">t1</span>, <span class="hljs-built_in">t1</span>, <span class="hljs-number">90</span><br><span class="hljs-keyword">sw </span><span class="hljs-built_in">t1</span>, <span class="hljs-number">12</span>(<span class="hljs-built_in">t0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-语法分析</title>
    <link href="/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>子不语</p><span id="more"></span><h1 id="语法分析">语法分析</h1><p>文法：一组描述良构程序语法结构的精确的规则</p><ul><li>文法给出了一个程序设计语言的精确易懂的语法规约</li><li>对于某些类型的文法，我们可以自动地构造出高效的语法分析器，它能够确定一个源程序的语法结构。同时，语法分析器的构造过程可以揭示出语法的二义性，还能发现一些容易在语法的初始设计阶段被忽略的问题</li><li>一个正确设计的文法给出了一个语言的结构，该结构有助于把源程序翻译成正确的目标代码，也有助于检测错误</li><li>一个文法支持逐步加入可以完成新任务的新语言构造从而迭代地演化和开发语言。如果对语言的实现遵循语言的文法结构，那么在实现中加入这些新构造的工作就变得更容易</li></ul><h2 id="一引论">一、引论</h2><h3 id="语法分析器的作用">语法分析器的作用</h3><p>语法分析器从词法分析器获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成，能够以易于理解的方式报告语法错误，并且能够从常见的错误中恢复并继续处理程序的其余部分。</p><ul><li><p>对于良构的程序，语法分析器构造出一棵语法分析树，并把它传递给编译器的其他部分进一步处理。</p></li><li><p>处理文法的语法分析器大体上可分为三种类型：</p><ul><li>通用的：效率较低不能用于编译器产品</li><li>自顶向下的：从语法分析树的顶部开始向底部构造语法分析树</li><li>自底向上的：从叶结点开始逐步向根结点构造<ul><li>语法分析器的输入总是按从左到右的方式被扫描，每次扫描一个符号</li></ul></li></ul></li></ul><h3 id="语法错误的处理">语法错误的处理</h3><p>错误的不同层次：</p><ul><li>词法错误</li><li>语法错误</li><li>语义错误</li><li>逻辑错误</li></ul><p>可行前缀特性：</p><p>一旦发现输入的某个前缀不能够通过添加一些符号而形成这个语言的串，就可以立即检测到语法错误。</p><p>错误恢复的一般策略：恐慌模式和短语层次恢复</p><ul><li>恐慌模式恢复<ul><li>一旦发现错误就不断丢弃输入中的符号，知道找到同步词法单元集合中的某个元素<ul><li>同步词法单元通常是界限符，如分号和右大括号</li><li>跳过大量输入，但简单且能保证不会进入无限循环</li></ul></li></ul></li><li>短语层次的恢复<ul><li>将余下输入的某个前缀替换为另一个串，使之可以继续分析<ul><li>必须小心选择替换方法以免无限循环</li></ul></li></ul></li><li>错误产生式<ul><li>预测常见错误，在文法中加入错误产生式</li></ul></li><li>全局纠正<ul><li>通过最小的改动序列将错误输入串转换为语法正确的串<ul><li>开销大，仅具理论价值</li></ul></li></ul></li></ul><h2 id="二上下文无关文法">二、上下文无关文法</h2><h3 id="上下文无关文法的定义">上下文无关文法的定义</h3><p>上下文无关文法（Context-free grammar，CFG）</p><p>一个上下文无关文法由终结符号，非终结符号，一个开始符号和一组产生式组成。</p><ul><li><p>终结符号是组成串的基本符号</p></li><li><p>非终结符号是表示串的集合的语法变量</p></li><li><p>一个文法中，某个非终结符号被指定为开始符号</p></li><li><p>一个文法的产生式描述了将终结符号和非终结符号组合成串的方法，其组成元素：</p><ul><li>一个被称为产生式头或左部的非终结符号，这个产生式定义了这个头所代表的串集合的一部分</li><li>符号<spanclass="math inline">\(\rightarrow\)</span>。有时也使用::=来替代箭头</li><li>一个由零个或多个终结符号与非终结符号组成的产生式体或右部</li></ul></li></ul><p>语义：上下文无关文法G定义了一个语义L(G)</p><p>约定：</p><ul><li>常用开始符号S</li><li>常用表达式、项和因子的非终结符号E、T、F</li><li>一般第一个产生式的头为开始符号</li></ul><h3 id="推导">推导</h3><p>将某个产生式的左边替换成它的右边。</p><ul><li><p>每一步推导需要选择替换哪个非终结符号，以及使用哪个产生式</p></li><li><p>一次推导：<spanclass="math inline">\(\Longrightarrow\)</span></p></li><li><p>一次或多次推导：<spanclass="math inline">\(\Longrightarrow^+\)</span></p></li><li><p>零次或多次推导：<spanclass="math inline">\(\Longrightarrow^*\)</span></p></li></ul><p>如果<span class="math inline">\(S\Longrightarrow^*\alpha\)</span>，其中S为文法G的开始符号，称<spanclass="math inline">\(\alpha\)</span>为G的一个句型。</p><ul><li>文法G的一个句子是不包含非终结符号的句型</li><li>文法生成的语言是它的所有句子的集合，称为上下文无关语言</li><li>两个生成相同语言的文法是等价的</li></ul><p>最左推导：总是选择每个句型的最左非终结符号</p><p>最右推导：总是选择每个句型的最右边的非终结符号</p><p>正则表达式的表达能力严格弱于上下文无关文法。</p><p>正则表达式转上下文无关文法：</p><ol type="1"><li>转NFA或DFA</li><li>自动机每个状态转为上下文无关文法的一个非终结符号</li><li>逐步转换</li></ol><h4 id="二义性">二义性</h4><p>如果一个文法可以为某个句子生成多棵语法分析树，那么它就是二义性的。</p><p>消除二义性</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">stmt</span>: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span><br>| <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span> <span class="hljs-keyword">else</span> <span class="hljs-type">stmt</span><br>| other<br></code></pre></td></tr></table></figure><p>修改规则：每个else和最近的尚未匹配的then匹配</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">stmt</span>: matched_stmt<br>| open_stmt<br>matched_stmt: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> thrn matched_stmt <span class="hljs-keyword">else</span> matched_stmt<br>| other<br>open_stmt: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span><br> | <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then matched_stmt <span class="hljs-keyword">else</span> open_stmt<br></code></pre></td></tr></table></figure><h4 id="左递归">左递归</h4><p>如果一个文法中有一个非终结符号使得对某个串<spanclass="math inline">\(\alpha\)</span>存在一个推导<spanclass="math inline">\(A\Longrightarrow^+A\alpha\)</span>，那么这个文法就是左递归的。</p><ul><li>自顶向下语法分析不能处理左递归文法</li></ul><p>消除直接左递归：</p><ol type="1"><li>将A的全部产生式分组：<span class="math inline">\(A\rightarrowA\alpha_1|A\alpha_2|...|A\alpha_m|\beta_1|\beta_2|...|\beta_n\)</span>，其中<spanclass="math inline">\(\beta_i\)</span>都不以A开始</li><li>将A的产生式替换为<ul><li><span class="math inline">\(A\rightarrow\beta_1A^{&#39;}|\beta_2A^{&#39;}|...|\beta_nA^{&#39;}\)</span></li><li><span class="math inline">\(A^{&#39;}\rightarrow\alpha_1A^{&#39;}|\alpha_2A^{&#39;}|...|\alpha_nA^{&#39;}|\epsilon\)</span></li></ul></li></ol><p>消除间接左递归：先化为直接左递归，再使用上述方法</p><ul><li>该方法下的文法不能存在环和<spanclass="math inline">\(\epsilon\)</span>产生式</li></ul><h4 id="提取左公因子">提取左公因子</h4><p>对于每个非终结符号A，找出它的两个或多个选项之间的最长公共前缀<spanclass="math inline">\(\alpha\)</span>，若<spanclass="math inline">\(\alpha \neq\epsilon\)</span>，即存在一个非平凡的公共前缀，将所有<spanclass="math inline">\(A\rightarrow\alpha\beta_1|\alpha\beta_2|...|\alpha\beta_n|\gamma\)</span>替换为</p><ul><li><span class="math inline">\(A\rightarrow \alphaA^{&#39;}|\gamma\)</span></li><li><span class="math inline">\(A^{&#39;}\rightarrow\beta_1|\beta_2|...|\beta_n\)</span></li></ul><p>其中<span class="math inline">\(\gamma\)</span>为A所有不以<spanclass="math inline">\(\alpha\)</span>开始的产生式体。</p><ul><li>不断应用上述转换，直到每个非终结符号的任意两个产生式体没有公共前缀为止</li></ul><h3 id="自顶向下的语法分析">自顶向下的语法分析</h3><p>为输入串构造语法分析树，从语法分析树的根结点开始，按照先根次序创建这棵语法分析树的各个结点。可以被看作寻找输入串的最左推导的过程。</p><ul><li>根结点是文法的起始符号S</li><li>每个中间结点表示对某个非终结符应用某个产生式进行推导</li><li>叶结点为词法单元流，仅包括终结符号和特殊的文件结束符$（EOF）</li></ul><p>对于有些文法，可以构造出向前看k个输入符号的预测分析器，这类文法称为LL(k)文法。</p><h4 id="递归下降">递归下降</h4><p>为每一个非终结符写一个递归函数，内部按需调用其他非终结符对应的递归函数进行下降。</p><h4 id="预测分析表">预测分析表</h4><p>指明每个非终结符在面对不同的词法单元或文件结束符时，该选择哪个产生式或报错。</p><p>首行为各个终结符和$，首列为各个非终结符。</p><h5 id="first和follow集合">FIRST和FOLLOW集合</h5><p><span class="math inline">\(First(\alpha)\)</span>是可以从<spanclass="math inline">\(\alpha\)</span>推导得到的句型的<strong>首终结符号</strong>的集合。</p><p><span class="math inline">\(First(\alpha)=\{t\inT\cup\{\epsilon\}|\alpha\Longrightarrow^*t\beta\or\alpha\Longrightarrow^*\epsilon \}\)</span></p><p>如果非终结符A的所有产生式对应的FIRST集合不相交，那么只需查看当前词法单元即可确定选择的产生式。</p><ul><li>单个符号X的<span class="math inline">\(First(X)\)</span>的计算<ul><li>先判断是否是终结符，若是，则<spanclass="math inline">\(First(X)\)</span>即其自身</li><li>否则，判断X的每一条产生式，且需要判断X可否推导出空串</li></ul></li><li>符号串<span class="math inline">\(\alpha\)</span>的<spanclass="math inline">\(First(\alpha)\)</span>的计算，<spanclass="math inline">\(\alpha=X\beta\)</span><ul><li>若<span class="math inline">\(\epsilon\notin L(X)\)</span>，即<spanclass="math inline">\(First(X)\)</span></li><li>若<span class="math inline">\(\epsilon\in L(X)\)</span>，为<spanclass="math inline">\((First(X)\setminus\{\epsilon\})\cupFirst(\beta)\)</span></li><li>如果<span class="math inline">\(\epsilon\in\alpha\)</span>，将<spanclass="math inline">\(\epsilon\)</span>加入<spanclass="math inline">\(First(\alpha)\)</span></li></ul></li></ul><p><spanclass="math inline">\(Follow(A)\)</span>是可能在某些句型中<strong>紧跟在A右边的终结符</strong>的集合。</p><p>对于任意的产生式左部非终结符<span class="math inline">\(A\inN\)</span>：</p><p><span class="math inline">\(Follow(A)=\{t\in T\cup\{\$\}|\exists.S\Longrightarrow^*s=^\triangle At\gamma\}\)</span></p><p>考虑产生式<span class="math inline">\(A\rightarrow\alpha\)</span>，如果从<spanclass="math inline">\(\alpha\)</span>可以推导出空串，则只有当当前词法单元属于<spanclass="math inline">\(Follow(A)\)</span>，才可以选择该产生式。</p><ul><li>非终结符X的<span class="math inline">\(Follow(X)\)</span>的计算<ul><li>若X是开始符号，则<span class="math inline">\(\$\)</span>也在<spanclass="math inline">\(Follow(X)\)</span>中<ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cup\{\$\}\)</span></li></ul></li><li>若X是某产生式右部最后一个符号，即<spanclass="math inline">\(A\rightarrow \alpha X\)</span><ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cupFollow(A)\)</span></li></ul></li><li>若X是某产生式右部中间的一个符号，即<spanclass="math inline">\(A\rightarrow \alpha X\beta\)</span><ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cup(First(\beta)\setminus\{\epsilon\})\)</span></li><li>若<span class="math inline">\(\epsilon\inFirst(\beta)\)</span>，<span class="math inline">\(Follow(X)\leftarrowFollow(X)\cup Follow(A)\)</span></li></ul></li></ul></li></ul><p>根据First和Follow集合计算确定给定文法G的预测分析表：</p><p>对应每条产生式<spanclass="math inline">\(A\rightarrow\alpha\)</span>与终结符t，如果</p><ul><li><span class="math inline">\(t\in First(\alpha)\)</span></li><li><span class="math inline">\(\epsilon\in First(\alpha)\and t\inFollow(A)\)</span></li></ul><p>则在表格[A,t]中填入<spanclass="math inline">\(A\rightarrow\alpha\)</span></p><h4 id="ll1文法">LL(1)文法</h4><ul><li><p>从左向右读入词法单元</p></li><li><p>在推导的每一步，LL(1)总是选择最左边的非终结符进行展开</p></li><li><p>如果文法G的预测分析表是无冲突的，则G是LL(1)文法。</p><ul><li>对于当前选择的非终结符，仅根据输入中当前的词法单元即可确定需要哪条产生式</li></ul></li></ul><p>非递归的预测分析算法：使用栈保存终结符和非终结符</p><h3 id="adaptive-ll算法">Adaptive LL(*)算法</h3><p>Adaptive LL(*)算法，简称ALLStar算法。</p><h4 id="优先级上升算法">优先级上升算法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;)&#x27;</span><br>| INT<br>| ID<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>: (<br><span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-built_in">expr</span>[0] <span class="hljs-string">&#x27;)&#x27;</span><br>| INT<br>| ID<br>)<br>(&#123;5 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-built_in">expr</span>[6]<br>| &#123;4 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[5]<br>)*<br>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;!&#x27;</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| ID<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>:(ID<br>| <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span>[4]<br>)<br>(&#123;3 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;!&#x27;</span><br>| &#123;2 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>)*<br>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: &lt;assoc = right&gt; <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| INT<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>:( INT )<br>(&#123;3 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>|&#123;2 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>)*<br>;<br></code></pre></td></tr></table></figure><p>总结：</p><p>按原产生式排序优先级；</p><p>左结合运算符右操作符优先级上升，右结合运算符右操作符优先级不变。</p><h4 id="antlr4的错误报告与恢复">ANTLR4的错误报告与恢复</h4><p>共四类词法、语法错误</p><ul><li>词法错误：LexerNoViableAltException</li><li>语法错误<ul><li>NoViableAltException：非终结符的可选分支均不可行</li><li>InputMismatchException：可选分支不匹配</li><li>FailedPerdicateException</li></ul></li></ul><h3 id="自底向上的语法分析">自底向上的语法分析</h3><p>自底向上的、不断归约的、基于句柄识别自动机的、适用于LR文法的LR语法分析器。</p><h4 id="自底向上构建语法分析树">自底向上构建语法分析树</h4><ul><li>根结点是文法起始符号S</li><li>叶结点是词法单元流，仅包含终结符号与特殊文件结束符$</li><li>每个中间非终结符结点表示使用它的某条产生式进行归约</li></ul><h4 id="lr语法分析器">LR语法分析器</h4><ul><li>从左向右扫描输入</li><li>构建反向最右推导</li></ul><p>LR语法分析器的状态：</p><p>在任意时刻，语法分析树的上边缘和剩余的输入构成当前句型。</p><ul><li>LR语法分析器使用栈存储语法分析树的上边缘，它包含了语法分析器目前所知的所有信息。</li></ul><p>栈上操作：</p><ul><li>移入输入符号</li><li>按产生式归约</li></ul><h4 id="lr分析表">LR分析表</h4><p>在当前状态（编号）下，面对当前文法符号时，该采取什么动作</p><ul><li><p>第一列为状态，用数字编号</p></li><li><p>其后的一组列为ACTION列，其首行为文法符号，余行指明动作</p></li><li><p>再之后的一组列为GOTO列，其首行为归约的文法符号，余行指明转换到的状态</p></li><li><p><spanclass="math inline">\(s_n\)</span>：移入输入符号，并进入状态n</p></li><li><p><spanclass="math inline">\(r_k\)</span>：使用k号产生式进行归约</p></li><li><p><span class="math inline">\(g_n\)</span>：转换到状态n</p></li><li><p><span class="math inline">\(acc\)</span>：成功接受，结束</p></li><li><p>空白：错误</p></li></ul><p>示例（SLR(1)分析表）：</p><figure><img src="/image/编译原理/LR分析表.png" alt="LR分析表" /><figcaption aria-hidden="true">LR分析表</figcaption></figure><p>栈中存储语法分析器的状态（编号），编码了语法分析树的上边缘。</p><p>如何构造LR分析表？</p><h5 id="句柄">句柄</h5><p>在输入串的反向最右推导中，如果下一步是逆用产生式<spanclass="math inline">\(A\rightarrow \alpha\)</span>，则称<spanclass="math inline">\(\alpha\)</span>为当前句型的句柄。</p><ul><li>LR语法分析器的关键就是高效寻找每个归约步骤所使用的句柄。</li></ul><p>存在一种LR语法分析方法，保证句柄总是出现在栈顶。</p><h5 id="lr0句柄识别有穷自动机">LR(0)句柄识别有穷自动机</h5><p>LR(0)项：文法G的一个LR(0)项是G的某个产生式加上一个位于体部的点。</p><ul><li>项指明了语法分析器已经观察到了某个产生式的某个前缀</li><li>例：<span class="math inline">\(A\rightarrow XYZ\)</span>的项<ul><li><span class="math inline">\(A\rightarrow ·XYZ\)</span></li><li><span class="math inline">\(A\rightarrow X·YZ\)</span></li><li><span class="math inline">\(A\rightarrow XY·Z\)</span></li><li><span class="math inline">\(A\rightarrow XYZ·\)</span></li></ul></li><li>项集：若干项构成的集合，可以表示句柄识别自动机的一个状态</li><li>项集族：若干项集的集合，可以表示句柄识别自动机的状态集</li></ul><p>增广文法：文法G的增广文法G‘为在G中加入产生式<spanclass="math inline">\(S&#39;\rightarrow S\)</span>的文法。</p><p>状态的划分：“点”的位置</p><ul><li><p>点指明了栈顶，左边是栈中内容，右边是期望看到的文法符号。</p></li><li><p>以<span class="math inline">\(E&#39;\rightarrow·E\)</span>为初始状态，推导点右边的内容。</p></li><li><p>逐步推导接受文法符号后的内容。</p></li></ul><p>示例：</p><figure><img src="/image/编译原理/LR0句柄识别自动机.png"alt="LR0句柄识别自动机" /><figcaption aria-hidden="true">LR0句柄识别自动机</figcaption></figure><p><span class="math inline">\(J=GOTO(I,X)=CLOSURE({[A\rightarrow\alphaX·\beta]|[A\rightarrow\alpha·X\beta]\in I})\)</span></p><p>接受状态：<span class="math inline">\(F=\{I\in C|\exist[A\rightarrow\alpha·]\in I \}\)</span></p><p>GOTO函数拆分成ACTION表（针对终结符）和GOTO表（针对非终结符）。</p><p>上图转化为的表：</p><figure><img src="/image/编译原理/LR0分析表.png" alt="LR0分析表" /><figcaption aria-hidden="true">LR0分析表</figcaption></figure><p>LR(0)分析表构造规则</p><ul><li><p><span class="math inline">\(GOTO(I_i,a)=I_j\and a\inT\Longrightarrow ACTION[i,a]\leftarrow sj\)</span></p></li><li><p><span class="math inline">\(GOTO(I_i,A)=I_j\and A\inN\Longrightarrow GOTO[i,A]\leftarrow gj\)</span></p></li><li><p><span class="math inline">\([k: A\rightarrow\alpha·]\in I_i\andA\neq S&#39;\Longrightarrow\forall t\inT\cup\{\$\}.ACTION[i,t]=rk\)</span></p></li><li><p><span class="math inline">\([S&#39;\rightarrow S·]\inI_i\Longrightarrow ACTION[i,\$]\leftarrow acc\)</span></p></li></ul><p>改进第三规则即为SLR(1)分析表：</p><p><span class="math inline">\([k: A\rightarrow\alpha·]\in I_i\and A\neqS&#39;\Longrightarrow\forall t\in Follow(A).ACTION[i,t]=rk\)</span></p><p>LR(0)文法</p><p>如果文法G的LR(0)分析表是无冲突的，则G是LR(0)文法。</p><ul><li>LR(0)分析表每一行选用的归约产生式是相同的。</li></ul><p>SLR(1)文法</p><p>如果文法G的SLR(1)分析表无冲突，则G是SLR(1)文法。</p><p>两类可能的冲突：移入/归约冲突、归约/归约冲突</p><h2 id="三属性文法">三、属性文法</h2><p>属性文法：为上下文无关文法赋予语义</p><p>在语义分析过程中实现属性文法，语义动作嵌入的位置决定了何时执行该动作。</p><p>基本思想：一个动作在它左边的所有文法符号都处理过之后立即执行</p><h3 id="语法制导定义">语法制导定义</h3><p>Syntax-Directed Definition，SDD</p><p>一个上下文无关文法和属性及规则的结合。</p><ul><li>每个文法符号都可以关联多个属性</li><li>每个产生式都可以关联一组规则</li></ul><p>SDD唯一确定了语法分析树上每个非终结符节点的属性；</p><p>SDD没有规定以什么方式、什么顺序计算这些属性值。</p><h4 id="综合属性">综合属性</h4><p>结点N的综合属性只能通过N的子结点或N本身的属性进行定义。</p><h4 id="s属性定义">S属性定义：</h4><p>如果一个SDD的每个属性都是综合属性，则它是S属性定义。</p><p>依赖图用于确定一棵给定的语法分析树中各个属性实例之间的依赖关系。</p><p>S 属性定义的依赖图刻画了属性实例之间自底向上的信息流动。</p><h4 id="继承属性">继承属性</h4><p>结点N上的继承属性只能通过N的父结点、N本身和N的兄弟结点上的属性来定义。</p><p>继承属性<spanclass="math inline">\(T^{&#39;}.inh\)</span>用于在表达式中从左到右传递中间计算结果</p><table><thead><tr class="header"><th>产生式</th><th>语法规则</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(T\rightarrow FT^{&#39;}\)</span></td><td><span class="math inline">\(T^{&#39;}.inh=F.val\)</span>；<spanclass="math inline">\(T.val=T^{&#39;}.syn\)</span>；</td></tr><tr class="even"><td><span class="math inline">\(T^{&#39;}\rightarrow*FT_1^{&#39;}\)</span></td><td><span class="math inline">\(T^{&#39;}_1.inh=T^{&#39;}.inh\timesF.val\)</span>；<spanclass="math inline">\(T^{&#39;}.syn=T^{&#39;}_1.syn\)</span>；</td></tr><tr class="odd"><td><span class="math inline">\(T^{&#39;}\rightarrow\epsilon\)</span></td><td><spanclass="math inline">\(T^{&#39;}.syn=T^{&#39;}.inh\)</span>；</td></tr><tr class="even"><td><span class="math inline">\(F\rightarrow digit\)</span></td><td><span class="math inline">\(F.val=digit.lexval\)</span>；</td></tr></tbody></table><p>综合属性<spanclass="math inline">\(T^{&#39;}.syn\)</span>则用以计算最终结果。</p><h4 id="l属性定义">L属性定义</h4><p>如果一个SDD的每个属性要么是综合属性，要么是继承属性，则它是L属性定义。</p><ul><li><p>继承属性规则需满足限制：</p><p>对于<span class="math inline">\(A\rightarrowX_1X_2...X_n\)</span>及其对应规则定义的<spanclass="math inline">\(X_i.a\)</span>，这个规则只能使用</p><ul><li>和产生式头A关联的继承属性</li><li>位于<spanclass="math inline">\(X_i\)</span>左边的文法符号的相关的综合属性或继承属性</li><li>和这个<spanclass="math inline">\(X_i\)</span>的实例本身相关的继承属性或综合属性，但是在这个<spanclass="math inline">\(X_i\)</span>的全部属性组成的依赖图中不存在环</li></ul></li></ul><p>数组类型文法：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">T:</span> BC<br><span class="hljs-symbol">B:</span> INT<br><span class="hljs-symbol">C:</span> <span class="hljs-string">&#x27;[&#x27;</span> INT <span class="hljs-string">&#x27;]&#x27;</span> C<br></code></pre></td></tr></table></figure><p>有符号二进制数文法</p><table><thead><tr class="header"><th>产生式</th><th>属性规则</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(Number\rightarrow SignList\)</span></td><td><spanclass="math inline">\(List.pos=0;\)</span>$if(Sign.neg){Number.val=-List.val;}<span class="math display">\[else\{Number.val=List.val;\}$ || $Sign\rightarrow +$           |$Sign.neg=false;$                                            || $Sign\rightarrow -$           |$Sign.neg=true;$                                             || $List\rightarrow Bit$         | $Bit.pos =List.pos;\]</span>List.val=Bit.val;$</td></tr><tr class="even"><td><span class="math inline">\(List\rightarrow List_1Bit\)</span></td><td><span class="math inline">\(List_1.pos=List.pos+1;\)</span><spanclass="math inline">\(Bit.pos=List.pos;\)</span><spanclass="math inline">\(List.val=List_1.val+Bit.val;\)</span></td></tr><tr class="odd"><td><span class="math inline">\(Bit\rightarrow 0\)</span></td><td><span class="math inline">\(Bit.val=0;\)</span></td></tr><tr class="even"><td><span class="math inline">\(Bit\rightarrow 1\)</span></td><td><span class="math inline">\(Bit.val=1;\)</span></td></tr></tbody></table><h4 id="后缀表示">后缀表示</h4><p>递归定义：</p><ul><li>如果E是一个常量或变量，则E的后缀表示是E本身</li><li>如果E是形如<span class="math inline">\(E_1 opE_2\)</span>的表达式，则E的后缀表示是<spanclass="math inline">\(E_1&#39;E_2&#39;op\)</span>，这里的<spanclass="math inline">\(E_1&#39;\)</span>和<spanclass="math inline">\(E_2&#39;\)</span>是<spanclass="math inline">\(E_1\)</span>和<spanclass="math inline">\(E_2\)</span>的后缀表达式</li><li>如果E是形如<spanclass="math inline">\((E_1)\)</span>的表达式，则E的后缀表示是<spanclass="math inline">\(E_1\)</span>的后缀表示</li></ul><h3 id="语法制导的翻译方案">语法制导的翻译方案</h3><p>Syntax-Directed translation，SDT</p><p>在其产生式体中嵌入语义动作的上下文无关文法。</p><ul><li>用大括号包括规则，写在产生式之后。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-词法分析</title>
    <link href="/2023/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2023/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>子不语</p><span id="more"></span><h1 id="词法分析">词法分析</h1><h2 id="一词法分析器的作用">一、词法分析器的作用</h2><h3 id="词法分析器的主要任务">词法分析器的主要任务</h3><p>读入源程序的输入字符，将它们组成词素，生成并输出一个词法单元序列，每个词法单元对应于一个词素。</p><p>词法分析器负责读取源程序，因此还会完成一些识别词素之外的任务，例如：</p><ul><li>过滤源程序中的注释与空白</li><li>将编译器生成的错误信息与源程序位置关联</li><li>宏预处理</li></ul><p>此后，进入词法分析阶段。</p><p>词法分析与语法分析分离的原因：</p><ol type="1"><li>简化编译器设计：简化词法分析和语法分析中的一些任务</li><li>提高编译器效率：使用专用于词法分析的一些技术</li><li>增强编译器可移植性：输入设备的特殊性可限制于词法分析中</li></ol><h3 id="术语">术语</h3><ul><li>词素：源程序中的一个字符序列，和某个词法单元的模式匹配，被词法分析器识别为该词法单元的一个实例</li><li>词法单元：一个词法单元名和一个可选的属性值</li><li>模式：一个词法单元的词素可能具有的形式</li></ul><p>词法单元的一般类别：</p><ol type="1"><li>关键字，其模式为其本身</li><li>运算符</li><li>表示符</li><li>常量词法单元</li><li>标点符号</li></ol><h3 id="词法错误">词法错误</h3><p>当出现所有词法单元的模式都无法和剩余输入的某个前缀相匹配的情况，词法分析器就不能继续处理输入。</p><p>“恐慌模式”恢复：从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的语法单元为止。</p><p>其他恢复动作：</p><ul><li>从剩余的输入中删除一个字符</li><li>向剩余的输入中插入一个遗漏的字符</li><li>用一个字符来替换另一个字符</li><li>交换两个相邻的字符</li></ul><h2 id="二输入缓冲">二、输入缓冲</h2><p>在编译一个大型源程序时需要处理大量的字符，利用两个交替读入的缓冲区可以减少处理字符的开销。</p><p>每个缓冲区都有N个字符，通常N为一个磁盘块的大小。可以使用系统读取命令一次将N个字符读入到缓冲区中，若读入的剩余字符不足N个，则会有一个特殊字符(如eof)标记源文件的结束，该字符不同于任何可能出现在源程序中的字符。</p><p>程序为输入维护了两个指针：</p><ul><li>lexemeBegin指针：指向当前词素的开始处</li><li>forward指针：一直向前扫描，直到发现某个模式被匹配为止</li></ul><p>确定一个词素后，词法分析器将这个词素记录下来，然后用lexemeBegin指向词素后第一个字符。</p><h3 id="哨兵标记">哨兵标记</h3><p>每次前移forward时，都须检查是否到了缓冲区的末尾，若是，则须加载另一个缓冲区。</p><p>我们扩展每一个缓冲区，在它们的末尾加上一个哨兵字符来完成对缓冲区末端的测试，这个哨兵字符的一个选择就是eof。</p><h2 id="三词法单元的规约">三、词法单元的规约</h2><h3 id="串和语言">串和语言</h3><ul><li><p>字母表：一个有限的符号集合。</p></li><li><p>串：某个字母表中符号的一个有穷序列。</p><ul><li>串s的长度，通常记作|s|。空串是长度为0的串，用𝜖表示。</li></ul></li><li><p>语言：某个给定字母表上一个任意的可数的串集合。</p></li></ul><p>串的一些术语：</p><ol type="1"><li>串的前缀是从其尾部删除0个或多个符号后得到的串，包括其本身和𝜖</li><li>串的后缀是从其首部删除0个或多个符号后得到的串，包括其本身和𝜖</li><li>串的子串是删除某个前缀和某个后缀后得到的串</li><li>串的真前缀、真后缀、真子串不等于其本身</li><li>串的子序列是从其中删除0个或多个符号后得到的串</li></ol><h4 id="串的连接">串的连接</h4><p>如果x和y是串，那么x和y的连接(记作xy)是把y附加到x后形成的串。</p><p>可以把连接看成两个串的乘积，定义串的指数运算：</p><p>串的0次方为𝜖，n次方为n个该串的连接。</p><h4 id="语言上的运算">语言上的运算</h4><p>并、连接、闭包</p><ul><li><p>L和M的并：<span class="math inline">\(L\cup M = \{s|s\in L\ors\in M\}\)</span></p></li><li><p>L和M的连接：<span class="math inline">\(LM= \{st|s\in L\and t\inM\}\)</span></p></li><li><p>L的Kleene闭包：将L连接0次或多次后得到的串集，记为<spanclass="math inline">\(L^*\)</span></p></li><li><p>L的正闭包：将L连接1次或多次后得到的串集，记为<spanclass="math inline">\(L^+\)</span></p></li></ul><h3 id="正则表达式的递归定义">正则表达式的递归定义</h3><p>归纳基础：</p><ol type="1"><li>𝜖是一个正则表达式，<span class="math inline">\(L(\epsilon ) =\{\epsilon\}\)</span>，即该语言只包含空串</li><li>如果a是字母表上的一个符号，那么a是一个正则表达式，并且<spanclass="math inline">\(L(a) =\{a\}\)</span>，即该语言只包含一个符号串a</li></ol><p>归纳步骤：由小的正则表达式构造大的正则表达式的步骤有四个部分。假定r和s都是正则表达式，分别表示语言L(r)和L(s)，那么：</p><ol type="1"><li><spanclass="math inline">\((r)\)</span>是一个正则表达式，表示语言<spanclass="math inline">\(L(r)\)</span></li><li><spanclass="math inline">\((r)(s)\)</span>是一个正则表达式，表示语言<spanclass="math inline">\(L(r)L(s)\)</span></li><li><spanclass="math inline">\((r)^*\)</span>是一个正则表达式，表示语言<spanclass="math inline">\((L(r))^*\)</span></li><li><spanclass="math inline">\((r)|(s)\)</span>是一个正则表达式，表示语言<spanclass="math inline">\(L(r)\cup L(s)\)</span></li></ol><p>采取如下约定来舍去不需要的括号：</p><ol type="1"><li>一元运算符*具有最高的优先级，并且左结合</li><li>连接具有次高的优先级，并且左结合</li><li>|的优先级最低，并且左结合</li></ol><p>正则集合：可以用一个正则表达式定义的语言。</p><p>称两个表示相同语言的正则表达式等价。</p><p>以下为一些正则表达式的代数定律</p><ol type="1"><li><span class="math inline">\(r|s=s|r\)</span>，即|运算具有交换性</li><li><spanclass="math inline">\(r|(s|t)=(r|s)|t\)</span>，|运算具有结合性</li><li><span class="math inline">\(r(st)=(rs)t\)</span>，连接可结合</li><li><span class="math inline">\(r(s|t)=rs|rt\)</span>，<spanclass="math inline">\((s|t)r=st|sr\)</span>连接对|可分配</li><li><span class="math inline">\(\epsilon\)</span>是连接的单位元</li><li>闭包中一定包含<span class="math inline">\(\epsilon\)</span></li><li><span class="math inline">\(r^*=r^{**}\)</span>，*具有幂等性</li></ol><p>正则定义：为某些正则表达式命名，使用这些名称来表示正则表达式。</p><p>正则表达式的扩展：</p><ol type="1"><li>单目后缀运算符+用以表示一个正则表达式及其语言的正闭包</li><li>单目后缀运算符?表示“0或1个出现”，?具有和+与*相同的优先级、结合性</li><li>字符类：用<spanclass="math inline">\([a_1a_2...a_n]\)</span>缩写<spanclass="math inline">\(a_1|a_2|...|a_n\)</span>，如果<spanclass="math inline">\([a_1a_2...a_n]\)</span>形成一个逻辑上连续的序列，可以表示成<spanclass="math inline">\([a_1-a_n]\)</span></li></ol><p>至此，我们可以使用正则表达式来表示一个模式。</p><h3 id="java正则表达式">Java正则表达式</h3><h4 id="单个字符">单个字符</h4><table><thead><tr class="header"><th>正则表达式</th><th>规则</th></tr></thead><tbody><tr class="odd"><td>A</td><td>指定字符</td></tr><tr class="even"><td>48c</td><td>指定Unicode字符</td></tr><tr class="odd"><td>.</td><td>任意字符</td></tr><tr class="even"><td> 数字0～9</td><td></td></tr><tr class="odd"><td></td><td>大小写字母、数字和下划线</td></tr><tr class="even"><td></td><td>空格、Tab键</td></tr><tr class="odd"><td></td><td>非数字</td></tr><tr class="even"><td></td><td>非</td></tr><tr class="odd"><td></td><td>非</td></tr></tbody></table><h4 id="多个字符">多个字符</h4><table><thead><tr class="header"><th>正则表达式</th><th>规则</th></tr></thead><tbody><tr class="odd"><td>A*</td><td>任意个数字符</td></tr><tr class="even"><td>A+</td><td>至少一个字符</td></tr><tr class="odd"><td>A？</td><td>0或1个字符</td></tr><tr class="even"><td>A{n}</td><td>指定个数字符</td></tr><tr class="odd"><td>A{2,3}</td><td>指定范围个数字符</td></tr><tr class="even"><td>A{n,}</td><td>至少n个字符</td></tr><tr class="odd"><td>A{,n}</td><td>最多n个字符</td></tr></tbody></table><h4 id="复杂匹配规则">复杂匹配规则</h4><table><thead><tr class="header"><th>正则表达式</th><th>规则</th><th>可以匹配</th></tr></thead><tbody><tr class="odd"><td>^</td><td>开头</td><td>字符串开头</td></tr><tr class="even"><td>$</td><td>结尾</td><td>字符串结束</td></tr><tr class="odd"><td>[ABC]</td><td>[...]内任意字符</td><td><code>A</code>,<code>B</code>,<code>C</code></td></tr><tr class="even"><td>[A-F0-9xy]</td><td>指定范围的字符</td><td><code>A</code>,...,<code>F</code>,<code>0</code>,...,<code>9</code>,<code>x</code>,<code>y</code></td></tr><tr class="odd"><td>[^A-F]</td><td>指定范围外的字符</td><td>非<code>A</code>~<code>F</code></td></tr><tr class="even"><td>AB|CD|EF</td><td>AB或者CD或者EF</td><td><code>AB</code>,<code>CD</code>,<code>EF</code></td></tr></tbody></table><h2 id="四词法单元的识别">四、词法单元的识别</h2><p>检查输入字符串，并在其前缀中找出一个和某个模式匹配的词素。</p><h3 id="状态转换图">状态转换图</h3><p>将模式转换成具有特定风格的流图，称为状态转换图。</p><ol type="1"><li>其中包含一组结点或圆圈，即状态，每个状态代表一个可能在词法分析器扫描输入串的过程中匹配到的情况。</li><li>状态图中的边从图的一个状态指向另一个状态，每条边的标号包含了一个或多个符号。</li></ol><p>规则：</p><ol type="1"><li>接受状态或最终状态指已经找到一个词素的状态，用双层的圈表示。</li><li>若需要在接受状态回退数个位置，就在该接受状态附近加上相应数目的*。</li><li>初始状态由一条没有出发结点的标号为start的边指定，是没有读入任何输入前状态转换图的位置。</li></ol><h3 id="保留字和标识符的处理">保留字和标识符的处理</h3><ol type="1"><li>初始化时即将各保留字填入符号表中</li><li>为每个关键字建立单独的状态转换图</li></ol><h2 id="五有穷状态机">五、有穷状态机</h2><ul><li>不确定的有穷状态机 (Nondeterministic Finite Automata，NFA)<ul><li>对边上的标号没有限制，一个符号标记离开同一状态的多条边，并且空串也可作为标号</li></ul></li><li>确定的有穷状态机 (Deterministic Finite Automata，DFA)<ul><li>对于每个状态及输入自动机的每个符号，有且只有一条离开该状态，以该符号为标号边</li></ul></li></ul><h3 id="不确定有穷状态机">不确定有穷状态机</h3><p>组成部分：</p><ol type="1"><li>一个有穷的状态集合S</li><li>一个输入符号集合<spanclass="math inline">\(\Sigma\)</span>，即输入字母表，假设空串的<spanclass="math inline">\(\epsilon\)</span>不是字母表中的元素</li><li>一个转换函数，为每个状态和<span class="math inline">\(\Sigma \cup\{\epsilon\}\)</span>中每个符号给出相应后继状态的集合</li><li>S中的一个状态<spanclass="math inline">\(s_0\)</span>被指定为开始状态</li><li>S的一个子集F被指定为接受状态的集合</li></ol><h4 id="转换图">转换图</h4><p>不管是不确定有穷状态机还是确定有穷状态机，都可以表示为一张转换图，图中的结点是状态，带有标号的边表示自动机的转换函数。从状态s到状态t存在一条标号为a的边当且仅当状态t是状态s在输入a之后的后继状态之一。</p><p>和状态转换图的区别：</p><ul><li>同一个符号可以标记从同一状态出发到达多个目标状态的多条边</li><li>一条边的标号不仅可以是输入字母表中的符号，也可以是空符号串<spanclass="math inline">\(\epsilon\)</span></li></ul><h4 id="转换表">转换表</h4><p>从次行起的各行对应各状态，首行的各列对应于输入符号和$$。</p><ul><li>对应于一个给定状态和给定输入的条目是将NFA的转换函数应用于这些参数后得到的值</li><li>如果转换函数没有给出对应于某个状态-输入对的信息，就将<spanclass="math inline">\(\varnothing\)</span>放入对应表项中</li></ul><p>转换表易于确定给定状态与输入符号对应的转换，但当输入字母表较大且多数状态在多数输入字符上无转换时需占用大量空间。</p><h4 id="自动机接受输入字符串">自动机接受输入字符串</h4><p>一个不确定有穷状态机接受输入字符串，当且仅当对应的转换图中存在一条从开始状态到某个接受状态的路径上的标号(忽略空串)组成该字符串。</p><p>由一个不确定有穷状态机定义的语言为从开始状态到接受状态的所有路径上标号串的集合。可以用<spanclass="math inline">\(L(A)\)</span>表示自动机A接受的语言。</p><h3 id="确定有穷状态机">确定有穷状态机</h3><p>组成部分：</p><ol type="1"><li>一个有穷的状态集合S</li><li>一个输入符号集合<spanclass="math inline">\(\Sigma\)</span>，即输入字母表，假设空串的<spanclass="math inline">\(\epsilon\)</span>不是字母表中的元素</li><li>一个转换函数，为每个状态和<spanclass="math inline">\(\Sigma\)</span>中每个符号给出相应后继状态的集合</li><li>S中的一个状态<spanclass="math inline">\(s_0\)</span>被指定为开始状态</li><li>S的一个子集F被指定为接受状态的集合</li></ol><p>不确定有穷状态机的特例</p><ul><li>没有输入<span class="math inline">\(\epsilon\)</span>的转换动作</li><li>对每个状态s和每个输入符号a，有且仅有一条为标号a的边离开s</li></ul><p>不确定有穷状态机抽象地表示了用来识别某个语言中的串的算法，而相应的确定有穷状态机则是一个简单具体的识别串的算法。</p><ul><li><p>在构造词法分析器时，真正实现或模拟的是确定有穷状态机。</p></li><li><p>每个正则表达式和每个确定有穷状态机都可以被转变成为一个接受相同语言的确定有穷状态机。</p></li></ul><h2 id="六从正则表达式到自动机">六、从正则表达式到自动机</h2><p>正则表达式——&gt;不确定有穷状态机——&gt;确定有穷状态机——&gt;词法分析器</p><p>第一步：Thompson构造法</p><p>第二步：子集构造法</p><h3 id="thompson构造法">Thompson构造法</h3><p>基本思想：按结构归纳</p><p>记r的不确定有穷状态机为N(r)。</p><p>根据正则表达式的递归定义进行构造：</p><ul><li>𝜖是一个正则表达式<ul><li>初始状态接受<spanclass="math inline">\(\epsilon\)</span>到达结束状态</li></ul></li><li>字母表上的一个符号a是一个正则表达式<ul><li>初始状态接受a到达结束状态</li></ul></li><li><span class="math inline">\((r)\)</span>是一个正则表达式<ul><li>等同于r的不确定有穷状态机</li></ul></li><li><span class="math inline">\((r)(s)\)</span>是一个正则表达式<ul><li>将r的结束状态和s的初始状态合并</li></ul></li><li><span class="math inline">\((r)^*\)</span>是一个正则表达式<ul><li>r的结束状态接受<spanclass="math inline">\(\epsilon\)</span>到达开始状态或系统结束状态</li><li>系统初始状态接受<spanclass="math inline">\(\epsilon\)</span>到r的初始状态或系统结束状态</li></ul></li><li><span class="math inline">\((r)|(s)\)</span>是一个正则表达式<ul><li>系统初始状态接受<spanclass="math inline">\(\epsilon\)</span>到达r和s的初始状态，r和s的结束状态接受<spanclass="math inline">\(\epsilon\)</span>到达系统结束状态</li></ul></li></ul><p>复杂度：<span class="math inline">\(O(n)\)</span></p><h4 id="nr的性质">N(r)的性质</h4><ul><li>开始状态和接受状态唯一</li><li>开始状态没有入边，接受状态没有出边</li><li>N(r)的状态数<span class="math inline">\(|S|\leq 2\times|r|\)</span>，其中|r|为r中运算符和运算分量的总和</li><li>每个状态最多有两个<spanclass="math inline">\(\epsilon\)</span>入边与两个<spanclass="math inline">\(\epsilon\)</span>出边（<spanclass="math inline">\(r|s\)</span>的情况下）</li><li>$a$，每个状态最多有一个a入边和一个a出边</li></ul><h3 id="子集构造算法">子集构造算法</h3><p>r的确定有穷状态机记为D(r)。</p><p>让构造得到的DFA每个状态对应于NFA的一个状态集合。</p><ol type="1"><li>使用NFA开始状态的<spanclass="math inline">\(\epsilon\)</span>闭包确定DFA的开始状态</li><li>根据NFA开始状态的<spanclass="math inline">\(\epsilon\)</span>闭包的转换确定DFA开始状态的转换</li><li>逐步进行DFA的模拟</li></ol><p>复杂度：<spanclass="math inline">\(O(2^n)\)</span>，极限情况下有<spanclass="math inline">\(\Omega (2^n)\)</span></p><p>闭包与不动点</p><p>集合T的函数f闭包为对T进行任意次或0次f的结果的集合。</p><p>若存在f(x)=x，则x称为f的不动点。</p><h3 id="dfa最小化算法">DFA最小化算法</h3><p>基本思想：等价的状态可以合并</p><p>状态等价的定义：</p><p>状态s和t等价，即两者接受相同的字符时，会到达相同的状态。记为s～t。</p><ul><li>但是无法判断初始等价的状态，无法进行递归合并。</li><li>于是使用不等价进行划分。</li></ul><p><span class="math inline">\(s不等价于t\Longleftrightarrow \existsa\in \Sigma. (s\rightarrow^a s&#39;) \and (t \rightarrow^at&#39;)\and(s&#39;不等价于t&#39;)\)</span></p><p>步骤：</p><ol type="1"><li>接受状态和非接受状态必然不等价，以此为初始条件进行等价状态的递归划分。</li><li>合并等价的状态。</li></ol><p>使用该算法前，需要确保该自动机确实是DFA，检查是否需要补充死状态。</p><h3 id="从dfa到词法分析器">从DFA到词法分析器</h3><ul><li><p>最前优先匹配：匹配匹配到的最优先的接受状态</p></li><li><p>最长优先匹配：匹配最长的字符串</p></li></ul><p>模拟DFA步骤</p><ol type="1"><li>模拟运行DFA，直到无法继续为止（输入结束或状态无转移）</li><li>若当前状态为接受状态，则识别成功</li><li>否则回溯至最近一次经过的接受状态，识别成功</li><li>若回溯到初始状态，则报错，删除当前字符，运行第1步</li></ol><h3 id="从dfa到正则表达式">从DFA到正则表达式</h3><p>暂略</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第六章_并发程序设计</title>
    <link href="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第六章-并发程序设计">第六章 并发程序设计</h1><h2 id="并发进程">6.1 并发进程</h2><h3 id="顺序程序设计">6.1.1 顺序程序设计</h3><p>进程在处理器上的顺序执行是严格按序的，一个操作结束后，才能开始后续操作。</p><p>顺序程序设计：把一个程序设计成顺序执行的程序模块。</p><ul><li>顺序不仅在一个程序模块内部，也在多个程序模块之间。</li></ul><p>顺序程序设计的特点：</p><ul><li>程序执行的顺序性</li><li>程序环境的封闭性</li><li>执行结果的确定性</li><li>计算过程的可再现性</li></ul><h3 id="进程的并发性">6.1.2 进程的并发性</h3><p>进程的并发性（Concurrency）是指一组进程的执行在时间上是重叠的。</p><ul><li>宏观上，并发性反映一个时间段中几个进程都在同一处理器上，处于运行还未运行结束状态</li><li>微观上，任一时刻仅有一个进程在处理器上运行</li></ul><h4 id="并发程序设计">并发程序设计</h4><p>使一个程序分成若干个可同时执行的程序模块的方法称为并发程序设计（concurrentprogramming），每个程序模块和它执行时所处理的数据就组成一个进程。</p><p>并发进程的分类：无关的、交互的</p><ul><li>无关的并发进程：一个进程的执行与其他并发进程的进展无关<ul><li>并发进程的无关性是进程的执行与时间无关的一个充分条件，又称为Bernstein条件</li></ul></li><li>交互的并发进程：一个进程的执行可能影响其他并发进程的结果</li></ul><h4 id="bernstein条件">Bernstein条件</h4><ul><li><p>程序<spanclass="math inline">\(p_i\)</span>在执行期间引用的变量集，记为<spanclass="math inline">\(R(p_i)=\{a_{i1},a_{i2},...,a_{in}\}\)</span>，</p></li><li><p>程序<spanclass="math inline">\(p_i\)</span>在执行期间改变的变量集，记为<spanclass="math inline">\(W(p_i)=\{b_{i1},b_{i2},...,b_{im}\}\)</span></p></li><li><p>若两个进程的程序<span class="math inline">\(p_1\)</span>和<spanclass="math inline">\(p_2\)</span>能满足Beinstein条件，即满足</p><p><span class="math inline">\((R(p_1)\cap W(p_2))\cup (R(p_2)\capW(p_1))\cup (W(p_1)\cap W(p_2))=\varnothing\)</span>，</p><p>则这两个并发进程的执行与时间无关</p></li></ul><p>与时间有关的错误：对于一组交互的并发进程，执行的相对速度无法相互控制，各种与时间有关的错误就有可能出现。</p><ul><li>与时间有关错误的表现形式：结果不唯一、永远等待</li></ul><h3 id="进程的交互竞争和协作">6.1.3 进程的交互：竞争和协作</h3><p>进程之间存在两种基本关系：竞争关系和协作关系</p><ul><li>竞争关系：一个进程的执行可能影响到同其竞争资源的其他进程，如果两个进程要访问同一资源，那么一个进程通过操作系统分配得到该资源，另一个将不得不等待</li><li>协作关系：某些进程为了完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的信号之前应阻塞自己，直到其他合作进程发来协调信号后方被唤醒并继续执行。</li></ul><h4 id="资源竞争的两个控制问题">资源竞争的两个控制问题</h4><ul><li>死锁：一组进程如果都获得了部分的资源，还想要得到其他进程所占有的资源，最终所有的进程都将陷入死锁</li><li>饥饿：一个进程由于其他进程总是优先于它而被无限期拖延</li><li>操作系统需要保证诸进程能互斥地访问临界资源，既要解决饥饿问题，又要解决死锁问题</li></ul><h4 id="进程的互斥与同步">进程的互斥与同步</h4><p>进程的互斥（mutual exclusion）是解决进程间竞争关系的手段。</p><ul><li>若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源</li></ul><p>进程的同步（Synchronization）是解决进程间协作关系的手段。</p><ul><li>两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的信号，当一个进程没有得到来自于另一个进程的信号则需等待。</li></ul><p>进程的互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，是对进程使用资源次序上的一种协调。</p><h2 id="临界区管理">6.2 临界区管理</h2><h3 id="互斥与临界区">6.2.1 互斥与临界区</h3><ul><li><p>并发进程中与共享变量有关的程序段称为临界区（criticalsection）</p><p>共享变量代表的资源称为临界资源</p></li><li><p>与同一变量有关的临界区分散在各进程的程序段中，而各进程的执行速度不可预见</p></li><li><p>如果保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问互斥，就不会造成与时间有关的错误。</p></li></ul><h4id="临界区调度原则dijkstra1965">临界区调度原则（Dijkstra，1965）</h4><ul><li>一次至多一个进程能够进入临界区内执行</li><li>如果已有进程在临界区，其他试图进入的进程应等待</li><li>进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入</li></ul><h3 id="临界区管理-1">6.2.2 临界区管理</h3><p>临界区管理的简单方法（忙式等待/反复测试）：</p><ul><li>Peterson算法</li><li>关中断</li><li>对换指令</li><li>测试并建立指令</li></ul><p>存在的问题：</p><ul><li>对不能进入临界区的进程，采用忙式等待测试法，浪费CPU时间</li><li>将测试能否加入临界区的责任推给各个竞争的进程会削弱系统的可靠性，加重编程负担</li></ul><p>通用的解决方案：信号量与PV操作</p><h4 id="peterson算法">Peterson算法</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">bool</span> inside[<span class="hljs-number">2</span>];<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">enum</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125; turn;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">P0</span><span class="hljs-params">()</span></span>&#123;<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>turn = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(inside[<span class="hljs-number">1</span>]&amp;&amp;turn==<span class="hljs-number">1</span>);<br>&#123;临界区&#125;;<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P1</span><span class="hljs-params">()</span></span>&#123;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(inside[<span class="hljs-number">0</span>]&amp;&amp;turn==<span class="hljs-number">0</span>)<br>&#123;临界区&#125;;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 1:1交替</span><br><span class="hljs-keyword">enum</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125; turn;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">P0</span><span class="hljs-params">()</span></span>&#123;<br>turn = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(turn==<span class="hljs-number">1</span>);<br>&#123;临界区&#125;;<br>turn = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P1</span><span class="hljs-params">()</span></span>&#123;<br>turn = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(turn==<span class="hljs-number">0</span>);<br>&#123;临界区&#125;;<br>turn = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关中断">关中断</h4><ul><li>实现互斥的最简单方法</li></ul><h4 id="测试并建立指令">测试并建立指令</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//TS指令实现进程互斥</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TS</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(x)&#123;<br>    x = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> s = <span class="hljs-literal">true</span>;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">Pi</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">TS</span>(s)); <span class="hljs-comment">//上锁</span><br>  &#123;临界区&#125;;<br>  s = <span class="hljs-literal">true</span>;      <span class="hljs-comment">//开锁</span><br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h4 id="对换指令">对换指令</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//对换指令实现进程互斥</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SWAP</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> &amp;a, <span class="hljs-built_in">bool</span> &amp;b</span>)</span>&#123;<br><span class="hljs-built_in">bool</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-built_in">bool</span> <span class="hljs-keyword">lock</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">Process <span class="hljs-title">Pi</span>()</span>&#123;<br><span class="hljs-built_in">bool</span> key = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">do</span>&#123;<br>SWAP(key, <span class="hljs-keyword">lock</span>);<br>&#125;<span class="hljs-keyword">while</span>(key);<span class="hljs-comment">//上锁</span><br>&#123;临界区&#125;;<br>SWAP&#123;key, <span class="hljs-keyword">lock</span>&#125;;<span class="hljs-comment">//开锁</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号量与pv操作">6.3 信号量与PV操作</h2><h3id="信号量与pv操作的数据结构与原语操作">信号量与PV操作的数据结构与原语操作</h3><p>设s为一个记录型数据结构，一个分量为整型量value，另一个为信号量队列queue，P和V操作原语的定义：</p><ul><li>P(s)：将信号量s减去1，若结果小于0，则调用P(s)的进程被设置成等待信号量s的状态</li><li>V(s)：将信号量s加1，若结果不大于0，则释放一个等待信号量s的进程，其转为就绪态</li></ul><p>对于信号量，只允许使用P和V原语操作访问，不能直接对信号量的整型值和队列作操作</p><p>原语：CPU处于内核态，在关中断环境下执行的一段指令序列</p><ul><li>原子性：不被中断，确保安全且完整执行这段指令序列</li></ul><h4 id="几个经典问题">几个经典问题</h4><h5 id="哲学家就餐问题互斥">哲学家就餐问题（互斥）</h5><p>有五个哲学家围坐在一圆桌旁，桌中央有一盘通心面，每人面前有一只空盘子，每两人之间放一把叉子。每个哲学家思考、饥饿、然后吃通心面。为了吃面，每个哲学家必须获得两把叉子，且每人只能直接从自己左边或右边去取叉子。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">semaphore fork<span class="hljs-literal">[<span class="hljs-number">5</span>]</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>fork<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=<span class="hljs-number">1</span>;<br>semaphore room=<span class="hljs-number">4</span>; <span class="hljs-comment">//增加一个侍者，设想有两个房间1号房间是会议室，2号房间是餐厅</span><br>cobegin<br>process philosopher<span class="hljs-constructor">_i()</span>&#123; <span class="hljs-comment">//i=0,1,2,3,4</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>think<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">room</span>)</span>; <span class="hljs-comment">//控制最多允许4位哲学家进入2号房间餐厅取叉子</span><br><span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>; <span class="hljs-comment">//偶数哲学家先右手</span><br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span> % <span class="hljs-number">5</span> ]); <span class="hljs-comment">//后左手</span><br>eat<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>;<br>V (fork<span class="hljs-literal">[(<span class="hljs-identifier">i</span>+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span> % <span class="hljs-number">5</span> ]); <span class="hljs-comment">//奇数哲学家，先左手</span><br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>; <span class="hljs-comment">//后右手</span><br>eat<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span>%<span class="hljs-number">5</span>]);<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>;<br>&#125;<br><span class="hljs-constructor">V(<span class="hljs-params">room</span>)</span>;<br>&#125;<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h5 id="生产者与消费者问题同步">生产者与消费者问题（同步）</h5><p>有n个生产者和m个消费者，连接在一个有k个单位缓冲 区的有界缓冲上。</p><p>其中，生产者进程<spanclass="math inline">\(Producer_i\)</span>和消费者进程<spanclass="math inline">\(Consumer_j\)</span>都是并发进程，只要缓冲区未满，生产者<spanclass="math inline">\(Producer_i\)</span>生产的产品就可投入缓冲区；只要缓冲区不空，消费者进程<spanclass="math inline">\(Consumer_j\)</span>就可从缓冲区取走并消耗产品。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">产品 Buffer<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>semaphore put = k, get = <span class="hljs-number">0</span>;<span class="hljs-comment">//可以put或get的缓冲区数</span><br><span class="hljs-built_in">int</span> putPos = getPos = <span class="hljs-number">0</span>;<span class="hljs-comment">//put或get的位置</span><br>semaphore p = g = <span class="hljs-number">1</span>;<span class="hljs-comment">//互斥使用put或get的位置</span><br><br>process <span class="hljs-constructor">Producer_i()</span>&#123;<br>&#123;生产产品&#125;;<br><span class="hljs-constructor">P(<span class="hljs-params">put</span>)</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">p</span>)</span>;<br>Buffer<span class="hljs-literal">[<span class="hljs-identifier">putPos</span>]</span> = 产品;<br>putPos = (putPos + <span class="hljs-number">1</span>) % k;<br><span class="hljs-constructor">V(<span class="hljs-params">p</span>)</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">get</span>)</span>;<br>&#125;<br><br>process <span class="hljs-constructor">Consumer_i()</span>&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">get</span>)</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">g</span>)</span>;<br>产品 = Buffer<span class="hljs-literal">[<span class="hljs-identifier">getPos</span>]</span>;<br>getPos = (getPos + <span class="hljs-number">1</span>) % k;<br><span class="hljs-constructor">V(<span class="hljs-params">g</span>)</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">put</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管程">6.4 管程</h2><h3 id="管程和条件变量">6.4.1 管程和条件变量</h3><p>管程的引入：</p><ul><li>把分散在各进程中的临界区集中管理</li><li>防止进程的违法同步操作</li><li>便于用高级语言来编写程序</li></ul><h4 id="管程的定义">管程的定义</h4><p>由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。</p><p>管程的属性：共享性、安全性、互斥性</p><h4 id="管程的形式">管程的形式</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">type 管程名<span class="hljs-operator">=</span>monitor &#123;<br>局部变量说明<span class="hljs-comment">;</span><br>  条件变量说明<span class="hljs-comment">;</span><br>  初始化语句<span class="hljs-comment">;</span><br>define 管程内定义的，管程外可调用的过程或函数名列表<span class="hljs-comment">;</span><br>use 管程外定义的，管程内将调用的过程或函数名列表<span class="hljs-comment">;</span><br>过程名/函数名(形式参数表) &#123;<br>&lt;过程/函数体&gt;<span class="hljs-comment">;</span><br>&#125;<br>...<br>过程名/函数名(形式参数表) &#123;<br>&lt;过程/函数体&gt;<span class="hljs-comment">;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管程的条件变量">管程的条件变量</h4><p>只有在管程中才能被访问，它对管程内所有过程是全局的，只能通过两个原语操作来控制</p><ul><li><p>wait()：阻塞调用进程并释放管程，直到另一个进程在该条件变量上执行signal()</p></li><li><p>signal()：释放由于对条件变量执行wait()而被阻塞的其他进程，若无，信号不被保存</p></li><li><p>使用signal释放等待进程时，可能出现两个进程同时停留在管程内</p><ul><li><p>执行signal的进程等待，直到被释放进程退出管程或等待另一个条件变量</p></li><li><p>被释放进程等待，直到执行signal的进程退出管程或等待另一个条件</p></li><li><p>Hoare采用前一种方法。</p></li></ul></li></ul><h3 id="管程的实现">6.4.2 管程的实现</h3><h4 id="hoare管程">Hoare管程</h4><p>Hoare使用P和V操作原语来实现对管程中过程的互斥调用，以及实现对共享资源互斥使用的管理。</p><ul><li>wait和signal操作可被设计成可以中断的进程</li></ul><h4 id="hoare管程数据结构">Hoare管程数据结构</h4><ol type="1"><li>mutex</li></ol><ul><li>对于每个管程，使用用于管程中过程互斥调用的信号量mutex（初值为1）</li><li>进程调用管程中的任何过程时，应执行P(mutex)，进程退出管程时，需要判断是否有进程在next信号量等待，如果有（即next_count&gt;0），则通过V(next)唤醒一个发出signal的进程，否则应执行V(mutex)开放管程，以便让其他调用者进入</li><li>为了使进程在等待资源期间，其他进程能进入管程，在wait操作中也必须执行V(mutex)</li></ul><ol start="2" type="1"><li>next和next-count</li></ol><ul><li><p>对每个管程，引入信号量next（初值为0），发出signal操作的进程应该用P(next)阻塞自己，直到被释放进程退出管程或产生其他等待条件</p></li><li><p>next-count（初值为0），记录next上等待的进程个数</p></li></ul><ol start="3" type="1"><li>x-sem和x-count</li></ol><ul><li>x-sem（初值为0），申请资源无法满足时，执行P(x-sem)阻塞。由于释放资源时，需知道是否有其他进程在等待资源，用计数器x-count（初值为0）记录等待资源的进程数</li><li>执行signal操作时，应让等待资源的诸进程中的某个进程立即恢复运行，而不让其他进程抢先进入管程，这使用V(x-sem)实现</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">typedef <span class="hljs-keyword">struct</span> Monitor&#123;<br>semaphore mutex;<br>semaphore next;<br><span class="hljs-built_in">int</span> next_count;<br>&#125;<br>mutex = <span class="hljs-number">1</span>;<br>next = <span class="hljs-number">0</span>;<br>next_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//enter()和leave()操作</span><br>void enter(Monitor &amp;m)&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<br>&#125;<br>void leave<span class="hljs-literal">()</span>&#123;Monitor &amp;m&#125;&#123;<br><span class="hljs-keyword">if</span>(m.next_count&gt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">//wait()</span><br>void wait(semaphore &amp;x_sem, <span class="hljs-built_in">int</span> x_count, Monitor &amp;m)&#123;<br>x_count++;<span class="hljs-comment">//等待资源进程个数加1</span><br><span class="hljs-keyword">if</span>(m.next_count&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//判断是否有发出过signal的进程</span><br><span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<span class="hljs-comment">//释放</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<span class="hljs-comment">//开放管程</span><br><span class="hljs-constructor">P(<span class="hljs-params">x_sem</span>)</span>;<span class="hljs-comment">//等待资源进程阻塞自己</span><br>x_count--;<span class="hljs-comment">//等待资源进程个数减1</span><br>&#125;<br><br><span class="hljs-comment">//signal()</span><br>void signal(semaphore &amp;x_sem, <span class="hljs-built_in">int</span> x_count, Monitor &amp;m)&#123;<br><span class="hljs-keyword">if</span>(x_count&gt;<span class="hljs-number">0</span>)&#123;<br>m.next_count++;<span class="hljs-comment">//发出signal进程数加1</span><br><span class="hljs-constructor">V(<span class="hljs-params">x_sem</span>)</span>;<span class="hljs-comment">//释放一个等待资源的进程</span><br><span class="hljs-constructor">P(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<span class="hljs-comment">//发出signal的进程阻塞自己</span><br>m.next_count--;<span class="hljs-comment">//发出signal的进程个数减1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管程求解进程的同步和互斥问题">6.4.3管程求解进程的同步和互斥问题</h3><p>互斥问题：读者写者问题、哲学家就餐问题</p><p>同步问题：生产者与消费者问题、苹果桔子问题</p><h4 id="哲学家就餐问题">哲学家就餐问题</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs perl">type philosophers=monitor<br>enum &#123;thinking,hungry,eating&#125; <span class="hljs-keyword">state</span>[<span class="hljs-number">5</span>];<br>semaphore self[<span class="hljs-number">5</span>]; <span class="hljs-keyword">int</span> self_count[<span class="hljs-number">5</span>]; Monitor M;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++) <span class="hljs-keyword">state</span>[i] = thinking;<br>define pickup, putdown;<br><span class="hljs-keyword">use</span> enter, leave, <span class="hljs-keyword">wait</span>, signal;<br><br>void pickup(<span class="hljs-keyword">int</span> i)&#123;<br>enter(M);<br><span class="hljs-keyword">state</span>[i] = hungry;<br>test(i);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">state</span>[i] != eating)<br><span class="hljs-keyword">wait</span>(self[i], self_count[i], M);<br>leave(M);<br>&#125;<br><br>void putdown(<span class="hljs-keyword">int</span> i)&#123; <span class="hljs-regexp">//i</span>=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,..,<span class="hljs-number">4</span><br>enter(M);<br>  <span class="hljs-keyword">state</span>[i] = thinking;<br>    test((i-<span class="hljs-number">1</span>)%5);<br>    test((i+<span class="hljs-number">1</span>)%5);<br>leave(M);<br>&#125;<br><br>void test(<span class="hljs-keyword">int</span> k)&#123; <span class="hljs-regexp">//</span>k=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,...,<span class="hljs-number">4</span> <br><span class="hljs-keyword">if</span>((<span class="hljs-keyword">state</span>[(k-<span class="hljs-number">1</span>)%5] != eating) &amp;&amp; (<span class="hljs-keyword">state</span>[k] == hungry) <br>&amp;&amp;(<span class="hljs-keyword">state</span>[(k+<span class="hljs-number">1</span>)%5] != eating)) <br><span class="hljs-keyword">state</span>[k]=eating;<br>signal(self[k], self_count[k], IM);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生产者与消费者问题">生产者与消费者问题</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> <span class="hljs-built_in">product</span>=monitor<br>item Buffer[k];//缓冲区<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">in</span>, <span class="hljs-keyword">out</span>;//存取位置<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>;<br>semaphore full, empty;<br><span class="hljs-built_in">int</span> full_count, empty_count;<br>Monitor m;<br>define append, take;<br><span class="hljs-keyword">use</span> enter, leave, <span class="hljs-keyword">wait</span>, signal;<br><br>void append(item x)&#123;<br>enter(m);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">count</span> == k) <span class="hljs-keyword">wait</span>(full, full_count, m);<br>Buffer[<span class="hljs-keyword">in</span>] = x;<br><span class="hljs-keyword">in</span> = (<span class="hljs-keyword">in</span> + <span class="hljs-number">1</span>) % k;<br><span class="hljs-built_in">count</span>++;<br>signal(empty, empty_count, m);<br>leave(m);<br>&#125;<br><br>void take(item x)&#123;<br>enter(m);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">count</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">wait</span>(empty, empty_count, m);<br>x = Buffer[<span class="hljs-keyword">out</span>];<br><span class="hljs-keyword">out</span> = (<span class="hljs-keyword">out</span> + <span class="hljs-number">1</span>) % k;<br><span class="hljs-built_in">count</span>--;<br>signal(full, full_count, m);<br>leave(m);<br>&#125;<br><br>cobegin<br>process producer_i()&#123;<br><span class="hljs-built_in">product</span>.append(x);<br>&#125;<br>process consumer_i()&#123;<br><span class="hljs-built_in">product</span>.take(x);<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h2 id="进程通信">6.5 进程通信</h2><h3 id="进程通信-1">6.5.1 进程通信</h3><p>当进程互相交互时，必须满足两个基本要求：同步和通信</p><ul><li>为实施互斥，进程间需要同步</li><li>为了协作，进程间需要交换信息</li></ul><p>消息传递提供了最典型的消息传递原语：send和receive</p><h4 id="进程直接通信">进程直接通信</h4><ul><li>对称直接寻址，发送进程和接收进程必须命名对方以便通信，原语定义如下：<ul><li><code>send(P, message)</code>发送消息到进程P</li><li><code>receive(Q, message)</code>接收来自进程Q的消息</li></ul></li><li>非对称直接寻址，只要发送者命名接收者，而接收者不需命名发送者<ul><li><code>send(P, message)</code>发送消息到进程P</li><li><code>receive(id, message)</code>接收来自任何进程的消息，id置为与其通信的进程名称</li></ul></li></ul><p>进程P向Q发送消息：</p><pre><code class=" mermaid">graph LR进程P--&gt;内核--&gt;进程Q</code></pre><p>消息格式：消息头与消息体（即消息内容），</p><ul><li>消息头包括：消息类型、目标ID、源ID、消息长度、控制信息</li></ul><h4 id="进程间接通信">进程间接通信</h4><ul><li><p>消息不是直接从发送者发送到接收者，而是发送到由临时保存这些信息的队列组成的一个共享数据结构，这些队列通常称为信箱。</p></li><li><p>一个进程给合适的信箱发送消息，另一进程从信箱中获得消息。</p></li><li><p>间接通信的通信原语定义：</p><ul><li><p><code>send(A, message)</code>把消息传送到信箱A</p></li><li><p><code>receive(A, message)</code>从信箱A接收消息</p></li></ul></li></ul><p>信箱可以分成信箱头和信箱体两部分，信箱头指出信箱容量、信件格式、存放信件位置的指针等；信箱体用来存放信件。信箱体分成若干个可容纳一封信的区。</p><ul><li>send：若指定信箱未满，将信件送入信箱中指针指示的位置，并释放该信箱中信件的等待者，否则，发送信件者被置为等待信箱状态</li><li>receive：如果指定信箱中有信，则取出一封信件，并释放等待信箱的等待者，否则，接收信件者被置成等待信箱中信件的状态</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> box = record<br><span class="hljs-built_in">int</span> size;<span class="hljs-comment">//信箱大小</span><br><span class="hljs-built_in">int</span> count;<span class="hljs-comment">//现有信件数</span><br>message<span class="hljs-literal">[<span class="hljs-identifier">n</span>]</span> letter;<br>semaphore s1, s2;<span class="hljs-comment">//等信箱和等信件信号量</span><br><br>procedure send(box B, message M)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>size) <span class="hljs-constructor">W(B.<span class="hljs-params">s1</span>)</span>;<span class="hljs-comment">//R和W时让进程入队和出队的两个过程</span><br><span class="hljs-built_in">int</span> i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count + <span class="hljs-number">1</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = M;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count = i;<br><span class="hljs-constructor">R(B.<span class="hljs-params">s2</span>)</span>;<br>&#125;<br><br>procedure receive(box B, message M)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) <span class="hljs-constructor">W(B.<span class="hljs-params">s2</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count - <span class="hljs-number">1</span>;<br>x = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count;i++)&#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span> + <span class="hljs-number">1</span>]</span>;<br>&#125;<br>&#125;<br><span class="hljs-constructor">R(B.<span class="hljs-params">s1</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消息传递的若干问题">消息传递的若干问题</h4><ul><li>信箱容量问题</li><li>多进程与信箱相连的信箱接收问题</li><li>信箱的所有权问题<ul><li>信箱为操作系统所有，是指操作系统统一设置信箱，归系统所有，供相互通信的进程共享，例：消息缓冲机制</li></ul></li><li>信件的格式问题和其他有关问题</li><li>通信进程的同步问题</li></ul><h4 id="消息缓冲通信">消息缓冲通信</h4><h5 id="基本思想">基本思想</h5><p>由操作系统统一管理一组用于通信的消息缓冲存储区，每个消息缓冲存储区可以存放一个消息。</p><p>当一个进程需要发送消息：</p><ol type="1"><li>先在自己的消息发送区内生成待发送的消息，包括接收进程名、消息长度、消息正文等。</li><li>向系统申请一个消息缓冲区，把消息从发送区复制到消息缓冲区中。复制过程中，系统会将接收进程名换为发送进程名，以便接收者识别。</li><li>该消息缓冲区被挂在接收消息的进程的消息队列上，供接收者在需要时从消息队列中摘下并复制到消息接收区使用，同时释放消息缓冲区。</li></ol><p>消息缓冲通信涉及的数据结构：</p><ul><li>sender：发送消息的进程名或标识符</li><li>size：发送的消息长度</li><li>text：发送的消息正文</li><li>next-ptr：指向下一个消息缓冲区的指针</li></ul><p>在进程的PCB中涉及通信的数据结构：</p><ul><li>mptr：消息队列首指针</li><li>mutex：消息队列互斥信号量，初始为1</li><li>sm：表示接收进程信号队列上消息的个数，初值为0，是控制收发进程同步的信号量</li></ul><h5 id="发送和接收原语的实现">发送和接收原语的实现</h5><ul><li>发送原语Send：<ul><li>申请一个消息缓冲区，把发送区内容复制到这个缓冲区中</li><li>找到接收进程的PCB，执行P(mutex)</li><li>把缓冲区挂在接收进程消息队列尾部</li><li>执行V(sm)</li><li>执行V(mutex)</li></ul></li><li>接收原语Receive：<ul><li>执行P(sm)查看是否有信件</li><li>执行P(mutex)，取消息</li><li>执行V(mutex)</li><li>把消息缓冲区内容复制到接收区，释放消息缓冲区</li></ul></li></ul><h4 id="管道和套接字">管道和套接字</h4><p>基于信箱的消息传递方式的一种变体，与传统的信箱方式等价，但没有设定消息的边界。</p><ul><li>即，若一个进程发送10条100字节的消息，另一个进程接收1000个字节，接收者将获得10条消息。</li></ul><h3 id="高级进程通信机制">6.5.2 高级进程通信机制</h3><h4 id="基于流的进程通信">基于流的进程通信</h4><ul><li><p>多个进程使用一个共享的消息缓冲区（可称为管道、多路转接器、套接字）。</p></li><li><p>一些进程向消息缓冲区中写入字符流</p></li><li><p>一些进程从消息缓冲区中读出字符流</p></li><li><p>信息以任意长度的字符流交换。</p></li></ul><h4 id="基于rpc的高级通信规约">基于RPC的高级通信规约</h4><p>采用客户/服务器计算模式，服务器进程提供一系列过程/服务，供客户进程调用；客户进程通过调用服务器进程提供的过程/服务获得服务。</p><ul><li>考虑到客户计算机和服务器计算机的硬件异构性，外部数据表示XDR被引入来转换每台计算机的特殊数据格式为标准数据格式。</li></ul><h5 id="rpc执行步骤">RPC执行步骤</h5><ol type="1"><li>客户进程以普通方式调用客户存根</li><li>客户存根组织RPC消息并执行Send，激活内核程序</li><li>内核把消息通过网络发送到远地内核</li><li>远地内核把消息送到服务器存根</li><li>服务器存根取出消息中参数后调用服务器过程</li><li>服务器过程执行完后把结果返回至服务器存根</li><li>服务器存根进程将它打包并激活内核程序</li><li>服务器内核把消息通过网络发送至客户机内核</li><li>客户内核把消息交给客户存根</li><li>客户存根从消息中取出结果并返回给客户进程</li><li>客户进程获得控制权并得到了过程调用的结果</li></ol><figure><img src="/image/计算机操作系统/远程过程调用RPC.png"alt="远程过程调用RPC" /><figcaption aria-hidden="true">远程过程调用RPC</figcaption></figure><h2 id="死锁">6.6 死锁</h2><h3 id="死锁的产生">6.6.1 死锁的产生</h3><h4 id="死锁产生的可能原因">死锁产生的可能原因</h4><ul><li>进程推进顺序不当</li><li>PV操作使用不当</li><li>资源分配不当</li><li>对临时性资源使用不加限制</li></ul><h4 id="死锁的定义">死锁的定义</h4><p>一个进程集合中的每一个进程都在等待只能由该集合中的其他进程才能引发的事件。</p><h4 id="系统形成死锁的四个必要条件">系统形成死锁的四个必要条件</h4><ul><li>互斥条件：系统中存在进程应互斥使用的临界资源</li><li>占有和等待条件：进程请求资源不得到满足而等待时，不释放已占有的资源</li><li>不剥夺条件：已被占有的资源只能被属主释放，不允许被其他进程剥夺</li><li>循环等待条件：存在循环等待链，每个进程都在链中等待下一个进程所持有的资源</li></ul><h3 id="死锁的防止">6.6.2 死锁的防止</h3><ul><li>破坏互斥条件：使资源可同时访问而不是互斥使用</li><li>破坏占有和等待条件：静态分配</li><li>破坏不剥夺条件：剥夺式调度</li><li>上述方法均导致资源利用率和吞吐率低</li></ul><h4 id="层次分配策略">层次分配策略</h4><p>破坏占有和等待条件、循环等待条件。</p><ul><li>资源被分为多个层次</li><li>当进程得到某一层的一个资源后，它只能再申请较高层次的资源</li><li>当进程要释放某层的一个资源时，必须先释放占有的较高层次的资源</li><li>当进程得到某一层的一个资源，并想申请该层的另一个资源，必须先释放该层中的已占资源</li></ul><p>变种：按序分配，资源排序，不得申请序数比占有资源序数小的资源。</p><h3 id="死锁的避免">6.6.3 死锁的避免</h3><h4 id="银行家算法">银行家算法</h4><ul><li>银行家拥有一笔周转资金</li><li>客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能归还贷款</li><li>银行家应谨慎地贷款，防止出现坏账<ul><li>操作系统——银行家</li><li>资源——周转资金</li><li>进程——客户</li></ul></li></ul><p>银行家算法的数据结构：</p><p>一个系统有n个进程和m种不同的资源，定义包含以下向量和矩阵的数据结构：</p><ul><li>系统每类资源总数：该m个元素的向量为系统中每类资源的数量<ul><li><span class="math inline">\(Resource=(R_1,R_2,...,R_m)\)</span></li></ul></li><li>每类资源未分配数量：该m个元素的向量为系统中每类资源尚可供分配数量<ul><li><spanclass="math inline">\(Available=(V_1,V_2,...,V_m)\)</span></li></ul></li><li>最大需求矩阵：每个进程对每类资源最大需求量，<spanclass="math inline">\(C_{ij}\)</span>表示进程<spanclass="math inline">\(P_i\)</span>需<spanclass="math inline">\(R_j\)</span>类资源最大数<ul><li><span class="math inline">\(Claim=\begin{pmatrix}C_{11} &amp; C_{12}&amp; ... &amp; C_{1m} \\ C_{21} &amp; C_{22} &amp; ... &amp; C_{2m} \\... \\ C_{n1} &amp; C_{n2} &amp; ... &amp; C_{nm}\end{pmatrix}\)</span></li></ul></li><li>分配矩阵：进程当前分得资源数，<spanclass="math inline">\(A_{ij}\)</span>表示进程<spanclass="math inline">\(P_{i}\)</span>已分得<spanclass="math inline">\(R_j\)</span>类资源个数<ul><li><span class="math inline">\(Allocation=\begin{pmatrix}A_{11} &amp;A_{12} &amp; ... &amp; A_{1m} \\ A_{21} &amp; A_{22} &amp; ... &amp;A_{2m} \\ ... \\ A_{n1} &amp; A_{n2} &amp; ... &amp; A_{nm}\end{pmatrix}\)</span></li></ul></li></ul><p>确定成立的关系式：</p><ul><li><span class="math inline">\(R_i=V_i+\sum A_{ki}\)</span>，对<spanclass="math inline">\(i=1,...,m,k=i,...,n\)</span><ul><li>表示所有资源要么已被分配，要么尚可分配</li></ul></li><li><span class="math inline">\(C_{ki} \leq R_i\)</span>，对<spanclass="math inline">\(i=1,...,m,k=1,...,n\)</span><ul><li>表示进程申请资源数不能超过系统拥有的资源总数</li></ul></li><li><span class="math inline">\(A_{ki} \leq C_{ki}\)</span>，对<spanclass="math inline">\(i=1,...,m,k=1,...n\)</span><ul><li>表示进程申请任何类资源数不能超过声明的最大资源需求数</li></ul></li></ul><p>一种死锁的避免策略：</p><p>系统中若要启动一个新进程工作，其对资源<spanclass="math inline">\(R_i\)</span>的需求仅当满足以下不等式：</p><p><span class="math inline">\(R_i \geq C_{(n+1)i} + \sumC_{ki}\)</span>，对<spanclass="math inline">\(i=1,...,m,k=1,...n\)</span></p><p>即应满足当前系统中所有进程对资源<spanclass="math inline">\(R_i\)</span>的最大资源需求数加上启动的新进程的最大资源需求数不超过系统拥有的最大数。</p><h5 id="系统安全性">系统安全性</h5><p>系统在时刻<spanclass="math inline">\(T_0\)</span>是安全的，仅当存在一个进程序列<spanclass="math inline">\(P_1,...,P_n\)</span>，对进程<spanclass="math inline">\(P_k\)</span>满足公式：</p><p><span class="math inline">\(C_{ki} - A_{ki} \leq V_i+\sumA_{ji}\)</span>，对i=1,...,m,k=1,...n$</p><h5 id="银行家算法基本思想">银行家算法基本思想</h5><ol type="1"><li>系统中的所有进程进入进程集合。</li><li>在安全状态下系统收到进程的资源请求后，先把资源试探性分配给它。</li><li>系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较，在进程集合中找到剩余资源能满足最大需求量的进程，从而保证这个进程运行完毕并归还全部资源。</li><li>把这个进程从集合中去掉, 系统的剩余资源更多了。反复执行上述步骤。<ul><li>进程退出系统，资源回收</li></ul></li><li>最后，检查进程集合，若为空表明本次申请可行，系统处于安全状态,可实施本次分配；否则，有进程执行不完，系统处于不安全状态，本次资源分配暂不实施，让申请进程等待。</li></ol><h3 id="死锁的检测和解除">6.6.4 死锁的检测和解除</h3><p>系统定时进行死锁的检测，如检测到，则解除它。</p><h4 id="进程-资源分配图">进程-资源分配图</h4><ul><li><p>约定<span class="math inline">\(P_i\rightarrowR_j\)</span>为请求边，表示进程<spanclass="math inline">\(P_i\)</span>申请资源类<spanclass="math inline">\(R_j\)</span>中的一个资源得不到满足而处于等待<spanclass="math inline">\(R_j\)</span>类资源的状态，该有向边从进程开始指到方框的边缘，表示进程<spanclass="math inline">\(P_i\)</span>申请<spanclass="math inline">\(R_j\)</span>中的一个资源。</p></li><li><p>约定<span class="math inline">\(R_j \rightarrowP_i\)</span>为分配边，表示<spanclass="math inline">\(R_j\)</span>类中的一个资源已被进程<spanclass="math inline">\(P_i\)</span>占用。由于已把一个具体的资源分配给了进程<spanclass="math inline">\(P_i\)</span>，故该有向边从方框内的某个黑圆点出发指向进程。</p></li></ul><p>死锁资源分配图示例：</p><figure><img src="/image/计算机操作系统/死锁资源分配图示例.png"alt="死锁资源分配图示例" /><figcaption aria-hidden="true">死锁资源分配图示例</figcaption></figure><ul><li>如果进程-资源分配图中无环路，则此时系统中没有发生死锁</li><li>如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充要条件，环路中的进程便为死锁进程</li><li>如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则，环路是系统发生死锁的必要条件而不是充分条件</li></ul><p>如果能在进程-资源分配图中消去此进程的所有请求边和分配边，成为孤立结点，经一系列简化，使所有进程成为孤立结点，则该图是可完全简化的</p><ul><li>系统为死锁状态的充分条件是，此进程-资源分配图是不可完全简化的</li></ul><h4 id="死锁的安全性测试算法">死锁的安全性测试算法</h4><p>类似于死锁避免算法，不同在于前者考虑了检查每个进程还需要的所有资源能否满足要求，后者则要根据进程的当前申请资源量来判断系统是否进入不安全状态。</p><p>一种检测方法：</p><ol type="1"><li>currentAvailable=available</li><li>若allocation[k,*]!=0，令finish[k]=false，否则finish[k]=true</li><li>寻找一个k，满足条件(finish[k]==false)&amp;&amp;(request[k,*]&lt;=currentavail[*])，找不到则跳到5</li><li>currentAvailable[*]=currentAvailable[*]+allocation[k,*]，finish[k]=true，跳至3</li><li>如果存在k(1≤k≤n)，finish[k]=false，则系统处于死锁状态，并且finish[k]=false的P_k为处于死锁的进程。</li></ol><h4 id="死锁的解除">死锁的解除</h4><ul><li><p>结束所有进程的执行，重新启动操作系统。</p><ul><li>以前工作全部作废，损失很大。</li></ul></li><li><p>撤销陷于死锁的所有进程，解除死锁继续运行。</p></li><li><p>逐个撤销陷于死锁的进程，回收其资源重新分派，直至死锁解除。</p></li><li><p>剥夺陷于死锁的进程占用的资源，但并不撤销它，直至死锁解除。</p><ul><li>可仿照撤销陷于死锁进程的条件来选择剥夺资源的进程</li></ul></li><li><p>根据系统保存的检查点，让所有进程回退，直到足以解除死锁</p><ul><li>要求系统建立保存检查点、 回退及重启机制。</li></ul></li><li><p>当检测到死锁时，可能存在某些未卷入死锁的进程，随着这些进程执行到结束，有可能释放足够的资源来解除死锁。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第五章_文件管理</title>
    <link href="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第五章-文件管理">第五章 文件管理</h1><h2 id="文件系统概述">5.1 文件系统概述</h2><h3 id="文件的概念">5.1.1 文件的概念</h3><p>具有符号名的，在逻辑上具有完整意义的一组相关信息项的序列</p><p>文件名是由字母、数字和其他符号组成的一个字符串，其格式和长度因系统而异</p><h4 id="文件的命名">文件的命名</h4><ul><li>一般包括文件名和扩展名<ul><li>前者用于识别文件，后者用于标识文件特性，两者用小数点隔开</li></ul></li><li>每个操作系统都有约定的扩展名，Windows系统中有：<ul><li>.com表示可执行的二进制代码文件</li><li>.exe表示可执行的浮动二进制代码文件</li><li>.lib表示库程序文件</li><li>.bat表示批命令文件</li><li>.obj表示编译或汇编生成的目标文件</li></ul></li></ul><h4 id="文件的分类">文件的分类</h4><ul><li>按用途：系统文件、库文件、用户文件</li><li>按保护级别：只读文件、读写文件、不保护文件</li><li>按信息时限：临时文件、永久文件、档案文件</li><li>按设备类型：磁盘文件、磁带文件、光盘文件、软盘文件</li><li>还可以按文件的逻辑结构或物理结构分类</li></ul><h4 id="引入文件的优点">引入文件的优点</h4><ul><li>用户使用方便</li><li>文件安全可靠</li><li>文件可备份</li><li>文件可共享</li></ul><h3 id="文件系统及其功能">5.1.2 文件系统及其功能</h3><h4 id="文件系统的概念">文件系统的概念</h4><p>操作系统中负责存取和管理信息的模块，用统一方式管理用户和系统信息的存储、检索、更新、共享和保护，为用户提供一整套方便有效的文件使用和操作方法。</p><ul><li>文件系统中的文件和用户概念中的逻辑结构以及存储器中的存储结构密切相关，因此，同一个文件需要从逻辑文件和物理文件两个侧面观察。</li></ul><h4 id="文件系统的功能">文件系统的功能</h4><p>文件系统面向用户的功能：</p><ul><li>文件的按名存取</li><li>文件的共享和保护</li><li>文件的操作和使用</li></ul><p>为了实现这些功能，操作系统必须考虑：</p><ul><li>文件目录的建立和维护</li><li>存储空间的分配和回收</li><li>数据的保密和保护</li><li>监督用户存取和修改文件的权限</li><li>实现在不同存储介质上信息的表示方式、编址方式、存储次序，以及信息检索等问题</li></ul><h4 id="文件系统的组成">文件系统的组成</h4><pre><code class=" mermaid">graph文件系统---文件的组织---组织方法---逻辑结构:\n流式文件\n记录式文件组织方法---物理结构:\n顺序文件\n连接文件\n直接文件\n索引文件文件系统---文件的存取---存取方法:\n顺序存取\n索引存取\n文件系统---文件的控制---控制系统:\n逻辑控制系统\n物理控制系统文件系统---文件的使用---文件操作:\n打开\n关闭\n读\n写\n控制</code></pre><h2 id="文件的组织">5.2 文件的组织</h2><h3 id="文件的存储">5.2.1 文件的存储</h3><h4 id="卷和块">卷和块</h4><p>文件存储介质有磁带、光盘和磁盘。</p><ul><li>卷是存储介质的物理单位，对应于一盘磁带、一块软盘、一片光盘、一个硬盘分区</li><li>块是存储介质上连续信息所组成的一个区域，也称为物理记录<ul><li>块是主存储器和辅助存储器进行信息交换的物理单位，每次总是交换一块或整数块信息</li><li>决定块的大小要考虑用户使用方式、数据传输效率和存储设备类型等因素</li><li>不同类型的存储介质，块的长短常常不同；对同一类型的存储介质，块的大小一般相同，但也可以不同</li><li>外围设备由于机械动作或识别不同块的要求，两个相邻块之间必须留有间隙，间隙是块之间不记录用户代码信息的区域</li></ul></li></ul><h4 id="顺序存取存储设备的信息安排">顺序存取存储设备的信息安排</h4><p>顺序存储设备是严格依赖信息的物理位置次序进行定位和读写的存储设备。</p><ul><li>磁带是最常用的一种顺序存取存储设备，它具有存储容量大、稳定可靠、卷可装卸和易于保存等优点，广泛用于存档<ul><li>磁带的突出特点是块长的变化范围较大，块可以很小，也可以很大，原则上没有限制</li></ul></li><li>光盘也是一种顺序存取存储设备</li></ul><h4 id="直接存取存储设备的信息安排">直接存取存储设备的信息安排</h4><p>磁盘是一种直接存取存储设备，又称为随机存取存储设备。 -移臂与旋转两维组织，存取速度高 -每个物理地址有确定的位置和唯一的地址，存取任何一个物理块所需的时间几乎不依赖于此信息的位置</p><h3 id="文件的逻辑结构">5.2.2 文件的逻辑结构</h3><p>逻辑文件，又称为文件的逻辑结构。</p><ul><li>独立于物理环境的，用户概念中的抽象信息组织方式</li><li>用户能观察到并加以处理的数据集合</li></ul><p>文件的逻辑结构分为两种：流式文件和记录式文件。</p><h4 id="流式文件">流式文件</h4><p>文件内的数据不再组成记录，只是由一串依次的字节组成的信息流序列。</p><ul><li>这种文件常常按长度来读取所需信息，也可以用插入的特殊字符作为分界。</li></ul><h4 id="记录式文件">记录式文件</h4><p>一种有结构的文件，是若干逻辑记录信息所组成的记录流文件。</p><ul><li>逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位</li></ul><p>记录式文件与数据库</p><ul><li>数据库管理系统也支持逻辑记录</li><li>有别于记录式文件的是，数据库中的记录之间可以通过数据冗余构成某种联系</li><li>数据库管理系统支持基于联系的数据查询，文件系统则不行</li></ul><h4 id="记录的成组与分解">记录的成组与分解</h4><p>一个物理记录只存放一个逻辑记录可能造成极大的浪费。</p><p>若干个逻辑记录合并成一组，写入一个块，称为记录的成组。</p><ul><li>每块中的逻辑记录数称为块因子</li></ul><p>对于流式文件，一个物理记录可以存放很多个连续字节</p><h5 id="成组与分解操作">成组与分解操作</h5><ol type="1"><li>系统设置独立于用户数据区的输入/输出缓冲区</li><li>记录的成组操作在输出缓冲区内进行，凑满一块后才将缓冲区内的信息写到存储介质上</li><li>当存储介质上的一个物理记录读进输入缓冲区后，把逻辑记录从块中分离出来的操作称为记录的分解操作</li></ol><p>成组与分解的特征：</p><ul><li>优点：记录成组与分解节省存储空间，减少输入/输出操作次数，提高系统效率</li><li>提前读与推迟写<ul><li>提前读：用户读请求，导致包含该逻辑记录的物理块读如输入缓冲区，这一操作可能读入了多个逻辑记录</li><li>推迟写：用户写请求，首先是写入输出缓冲区，只有当该缓冲区中的逻辑记录满后才会引起实际输出</li></ul></li></ul><h3 id="文件的物理结构">5.2.3 文件的物理结构</h3><p>文件的物理结构和组织是指文件在物理存储空间中的存放方法和组织关系，又称为物理文件。</p><ul><li>文件的存储结构涉及块的划分、记录的排列、索引的组织、信息的搜索等问题</li><li>直接影响文件系统性能</li></ul><h4 id="顺序文件">顺序文件</h4><p>将一个文件中逻辑上连续的信息存放到存储介质的依次相邻的块中形成顺序结构，这类文件称为顺序文件，也称连续文件。</p><ul><li><p>例：磁带文件、光盘文件</p></li><li><p>优点：顺序存取记录时速度较快</p><ul><li>常用于批处理文件和系统文件</li><li>采用磁带存放顺序文件，总可以保持快速存取存储的优点</li></ul></li><li><p>缺点：建立文件前需要能预先确定文件长度以便分配存储空间；修改、插入和增加文件记录有困难</p></li></ul><h4 id="连接文件">连接文件</h4><p>连接文件又称串联文件，使用连接字来表示文件中各个物理块之间的先后次序。</p><ul><li><p>第一块文件信息的物理地址由文件目录给出，每一块的连接字指出了文件的下一个物理块位置，连接字内容为0时，表示文件至本块结束。</p></li><li><p>输入井、输出井都是连接文件</p></li><li><p>优点：易于对文件记录做增、删、改，易于动态增长记录；不必预先确知文件长度；存储空间利用率高</p></li><li><p>缺点：存放指针需要额外的存储空间，由于存取需通过缓冲区，待获得连接字后，才能找到下一物理块的地址，因而仅适用于顺序存取</p></li></ul><h4 id="直接文件">直接文件</h4><p>直接文件又称散列文件，通过计算记录的关键字建立与其物理存储地址之间的对应关系，这种变换通常采用散列。</p><ul><li>计算寻址结构可能出现冲突，解决办法有拉链法、循环探查法、二次散列法、溢出区法等</li></ul><h4 id="索引文件">索引文件</h4><p>索引文件为每个文件建立了一张索引表，其中每个表目包含一个记录的键（逻辑记录号）及其存储地址。</p><ul><li>索引表的地址可由文件目录指出，查阅索引表先找到相应记录键，然后获得数据存储地址</li></ul><p>访问方式：</p><ul><li>索引文件在文件存储器上分为索引区和数据区</li><li>访问索引文件的两步操作：查找索引表，获得记录的物理地址</li><li>需要两次访问辅助存储器，若文件索引表已预先掉入主存储器，可减少一次内外存信息交换</li></ul><p>索引结构时连接结构的一种扩展，克服了连接文件只能作顺序存取的缺点，但增加了索引表的空间开销和查找时间。</p><p>索引表的组织：一级索引、二级索引、多级索引</p><h2 id="文件目录">5.3 文件目录</h2><h3 id="文件目录结构">5.3.1 文件目录结构</h3><p>文件目录是实现文件的按名存取的关键数据结构。</p><ul><li>文件系统的基本功能之一就是负责文件目录的建立、维护和检索，要求编排的目录便于查找、防止冲突</li><li>文件目录需要永久保存，因此也组织成文件存放在磁盘上</li></ul><h4 id="一级目录结构">一级目录结构</h4><p>在操作系统中构造一张线性表，与每个文件的相关属性占一个目录项，构成一级目录结构</p><ul><li>由于用户与文件众多，容易重名，不利于记忆</li></ul><h4 id="二级目录结构">二级目录结构</h4><ul><li>第一级为主文件目录，用于管理所有用户文件目录，目录项登记系统接受的用户名和该用户文件目录的地址</li><li>第二级为用户文件目录，为该用户的每个文件保存一个登记栏，内容与一级目录的目录项相同</li><li>每个用户只允许查看自己的文件目录</li></ul><p>二级目录结构的特点：</p><ul><li>可以检查访问文件者的存取权限，实现对文件的保密和保护</li><li>对同一个用户而言，依然存在文件多、易重名的问题</li></ul><h4 id="树形目录结构">树形目录结构</h4><p>每一级目录可以登记下一级目录，也可以登记文件，形成层次文件目录结构，一般采用树形目录结构，根是根目录，非叶节点为子目录，叶节点为文件</p><ul><li>较好地反映现实世界中具有层次关系的数据集合，较准确地反映系统内部文件的组织结构</li><li>不位于同一末端子目录的不同文件可以重名</li><li>易于规定不同层次货子树中文件的不同存取权限，便于文件的保护、保密和共享</li></ul><p>树形目录结构的文件定位</p><ul><li>一个文件的全名包括从根目录到文件为止的所有子目录路径</li><li>各子目录名间用文件分隔符分开</li><li>一个硬盘分区组织成一棵子树<ul><li>每棵子树对应一个逻辑盘符（Windows）</li><li>众多子树嫁接成一棵大树（UNIX）</li></ul></li></ul><h3 id="文件目录的管理">5.3.2 文件目录的管理</h3><h4 id="文件查找">文件查找</h4><p>系统跟去用户提供的文件路径（绝对/相对）搜索各级文件目录，找到文件。</p><ul><li>现代操作系统都有改变工作目录的命令。</li></ul><h4 id="目录项查找">目录项查找</h4><p>搜索具体目录项时，可以采用顺序查找法或二分查找、杂凑法等方式查找。</p><ul><li>目录项按一定顺序编排时可用二分查找</li><li>杂凑法，把每个文件名经过变换函数变换成唯一的目录表表项。</li></ul><h4 id="活动文件表">活动文件表</h4><ul><li><p>树形目录结构存在的问题：一个文件经过许多目录节点时，使用不方便，系统在沿路径查找目录时，要多次访问文件存储器，使访问速度大大减慢。</p></li><li><p>若将所有文件的目录都复制到主存，访问速度加快但主存开销大。</p></li><li><p>一种办法是，把常用的和正在使用的文件目录复制进主存</p></li></ul><p>系统为每个用户进程建立一张活动文件表，用户使用一个文件前，先通过打开操作，把该文件有关目录信息复制到指定主存区域，有关信息填入活动文件表，以建立用户进程和该文件索引的联系。</p><p>不再使用该文件时，使用关闭操作，切断用户进程和这个文件的联系，同时若该目录已被修改过，更新辅存中对应的文件目录。</p><h2 id="文件的共享保护和保密">5.4 文件的共享、保护和保密</h2><p>文件是计算机系统的重要资源，文件系统需要具有保障文件安全的手段，提供文件保密的措施，有效实现文件共享。</p><ul><li>文件共享是指不同用户共同使用某些文件</li><li>文件保护是指防止文件被破坏</li><li>文件保密是指防止文件及其内容被其他用户窃取</li></ul><h3 id="文件的共享">5.4.1 文件的共享</h3><p>文件共享是计算机用户完成共同任务所必需的。</p><ul><li>好处：减少用户大量重复性劳动；免除系统复制文件的工作；节省文件占用的存储空间；减少程序设计输入/输出文件的次数</li></ul><p>文件共享的并发控制：</p><ul><li>在允许文件共享的系统中，操作系统应提供手段实现对共享文件的同步控制</li><li>多个进程可能同时存取一个文件如果它们同时进行读操作，操作系统应对文件进行公用控制</li><li>如果有进程进行写操作，操作系统须提供同步控制机制以保证文件数据完整性</li></ul><p>文件的保密：</p><ul><li>文件保密是指文件及其内容不能被未经文件主授权的其他用户窃取</li><li>保密措施：<ul><li>隐蔽文件目录</li><li>设置口令</li><li>使用密码</li></ul></li></ul><h3 id="文件的保护">5.4.2 文件的保护</h3><p>文件保护是指防止文件被破坏。操作系统须提供文件保护机制，实现文件完整性。</p><p>常见的文件保护方法：文件副本；文件存取矩阵；文件属性</p><h4 id="文件副本">文件副本</h4><p>文件系统必须要有防止硬软件故障，保存信息完整性的能力，文件副本是主要实现机制。</p><ul><li>动态多副本技术</li><li>转储、备份和恢复</li></ul><h5 id="动态多副本">动态多副本</h5><p>在多个介质上维持同一内容的文件，在更新内容时同时进行。</p><p>增加了设备费用和系统负载，一般适用于容量较小且较为重要的文件，当文件发生故障时只需切换到备用设备即可。</p><p>一般适用于不需更新的系统文件及专用文件，</p><h5 id="文件转储">文件转储</h5><p>定时将文件复制转储到其他介质上，当某介质上出现故障时，复原转储文件。</p><p>转储的两种方式：</p><ul><li>一，一定时间间隔或一个单位处理结束时，系统自动复写更新过的文件和数据</li><li>二，每天或每周把文件信息全部复写，需要时再通过装入转储文件来恢复系统</li></ul><h4 id="文件的存取控制矩阵">文件的存取控制矩阵</h4><p>系统为每个用户设置访问每个文件对象的存取属性，则全部用户对全部文件的存取属性就组成一个二维矩阵，称为存取控制矩阵。</p><ul><li>由于操作系统具有很多用户和众多文件，存取控制矩阵是一个稀疏矩阵，可以将其简化为一张存取控制表<ul><li>每行包括：用户、文件、存取属性</li><li>仅登记那些对文件拥有存取属性的部分</li></ul></li></ul><p>基于存取控制矩阵/表的文件保护：</p><ul><li>存取属性：可以有访问、读、写、执行、创建、删除、授权等</li><li>系统通过查阅矩阵/表核对用户对文件的存取权限</li><li>文件主通过命令进行授权甚至授权权的转授</li><li>系统管理用户等同于文件主权限，获得对系统文件的授访问权权限</li></ul><h4 id="文件属性">文件属性</h4><p>存取控制表的一种简化方法是用户分类，再针对每类用户规定文件属性。</p><ul><li>用户分类：属主、合作者、其他</li><li>文件属性：读、写、执行</li><li>文件属性可以放在文件目录项中，管理大为简化</li><li>用户使用文件时，通过核对文件属性，实现保护</li></ul><h2 id="文件的使用">5.5 文件的使用</h2><h3 id="文件存取方法">5.5.1 文件存取方法</h3><p>文件存取方法是操作系统为用户程序提供的使用文件的技术和手段，在某种程度上依赖于文件的物理结构。</p><h4 id="顺序存取">顺序存取</h4><p>按记录顺序进行读写操作的存取方法。</p><ul><li>读操作根据读指针读出当前记录，同时推进读指针，指向下一次要读出的记录</li><li>写操作则设置写指针，把一个记录写到文件末端，同时推进写指针</li><li>允许对读指针进行前进或后退整数个记录的操作</li></ul><h4 id="直接存取">直接存取</h4><p>快速地以任意次序直接读写某个记录。</p><h4 id="索引存取">索引存取</h4><p>基于索引文件的索引存取方法。</p><ul><li>信息块的地址可以通过查找记录键换算出</li><li>也可以采用顺序存取或直接存取的方法</li><li>实际都采用多级索引加速记录查找</li></ul><h3 id="文件的使用-1">5.5.2 文件的使用</h3><p>用户通过两类接口与文件系统联系。</p><ul><li>一类是与文件有关的操作命令</li><li>另一类是提供给用户程序的文件类系统调用，如下</li></ul><h4 id="建立文件">建立文件</h4><p>参数：文件名、设备类、文件属性及存取控制信息</p><p>流程：在相应设备上建立一个文件目录项，分配第一个物理块，在活动文件表中申请一个项，登记有关目录信息，返回一个文件句柄。</p><h4 id="撤销文件">撤销文件</h4><p>参数：文件名、设备类</p><p>流程：若文件未关闭，先关闭文件；若为共享文件，进行联访处理；在目录文件中删除对应目录项，释放文件占用的文件存储空间</p><h4 id="打开文件">打开文件</h4><p>参数：文件名、设备类、打开方式</p><p>流程：在主存活动文件表中申请一个项，返回一个文件句柄；跟踪文件名查找目录文件，把目录信息复制到活动文件表相应栏，按存取控制说明检查访问的合法性；对共享文件进行相应的额外处理</p><h4 id="关闭文件">关闭文件</h4><p>参数：文件句柄</p><p>流程：将活动文件表中该文件的当前使用用户数减一，若此值为0，则收回此活动文件表，完成推迟写；若活动文件表目内容已被改过，则应先将表目内容写回文件存储器上相应表目中，使文件目录保存最新状态。</p><h4 id="读写文件">读写文件</h4><p>参数：文件句柄、用户数据区地址、读写的记录或字节数</p><p>按文件句柄从活动文件表中找到该目录的目录项信息；根据目录项指出的该文件逻辑和物理组织方式，把相关逻辑记录转换成物理块</p><h4 id="定位文件">定位文件</h4><p>调整所打开文件的读写指针位置</p><p>参数：文件句柄，定位指针</p><h2 id="文件系统的实现">5.6 文件系统的实现</h2><h3 id="辅存空间管理">1. 辅存空间管理</h3><h4 id="辅存空间的分配方式">辅存空间的分配方式</h4><ul><li>连续分配：存放在辅存空间连续存储区中（连续的存储块号）<ul><li>优点是顺序访问速度快，管理简单</li><li>为了获得足够大的连续存储区，需要定时进行碎片整理</li></ul></li><li>非连续分配：动态分配给若干扇区或簇，不要求连续<ul><li>辅存空间管理效率高，便于文件动态增长和收缩</li></ul></li></ul><h4 id="空闲块的管理">空闲块的管理</h4><h5 id="位示图">位示图</h5><p>使用若干字节构成一张表，表中每一字位对应一个物理块，字位的顺序和块的相对次序一致，字位为1表示相应块已占用，字位为0表示该块空闲。</p><p>优点：可以把位示图全部或大部分保存在主存中，配合位操作指令实现高速物理块分配与去配。</p><h5 id="空闲块成组连接法">空闲块成组连接法</h5><h3 id="文件系统的实现层次">2. 文件系统的实现层次</h3><ul><li>用户接口：接受用户发来的系统调用，进行语法检查，进入逻辑文件控制子系统</li><li>逻辑文件控制子系统：根据文件路径名，搜索文件目录，建立活动文件表，根据文件结构和存取方法，把逻辑记录转换成相对物理块号和块内相对地址</li><li>文件保护子系统：识别调用者身份，验证存取权限，判定本次文件操作的合法性</li><li>物理文件控制子系统：实现缓冲区管理，根据物理结构，将对应相对物理块号转换为实际物理块号，负责文件存储空间的分配，生存输入/输出控制系统调用形式</li><li>输入/输出控制子系统：执行具体的物理块输入/输出操作</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第四章_设备管理</title>
    <link href="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第四章-设备管理">第四章 设备管理</h1><h2 id="设备管理基础">4.1 设备管理基础</h2><h3 id="设备管理概述">4.1.1 设备管理概述</h3><h4 id="输入输出设备及其分类">1. 输入/输出设备及其分类</h4><ul><li><p>输入/输出设备，又称外围设备、外设，用于计算机系统与外部世界的信息交换或存储。</p></li><li><p>输入/输出操作：内存和外设间的信息传送操作</p><ul><li>影响计算机系统的通用性和可扩展性</li><li>影响计算机系统综合处理能力及性价比</li></ul></li></ul><p>输入/输出设备分类：</p><ul><li>信息传输视角：分为输入设备、输出设备和输入输出设备</li><li>交互功能视角：分为人机交互设备、存储设备和机机通信设备</li><li>设备管理视角：分为字符设备、块设备和网络设备</li></ul><h4 id="设备管理的目标">2. 设备管理的目标</h4><p>解决设备和CPU速度的不匹配，使主机和设备充分并行工作，提高设备使用效率。</p><p>屏蔽设备的物理细节和操作过程，配置驱动程序，提供同一界面。</p><ul><li>抽象为裸设备</li><li>抽象为设备文件</li></ul><h4 id="设备管理的功能">3. 设备管理的功能</h4><ul><li>设备中断管理</li><li>缓冲区管理</li><li>设备的分配与去配</li><li>设备驱动调度</li><li>虚拟设备的实现</li></ul><h4 id="设备管理的实现层次">4. 设备管理的实现层次</h4><ul><li>输入/输出硬件<ul><li>输入/输出设备及其接口线路</li><li>控制部件</li><li>通道</li></ul></li><li>输入/输出软件<ul><li>系统输入/输出软件</li><li>用户空间输入/输出软件</li></ul></li></ul><h3 id="输入输出控制方式">4.1.2 输入/输出控制方式</h3><h4 id="设备控制器">1. 设备控制器</h4><p>为达到模块化和通用性的设计目标，通常分开设置设备的机械部件和电子部件。</p><p>电子部件成为设备控制器，又称为设备适配器、输入/输出控制器(模块/接口等)。</p><p>系统与控制器交互，而非与设备交互，设备控制器具体控制设备进行输入/输出。</p><h5 id="设备控制器的功能">设备控制器的功能</h5><p>设备控制器是CPU与设备之间的接口。</p><ul><li>接受和识别CPU或通道发来的命令</li><li>实现数据交换</li><li>发现和记录设备及其自身的状态信息，供CPU处理时使用</li><li>当连接多台设备时，识别设备地址</li></ul><h4 id="三种基本输入输出控制方式">2. 三种基本输入/输出控制方式</h4><h5 id="轮询方式">轮询方式</h5><ul><li>处理器向控制器发送输入/输出命令，轮询输入/输出结果</li><li>若设备未就绪，则重复测试过程，直至设备就绪</li><li>执行内存数据交换</li><li>等待输入/输出操作完成后，处理器才可以继续其他操作</li></ul><h5 id="中断方式">中断方式</h5><ul><li>处理器向控制器发出具体输入/输出命令，然后继续执行后续指令<ul><li>若进程支持异步输入/输出，后续指令仍然可以是该进程中指令</li><li>否则该进程在这个中断上挂起，处理器执行其他工作</li></ul></li><li>控制器检查设备状态，就绪后发出中断</li><li>CPU响应中断，进行中断处理，执行内存数据交换</li></ul><h5 id="dmadirect-memory-access直接存储器访问方式">DMA（Direct MemoryAccess，直接存储器访问）方式</h5><p>DMA模块：替代处理器来控制主存和设备控制器间的数据交换</p><ul><li>处理器向DMA模块发出输入/输出命令</li><li>处理器继续执行其他工作，DMA模块负责传送全部数据</li><li>数据传送结束后，DMA中断处理器</li></ul><h5 id="dma方式中的周期窃取">DMA方式中的周期窃取</h5><p>DMA和CPU同时通过总线访问内存，CPU会把总线的占有权让给DMA一个或几个主存周期。</p><p>周期窃取对CPU与主存的数据交换影响不大</p><ul><li>数据传送过程是不连续、不规则的</li><li>CPU大部分情况下与Cache进行数据交换，直接访问内存较少</li></ul><p>总结：</p><ul><li>轮询：CPU等待设备就绪，参与内存数据交换</li><li>中断：CPU不等待设备就绪，响应中断后参与内存数据交换</li><li>DMA：CPU不等待设备就绪，不参与主存数据交换</li></ul><h4 id="输入输出通道及其工作方式">3. 输入/输出通道及其工作方式</h4><h5 id="输入输出通道">输入/输出通道</h5><p>又称为通道控制器、输入/输出处理器，用于完成逻辑上独立的输入/输出任务。</p><p>采用四级连接：处理器、通道、控制器、设备</p><ul><li>通道可控制多台同类或不同类设备</li></ul><p>处理器不再执行输入/输出指令，而是在主存中组织通道程序，由输入/输出通道执行。</p><h5 id="输入输出通道的工作流程">输入/输出通道的工作流程</h5><ol type="1"><li>CPU遇到输入/输出任务，组织通道程序，置通道程序地址字CAW，启动指定通道</li><li>通道从CAW获得通道程序，控制输入/输出设备进行操作，CPU执行其他任务</li><li>输入/输出操作完成后，输入/输出通道发出中断，CPU处理中断，并从通道程序状态字CSW获得通道执行情况，处理输入/输出操作</li></ol><ul><li>CPU与通道高度并行工作</li></ul><h3 id="总线与输入输出">4.1.3 总线与输入/输出</h3><h4 id="总线对输入输出的影响">1. 总线对输入/输出的影响</h4><ul><li>输入/输出和CPU速度不匹配、各设备输入/输出速度不匹配</li><li>总线使主机和设备充分并行，提高系统效率</li></ul><h4 id="几种经典总线模型">2. 几种经典总线模型</h4><h5 id="单总线结构模型">单总线结构模型</h5><p>将CPU、主存和输入/输出模块连接到同一总线</p><ul><li><p>优点：结构简单、易于扩充</p></li><li><p>缺点：设备多时总线压力大，传输时间延长，慢速外设占用带宽多</p></li></ul><h5 id="三级总线模型">三级总线模型</h5><p>主存和Cache通过主存总线连接，主存总线和扩展总线上的输入/输出设备通过扩展总线接口缓冲</p><ul><li>优点：主存和输入/输出之间的数据传送、处理器的内存活动分离，可以支持更多输入/输出设备</li><li>缺点：不适用于输入/输出设备数据速率相差太大的情形</li></ul><h5id="南桥输入输出控制器与北桥主存控制器">南桥（输入/输出控制器）与北桥（主存控制器）</h5><p>通过存储总线、PCI总线、E(ISA)总线分别连接主存、高速输入/输出设备和低速输入/输出设备。</p><p>优点：可以支持不同数据速率的输入输出设备。</p><pre><code class=" mermaid">graph LRCPU--处理器总线---北桥--存储总线---Cache北桥--桥间接口---南桥南桥---PCI总线---E总线</code></pre><h5 id="一种基于通道的服务器总线模型">一种基于通道的服务器总线模型</h5><p>支持CPU、主存和多个输入/输出通道之间的数据传送</p><p>支持输入/输出通道和输入/输出控制器，以及输入/输出控制器和设备之间的数据传送。</p><ul><li>CPU通过主存控制器连接主存</li><li>CPU、主存和主存控制器均连接在一条与各个输入/输出通道连接的总线上</li><li>各个输入/输出通道分别与负责的输入/输出控制器连接</li><li>各个输入/输出控制器分别与负责的设备连接</li></ul><h2 id="设备管理软件">4.2 设备管理软件</h2><h3 id="输入输出软件的实现层次">4.2.1 输入/输出软件的实现层次</h3><h4 id="输入输出软件的设计">1. 输入/输出软件的设计</h4><p>设计目标：</p><ul><li>高效率：改善设备效率，尤其是磁盘输入/输出操作的效率</li><li>通用性：用统一标准来管理所有设备</li></ul><p>设计思路：</p><ul><li>把软件组织成层次结构，底层软件用来屏蔽硬件细节，高层软件向用户提供简洁、友善、统一的界面</li></ul><p>设计需要考虑的问题：</p><ul><li>设备无关性：访问设备的程序与具体设备无关</li><li>出错处理：低层软件能处理的错误不让高层软件感知</li><li>同步/异步传输：支持阻塞和中断驱动两种工作方式</li><li>缓冲技术：建立内存数据缓冲区，提高吞吐量</li></ul><h4 id="输入输出软件的实现层次-1">2. 输入/输出软件的实现层次</h4><p>从低到高有：</p><ol type="1"><li>输入/输出硬件：执行输入/输出操作</li><li>输入/输出中断处理程序：处理输入/输出中断，报告输入/输出错误，唤醒输入/输出设备驱动程序</li><li>输入/输出设备驱动程序：设备寄存器初始化，启动输入/输出操作，检查输入/输出状态</li><li>独立于设备的输入/输出软件：设备的命名、保护、阻塞、缓冲、分配、跟踪</li><li>用户空间的输入/输出软件：输入/输出系统调研、输入/输出格式化、SPOOLing</li></ol><h3 id="输入输出软件的实现">4.2.2 输入/输出软件的实现</h3><h4 id="输入输出中断处理程序">1. 输入/输出中断处理程序</h4><p>输入/输出中断处理程序位于操作系统底层，与硬件设备密切相关，与系统其余部分尽可能少地发生联系。</p><ul><li>进程请求输入/输出操作时，通常被阻塞</li><li>数据传输结束后产生输入/输出中断</li><li>CPU响应请求并转入中断处理程序</li></ul><h5 id="输入输出中断处理程序的功能">输入/输出中断处理程序的功能</h5><p>检查设备状态寄存器，判断中断原因，根据输入/输出操作完成情况进行相应处理</p><ul><li>如果数据传输有误，向上层软件报告设备出错信息，实施重新执行</li><li>如果正常结束，唤醒等待传输的进程，使其转换为就绪态</li><li>如果有等待传输的输入/输出命令，通知相应软件开启下一个输入/输出请求</li></ul><h4 id="设备驱动程序">2. 设备驱动程序</h4><ul><li>包括与设备密切相关的所有代码</li><li>从独立于设备的软件中接受输入/输出请求</li><li>把用户提交的逻辑输入/输出请求转化为物理输入/输出操作的启动和执行</li><li>监督设备是否正确执行，访问数据缓冲区，进行必要的纠错处理</li></ul><h5 id="设备驱动程序的功能">设备驱动程序的功能</h5><ul><li>设备初始化：在设备传输数据时，预置设备、控制器以及通道状态</li><li>执行设备驱动例程：负责启动设备，进行数据传输；对于通道，负责组织通道程序，启动通道工作</li><li>执行与设备相关的具体中断处理，负责处理设备、控制器及通道所发出的各种具体中断</li></ul><h5 id="设备驱动程序的层次">设备驱动程序的层次</h5><p>每个设备驱动程序原则上只处理一种设备，或者一类紧密相关的设备。</p><p>设备驱动程序的分层实现：</p><ul><li>高层/处理类设备，底层/处理具体设备</li><li>系统建立栈，接到输入/输出请求时先调用栈顶的驱动程序，然后继续向下调用底层驱动程序，直至所有物理操作被处理</li><li>这一方式使设备驱动的实现结构清晰，易于移植，但会增加一部分系统开销</li></ul><h4 id="独立于设备的输入输出软件">3. 独立于设备的输入/输出软件</h4><p>执行适用于所有设备的常用输入/输出功能，并向用户层软件提供一致性接口，包括：</p><ul><li>设备命名：通过路径名寻址设备</li><li>设备保护：用户是否有权访问设备</li><li>提供与设备无关的数据单位：字符、块</li><li>缓冲技术：调整CPU与输入/输出速度不匹配</li><li>分配和状态跟踪：分配设备</li><li>错误处理与报告：驱动无法处理的错误</li></ul><h4 id="用户空间的输入输出软件">4. 用户空间的输入/输出软件</h4><ul><li>库函数：操作系统内核外，使用库函数实现的输入/输出软件，运行时与应用程序链接</li><li>虚拟设备：用一类设备模拟另一类设备的仿真输入/输出软件</li></ul><h3 id="输入输出缓冲">4.2.3 输入/输出缓冲</h3><h4 id="输入输出缓冲-1">1. 输入/输出缓冲</h4><h5 id="设置输入输出缓冲的目的">设置输入/输出缓冲的目的</h5><ul><li>解决CPU与设备之间速度不匹配的矛盾</li><li>协调逻辑记录大小和物理记录大小不一致的问题</li><li>提高CPU和设备的并行性</li><li>减少输入/输出操作对CPU的中断次数</li><li>放宽对CPU中断响应时间的要求</li></ul><h5 id="输入输出缓冲区">输入/输出缓冲区</h5><p>在内存中开辟的存储区，专门用于临时存放输入/输出操作的数据</p><p>操作过程：</p><ul><li>写操作：将数据送至缓冲区，直到写满或需要写出，待适当时候系统将缓冲区内容写到设备上</li><li>读操作：系统将设备上的物理记录读至缓冲区，根据要求将当前所需要的数据从缓冲区中读出并传送给进程</li></ul><h4 id="几种缓冲技术">2. 几种缓冲技术</h4><h5 id="单缓冲技术">单缓冲技术</h5><p>操作系统在主存系统区中开设一个缓冲区。</p><ul><li>输入：先把数据读至缓冲区，再把缓冲区数据送至用户区，应用程序处理数据，如此往复，系统继续读入后续数据</li><li>输出，把数据从用户区传送至缓冲区，再将数据输出至设备，应用程序继续请求输出</li></ul><h5 id="双缓冲技术">双缓冲技术</h5><p>操作系统在主存系统区开设两个缓冲区。</p><ul><li>输入：先把数据输入缓冲区1，再从缓冲区1把数据传到用户区，供应用程序处理（同时设备可将数据传送到缓冲区2）</li><li>输出：先将数据从用户区传送到缓冲区1，再将数据传送到设备（同时应用程序可将数据传送到缓冲区2）</li></ul><h5 id="循环缓冲技术">循环缓冲技术</h5><p>操作系统分配一组缓冲区，每个缓冲区有指向下一个缓冲区的链接指针，构成循环</p><ul><li>调节设备和进程速度不匹配的问题</li></ul><h2 id="独占型外围设备的分配">4.3 独占型外围设备的分配</h2><h3 id="设备独立性">4.3.1 设备独立性</h3><ul><li><p>用户通常不指定物理设备，而是指定逻辑设备，使得用户进程和物理设备分离，再通过其他途径建立逻辑设备和物理设备间的映射。</p></li><li><p>设备管理中需要将逻辑设备名转换为物理设备名，为此系统需要提供逻辑设备名和物理设备名的对应表以供转换使用</p></li></ul><h4 id="设备独立性的优点">设备独立性的优点</h4><ul><li>应用程序与具体物理设备无关，系统增减或变更设备时不需要修改原程序</li><li>易于应对各种输入/输出设备故障，提高系统的可靠性</li><li>增加设备分配的灵活性，有利于更加有效地利用设备资源，实现多道程序设计</li></ul><h3 id="独占型外围设备的分配-1">4.3.2 独占型外围设备的分配</h3><h4 id="设备分配方式">设备分配方式</h4><p>独占型外围设备：一次只能由一个进程独占使用</p><p>分配方式：</p><ul><li>静态分配：进程运行前申请<ul><li>实现简单，能防止系统发生死锁，但会降低设备利用率</li></ul></li><li>动态分配：进程随用随申请<ul><li>提高设备利用率</li></ul></li></ul><h4 id="设备分配的数据结构">设备分配的数据结构</h4><p>设备类表</p><ul><li>每类设备对应于设备类表中的一栏</li><li>包括设备类、总台数、空闲台数、设备表起始地址等</li><li>支持设备独立性</li></ul><p>设备表</p><ul><li>每类设备有各自的设备表，用来登记这类设备的每台物理设备</li><li>包括：物理设备名，逻辑设备名，占有设备的进程，分配标志，好/坏标志等</li></ul><h2 id="共享型外围设备的驱动">4.4 共享型外围设备的驱动</h2><h3 id="磁盘的物理结构">4.4.1 磁盘的物理结构</h3><h4 id="磁盘结构">1. 磁盘结构</h4><ul><li>磁盘一般由多个盘片组成</li><li>每个盘片一般由两个盘面</li><li>盘面包括多个同心圆结构的磁道，不同盘面上位于相同位置的磁道构成柱面</li><li>每个磁道分为固定多个扇区，相邻扇区组合成簇</li><li>物理块的地址：<ul><li>柱面号，磁道号，扇区号</li><li>0面0道1扇区（此处面指磁头而不是柱面）</li></ul></li></ul><h4 id="磁盘读写数据的方式">2. 磁盘读写数据的方式</h4><p>读写数据时，磁头必须定位到指定磁道上的指定扇区的开始处，过程为：</p><ol type="1"><li>寻道：控制移动臂到达指定柱面</li><li>旋转：等待要读写的扇区旋转到磁头下</li><li>选择磁头号，进行数据传送</li></ol><h4 id="磁盘存取时间">3. 磁盘存取时间</h4><p>磁盘完成数据读写所需要的时间，是寻道时间、旋转延迟、传送时间的总和。</p><p><spanclass="math inline">\(T_a=T_s+\frac{1}{2r}+\frac{b}{rN}\)</span></p><p>其中，<span class="math inline">\(T_a\)</span>为存取时间，<spanclass="math inline">\(T_s\)</span>为寻道时间，<spanclass="math inline">\(r\)</span>为磁盘旋转速度（转/秒），<spanclass="math inline">\(b\)</span>为要传送的字节数，<spanclass="math inline">\(N\)</span>为一个磁道中的字节数。</p><h3 id="磁盘的驱动调度">4.4.2 磁盘的驱动调度</h3><p>磁盘可能同时接收到若干输入/输出请求，如果随机响应，性能会很差。</p><p>驱动调度：操作系统的磁盘调度策略，按照最佳次序执行处理访问磁盘的多个输入/输出请求，以减少磁盘访问的总处理时间。</p><p>驱动调度策略有移臂调度和旋转调度。</p><h4 id="移臂调度及其算法">移臂调度及其算法</h4><ul><li><p>目的：使移动臂的移动时间最短以减少寻道总时间</p></li><li><p>算法：</p><ul><li>先来先服务：移臂距离大，性能差</li><li>最短查找时间优先<ul><li>先执行查找时间最短的请求，寻道性能较好</li><li>存在“饥饿”现象</li></ul></li><li>单向扫描：移动臂向一个方向扫描，归途不提供服务</li><li>双向扫描：移动臂向一个方向移动，到达最后一个柱面再向反方向移动</li><li>电梯调度：改进双向扫描，当前移动方向没有访问请求时就改变方向</li></ul></li></ul><h4 id="旋转调度及其策略">旋转调度及其策略</h4><p>目的：使旋转延迟的总时间最少</p><p>循环排序：</p><ul><li><p>通过优化输入/输出请求排序，在最少旋转圈数内完成位于同一柱面的访问请求</p></li><li><p>旋转位置测定硬件和多磁头同时读写技术有利于提高旋转调度的效率</p></li></ul><p>优化分布：</p><ul><li>通过信息在存储空间的排列方式来减少旋转延迟</li><li>交替排序：由于磁盘匀速旋转，可能处理当前扇区数据时，下个扇区已经跳过。因此，可对扇区间隔编号，交叉因子为n:1表示相邻编号间间隔n-1个扇区</li><li>相邻扇区集中成簇读写</li><li>按柱面集中存储数据，可以减少数据读写时的移臂操作</li></ul><h2 id="虚拟设备">4.5 虚拟设备</h2><h3 id="spooling系统">4.5.1 SPOOLing系统</h3><h4 id="虚拟设备-1">1. 虚拟设备</h4><p>使用一类物理设备模拟另一类物理设备的技术。</p><p>示例：</p><ul><li>内存模拟磁盘</li><li>块设备模拟字符设备</li><li>输入输出重定向</li></ul><h4 id="spooling系统-1">2. SPOOLing系统</h4><p>SPOOLing（Simultaneous Peripheral OperationsOn-Line，外部设备联机并行操作），是关于慢速字符设备如何与计算机主机交换信息的一种技术，通常称为“假脱机技术”。</p><p>一个经典的SPOOLing系统：</p><ul><li>用高速的磁盘设备来模拟慢速的字符设备，缩短进程在内存中的驻留时间</li><li>慢速输出设备先输出到输出井</li><li>进程运行过程中只从输入井读入数据，只向输出井输出数据，使得全部输入/输出都基于磁盘</li><li>加快进程周转时间，提高系统吞吐量</li></ul><p>该系统的软件组成：</p><ul><li>预输入系统：预先把数据从输入设备传送到磁盘输入井</li><li>缓输出设备：把数据从磁盘输出并传送到输出设备</li><li>井管理程序：控制进程和井之间的数据交换（输入/输出重定向）</li></ul><p>打印SPOOLing系统：打印机守护进程和SPOOLing打印目录</p><ul><li>守护进程是唯一有特权使用打印机设备的进程</li><li>打印文件前，用户进程先产生完整的待输出文件，存放在打印目录下</li><li>打印机空闲时，启动守护进程，打印待输出文件</li></ul><h3 id="批处理系统的作业管理">4.5.2 批处理系统的作业管理</h3><ul><li>作业说明语言：用于作业控制的语言</li><li>作业说明书：刻画具体作业的控制方式</li><li>作业状态：输入状态（预输入）、后备状态（空闲）、运行状态（运行）、完成状态（缓输出）</li><li>作业调度：从后备状态作业中选择部分进入运行状态</li><li>作业调度算法：优先数、短作业、响应比、设备搭配等</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第三章_存储管理</title>
    <link href="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第三章-存储管理">第三章 存储管理</h1><h2 id="存储管理基础">3.1 存储管理基础</h2><h3 id="基本内容">3.1.1 基本内容</h3><p>逻辑地址(相对地址)，用户编程所使用的地址空间，从0开始编号，两种形式：</p><ol type="1"><li>一维，即地址</li><li>二维，段号：段内地址</li></ol><p>物理地址(绝对地址)，处理器执行指令时按照物理地址进行。</p><h4 id="段式程序设计">段式程序设计</h4><p>将一个程序设计成多个段(代码段、数据段、堆栈段，等等)。</p><p>用户可以应用段覆盖技术(程序设计技术)扩展内存空间使用量。</p><h4 id="主存储器的复用">主存储器的复用</h4><p>多道程序设计需要复用主存</p><ul><li>按照分区复用</li></ul><p>主存划分为多个固定/可变尺寸的分区，一个程序/程序段占用一个分区</p><ul><li>按照页架复用</li></ul><p>主存划分为多个固定大小的页架，一个程序/程序段占用多个页架</p><h4 id="存储管理的基本模式">存储管理的基本模式</h4><ol type="1"><li>单连续存储管理：一维逻辑地址空间的程序占用一个主存固定/可变分区</li><li>段式存储管理：段式二维逻辑地址空间的程序占用多个主存可变分区</li><li>页式存储管理：一维逻辑地址空间的程序占用多个主存页架区</li><li>段页式存储管理：段式二维逻辑地址空间的程序占用多个主存页架区</li></ol><figure><img src="/image/计算机操作系统/存储管理基本模式.png"alt="存储管理基本模式" /><figcaption aria-hidden="true">存储管理基本模式</figcaption></figure><h3 id="存储管理功能">3.1.2 存储管理功能</h3><p>地址转换：又称重定位，将逻辑地址转换为绝对地址</p><p>静态重定位：程序装入内存时进行重定位，早期小型OS使用，由装入程序执行</p><p>动态重定位：CPU执行程序时进行重定位，效率依赖硬件地址转换机构</p><h4 id="主存储器空间的分配和去配">主存储器空间的分配和去配</h4><ul><li><p>分配：进程装入主存时，存储管理软件进行具体的主存分配操作，并设置表格记录主存空间的分配情况</p></li><li><p>去配：当某个进程撤离或主动归还主存资源时，存储管理软件收回其占用的全部或部分存储空间，调整主存分配表信息</p></li></ul><h4 id="主存储器空间的共享">主存储器空间的共享</h4><ul><li>多个进程共享主存储器资源：多道程序设计技术使若干个程序同时进入主存储器，各自占用一定数量的存储空间，共同使用一个主存储器</li><li>多个进程共享主存储器的某些区域：若干个协作进程有共同的主存程序或者主存数据块</li></ul><h4 id="存储保护">存储保护</h4><p>为避免主存中多个进程相互干扰，须对主存中程序和数据进行保护：</p><ul><li>私有主存区信息：可读写</li><li>公共区共享信息：根据授权</li><li>非本进程信息：不可读写</li></ul><p>需软硬件协同完成：CPU检查是否允许访问，不允许则产生地址保护异常。</p><h4 id="主存空间的扩充">主存空间的扩充</h4><p>存储扩充：把磁盘作为主存扩充，只把部分进程或进程的部分内容装入内存</p><ol type="1"><li>对换技术：把部分不运行的进程调出</li><li>虚拟技术：只调入进程的部分内容</li></ol><p>需软硬件协同完成：</p><ol type="1"><li>对换进程决定对换，硬件机构调入</li><li>CPU处理到不在主存的地址，发出虚拟地址异常，OS将其调入再执行指令</li></ol><h3 id="虚拟存储器">3.1.3 虚拟存储器</h3><p>主存容量限制了用户编程与多道程序设计的道数—&gt;部分调入进程内容。</p><h4 id="虚拟存储器的基本思想">虚拟存储器的基本思想</h4><ol type="1"><li>存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，之后根据执行行为随用随调</li><li>若主存空间不足，存储管理根据执行将主存中暂时不用的信息调出到辅存</li></ol><h4 id="实现思路">实现思路</h4><p>建立和自动管理两个地址空间</p><ol type="1"><li>主存：实际地址空间，承载进程执行</li><li>辅存：虚拟地址空间，容纳进程装入</li></ol><p>对于用户，计算机系统具有一个容量大得多的主存空间，即虚拟存储器</p><p>虚拟存储器是一种地址空间扩展技术，通常意义上对用户编程是透明的，除非用户需要进行高性能程序设计。</p><h3 id="存储管理的硬件支撑">3.1.4 存储管理的硬件支撑</h3><h4 id="存储器的组织层次">存储器的组织层次</h4><figure><img src="/image/计算机操作系统/存储器组织层次.png"alt="存储器组织层次" /><figcaption aria-hidden="true">存储器组织层次</figcaption></figure><p>存储管理是操作系统管理主存储器的软件部分。</p><p>为了更好的处理性能，部分主存程序与数据被调入Cache；</p><p>为了获得更大虚拟地址空间，存储管理需要管理更大的虚拟存储器。</p><h4 id="高速缓冲存储器cache">高速缓冲存储器(Cache)</h4><p>介于CPU和主存间的高速小容量存储器。</p><p>构成：高速存储器、联想存储器、地址转换部件、替换部件等。</p><ol type="1"><li>联想存储器：根据内容进行寻址的存储器</li><li>地址转换部件：通过联想存储器建立目录表以实现快速地址转换，命中时直接访问Cache，未命中时从内存读取放入Cache</li><li>替换部件：缓存已满时按一定策略进行数据块替换，并修改地址转换部件</li></ol><p>组织：由于中央处理器芯片面积和成本，Cache很小</p><p>根据成本控制，划分为L1、L2、L3三级。</p><ol type="1"><li>L1Cache：分为数据缓存和指令缓存，内置，成本最高，对CPU性能影响最大，通常在32-256KB</li><li>L2 Cache：分内置和外置两种，后者性能低。通常在512KB-8MB</li><li>L3 Cache：多为外置，在游戏和服务器领域有效。</li></ol><p>对很多应用而言，改善总线比设置L3更加有利于提升系统性能</p><h4 id="存储管理与硬件支撑">存储管理与硬件支撑</h4><ol type="1"><li>程序执行与数据访问的局部性原理—&gt;使用Cache可大幅提升程序执行效率</li><li>动态重定位、存储保护等，无硬件支撑在效率上无意义</li><li>无虚拟地址中断，虚拟存储器无法实现</li><li>无页面替换等硬件支撑机制，虚拟存储器在效率上无意义</li></ol><p>存储保护的硬件支撑：限长寄存器与逻辑地址比较判断是否越界</p><p>地址转换的硬件支撑：基址寄存器与逻辑地址运算得物理地址</p><h2 id="单连续分区存储管理">3.2 单连续分区存储管理</h2><p>每个进程占用一个物理上完全连续的存储空间。</p><p>分为：单用户连续分区存储管理、固定分区存储管理、可变分区存储管理</p><h3 id="单用户连续分区存储管理">3.2.1 单用户连续分区存储管理</h3><ol type="1"><li>主存区域划分为系统区和用户区</li><li>设置一个栅栏寄存器界分两个区域，硬件用其在执行时进行存储保护</li><li>一般使用静态重定位进行地址转换</li></ol><p>硬件实现代价低，适用于单用户单任务操作系统，如DOS。</p><h4 id="静态重定位">静态重定位</h4><p>装入作业时，把该作业中程序的指令地址和数据地址全部转换为绝对地址。</p><h3 id="固定分区存储管理">3.2.2 固定分区存储管理</h3><p>硬件实现代价低，早期操作系统采用</p><p>基本思想：支持多个数量、大小固定的分区</p><p>使用主存分配表(分区号，起始地址，长度，占用标志)，执行主存分配/去配。</p><p>固定分区会产生内存内零头，即内存分区中空闲的部分。</p><h3 id="三可变分区存储管理">三、可变分区存储管理</h3><p>创建进程时，根据进程所需主存查看主存中是否有足够空闲空间，有则分配，无则等待。由于分区大小为实际分配，其个数是随机变化的。</p><h4 id="主存分配表">主存分配表</h4><p>分为已分配区表和未分配区表，采用链表。</p><h4 id="内存分配">内存分配</h4><ul><li>最先适应分配算法</li><li>邻近适应分配算法</li><li>最优适应分配算法</li><li>最坏适应分配算法</li></ul><p>可变分区会随着进程的内存分配产生不可用的小内存分区，称为内存外零头。</p><p>任何算法难免产生外零头，最优适配算法最容易产生外零头。</p><h4 id="移动技术程序浮动技术">移动技术（程序浮动技术）</h4><p>移动分区以解决内存外零头，需要动态重定位支撑</p><h2 id="页式存储管理">3.3 页式存储管理</h2><h3 id="页式存储管理的基本原理">3.3.1 页式存储管理的基本原理</h3><ol type="1"><li>分页存储器将主存划分为多个大小相等的页架</li><li>逻辑地址被页架分成页</li><li>不同的页可以放在不同页架中，不需要连续</li><li>页表用于维系进程的主存完整性</li></ol><h4 id="地址">地址</h4><ol type="1"><li>逻辑地址由页号和单元号组成</li><li>物理地址由页架号和单元号组成</li><li>地址转换可以通过查页表完成</li></ol><h4 id="内存分配去配">内存分配/去配</h4><ol type="1"><li>可用位示图记录主存分配情况</li><li>建立进程页表维护主存逻辑完整性</li></ol><p>位示图：使用0和1表示磁盘中块的使用情况。</p><h4 id="页的共享">页的共享</h4><ol type="1"><li>数据共享：不同进程可以使用不同页号共享数据页</li><li>程序共享：不同进程必须使用相同页号共享代码页</li></ol><p>原因：共享代码页中的JMP <页内地址>使用不同页号是做不到的。</p><h3 id="页式存储管理的地址转换">3.3.2 页式存储管理的地址转换</h3><h4 id="页式存储管理的代价">页式存储管理的代价</h4><p>页表放在主存，每次地址转换需访问两次主存</p><ol type="1"><li>按页号读出页表中相应页架号</li><li>按计算出来的绝对地址进行读写</li></ol><p>这降低了存取速度—&gt;使用Cache存放部分页表，即快表。</p><h4 id="快表">快表</h4><p>存放在高速缓冲存储器中的页表部分</p><p>快表的表项：页号和页架号</p><p>这种高速存储器是联想存储器，即按照内容寻址，而非按照地址寻址。</p><p>基于快表的地址转换流程：</p><ol type="1"><li>按逻辑地址中的页号查快表</li><li>若在快表中，则由页架号和单元号生成绝对地址</li><li>不在快表中，再查主存页表形成绝对地址，同时登记该页到快表中</li><li>快表填满后，按一定策略淘汰一个旧登记项，登记新页</li></ol><h4 id="多道程序环境下的进程表">多道程序环境下的进程表</h4><p>进程表中登记了每个进程的页表，进程占有处理器运行时，其页表起始地址和长度送入页表控制寄存器。</p><p>多道程序环境下的地址转换：</p><figure><img src="/image/计算机操作系统/多道程序环境下的地址转换.png"alt="多道程序环境下的地址转换" /><figcaption aria-hidden="true">多道程序环境下的地址转换</figcaption></figure><h3 id="页式虚拟存储管理">3.3.3 页式虚拟存储管理</h3><p>基本思想：</p><p>把进程全部页面装入虚拟存储器，执行时先把部分页面装入实际内存，然后根据执行行为动态调入不在主存的页，并进行必要的页面调出。</p><ul><li>这是现代操作系统主流存储管理技术。</li></ul><p>首次只把进程第一页信息装入主存，称为请求页式存储管理。</p><h4 id="页式虚拟存储管理的页表">页式虚拟存储管理的页表</h4><p>扩充页表项，指出：</p><ul><li><p>每页的虚拟地址、实际地址</p></li><li><p>主存驻留标志、写回标志、保护标志、引用标志、可移动标志，等等</p></li></ul><p>实现</p><ul><li>中央处理器处理地址<ul><li>若页驻留，则获得块号形成绝对地址</li><li>若页不在内存，则中央处理器发出缺页中断</li></ul></li><li>操作系统处理缺页中断<ul><li>若有空闲页架，则根据辅存地址调入页，更新页表和快表等</li><li>若无空闲页架，则决定淘汰页，调出已修改页，调入页，更新页表与快表</li></ul></li></ul><figure><img src="/image/计算机操作系统/页式虚拟存储管理.png"alt="页式虚拟存储管理" /><figcaption aria-hidden="true">页式虚拟存储管理</figcaption></figure><figure><img src="/image/计算机操作系统/页式虚拟存储管理2.png"alt="页式虚拟存储管理2" /><figcaption aria-hidden="true">页式虚拟存储管理2</figcaption></figure><h3 id="页式存储管理的页面调度">3.3.4 页式存储管理的页面调度</h3><p>当主存空间已满又需要装入新页时，页式虚拟存储管理必须按一定的算法把已在主存的一些页调出去。选择淘汰页的工作即为页面调度。</p><p>若页面调度算法设计不当，会导致页面被反复淘汰、调入，这称为页面抖动。</p><h4 id="缺页中断率">缺页中断率</h4><p>衡量存储管理性能和用户编程水平的重要依据</p><p>假定进程P共n页，系统分配页架数m个，P运行中成功访问次数S，不成功访问次数F，总访问次数A=S+F，缺页中断率为：f=F/A。</p><p>影响缺页中断率的因素：</p><ul><li>分配给进程的页架数：可用页架数越多，缺页中断率越低</li><li>页面大小：页面尺寸越大，缺页中断率越低</li><li>用户编程方法：大数据条件下，对缺页中断率影响也很大</li></ul><h4 id="页面调度算法">页面调度算法</h4><ul><li><p>OPT页面调度算法</p><ul><li><p>由Belady提出，又称Belady算法。</p></li><li><p>只可模拟，不可实现。</p></li></ul><p>当要调入新页面时，先淘汰以后不再访问的页，后选择距现在最长时间后再访问的页。</p></li><li><p>先进先出算法(FIFO)：总是淘汰最先调入主存的页</p></li><li><p>最近最少用算法(LRU)：淘汰最近一段时间较久未被访问的页</p><ul><li>严格实现的代价大：维持特殊队列</li></ul></li><li><p>最不常用算法(LFU)：淘汰最近一段时间内访问次数较少的页</p></li><li><p>时钟调度算法：用循环队列构造页面队列，队列指针指向可能要淘汰的页</p></li></ul><p>LFU模拟OPT比LRU更接近。</p><p>时钟调度算法使用页引用标志位，工作流程：</p><ol type="1"><li><p>页面调入主存时，引用标志位被置为1</p></li><li><p>访问主存页面时，引用标志位被置为1</p></li><li><p>淘汰页面时，从指针当前指向的页面开始扫描循环队列</p><ul><li>将所遇到的引用标志位是1的页面的引用标志位清0，跳过</li><li>将所遇到的引用标志位是0的页面淘汰，指针推进</li></ul></li></ol><h3 id="反置页表">3.3.5 反置页表</h3><h4 id="反置页表的提出">反置页表的提出</h4><ul><li><p>页表及相关硬件机制在地址转换、存储保护、地址虚拟中发挥了关键作用</p><ul><li>为页式存储管理设置专门硬件机构</li></ul></li><li><p>内存管理单元（MMU）：中央处理器管理虚拟/物理存储器的控制线路，把虚拟地址映射成物理地址，提供存储保护，必要时确定淘汰页面</p></li><li><p>反置页表（IPT）：MMU的数据结构</p></li></ul><h4 id="反置页表的基本设计思想">反置页表的基本设计思想</h4><ol type="1"><li>对内存中每个页架建立一个页表，按照块号排序</li><li>用以完成内存页架到访问进程页号的对应，即物理到逻辑地址的转换</li></ol><h4 id="反置页表的页表项">反置页表的页表项</h4><ol type="1"><li>页号：虚拟地址页号</li><li>进程标识符：使用该页的进程号</li><li>标志位：有效、引用、修改、保护和锁定等标志信息</li><li>链指针：哈希链</li></ol><h4 id="基于反置页表的地址转换过程">基于反置页表的地址转换过程</h4><ol type="1"><li>MMU通过哈希表把进程标识和虚页号转换成一个哈希值，指向反置页表的一个表目</li><li>MMU遍历哈希链找到所需进程的虚页号，该项的索引就是页架号，通过拼接移位即可生成物理地址</li><li>若遍历反置页表未能找到匹配页表项，则产生缺页中断</li><li>选择淘汰页面也由MMU完成</li></ol><h2 id="段式存储管理">3.4 段式存储管理</h2><h3 id="段式程序设计-1">3.4.1 段式程序设计</h3><p>每个程序可由若干段组成，每一段都可以从0开始编址，段内的地址是连续的。</p><ul><li>分段存储器的逻辑地址由两部分组成<ul><li>段号：单元号</li></ul></li></ul><h4 id="基本思想">基本思想</h4><ul><li>段式存储管理基于可变分区存储管理实现，一个进程要占用多个分区。</li><li>硬件需要增加一组用户可见的段地址寄存器（代码段、数据段、堆栈段、附加段），供地址转换使用</li><li>存储管理需要增加设置一个段表，每个段占用一个段表项，包括：<ul><li>段始址、段限长、存储保护、可移动、可扩充等标志位</li></ul></li></ul><h4 id="地址转换流程">地址转换流程</h4><ol type="1"><li>从段表控制寄存器中得到当前段表</li><li>按逻辑地址中段号查段表</li><li>得到段始址和段限长</li><li>比较逻辑地址中的单元号和段限长<ul><li>若单元号&gt;段限长则发生越界中断</li><li>否则，绝对地址=段始址+单元号</li></ul></li></ol><h4 id="段的共享">段的共享</h4><ul><li>通过不同进程段表中的项指向同一个段基址来实现</li><li>对共享段的信息必须进行保护，如规定只能读不能写。不满足条件则产生保护中断</li></ul><h3 id="段式虚拟存储管理">3.4.2 段式虚拟存储管理</h3><h4 id="基本思想-1">基本思想</h4><p>把进程的所有分段都存放在辅存中，进程运行时先把当前需要的一段或几段装入主存，在执行过程中访问到不在主存的段时再把它们动态装入。</p><ul><li>段式虚拟存储管理中段的调入和调出由操作系统自动实现，对用户透明</li><li>与段覆盖技术不同，它是用户控制的主存扩充技术，操作系统不感知</li></ul><h4 id="段表扩充">段表扩充</h4><ul><li>特征位<ul><li>00：不在主存</li><li>01：在主存</li><li>11：共享段</li></ul></li><li>存取权限<ul><li>00：可执行</li><li>01：可读</li><li>11：可写</li></ul></li><li>扩充位<ul><li>0：固定长</li><li>1：可扩充</li></ul></li><li>标志位<ul><li>00：未修改</li><li>01：已修改</li></ul></li></ul><h4 id="地址转换流程-1">地址转换流程</h4><figure><img src="/image/计算机操作系统/段式虚拟存储管理的地址转换.png"alt="段式虚拟存储管理的地址转换" /><figcaption aria-hidden="true">段式虚拟存储管理的地址转换</figcaption></figure><h3 id="段页式存储管理">3.4.3 段页式存储管理</h3><h4 id="基本思想-2">基本思想</h4><p>段式存储管理可以基于页式存储管理实现，每一段不必占据连续的存储空间，可以存放在不连续的主存页架中。</p><ul><li>可以扩充出段页式虚拟存储管理：装入部分段，或者装入段中部分页面</li></ul><p>段表项为标志、页表始址和页表长，页表项为标志和块号。</p><h4 id="段页式存储管理的地址转换">段页式存储管理的地址转换</h4><figure><img src="/image/计算机操作系统/段页式存储管理的地址转换.png"alt="段页式存储管理的地址转换" /><figcaption aria-hidden="true">段页式存储管理的地址转换</figcaption></figure><h4 id="段页式虚拟存储管理的地址转换">段页式虚拟存储管理的地址转换</h4><figure><img src="/image/计算机操作系统/段页式虚拟存储管理的地址转换.png"alt="段页式虚拟存储管理的地址转换" /><figcaption aria-hidden="true">段页式虚拟存储管理的地址转换</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第二章_处理器管理文件</title>
    <link href="/2023/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6/"/>
    <url>/2023/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第二章-处理器管理文件">第二章 处理器管理文件</h1><h2 id="处理器">2.1 处理器</h2><h3 id="处理器与寄存器">2.1.1 处理器与寄存器</h3><h4 id="处理器部件的简单示意">处理器部件的简单示意</h4><figure><img src="/image/计算机操作系统/处理器部件简单示意.png"alt="处理器部件简单示意" /><figcaption aria-hidden="true">处理器部件简单示意</figcaption></figure><h4 id="用户程序可见寄存器">用户程序可见寄存器</h4><ul><li><p>可以让程序员减少访问主存储器次数，提高指令执行的效率</p></li><li><p>所有程序可使用，包括应用程序和系统程序</p></li></ul><ol type="1"><li>数据寄存器，又称通用寄存器</li><li>地址寄存器：索引、栈指针、段地址等寄存器</li></ol><h4 id="控制与状态寄存器">控制与状态寄存器</h4><p>用于控制处理器的操作，主要被具有特权的操作系统程序使用</p><ol type="1"><li>程序计数器：存储将取指令的地址</li><li>指令寄存器：存储最近使用的指令</li><li>条件码：中央处理器为指令操作结果设置的位，标志正/负/零、溢出等结果</li><li>标志位：中断位、中断允许位、中断屏蔽位、处理器模式位、内存保护位等</li></ol><h4 id="程序状态字psw">程序状态字（PSW）</h4><p>记录当前程序运行的动态信息。</p><p>通常包含：</p><ul><li>程序计数器、指令寄存器、条件码</li><li>中断字、中断允许/禁止、中断屏蔽、处理器模式、内存保护、调试控制</li></ul><p>程序状态字也是计算机系统的寄存器。</p><ul><li>通常设置一组控制与状态寄存器，也可以专设一个程序状态字寄存器</li></ul><h3 id="指令与处理器模式">2.1.2 指令与处理器模式</h3><h4 id="机器指令">机器指令</h4><p>计算机系统执行的基本命令，中央处理器执行的基本单位</p><ul><li><p>指令由一个或多个字节组成，包括操作码、操作数地址、状态字以及特征码。</p></li><li><p>指令完成各种算术逻辑运算、数据传输、控制流跳转。</p></li></ul><p>指令执行过程</p><ol type="1"><li>取指：根据程序计数器从存储器或高速缓冲存储器中取指令到指令寄存器</li><li>译码：解译指令寄存器中的指令</li><li>执行：连接中央处理器，执行运算</li></ol><h4 id="特权指令与处理器模式">特权指令与处理器模式</h4><p>与计算机核心资源相关的特殊指令会被保护，只能被操作系统程序使用。</p><p>特权指令：只能被操作系统内核使用的指令。</p><p>处理器模式：管理特权指令</p><p>设置0、1、2、3等运行模式，执行规定的指令子集。</p><p>0：操作系统内核</p><p>1：系统调用</p><p>2：共享库程序</p><p>3：用户程序</p><p>0模式可执行全部指令，3模式只能执行非特权指令。</p><p>一般而言，现代操作系统只使用0和3两种模式，即内核模式与用户模式。</p><p>处理器模式切换：中断、异常或系统异常等事件导致用户程序向OS内核切换。</p><h2 id="中断">2.2 中断</h2><h3 id="中断的概念">2.2.1 中断的概念</h3><p>在程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转而执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程，称为中断。</p><ul><li>操作系统是中断驱动的，换言之，中断是激活操作系统的唯一方式。</li></ul><p>由硬件产生的中断称为硬中断，可分为外中断和内中断</p><ol type="1"><li>外中断，也称中断（狭义）、异步中断，是来自处理器外的中断，如设备中断</li><li>内中断，也称异常，是来自处理器内部的中断，通常是程序执行过程中发生的与当前指令关联的不正常的事件，如访管、硬件故障、程序性异常</li></ol><p>外中断会根据中断优先级处理，内中断一旦出现则立即由异常处理程序处理。</p><h3 id="中断的响应和处理">2.2.2 中断的响应和处理</h3><p>在指令执行周期最后增加一个检查中断的微操作以响应中断。</p><p>中断系统是响应和处理中断的系统，包括硬件(响应)和软件(处理)子系统两部分</p><p>中断装置是计算机系统中发现并响应中断/异常的硬件装置。</p><ul><li><p>外中断；中断控制器发现和响应</p></li><li><p>异常：由指令的控制逻辑和实现线路发现和响应，Trap机制</p></li></ul><h4 id="中断控制器">中断控制器</h4><p>CPU的一个控制部件，包括中断控制逻辑线路、中断寄存器</p><ol type="1"><li>外部设备向其发出中断请求，在中断寄存器中设置已发生的中断</li><li>指令处理结束前，检查中断寄存器，若有不被屏蔽的中断产生，则改变处理器内操作顺序，引出操作系统中的中断处理程序</li></ol><h4 id="中断响应的一般过程">中断响应的一般过程</h4><ol type="1"><li>发现中断源：发现中断寄存器中中断，根据优先级决定是否响应</li><li>保护现场：将当前程序的PSW/PC保存至核心栈</li><li>处理中断</li><li>恢复现场</li></ol><h4 id="不同中断源的处理原则">不同中断源的处理原则</h4><ol type="1"><li>硬件故障中断：由处理器、内存储器、总线等硬件故障引起。</li></ol><p>保护现场，停止设备，停止中央处理器，报告操作员，等待人工干预。</p><ol start="2" type="1"><li>程序性中断：处理器执行机器指令引起。</li></ol><p>算术异常—简单处理，报告用户；也可由用户编写中断续元程序处理。</p><p>非法指令、用户态使用特权指令、地址越界、非法存取等指令异常：终止进程。</p><p>虚拟地址异常：调整内存后重新执行指令。</p><ol start="3" type="1"><li>访管/自愿性中断：由系统调用引起。</li></ol><p>保护现场，跳转具体处理程序。</p><ol start="4" type="1"><li>输入/输出中断：外围设备报告输入/输出状态。<ul><li>输入/输出完成：调整进程状态，释放等待进程</li><li>出错：等待人工干预</li></ul></li><li>外部中断：外围设备发出的信号引起。<ul><li>时钟中断、间隔时钟中断：记时和时间片处理</li><li>设备报到与结束中断：调整设备表</li><li>键盘/鼠标信号中断：根据信号相应反应</li><li>关机/重启中断：写回文件，停止设备和中央处理器</li></ul></li></ol><h3 id="多中断的响应和处理">2.2.3 多中断的响应和处理</h3><p>中断优先级：中断装置预设的对不同中断的响应顺序</p><p>中断屏蔽：高级中断事件屏蔽低级中断源（中断屏蔽位）</p><p>中断嵌套：高级中断嵌套在低级中断中，嵌套层数不宜太多。</p><h2 id="进程">2.3 进程</h2><h3 id="进程-1">2.3.1 进程</h3><p>进程是操作系统进行资源分配和调度的基本单位。</p><p>进程的概念：具有一定独立功能的程序关于某个数据集合的一次运行活动。</p><p>包括五个实体部分：</p><ol type="1"><li>操作系统管理运行程序的数据结构P</li><li>程序的内存代码C</li><li>程序的内存数据D</li><li>程序的通用寄存器信息R</li><li>操作系统控制程序执行的程序状态字PSW</li></ol><h4 id="三态模型">三态模型</h4><ul><li>就绪态：进程具有运行条件等待处理器运行</li><li>等待态：进程由于等待资源、输入输出、信号等而不具备运行条件</li><li>运行态：进程占有处理器运行</li></ul><ol type="1"><li>就绪态—&gt;运行态：处理器空闲时选择、优先进程抢占</li><li>运行态—&gt;等待态：等待资源、输入输出、信号</li><li>等待态—&gt;就绪态：资源满足、输入输出结束、信号完成</li><li>运行态—&gt;就绪态：运行时间片到、优先进程抢占</li></ol><p>此外，也有短暂的新建态和结束态，但并不属于三态模型的循环中。</p><h4 id="进程挂起">进程挂起</h4><ol type="1"><li>操作系统无法预期进程的数目和资源需求，系统运行过程中可能资源不足</li><li>运行资源不足将导致低性能与死锁</li><li>解决办法：剥夺某些进程的内存及其他资源，调入操作系统管理对换区，不参加进程调度，等合适时机调入内存、恢复资源、参与运行<ul><li>等待态占有已申请的资源，而挂起态不具有任何资源。</li></ul></li></ol><p>进程挂起和恢复的过程：</p><ol type="1"><li>一般使等待态进程进入挂起等待态，也可使就绪态进程进入挂起就绪态</li><li>运行态进程可以挂起自己进入挂起就绪态</li><li>等待事件结束后，挂起等待态进入挂起就绪态</li><li>一般恢复挂起就绪态进程为就绪态进程，也可恢复挂起等待态为等待态</li></ol><h3 id="进程的数据描述">2.3.2 进程的数据描述</h3><h4 id="进程映像">进程映像</h4><p>某时刻进程的内容及其状态集合，包括</p><ol type="1"><li>进程控制块 (Process Control Block，PCB)</li><li>进程程序块：被进程执行的程序，规定进程运行所应完成的功能</li><li>进程数据块：进程的私有地址空间，存放各种私有数据，用户栈也在数据块中，用于在函数调用时存放栈帧、局部变量和返回地址等</li><li>进程核心栈：进程在内核态工作时使用，用于保存中断现场，以及函数调用参数、局部变量和返回地址等</li></ol><h4 id="进程上下文">进程上下文</h4><p>进程物理实体和支持进程运行的环境，由三部分组成</p><ol type="1"><li>用户级上下文：程序块、数据块、共享内存区、用户栈</li><li>寄存器上下文：处理器状态寄存器、程序计数器、栈指针、通用寄存器</li><li>系统级上下文：进程控制块、内存管理信息、核心栈等操作系统管理进程所需信息</li></ol><p>当系统调度新进程占有处理器，新老进程随之发生上下文切换。</p><h4 id="进程控制块">进程控制块</h4><p>进程创建时建立进程控制块，进程销毁时回收进程控制块，与进程一一对应。</p><p>操作系统根据进程控制块对进程进行控制和管理。</p><p>进程控制块是操作系统记录和刻画进程状态及环境信息的数据结构，包含：</p><ol type="1"><li><p>标识信息：唯一地标识一个进程</p></li><li><p>现场信息：通用、控制寄存器内容、核心与用户栈指针、程序状态字等</p></li><li><p>控制信息：用于管理和调度进程</p></li><li><p>进程调度相关信息：进程状态、等待事件及原因、优先级、队列指针等</p></li><li><p>进程组成信息：代码、数据地址，进程映像在外存的地址</p></li><li><p>进程队列指引元：进程队列指针、父子进程指针</p></li><li><p>进程通信相关信息：消息队列、信号量、锁</p></li><li><p>进程处理器使用信息：占用的处理器、时间片、处理器使用时间</p></li><li><p>进程特权信息：内存访问权限、处理器特权</p></li><li><p>进程资源清单：正占有的资源、已使用的资源</p></li></ol><h3 id="进程管理">2.3.3 进程管理</h3><p>关键进程管理软件包括：</p><ol type="1"><li>系统调用/中断/异常处理</li><li>队列管理</li><li>进程控制</li><li>进程调度</li><li>进程通信</li><li>终端登录与作业控制、性能监控、审计程序等外围程序</li></ol><h4 id="进程队列">进程队列</h4><p>将处于同一状态的所有进程的PCB链接在一起的数据结构。</p><p>不同状态的进程可以排列成运行、就绪或等待队列，组织方式有：</p><ol type="1"><li>链接方式</li></ol><p>通过PCB的链接指针将同一状态进程的PCB链接，可采用单/双链表</p><ol start="2" type="1"><li>索引方式</li></ol><p>建立索引表，存放PCB地址或在PCB表中的编号</p><p>队列管理模块是操作系统实现进程管理的核心模块，进程与资源调度围绕进程队列展开。</p><h4 id="进程管理原语">进程管理原语</h4><p>操作系统通过原语来完成进程管理。常见的进程管理原语有：</p><ol type="1"><li>进程创建：在进程列表添加新进程，申请PCB并完成初始化</li><li>进程撤销：从队列中移除，归还资源，回收PCB，移除进程表项</li><li>进程阻塞：保存现场信息，修改PCB，移入等待队列，调度其他进程执行</li><li>进程唤醒：修改PCB，从等待队列移入就绪队列</li><li>进程挂起：修改状态，出入相关队列，收回资源</li><li>进程激活：修改状态，出入相关队列，分配内存</li><li>其他，如修改进程特权</li></ol><h4 id="处理器状态模式切换">处理器状态（模式）切换</h4><p>处理器状态从用户态到内核态，或从内核态到用户态。</p><p>当发生中断或系统调用，处理器状态从用户态切换到内核态。切换过程：</p><ol type="1"><li>保存被中断进程的处理器现场信息</li><li>处理器从用户态转换到内核态</li><li>处理中断或进行系统调用</li></ol><p>此时进程仍在自己的上下文中执行，仅处理器状态发生变化。</p><h4 id="进程切换">进程切换</h4><p>收回运行中进程占用的处理器，让待运行进程执行</p><p>实质上，进程切换就是进程上下文的切换：</p><ol type="1"><li>保存被中断进程的上下文</li><li>进程调度（队列管理）</li><li>恢复待运行进程的上下文</li></ol><p>进程切换的发生时机：一定发生在中断处理过程，也就是在内核态中。</p><p>P：可再入程序是能够被多个程序同时调用的程序，它是纯代码的。</p><h2 id="线程">2.4 线程</h2><h3 id="多线程环境">2.4.1 多线程环境</h3><h4id="单线程结构在并发程序设计上的问题">单线程结构在并发程序设计上的问题</h4><ul><li>进程切换、通信开销大</li><li>进程并发粒度受限，并行计算效率低</li></ul><p>解决办法：进程分配资源，线程调度执行。</p><h4 id="多线程">多线程</h4><p>在多线程环境中，进程是操作系统中进行资源分配与保护的独立单位，具有：</p><ul><li><p>容纳进程映像的虚拟地址空间</p></li><li><p>对进程、文件和设备的存取保护机制</p></li></ul><p>线程是进程的一条执行路径，是调度的基本单位。</p><p>同一个进程中所有线程共享进程获得的主存空间和资源，具有：</p><ul><li>线程唯一标识符和其状态</li><li>受保护的线程上下文</li><li>独立的程序计数器</li><li>执行堆栈</li><li>容纳局部变量的静态存储器</li></ul><p>线程的状态：运行(Active)、就绪(Runnable)和睡眠(Sleeping)</p><p>线程状态变化的相关操作：孵化、封锁、活化、剥夺、指派、结束</p><p>线程的调度：</p><p>操作系统感知线程环境：</p><ul><li><p>处理器调度线程</p></li><li><p>进程只有挂起状态</p></li></ul><p>操作系统不感知线程环境：</p><ul><li><p>处理器调度进程</p></li><li><p>用户空间中的用户调度程序调度线程</p></li></ul><h4 id="并发多线程程序设计的优点">并发多线程程序设计的优点</h4><ol type="1"><li>快速线程切换</li><li>减少系统管理开销</li><li>线程通信易于实现</li><li>并行程度提高</li><li>节省内存空间</li></ol><h3 id="多线程的实现">2.4.2 多线程的实现</h3><h4 id="内核级线程kltkernel-level-thread">内核级线程（KLT，Kernel-levelThread）</h4><ol type="1"><li>线程管理的所有工作交由操作系统内核</li><li>操作系统提供了使用KLT的程序设计接口</li><li>操作系统直接调度KLT</li></ol><p>内核级线程的特点：</p><ol type="1"><li>进程的一个线程阻塞，内核能调度同一进程的其他线程运行</li><li>多处理器环境中，内核能同时调度同一进程的多个线程并行执行</li><li>内核自身也可用多线程技术实现，提高操作系统执行速度和效率</li><li>应用程序线程在用户态而线程调度在内核态，因而线程切换需要模式切换，系统开销大</li></ol><h4 id="用户级线程ultuser-level-thread">用户级线程（ULT，User-levelThread）</h4><ol type="1"><li>用户空间运行的线程库提供多线程应用程序的开发和运行环境</li><li>任何应用程序需通过线程库进行程序设计，与线程库连接后运行</li><li>线程管理的所有工作由应用程序完成，内核不知道线程的存在</li></ol><p>用户级线程的特点</p><ol type="1"><li>线程切换不需要模式切换，系统开销小</li><li>允许进程按特定需要选择调度算法</li><li>能运行在任何操作系统上</li><li>不能利用多处理器，操作系统调度进程，只有一个ULT能执行</li><li>一个ULT的阻塞将引起整个进程的阻塞</li></ol><h4 id="jacketing技术">Jacketing技术</h4><p>将阻塞式操作系统改造为非阻塞的。</p><p>当线程陷入系统调用，执行Jacketing程序，检查资源使用，决定是否进行进程切换或线程切换。</p><h4 id="混合式线程">混合式线程</h4><p>在用户空间进行线程创建、调度与同步，单应用多个ULT可映射成一些KLT。</p><p>混合式线程的特点：</p><ol type="1"><li>组合用户级线程/内核级线程设施</li><li>程序员可针对特定应用和机器调节内核级线程数目以达更好效果</li><li>结合了纯粹用户级、内核级线程优点，减少其缺点</li></ol><figure><img src="/image/计算机操作系统/混合式线程调用.png"alt="混合式线程调用" /><figcaption aria-hidden="true">混合式线程调用</figcaption></figure><h2 id="处理器调度">2.5 处理器调度</h2><h3 id="处理器调度的层次">2.5.1 处理器调度的层次</h3><ul><li><p>高级调度，又称长程调度，作业调度，决定能否加入执行的进程池中</p><p>分时操作系统中，高级调度决定：</p><ul><li>是否接受终端用户连接</li><li>命令是否被系统接纳并构成进程</li><li>新建的进程是否加入就绪进程队列</li></ul><p>批处理操作系统中，高级调度又称为作业调度，按某种原则从后备作业队列中选取作业进入主存，并为作业做好运行前的准备和完成后的完善。</p></li><li><p>中级调度，又称平衡负载调度，决定主存中的可用进程集合</p><ul><li>提高内存利用率和作业吞吐量。</li><li>决定哪些进程被允许驻留在主存中参与竞争处理器及其他资源，起到短期调整系统负荷的作用。（将一些进程挂起）</li></ul></li><li><p>低级调度，又称短程调度，进程调度，决定哪个进程占用处理器执行</p><ul><li>按某种原则将处理器分配给就绪态进程或内核级线程。</li></ul></li></ul><p>进程调度程序，又称分派程序，是操作系统中实现处理器调度的程序。</p><figure><img src="/image/计算机操作系统/处理器调度.png" alt="处理器调度" /><figcaption aria-hidden="true">处理器调度</figcaption></figure><h3 id="处理器调度算法">2.5.2 处理器调度算法</h3><h4 id="选择处理器调度算法的原则">选择处理器调度算法的原则</h4><ol type="1"><li>资源利用率</li><li>响应时间：尽快处理实时任务</li><li>周转时间：提交给系统开始到执行完成获得结果为止的时间</li><li>吞吐量：单位时间处理的进程数</li><li>公平性：每个用户每个进程获得合理的资源份额</li></ol><h4 id="优先数调度算法">优先数调度算法</h4><p>根据分配给进程的优先数决定运行进程，分为抢占式和非抢占式</p><p>优先数的确定准则：</p><ul><li>任务的紧迫程度</li><li>交互性</li><li>使用外设的频度</li><li>进入系统时间长短</li></ul><p>一些优先数选择：</p><ul><li>计算时间短优先</li><li>剩余时间短优先</li><li>响应比（等待时间/进入时间）高优先</li><li>先来先服务FCFS：先进队先选择 (多用于高级调度)</li></ul><h4 id="时间片轮转调度算法">时间片轮转调度算法</h4><ul><li>根据各个进程进入就绪队列的顺序轮流占有CPU一个时间片</li></ul><p>时间片的确定：适中，过长则为FCFS，过短则开销大</p><p>分为单时间片、多时间片和动态时间片</p><h4 id="分级调度算法">分级调度算法</h4><ul><li>又称多队列策略，反馈循环队列</li></ul><p>基本思想：</p><ol type="1"><li>建立多个不同优先级的就绪进程队列</li><li>多个就绪进程队列间按照优先数调度</li><li>高优先级就绪进程分配的时间片短</li><li>单个就绪进程队列中进程的优先数和时间片相同</li></ol><h4 id="随机调度算法">随机调度算法</h4>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第一章_概述</title>
    <link href="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第一章-计算机操作系统概述">第一章 计算机操作系统概述</h1><h2 id="计算机系统">1.1 计算机系统</h2><h3 id="计算机系统概述">1.1.1 计算机系统概述</h3><p>电子数字计算机：能够自行按照已设定的程序进行数据处理的电子设备。</p><h4 id="计算机发展历史">计算机发展历史</h4><ul><li><p>1945～：电子真空管、机器语言，应用于科学计算</p></li><li><p>1956～：晶体管、批处理控制、Fortran/COBOL，扩展到数据处理</p></li><li><p>1959～：集成电路、多道程序、操作系统/数据库/高级语言</p></li><li><p>1976～：大规模集成电路，向快速化、小型化、系统化、网络化、智能化发展</p></li><li><p>1980～：微机出现</p></li><li><p>1990～：图形化人机交互</p></li><li><p>2003～：移动计算</p></li></ul><h4 id="计算机系统组成">计算机系统组成</h4><p>包括硬件子系统和软件子系统</p><ul><li><p>硬件：借助电、磁、光、机械等原理构成的各种物理部件的有机组合</p></li><li><p>软件：各种程序和文件，包括系统软件、支撑软件和应用软件</p><ul><li>关键系统软件：操作系统和语言处理程序</li></ul></li></ul><h4 id="计算机系统视图">计算机系统视图</h4><ul><li><p>用户视图：应用、语言处理、操作系统、计算机硬件</p></li><li><p>应用程序员视图：语言处理、操作系统、计算机硬件</p></li><li><p>语言处理程序设计者视图：操作系统、计算机硬件</p></li><li><p>操作系统设计者视图：计算机硬件</p></li></ul><h3 id="计算机硬件系统">1.1.2 计算机硬件系统</h3><h4 id="一计算机硬件系统的组成">一、计算机硬件系统的组成</h4><ol type="1"><li>中央处理器：运算单元、控制单元</li><li>主存储器</li><li>外围设备：输入/输出设备、存储设备、网络通信设备</li><li>总线</li></ol><h4 id="二冯氏计算机存储程序计算机">二、冯氏计算机：存储程序计算机</h4><p>冯·诺伊曼等人在1946年总结提出，称为冯·诺伊曼计算机模型</p><ol type="1"><li>以运算单元为中心，控制流由指令流产生</li><li>采用存储程序原理，面向主存组织数据流</li><li>主存是按地址访问、线性编址的空间</li><li>指令由操作码和地址码组成</li><li>数据以二进制编码</li></ol><h4 id="三总线">三、总线</h4><p>总线是计算机各种功能部件之间传送信息的公共通信干线，是CPU、内存、输入输出设备传递信息的公用通道。</p><p>计算机各个部件通过总线相连接，外围设备通过相应的接口电路与总线相连接，形成了计算机硬件系统。</p><p>总线的组成：一组控制线、一组数据线、一组地址线</p><p>总线的类型：</p><ol type="1"><li>内部总线：用于CPU芯片内部连接各元件</li><li>系统总线：用于连接CPU、存储器和各种输入/输出模块等主要部件</li><li>通信总线：用于计算机系统间通信</li></ol><p>片上系统 (SoC: System on a Chip)</p><p>在单个芯片上集成一个完整的系统(包括中央处理器、存储器以及外围电路等)，对所有或部分必要的电子电路进行包分组的技术。</p><p>SoC是与其他技术(如绝缘硅，提高增强时钟频率，降低功耗)并行发展的。</p><h4 id="四中央处理器">四、中央处理器</h4><p>中央处理器是计算机的运算核心和控制单元，主要包括：</p><ol type="1"><li>运算逻辑部件：一个或多个运算器</li><li>寄存器部件：包括通用寄存器、控制与状态寄存器、高速缓冲存储器</li><li>控制部件：实现各部件之间联系的数据、控制与状态内部总线；指令译码、控制指令执行、实现数据传输等功能的部件</li></ol><figure><img src="/image/计算机操作系统/中央处理器.png" alt="中央处理器" /><figcaption aria-hidden="true">中央处理器</figcaption></figure><p>存储器组织层次：越往下，容量越大、速度越慢、价格越低</p><p>L0：寄存器</p><p>L1：L1 Cache</p><p>L2：L2 Cache</p><p>L3：L3 Cache</p><p>L4：主存</p><p>L5：本地固态硬盘</p><p>L6：本地硬盘</p><p>外围设备：输入/输出设备、存储设备、通信设备</p><p>输入/输出控制方式：</p><ol type="1"><li>轮询：CPU忙式控制输入/输出，执行内存数据交换</li><li>中断：CPU启动输入/输出设备，设备中断CPU</li><li>DMA方式：CPU启动DMA，DMA独立进行输入/输出和内存数据交换，DMA中断CPU</li></ol><h3 id="计算机软件系统">1.1.3 计算机软件系统</h3><h4 id="一计算机软件系统的组成">一、计算机软件系统的组成</h4><ol type="1"><li>系统软件</li></ol><p>操作系统、实用程序、语言处理程序、数据库管理系统</p><ol start="2" type="1"><li>支撑软件</li></ol><p>接口软件、工具软件、环境数据库，也可认为是系统软件的一部分</p><ol start="3" type="1"><li>应用软件</li></ol><p>用户按其需要自行编写的专用程序</p><h4 id="二程序员的计算机系统视图">二、程序员的计算机系统视图</h4><ol type="1"><li>机器语言：计算机硬件系统</li><li>机器指令：操作系统和实用程序</li><li>数据库语言：数据库管理系统</li><li>高级语言：支撑软件</li><li>更高：支撑软件</li></ol><p>软件开发的不同层次</p><ol type="1"><li>计算机硬件系统：机器语言</li><li>操作系统资源管理：机器语言+广义指令</li><li>操作系统文件系统：机器语言+系统调用</li><li>数据库管理系统：数据库语言</li><li>语言处理程序：面向问题的语言</li></ol><h4 id="三计算机程序的执行过程">三、计算机程序的执行过程</h4><figure><img src="/image/计算机操作系统/计算机程序执行过程.png"alt="计算机程序执行过程" /><figcaption aria-hidden="true">计算机程序执行过程</figcaption></figure><h2 id="计算机操作技术">1.2 计算机操作技术</h2><h3 id="计算机操作技术的发展">1.2.1 计算机操作技术的发展</h3><h4 id="操作平台与操作系统">1. 操作平台与操作系统：</h4><p>任何一台机器都有其操作平台与操作系统，操作平台的精细化和系统化，产生了操作系统。</p><h4 id="计算机人工操作">2. 计算机人工操作</h4><p>计算机手工操作的问题：手工操作速度和电子计算速度不匹配</p><p>装入程序的引进：</p><ol type="1"><li>引入卡片和打孔纸带描述程序指令和数据</li><li>装入程序：自动化执行程序装入，必要时进行地址切换，存放在ROM中</li></ol><p>外存储设备变迁：过去的磁带与软盘，使用逐渐减少的光盘</p><p>计算机控制</p><p>汇编语言：先将汇编语言程序编译为可执行程序，再由计算机执行</p><p>高级语言：高级语言程序编译为目标代码，后编译成可执行程序，再执行</p><h4 id="简单批处理系统的操作方式">3. 简单批处理系统的操作方式</h4><p>简单批处理系统的操作控制：</p><p>引入作业控制语言，用户编写作业说明书，描述对一次计算机作业的控制。</p><p>操作员控制计算机成批输入作业，成批执行作业。</p><p>这一方式缩短了手工操作时间，提高了计算机系统的使用效率。</p><p>进展：</p><ol type="1"><li>出现了初步的资源管理程序，屏蔽了硬件处理细节</li><li>输入/输出中断出现，实现CPU与输入/输出设备并行</li><li>磁带出现，磁盘文件系统形成，但输入/输出效率还是不支持多道程序</li></ol><h4 id="操作系统与自动化操作方式">4. 操作系统与自动化操作方式</h4><p>操作系统与自动化操作控制：</p><ol type="1"><li>电子计算速度与机械输入/输出速度的矛盾</li><li>程序执行过程中输入作业，重叠时间</li></ol><p>需要多道程序同时执行，程序切换需要高速外存储设备</p><ol start="3" type="1"><li>磁盘设备出现，于是有了计算机操作系统，实现自动化控制</li></ol><h3 id="计算机操作系统">1.2.2 计算机操作系统</h3><h4 id="操作系统基本概念">1. 操作系统基本概念</h4><p>操作系统是计算机系统最基础的系统软件，管理软硬件资源、控制程序执行、改善人机界面，合理组织计算机工作流程，为用户使用计算机提供良好运行环境。</p><h4 id="操作系统组成">2. 操作系统组成</h4><ol type="1"><li>进程调度子系统</li><li>进程通信子系统</li><li>内存管理子系统</li><li>设备管理子系统</li><li>文件管理子系统</li><li>网络通信子系统</li><li>作业控制子系统</li></ol><h4 id="操作系统分类">3. 操作系统分类</h4><p>从操作方式看：</p><ol type="1"><li>多道批处理操作系统，脱机控制方式</li><li>分时操作系统，交互式操作系统</li><li>实时操作系统</li></ol><p>按应用领域分类：</p><p>服务器操作系统、并行操作系统、网络操作系统、分布式操作系统、个人机操作系统、手机操作系统、嵌入式操作系统、传感器操作系统</p><p>普适计算 Pervasive/Ubiquitous Computing</p><p>物联网 Things of Internet, CPS</p><p>移动计算 Mobile Computing (移动互联网)</p><p>嵌入式的操作系统: μC/OS-II, VxWorks, LiteOS, 翼辉SylixOS......</p><p>移动终端的操作系统： Android, iOS, 鸿蒙OS......</p><p>PC的OS: 微软的桌面系统</p><p>服务器的OS: CentOS, Ubuntu等Linux各类发行版, EulerOS, ...</p><h2 id="操作系统的不同视角">1.3 操作系统的不同视角</h2><h3 id="资源管理的视角">1.3.1 资源管理的视角</h3><h4 id="计算机系统的资源">计算机系统的资源</h4><ul><li>硬件资源：处理器、内存、外设</li><li>信息资源：数据、程序</li></ul><h4 id="软硬件资源管理">软硬件资源管理</h4><ul><li>处理器资源：占有处理器运行的程序</li><li>内存资源：程序、数据在内存中的分布</li><li>设备资源：分配、去配和使用资源</li><li>信息资源管理：访问文件信息</li><li>信号量资源：管理进程间通信</li></ul><h4 id="屏蔽资源使用的底层细节">屏蔽资源使用的底层细节</h4><p>驱动程序：最底层的、直接控制和监视各类硬件资源的地方</p><ul><li>隐藏底层硬件的具体细节，为其他部分提供抽象、具体的接口</li></ul><h4 id="资源的共享独占与并发">资源的共享：独占与并发</h4><p>资源的分配：</p><ul><li>静态分配：进程运行前一次拿到所有全部独占资源</li><li>动态分配：使用资源前临时申请</li></ul><p>可能产生竞争资源的死锁。</p><p>资源抢占方式：被抢占资源的进程需要回滚执行</p><h3 id="控制程序执行的视角">1.3.2 控制程序执行的视角</h3><p>由于中央处理器速度和输入/输出速度不匹配的矛盾，只有让多道程序同时进入内存争抢中央处理器运行，才可以使中央处理器与外围设备充分并行，提高计算机系统使用效率。</p><h4 id="多道程序设计">多道程序设计</h4><p>让多个程序同时进入计算机主存储器进行计算。</p><p>特点：</p><ol type="1"><li>中央处理器与外部设备充分并行</li><li>外部设备间充分并行</li><li>发挥中央处理器使用效率</li><li>提高单位时间算题量</li><li>单道程序的运算时间会增加</li></ol><p>多道程序系统的实现：</p><ol type="1"><li>为进入内存执行的程序建立管理实体：进程</li><li>操作系统管理和控制进程程序的执行</li><li>操作系统协调管理各类资源在进程间使用</li></ol><ul><li>处理器的管理与调度</li><li>主存储器的管理与调度</li><li>其他资源的管理与调度</li></ul><p>实现要点：</p><ol type="1"><li>如何使用资源：调用操作系统提供的服务例程</li><li>如何复用中央处理器：调度程序，让其他程序在中央处理器空闲时运行</li><li>如何使中央处理器和输入/输出设备充分并行：设备控制器和通道</li><li>如何让正在运行的程序让出中央处理器：中断</li></ol><h3 id="操作控制计算机的视角">1.3.3 操作控制计算机的视角</h3><ol type="1"><li>计算机操作控制方式</li><li>脱机作业控制方式</li><li>联机作业控制方式</li><li>命令解释程序及其处理过程</li></ol><h4 id="计算机系统操作方式">计算机系统操作方式</h4><ol type="1"><li>操作系统规定了合理操作计算机的工作流程</li><li>操作系统的操作接口：系统程序</li><li>两类作业级接口：</li></ol><p>脱机作业控制方式、联机作业控制方式</p><h4 id="脱机作业控制方式">脱机作业控制方式</h4><p>例：shell程序</p><ul><li>操作系统：提供作业说明语言</li><li>用户：编写作业说明书，确定作业加工控制步骤，并与程序数据一起提交</li><li>操作员：通过控制台输入作业</li><li>操作系统：通过作业控制程序自动控制作业的执行</li></ul><h4 id="联机作业控制方式">联机作业控制方式</h4><p>例：分时操作系统的交互控制方式</p><ul><li>计算机：提供终端 (键盘、显示器)</li><li>用户：登录系统</li><li>操作系统：提供命令解释程序</li><li>用户：联机输入操作控制命令，直接控制作业的执行</li></ul><h4 id="命令解释程序">命令解释程序</h4><p>接受和执行一条用户提出的对作业的加工处理命令</p><ul><li>会话语言：可编程的命令解释语言</li><li>图形化的命令控制方式</li><li>多通道交互的命令控制方式</li></ul><p>处理过程：</p><ol type="1"><li>操作系统启动命令解释程序，输出命令提示符，等待键盘中断、鼠标点击、多通道识别</li><li>每当用户输入命令并按回车换行，将命令暂存在命令缓冲区后，申请中断</li><li>中央处理器响应后，将控制权交给命令解释器程序，读入命令缓冲区内容，分析命令、接受参数，执行处理代码</li></ol><p>前台命令和后台命令</p><ul><li><p>前台命令执行结束后，再次输出命令提示符，等待下一条命令</p></li><li><p>后台命令处理启动后，即可接收下一条命令</p></li></ul><h3 id="人机交互的视角">1.3.4 人机交互的视角</h3><h4 id="操作系统的人机交互部分">操作系统的人机交互部分</h4><ol type="1"><li>操作系统改善人机界面，为用户使用计算机提供良好的环境</li><li>人机交互设备包括传统终端设备和新型模式识别设备</li><li>人机交互部分用于控制有关设备运行、理解执行设备传来命令</li><li>人机交互功能决定了计算机系统的友善性</li></ol><h4 id="人机交互的发展">人机交互的发展</h4><p>交互式控制方式：</p><ul><li><p>行命令控制方式：1960年代开始使用</p></li><li><p>全屏幕控制方式：1970年代开始使用</p></li></ul><p>人，而不是技术，是人机交互的中心——&gt;鼠标、菜单、窗口控制</p><h4 id="wimp界面">WIMP界面</h4><p>窗口(Window)、图标(Icon)、菜单(Menu)、指示装置(Pointing Devices)</p><ul><li><p>1990年代开始广泛使用。</p></li><li><p>不足：不能同时使用多个交互通道，产生人机交互的不平衡。</p></li></ul><h4 id="多媒体计算机">多媒体计算机</h4><p>将音频视频、图形图像和人机交互控制结合，进行综合处理</p><h4 id="虚拟现实系统">虚拟现实系统</h4><p>例：VR</p><h3 id="程序接口的视角">1.3.5 程序接口的视角</h3><h4 id="操作系统的程序接口">操作系统的程序接口</h4><p>操作系统为程序运行扩充的编程接口。</p><p>系统调用：操作系统实现的完成某种特定功能的过程</p><p>POSIX支持</p><h4 id="系统调用的实现机制">系统调用的实现机制</h4><p>中断。</p><p>系统调用的实现要点：</p><ol type="1"><li>编写系统调用处理程序</li><li>系统调用入口地址表</li><li>系统调用时，需保存当时的处理器情况</li></ol><h4 id="系统调用的实现流程">系统调用的实现流程</h4><figure><img src="/image/计算机操作系统/系统调用的实现流程.png"alt="系统调用的实现流程" /><figcaption aria-hidden="true">系统调用的实现流程</figcaption></figure><h3 id="系统结构的视角">1.3.6 系统结构的视角</h3><p>操作系统是计算机软件发展史上第一个大规模软件系统。</p><h4 id="操作系统软件的结构设计">操作系统软件的结构设计</h4><ul><li>操作系统构件：内核、进程、线程、管程等</li><li>设计概念：模块化、层次化、虚拟化</li><li>内核设计是操作系统设计中最为复杂的部分</li></ul><h4 id="操作系统内核">操作系统内核</h4><ul><li>单内核：内核中各部件杂然混居</li><li>微内核：结构性部件与功能性部件分离</li><li>混合内核：微内核和单内核的折中，较多组件在核心态中运行以更快执行</li><li>外内核：减少内核的软件抽象化和传统微内核的消息传递机制，使得开发者专注于硬件的抽象化</li></ul><h4id="操作系统实现的一种层次式结构">操作系统实现的一种层次式结构：</h4><ul><li><p>用户模式：用户与文件系统</p></li><li><p>内核模式：进程交互、输入/输出设备管理、虚拟内存、基本进程管理、硬件</p></li></ul><p>另一种层次式结构：</p><ol type="1"><li>用户：命令、进程、库、环境</li><li>文件系统调用：用户进程管理、目录管理、设备文件、文件系统、管道等高阶通信</li><li>软硬件协同内核：内存与虚拟内存管理、块设备管理与输入/输出控制、核心进程管理和控制与通信原语、中断管理</li><li>硬件电路：过程机制、指令解译、电路执行</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件工程与计算II复习</title>
    <link href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/SEII%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/04/30/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/SEII%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="seii复习">SEII复习</h1><span id="more"></span><ul><li>软件需求工程</li><li>软件设计</li><li>软件构造</li><li>软件测试</li><li>软件交付</li><li>软件维护</li></ul><h2 id="包的原则">包的原则</h2><ul><li>重用发布等价原则（REP）</li><li>共同封闭原则（CCP）</li><li>共同重用原则（CRP）</li><li>无环依赖原则（ARP）</li><li>稳定依赖原则（SDP）</li><li>稳定抽象原则（SAP）</li></ul><h2 id="人机交互">人机交互</h2><h3 id="人机交互设计原则">人机交互设计原则</h3><ul><li><p>简洁</p></li><li><p>一致性</p></li><li><p>低出错</p></li><li><p>易记性</p></li><li><p>可视化</p></li><li><p>导航</p></li><li><p>反馈</p></li><li><p>差异性</p></li></ul><h2 id="耦合和内聚">耦合和内聚</h2><h3 id="耦合">耦合</h3><p>从高到低，越低越好，1、2、3不可接受</p><ol type="1"><li>内容耦合：一个模块直接修改另一个模块的内容</li><li>公共耦合：全局变量、文件、设备</li><li>重复耦合：重复代码</li><li>控制耦合：一个模块给其他模块传递控制信息</li><li>印记耦合：共享数据结构却只使用一部分</li><li>数据耦合：模块间传参只传需要的数据，最理想</li></ol><h3 id="内聚">内聚</h3><p>从高到低，越低越差，6、7不能接受</p><ol type="1"><li>信息内聚：模块进行许多操作，各自有各自的入又点，每个操作代码相对独立，而且所有操作都在相同的数据结构上进行</li><li>功能内聚：只执行一个操作或达到一个目的</li><li>通信内聚：对相同数据执行不同操作</li><li>过程内聚：含有不同步骤操作</li><li>时间内聚：具有时间相关性的相关操作</li><li>逻辑内聚：逻辑上相似但没有直接关联操作</li><li>偶然内聚：多个毫不相干的操作</li></ol><h2 id="设计原则">设计原则</h2><ol type="1"><li>全局变量有害</li><li>代码清晰可修改</li><li>避免重复</li><li>面向接口编程</li><li>迪米特法则：不能出现a.b.method()</li><li>接口隔离原则（接口最小化原则）</li><li>里氏替换原则：所有派生类都须可以替代其基类</li><li>组合代替继承</li><li>单一职责原则</li><li>最小化类和成员的可访问性</li><li>开放/封闭原则（OCP）：模块可扩展，不应修改（无switch、if/else）</li><li>依赖倒置原则（DIP）：高级模块不应依赖于低级，两者均应依赖抽象</li></ol><h2 id="设计模式">设计模式</h2><ul><li>策略模式</li><li>迭代器模式</li><li>抽象工厂模式</li><li>单件模式</li></ul><h2 id="代码设计">代码设计</h2><ul><li>单元测试用例的设计</li><li>契约式设计</li><li>防御式编程</li><li>表驱动</li></ul><h2 id="软件开发过程模型">软件开发过程模型</h2><ul><li>生命周期模型</li><li>构建-修复模型</li><li>瀑布模型</li><li>增量迭代模型</li><li>演化模型</li><li>原型模型</li><li>螺旋模型</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件工程与计算2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软工2-三-软件需求</title>
    <link href="/2023/04/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%B8%89-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/"/>
    <url>/2023/04/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%B8%89-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<p>单纯的软件系统是不能解决问题的，只有和现实世界之间形成有效互动才能实现问题的解决。</p><span id="more"></span><h1 id="第三部分-软件需求">第三部分 软件需求</h1><h2 id="一需求工程">一、需求工程</h2><h3 id="需求工程的概念">需求工程的概念</h3><p>所有需求处理活动的总和。它收集信息、分析问题、整合观点、记录需求并验证其正确性，最终描述出软件被应用后与其环境互动形成的期望效应。</p><p>三个主要任务：</p><ul><li><p>需求工程必须说明软件系统将被应用的应用环境及其目标，说明用来达成这些目标的软件行动（为什么、做什么）</p></li><li><p>需求工程必须将目标和功能反映到软件系统中，映射为可行的软件行为，并对软件行为进行准确的规格说明</p></li><li><p>现实世界是不断变化的世界，因此需求工程还需要妥善处理目标和功能随着时间演化的变动情况</p></li></ul><h3 id="需求工程的活动">需求工程的活动</h3><ul><li>需求开发<ul><li>需求获取</li><li>需求分析</li><li>需求规格说明</li><li>需求验证</li></ul></li><li>需求管理</li></ul><h4 id="需求获取">1. 需求获取</h4><p>从人、文档或者环境中利用各种方法和技术获取需求</p><ul><li>目标分析：根据问题确定目标、分析利害关系人确定目标</li><li>常见困难：用户与开发人员的认知差异</li><li>获取方法：面谈、问卷、文档分析、头脑风暴、专题讨论、原型</li></ul><h4 id="需求分析">2. 需求分析</h4><ol type="1"><li>通过建模整合各种信息</li><li>为问题定义出一个需求集合，该集合能界定一个问题的解决方案</li><li>检查需求中的错漏，加以修正</li></ol><h5 id="边界分析">(1) 边界分析</h5><ol type="1"><li>定义项目的范围</li><li>系统边界的定义要保证系统能和周围环境形成有效互动</li><li>系统用例图常被用于定义系统边界</li></ol><h5 id="需求建模">(2) 需求建模</h5><p>为展现和解释信息而进行的抽象描述活动</p><ul><li>常用类图、顺序图、状态图</li></ul><h4 id="需求规格说明">3. 需求规格说明</h4><p>在系统用户间交流需求信息</p><ul><li><p>要简洁、精确、一致和易于理解</p></li><li><p>需求工程师在该阶段的重要工作：定制文档模版、编写文档</p></li></ul><h4 id="需求验证">4. 需求验证</h4><p>需求规格说明文档的要求：</p><ol type="1"><li>每条需求都正确、准确地反映了用户意图</li><li>需求集在整体上具有整体性和一致性</li><li>文档的组织方式和需求的书写方式具有可读性和可修改性</li></ol><p>验证的方法：同级评审、原型、模拟</p><h3 id="需求管理">需求管理</h3><ol type="1"><li>保证需求作用的持续、稳定和有效发挥<ul><li>在需求开发活动后，设计、测试、实现等后续的软件系统开发活动都需要以围绕需求开展工作</li></ul></li><li>进行变更控制<ul><li>纳入实现合理的变更需求、拒绝不合理变更需求，控制变更成本和影响范围</li></ul></li></ol><h2 id="二需求基础">二、需求基础</h2><h3 id="需求的定义">需求的定义</h3><ul><li>用户为了解决问题或达到某种目标所需要的条件或能力</li><li>系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力</li><li>对上述中的一个条件或一种能力的一种文档化表述</li></ul><p>需求是一种解决问题后所能达到的期望。</p><p>问题域：</p><ul><li>现实世界运行规律的一种反映</li><li>需求的产生地与解决地</li><li>最终的软件产品要在现实中部署，它能够部分影响问题域，但不能任意改变现实<ul><li>软件开发必须尊重问题域，不能因为技术原因妄自修改现实情况</li></ul></li></ul><p>问题的解决：</p><ul><li>基础：模拟与共享现象</li><li>方法：直接、间接</li><li>解决方案：需求规格说明</li></ul><h3 id="需求开发的目标">需求开发的目标</h3><p>将现实世界问题域描述转化为计算世界的规格说明。</p><p>规格说明：软件产品的方案描述，以软件产品的运行机制为主要内容。</p><ul><li>关注对外交互的方式描述软件解决方案</li></ul><p>需求层次性</p><ul><li><p>业务需求：系统具备的特性</p></li><li><p>用户需求：系统能帮助用户做些什么</p></li><li><p>系统需求：用户对系统行为的期望</p></li></ul><h3 id="需求分类">需求分类</h3><h4 id="需求谱系">需求谱系</h4><ul><li>需求<ul><li>项目需求</li><li>过程需求</li><li>系统需求<ul><li>软件需求</li><li>硬件需求</li><li>其他需求</li></ul></li></ul></li><li>不切实际的期望</li></ul><h4 id="需求分类-1">需求分类</h4><ul><li>功能需求<ul><li>不考虑物理约束的情况下，用户希望系统能够执行的活动</li><li>主要表现为系统和环境之间的行为交互</li></ul></li><li>性能需求<ul><li>系统整体或系统组成部分应该拥有的性能特征</li></ul></li><li>质量属性<ul><li>系统完成工作的质量</li></ul></li><li>对外接口<ul><li>系统和环境中其他系统需要建立的接口</li></ul></li><li>约束<ul><li>进行系统构造时需要遵守的约束</li></ul></li></ul><h2 id="三需求分析">三、需求分析</h2><h3 id="需求分析的任务">需求分析的任务</h3><ul><li>建立分析模型，达成开发者和用户对需求信息的共同理解</li><li>依据共同的理解发挥创造性，创建软件系统解决方案</li></ul><h3 id="需求分析模型">需求分析模型</h3><p>模型是对事物的抽象，帮助人们在创建一个事物之前可以有更好的理解。</p><h4 id="面向对象方法模型">面向对象方法模型</h4><table><thead><tr class="header"><th>模型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>用例图</td><td>描述用户与系统的交互。从交互的角度说明了系统的边界和功能范围。</td></tr><tr class="even"><td>类图</td><td>描述应用领域中重要的概念以及概念之间的关系。它捕获了系统的静态结构。</td></tr><tr class="odd"><td>顺序图</td><td>描述系统中一次交互的行为过程，说明了在交互中的对象协作关系。</td></tr><tr class="even"><td>状态图</td><td>描述系统、用例或者对象在其整个生命期内的状态变化和行为过程。</td></tr></tbody></table><h4 id="结构化方法模型">结构化方法模型</h4><table><thead><tr class="header"><th>模型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>数据流图</td><td>从数据传递和加工的角度，描述了系统从输入到输出的功能处理过程。运用功能分解的方法，用层次结构简化处理复杂的问题。</td></tr><tr class="even"><td>实体关系图</td><td>描述系统中的数据对象及其关系，定义了系统中使用、处理和产生的所有数据。</td></tr></tbody></table><h4 id="建模">建模</h4><p>建立模型的过程被称为建模。</p><ul><li><p>建模是对系统进行思考和推理的一种方式</p></li><li><p>建模的目标是建立系统的一个表示，这个表示以精确一致的方式描述系统，使得系统的使用更加容易</p></li><li><p>建模的常用手段：抽象和分解</p></li></ul><h2 id="四面向对象分析">四、面向对象分析</h2><h3 id="简单过程">简单过程</h3><ul><li><p>系统用例图——细化系统的对外交互——&gt;用例模型/用例描述</p></li><li><p>用例模型/用例描述——明确用例中的协作对象——&gt;概念类图/领域模型</p></li><li><p>用例模型/用例描述——明确用例中的协作行为——&gt;顺序图、状态图、对象约束语言</p></li></ul><h3 id="用例图">1. 用例图</h3><h4 id="用例的定义">用例的定义</h4><p>在系统（或者子系统或者类）和外部对象的交互当中所执行的行为序列的描述，包括各种不同的序列和错误的序列，它们能够联合提供一种有价值的服务。</p><h4 id="用例图的基本元素">用例图的基本元素</h4><p>参与者、用例、关系、系统边界</p><ul><li>参与者（小人形）<ul><li>一个与正在开发的系统进行交互的用户或系统所扮演的角色</li><li>用例图中的一个参与者可以代表多个用户或系统、扮演多种角色</li></ul></li><li>用例（椭圆）</li><li>关系（不同的线和箭头及上面的补充文字）</li><li>系统边界（矩形）<ul><li>参与者总在系统边界外</li></ul></li></ul><h4 id="用例图的建立">用例图的建立</h4><ol type="1"><li>目标分析与解决方向的确定</li><li>寻找参与者</li><li>寻找用例</li><li>细化用例</li></ol><ul><li>如果用例的粒度不合适就需要进行细化和调整<ul><li>判断标准：用例描述了为应对一个业务事件，由一个用户发起，并在一个连续时间段内完成，可以增加业务价值的任务。</li></ul></li></ul><h4 id="常见错误">常见错误</h4><ul><li>不要把用例细化为单个操作<ul><li>例：不要将用户管理细化为增加、修改和删除三个更小的用例，因为它们要联合起来才能体现出业务价值。</li></ul></li><li>不要把同一个业务目标细化为不同用例<ul><li>例：特价策略制定和赠送策略制定。</li></ul></li><li>不要把没有业务价值的内容作为用例<ul><li>例：“登录”(应该描述为安全性质量需求)、“数据验证”(应该描述为数据需求)、“连接数据库”(属性软件内部实现而不是需求)等。</li></ul></li></ul><h3 id="概念类图">2. 概念类图</h3><p>概念类图又被称为领域模型。</p><p>类图是面向对象分析方法的核心，描述类和类之间的关系。</p><ul><li>和设计类图的不同：关注系统与外界的交互，而不是软件系统的内部构造机制</li><li>类型、方法、可见性等复杂的软件构造细节不会在概念类图中</li></ul><h4 id="概念类图的基本元素">概念类图的基本元素</h4><p>对象、类、链接、关联、继承</p><p>继承、组合、聚合、关联的图示：</p><pre><code class=" mermaid">classDiagram A &lt;|-- BC *-- DE o-- FG -- H</code></pre><h4 id="建立概念类图">建立概念类图</h4><p>先对每个用例文本描述，尤其是场景描述建立局部概念类图，再合并为整体概念类图。</p><ol type="1"><li>根据用例文本描述识别候选类<ul><li>软件系统与外界交互时可能设计的对象与类</li></ul></li><li>筛选候选类，确定概念类<ul><li>准则：依据系统需求；该类的对象实例的状态与行为是否完全必要</li><li>候选类向概念类的转化：<ul><li>需要维护状态、表现行为：概念类</li><li>需要维护状态，不需要表现行为：其他概念类的属性</li><li>不需要维护状态，需要表现行为：审视需求，转交行为</li><li>不需要维护状态、表现行为：剔除</li></ul></li></ul></li><li>识别关联</li><li>识别重要属性</li></ol><h3 id="顺序图">3. 顺序图</h3><p>也称交互图。</p><h4 id="消息种类">消息种类</h4><ul><li>同步消息：实线，实心三角箭头</li><li>异步消息：实线，&gt;</li><li>返回消息：虚线，&gt;</li></ul><h4 id="顺序图的建立">顺序图的建立</h4><ol type="1"><li>确定上下文环境</li><li>根据用例描述找到交互对象</li><li>按照用例描述中的流程顺序逐步添加信息</li></ol><h3 id="状态图">4. 状态图</h3><h4 id="概念">概念</h4><ul><li>状态：描述系统在特定时间行为的可视化状况的集合</li><li>状态转换：从一个状态到另一个状态</li><li>事件：导致系统表现一些可预测的行为</li><li>活动：作为状态转换的结果发生的过程</li></ul><h4 id="状态图的建立">状态图的建立</h4><ol type="1"><li>确立上下文环境</li><li>识别状态</li><li>建立状态转换</li><li>完善状态图</li></ol><h2 id="五需求文档化与验证">五、需求文档化与验证</h2><h3 id="用例文档">1. 用例文档</h3><p>在用户的角度以用例文本为主描述软件系统与外界的交互。</p><ul><li>基本职责是把问题域信息和需求传达给软件系统解决方案的设计者</li></ul><h4 id="用例文档结构示例">用例文档结构示例</h4><ul><li>文档的信息</li><li>用例图或用例列表</li><li>用例描述</li></ul><h3 id="软件需求规格说明文档">2. 软件需求规格说明文档</h3><p>在软件产品的角度以系统级需求列表的方式描述软件系统解决方案。</p><table><thead><tr class="header"><th>用例</th><th>系统规格</th></tr></thead><tbody><tr class="odd"><td>侧重于交互流程</td><td>侧重于独立需求</td></tr><tr class="even"><td>基于一次交互</td><td>基于一次交互中的软件系统处理细节</td></tr></tbody></table><h4 id="需求规格说明文档结构示例">需求规格说明文档结构示例</h4><ul><li>引言</li><li>总体描述</li><li>详细需求描述<ul><li>对外接口需求</li><li>功能需求</li><li>性能需求</li><li>约束</li><li>质量属性</li><li>其他需求</li></ul></li><li>附录</li><li>索引</li></ul><h3 id="文档化需求的注意事项">3. 文档化需求的注意事项</h3><h4 id="技术文档写作要点">技术文档写作要点</h4><ul><li>简洁</li><li>精确</li><li>易读<ul><li>有效使用引言、目录、索引等</li><li>使用系统化的方式组织内容信息<ul><li>使用相同的语句格式来组织相似、关联的信息</li><li>使用列表或表格来组织独立、并列的信息</li><li>使用编号来表达繁杂信息之间的关系，包括顺序、嵌套、层次关系</li></ul></li></ul></li><li>易修改<ul><li>独立性</li><li>ID</li><li>引用，不重复</li></ul></li></ul><h4 id="需求书写要点">需求书写要点</h4><ul><li>使用用户属于</li><li>可验证</li><li>可行性</li></ul><h4 id="需求规格说明文档书写要点">需求规格说明文档书写要点</h4><ul><li>充分利用标准文档模版，保持所有内容位置得当</li><li>保持文档内的需求集具有完备性和一致性</li><li>为需求划分优先级</li></ul><h3 id="验证需求文档">4. 验证需求文档</h3><p>方法：评审、开发系统测试用例、度量</p><h4 id="开发系统测试用例">开发系统测试用例</h4><ol type="1"><li>以需求为线索，开发测试用例套件</li><li>使用测试技术确定输入/输出数据，开发测试用例</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件工程与计算2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软工2-二-项目启动</title>
    <link href="/2023/04/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/"/>
    <url>/2023/04/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>原神，启动！</p><span id="more"></span><h1 id="第二部分-项目启动">第二部分-项目启动</h1><h2 id="项目和项目管理">1. 项目和项目管理</h2><h3 id="项目的概念">项目的概念</h3><p>项目是具有下列特征的一系列活动和任务：</p><ul><li>具有一个明确的目标</li><li>有限定的开始和结束日期</li><li>有成本限制</li><li>消耗人力和非人力资源</li><li>多工种合作</li></ul><h3 id="项目管理的目标">项目管理的目标</h3><p>在限定时间内、一定成本内、要求的质量水平上，高效使用资源，获得用户认可。</p><h3 id="过程组与活动">过程组与活动</h3><p>过程组：</p><ol type="1"><li>项目启动</li><li>项目计划</li><li>项目执行</li><li>项目跟踪</li><li>项目收尾</li></ol><p>活动：计划制定、团队管理、成本控制、质量保障、度量、过程管理、进度跟踪与控制、风险管理、配置管理</p><h2 id="团队组织与管理">2. 团队组织与管理</h2><ul><li>一个协作良好的团队是任何项目成功的基础</li><li>软件项目尤其依赖于有效的团队组织和管理</li><li>软件开发是一个以人为主的活动，人力资源是软件项目最大的资产</li></ul><h3 id="团队的概念">团队的概念</h3><p>为了一致的目的、绩效标准、方法而共担责任并且技能互补的少数人。</p><ul><li>团队内部要有一个明确的结构</li></ul><h3 id="团队的结构">团队的结构</h3><ul><li>主程序员团队</li><li>民主团队</li><li>开放团队</li></ul><h3 id="团队建设">团队建设</h3><ol type="1"><li><p>建立团队章程</p></li><li><p>持续成功</p><p>项目阶段性成功/团队活动成功</p></li><li><p>和谐沟通</p></li><li><p>避免团队杀手</p></li></ol><ul><li>防范式管理</li><li>官僚主义</li><li>地理分散</li><li>时间分割</li><li>产品质量的降低</li><li>虚假的最后期限</li><li>小圈子控制</li></ul><h2 id="软件质量保障">3. 软件质量保障</h2><p>软件工程师需要对软件产品的质量负责。</p><p>人们通常会选用系统的某些质量要素进行量化处理，建立质量特征，这些特征被称为质量属性。</p><p>为了根据质量属性描述和评价系统的整体质量，人们从很多质量属性的定义中选择了一些能够相互配合、相互联系的特征集，它们被称为质量模型。</p><p>质量模型的因素</p><ul><li>功能性、可靠性、易用性、效率、可维护性、可移植性</li></ul><h3 id="质量保障">质量保障</h3><table><thead><tr class="header"><th>里程碑</th><th>质量保障活动</th></tr></thead><tbody><tr class="odd"><td>需求开发</td><td>需求评审、需求度量</td></tr><tr class="even"><td>体系结构</td><td>体系结构评审、集成测试</td></tr><tr class="odd"><td>详细设计</td><td>详细设计评审、设计度量、集成测试</td></tr><tr class="even"><td>实现</td><td>代码评审、代码度量、测试</td></tr><tr class="odd"><td>测试</td><td>测试、测试度量</td></tr></tbody></table><h3 id="评审">评审</h3><ol type="1"><li><p>在规划阶段(Planning)，制定审查计划，决定审查会议的次数，安排每次审查会议的时间、地点、参与人员、审查内容等等。</p></li><li><p>在总体部署阶段(Overview)，向所有参与审查会议的人员描述待审查材料的内容、审查的目标以及一些假设，并分发文档。</p></li><li><p>在准备阶段(Preparation)，审查人员各自独立执行检查任务。在检查的过程当中，他们可能会被要求使用检查清单、场景等检查方法。检查中发现的问题会被记录下来，以准备开会讨论或者提交给收集人员。</p></li><li><p>在审查会议阶段(InspectionMeeting)，通过会议讨论，识别、确认、分类发现的错误。</p></li><li><p>在返工阶段(Rework)，修改发现的缺陷。</p></li><li><p>在跟踪阶段(Follow-up)，要确认所有发现的问题都得到了解决，所有的错误都得到了修正。</p></li></ol><h3 id="质量度量">质量度量</h3><p>度量是软件产品在特点属性的量化测试程度。</p><h2 id="软件配置管理">4. 软件配置管理</h2><h3 id="配置管理的概念">配置管理的概念</h3><p>用技术的和管理的指导和监督方法，来标识和说明配置项的功能和物理特征，控制对这些特征的变更，记录和报告变更处理及其实现状态，并验证与规格需求的一致性。</p><p>配置项：</p><p>置于软件配置管理之下的软件配置的各种有关项目，包括各类文档、评审记录与文档、软件文档、源码及其可执行码、运行所需的系统软件和支持软件以及有关数据等。</p><h3 id="配置管理活动">配置管理活动</h3><ul><li>标识配置项</li><li>版本管理</li><li>变更控制</li><li>配置审计</li><li>状态报告</li><li>软件发布管理</li></ul><h3 id="分支管理常见策略">分支管理常见策略</h3><ul><li>主分支</li><li>开发分支</li><li>临时分支<ul><li>功能</li><li>预发布</li><li>修补bug</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件工程与计算2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第十一章_并发控制</title>
    <link href="/2023/03/11/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/03/11/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第十一章-并发控制">第十一章 并发控制</h1><p>事务可以一个一个地串行执行，即每一刻都只有一个事务运行。</p><ul><li>在单处理器系统中，事务的并行执行实际上是这些并行事务的并行操作轮流交叉运行。</li><li>在多处理器系统中，可以实现真正多个事务的并行运行，称为同时并发方式。</li></ul><p>本章讨论的数据库并发控制以单处理器系统为基础。</p><h2 id="并发控制概述">11.1 并发控制概述</h2><p>事务是并发控制的基本单位。</p><p>数据库管理系统需要对并发操作进行正确调度，以保证事务的隔离性和一致性。</p><h3 id="并发操作带来的数据不一致性">并发操作带来的数据不一致性</h3><ul><li>丢失修改<ul><li>两个事务同时读入同一数据进行修改，导致其中一者的修改被丢失</li></ul></li><li>不可重复读<ul><li>一个事务读取数据后，另一个事务更新了数据，使得前一个事务再读取数据异常</li></ul></li><li>读“脏”数据（dirty read）<ul><li>一个事务修改数据，另一个事务读取了数据后，前一个事务被撤销</li></ul></li></ul><p>并发控制机制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务干扰，从而避免造成数据的不一致性。</p><p>并发控制的主要技术：</p><ul><li>封锁</li><li>时间戳</li><li>乐观控制法</li><li>多版本并发控制</li></ul><h2 id="封锁">11.2 封锁</h2><p>封锁是实现并发控制的一种非常重要的技术。封锁就是事务在操作某个数据对象前，先向系统发出请求对其加锁，避免其他事务干扰。</p><h3 id="基本的封锁类型">基本的封锁类型</h3><ul><li>排他锁（exclusive locks，又称X锁、写锁）<ul><li>事务T对数据对象A加上X锁后，只允许T读取和修改A，其他任何事务都不能对A加任何锁，直到T释放锁。</li><li>保证其他事务在T释放锁前不能再读取和修改A。</li></ul></li><li>共享锁（share locks，又称S锁、读锁）<ul><li>事务T对数据对象A加上S锁后，事务T可以读A但不能修改A，而其他事务也只能对A加S锁。</li><li>保证其他事务在T释放锁前不能修改A。</li></ul></li></ul><h3 id="封锁协议">封锁协议</h3><p>封锁协议是运用X锁和S锁的一些规则。</p><p>三级封锁协议的主要区别在于什么操作需要申请封锁，以及何时释放锁。</p><ul><li>封锁协议级别越高，一致性程度越高。</li></ul><h4 id="一级封锁协议">一级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放。</p><ul><li>不能保证可重复读和不读“脏”数据</li></ul><h4 id="二级封锁协议">二级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放；</p><p>事务T在读取数据R之前必须对其加S锁，读完即可释放S锁。</p><ul><li>不能保证可重复读</li></ul><h4 id="三级封锁协议">三级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放；</p><p>事务T在读取数据R之前必须对其加S锁，直到事务结束才释放。</p><h3 id="活锁和死锁">11.2.3 活锁和死锁</h3><h4 id="活锁">活锁</h4><p>事务由于一直被其他事务封锁而永远等待，这就是活锁。</p><p>避免活锁的简单办法是采用先来先服务的策略。</p><h4 id="死锁">死锁</h4><p>两个事务各自封锁了部分资源，又等待对方封锁的资源，这就形成了死锁。</p><p>解决死锁问题的方法：采取一定措施预防死锁；定期诊断系统中有无死锁，有则解除之。</p><h5 id="死锁的预防">死锁的预防</h5><ul><li>一次封锁法<ul><li>每个事务必须一次将所有要使用的数据全部加锁，否则就不能执行</li><li>可以有效防止死锁</li><li>缺点：<ul><li>一次加锁全部数据，扩大封锁范围，降低系统并发度</li><li>数据库数据不断变化，原本不要求封锁的数据可能也会变成封锁对象，很难事先确定每个事务要封锁的全部数据对象。为此只能进一步扩大封锁范围，降低并发度</li></ul></li></ul></li><li>顺序封锁法<ul><li>预先对数据对象规定一个封锁顺序</li><li>可以有效防止死锁</li><li>缺点：<ul><li>数据库系统中要封锁的数据对象太多，维护资源封锁顺序非常困难</li><li>事务的封锁请求可以随着事务的执行动态决定，很难事先确定，按顺序封锁</li></ul></li></ul></li></ul><h5 id="死锁的诊断和解除">死锁的诊断和解除</h5><p>一般使用超时法或事务等待图法。</p><ul><li>超时法<ul><li>一个事务的等待时间超过规定的时限，就认为发生了死锁</li><li>实现简单</li><li>缺点：<ul><li>容易误判死锁</li><li>时间若设置太长，死锁发生后不能及时发现</li></ul></li></ul></li><li>等待图法<ul><li>使用有向图表示的事务等待图动态地反映事务的等待情况。</li></ul></li></ul><p>解除死锁的方法：选择一个处理死锁代价最小的事务进行撤销，之后再加以恢复。</p><h2 id="并发调度的可串行性">11.3 并发调度的可串行性</h2><p>多个事务的并发调度是正确的，当且仅当其结果与按某一次序串行地执行这些事务的结果相同，这种调度策略称为可串行化调度。</p><p>可串行性是并发事务正确调度的准则。一个可串行化的并发调度才是正确的调度。</p><h3 id="可串行化调度的充分条件">可串行化调度的充分条件</h3><h4 id="冲突可串行化">冲突可串行化</h4><p>冲突操作是指不同的事务对同一个数据的读写操作和写写操作。</p><p>不同事务的冲突操作和同一事务的两个操作是不能交换的。</p><p>一个调度在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度。如果这另一个调度是串行的，则称原调度是冲突可串行化的调度。</p><ul><li><p>一个冲突可串行化的调度一定是可串行化的调度。</p><p>即，冲突可串行化是可串行化的充分条件。</p></li></ul><h4 id="两段锁协议">两段锁协议</h4><p>两段锁协议（简称2PL）是当前数据库管理系统普遍采用以实现并发调度可串行性的方法。</p><ul><li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁，称为扩展阶段</li><li>在释放一个封锁后，事务不再申请和获得其他封锁，称为收缩阶段</li></ul><p>事务遵守两段锁协议是可串行化调度的充分条件。</p><h2 id="封锁的粒度">11.4 封锁的粒度</h2><p>封锁对象的大小称为封锁粒度（granularity）。</p><ul><li><p>封锁粒度和系统的并发度和并发控制的开销密切相关。</p></li><li><p>一个系统同时支持多种封锁粒度供不同的事务选择是比较理想的，称为多粒度封锁。</p></li></ul><h3 id="多粒度封锁">多粒度封锁</h3><p>多粒度树：根结点是整个数据库，表示最大的数据粒度，叶结点表示最小的数据粒度。</p><p><strong>多粒度封锁协议</strong>允许多粒度树中的每一个结点被独立地加锁。</p><ul><li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样的锁<ul><li>显式封锁：应事务要求直接加到数据对象上的锁</li><li>隐式封锁：未被独立加锁，因为其上级结点加锁而被加锁</li></ul></li><li>对某个对象加锁，先要检查自身是否有显式封锁与之冲突，再要检查所有上级结点是否赋于它隐式封锁，最后还要检查其下级结点是否有冲突的显式封锁，这样效率太低<ul><li>引入意向锁</li></ul></li></ul><h3 id="意向锁">意向锁</h3><p>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；即任一结点加锁时，须对它的上层结点加意向锁。</p><p>三种常见意向锁：</p><ul><li>意向共享锁（Intent Share Lock，IS锁）<ul><li>对一个结点加S锁，先对其上级结点加IS锁</li></ul></li><li>意向排他锁（Intent Exclusive Lock，IX锁）<ul><li>对一个结点加X锁，先对其上层结点加IX锁</li></ul></li><li>共享意向排他锁（Share Intent Exclusive Lock，SIX锁）<ul><li>一个数据对象先被加了S锁，后被加了IX锁</li></ul></li></ul><p>锁的强度偏序：X—SIX—S/IX—IS</p><ul><li><p>以强锁代替弱锁是安全的，反之则不然</p></li><li><p>申请时自上而下检查，释放时自下而上</p></li></ul><h2 id="其他并发控制机制">11.5 其他并发控制机制</h2><p>时间戳方法、乐观控制法和多版本并发控制等。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第十章_数据库恢复技术</title>
    <link href="/2023/03/10/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/03/10/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第十章-数据库恢复技术">第十章 数据库恢复技术</h1><h2 id="事物的基本概念">10.1 事物的基本概念</h2><h3 id="事物">事物</h3><p>事物是用户定义的一个数据库操作序列，是一个不可分割的工作单位。</p><p>在SQL中，定义事务的语句一般有三条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>事务以<code>BEGIN TRANSACTION</code>开始，以<code>COMMIT</code>或<code>ROLLBACK</code>结束。</p><ul><li><code>COMMIT</code>表示提交</li><li><code>ROLLBACK</code>表示回滚，系统将该事务已经完成的操作全部撤销</li></ul><p>事务是恢复和并发控制的基本单位。</p><h3 id="事务的acid特性">事务的ACID特性</h3><ul><li>原子性（Atomicity）<ul><li>事务是数据库的逻辑工作单位，包括的操作要么都做，要么不做</li></ul></li><li>一致性（Consistency）<ul><li>事务执行的结果必须是数据库从一个一致性状态到另一个一致性状态</li></ul></li><li>隔离性（Isolation）<ul><li>一个事务的执行不能被其他事务干扰</li></ul></li><li>持续性（Durability）<ul><li>也称永久性，一个事务一旦提交，它对数据库中数据的改变就是永久的</li></ul></li></ul><p>保证事务ACID特性是事务管理的重要任务，可能破坏ACID的因素有：</p><ul><li>多个事务并行运行时，不同事务的操作交叉执行</li><li>事务在运行过程中被强行停止</li></ul><h2 id="数据库恢复概述">10.2 数据库恢复概述</h2><p>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态的功能。</p><ul><li>恢复子系统是数据库管理系统的一个重要组成部分</li></ul><h3 id="故障的种类">10.2.1 故障的种类</h3><ul><li>事务内部的故障<ul><li>非预期的，不能由应用程序处理的故障</li><li>恢复程序需要强行回滚该事务，这类恢复操作称为事务撤销（UNDO）</li></ul></li><li>系统故障<ul><li>又称软故障，指造成系统停止运转的任何事件，使得系统要重新启动</li><li>恢复子系统除需要撤销所有未完成的事务，还需要重做（REDO）所有已提交事务</li></ul></li><li>介质故障<ul><li>又称硬故障，指外存故障，如磁盘损坏、磁头碰撞等</li></ul></li><li>计算机病毒</li></ul><p>各类故障对数据库的影响有两种可能性：数据库本身被破坏；数据可能不正确。</p><p>恢复的基本原理：冗余</p><ul><li>数据库任何一部分被破坏或不正确的数据可以根据存储在系统别处的冗余数据来重建</li></ul><h3 id="恢复的实现技术">10.2.2 恢复的实现技术</h3><p>建立冗余数据最常用的技术是数据转储和登记日志文件。通常一个数据库系统会同时使用这两种方法。</p><h4 id="数据转储">数据转储</h4><p>数据转储是数据库恢复中采用的基本技术。数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存。这些备用的数据称为<strong>后备副本</strong>或后援副本。</p><ul><li>重装后备副本只能将数据库恢复到转储时的状态，故必须重新运行转储后的所有更新</li><li>转储十分耗费时间和资源，不能频繁进行</li></ul><p>转储可分为静态转储和动态转储：</p><ul><li>静态转储是在系统中无运行事务时进行的转储操作。<ul><li>简单，保证数据库的一致性，但会降低数据库的可用性</li></ul></li><li>动态转储是指转储期间允许对数据库进行存取或修改<ul><li>必须登记转储期间各事务对数据库的修改活动，建立日志文件</li></ul></li></ul><p>转储又可分为海量转储和增量转储：</p><ul><li>海量转储，一次转储全部数据库</li><li>增量转储，每次只转储上次转储后更新过的数据</li></ul><h4 id="日志文件">日志文件</h4><p>日志文件是用来记录事务对数据库的更新操作的文件，主要有两种格式：</p><ul><li>以记录为单位的日志文件</li><li>以数据块为单位的日志文件</li></ul><p>以记录为单位的日志文件需要登记的内容：</p><ul><li>各个事务的开始、结束标记</li><li>各个事务的所有更新操作</li></ul><p>这里每个事务的开始、结束标记和每个更新操作均作为日志文件的一个日志记录，包括：</p><ul><li>事务标识（表明是哪个事务）</li><li>操作的类型（更新、插入和删除）</li><li>操作对象</li><li>更新前数据的旧值（对于插入操作为空）</li><li>更新后数据的新值（对于删除操作为空）</li></ul><p>以数据块为单位的日志文件需要登记事务标识和被更新的数据块，将更新前和更新后的整个块放入日志文件中。</p><h5 id="日志文件的作用">日志文件的作用</h5><ul><li>事务故障恢复和系统故障恢复必须用日志文件</li><li>在动态转储方式中必须建立日志文件，结合后备副本和日志文件恢复数据库</li><li>在静态转储方式中也可以建立日志文件帮助恢复，不必重新运行已完成的事务</li></ul><h5 id="登记日志文件">登记日志文件</h5><p>为保证数据库可恢复，登记日志文件必须遵循两条原则：</p><ul><li>登记的次序严格按并发事务处理的时间顺序。</li><li>必须先写日志文件，后写数据库</li></ul><h3 id="恢复策略">10.2.3 恢复策略</h3><h4 id="事务故障的恢复">1. 事务故障的恢复</h4><p>事务故障是指事务在运行至正常终点前被终止，这时恢复子系统应利用日志文件做撤销：</p><ol type="1"><li>反向扫描日志文件，查找该事务的更新操作</li><li>对该事务的更新操作进行逆操作</li><li>继续扫描处理直到该事务的开始标记</li></ol><h4 id="系统故障的恢复">2. 系统故障的恢复</h4><p>系统故障的恢复是由系统在重新启动时自动完成的。</p><ol type="1"><li>正向扫描日志文件，找出故障发生前已经提交的事务，将其事务标记记入重做队列，同时找出故障发生时尚未完成的事务，记入撤销队列</li><li>对撤销队列中的各个事务进行撤销</li><li>对重做队列中的各个事务进行重做</li></ol><h4 id="介质故障的恢复">3. 介质故障的恢复</h4><p>恢复方法时重装数据库，重做已完成的事务。</p><ol type="1"><li>装入最新的数据库后备副本</li><li>装入相应的日志文件副本，重做已完成的事务</li></ol><h3 id="具有检查点的恢复技术">10.2.4 具有检查点的恢复技术</h3><p>在日志中增加一类新的记录——检查点记录，增加一个重新开始文件，让恢复子系统在登录日志期间动态维护日志。</p><p>检查点记录的内容：</p><ul><li>建立检查点时刻所有在执行的事务清单</li><li>这些进程是最近一个日志记录的地址</li></ul><p>动态维护日志的方法是：周期性地执行建立检查点、保存数据库状态的操作</p><ol type="1"><li>将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上。</li><li>在日志文件中写入一个检查点记录。</li><li>将当前数据缓冲区的所有数据记录写入磁盘的数据库中。</li><li>把检查点记录在日志文件中的地址写入一个重新开始文件</li></ol><p>使用检查点方法可以改善恢复效率。</p><p>系统使用检查点方法进行恢复的步骤：</p><ol type="1"><li><p>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。</p></li><li><p>由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。这里建立两个事务队列:</p><ul><li>UNDO-LIST：需要执行UNDO操作的事务集合；</li><li>REDO- LIST：需要执行REDO操作的事务集合。</li></ul></li><li><p>从检查点开始正向扫描日志文件。</p><ul><li>如有新开始的事务，把事务暂时放入UNDO-LIST队列；</li><li>如有提交的事务，把事务从UNDO-LIST队列移到REDO-LIST队列；</li></ul><p>直到日志文件结束。</p></li><li><p>对UNDO-LIST中的每个事务执行UNDO操作，对REDO-LIST中的每个事务执行REDO 操作。</p></li></ol><h3 id="数据库镜像">10.2.5 数据库镜像</h3><p>数据库镜像，即数据库管理系统根据数据管理员要求，自动把整个数据库或其中关键数据复制到另一个磁盘上。每当主数据库更新，数据库管理系统自动把更新后的数据复制过去，由数据库管理系统自动保证镜像数据和主数据库的一致性。</p><p>实际应用中，用户往往只选择对关键数据和日志文件进行镜像。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第八章_数据库编程</title>
    <link href="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AB%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/03/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AB%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第八章-数据库编程">第八章 数据库编程</h1><p>SQL编程技术可以有效克服SQL语言实现复杂应用方面的不足，提高应用系统和数据库管理系统间的互操作性。</p><p>在应用系统中使用SQL编程来访问和管理数据库中数据的方式主要有：嵌入式SQL、过程化SQL、存储过程和自定义函数、开放数据库互连、OLEDB、JDBC（Java数据库连接）等。</p><h2 id="嵌入式sql">8.1 嵌入式SQL</h2><p>将SQL语句嵌入程序设计语言中，一般采取预编译方法实现。</p><h3 id="嵌入式sql语句和主语言之间的通信">8.1.1嵌入式SQL语句和主语言之间的通信</h3><p>数据库工作单元与源程序工作单元之间的通信主要包括</p><ul><li>向主语言传递SQL语句的执行状态信息，使主语言能够据此信息控制程序流程，主要用SQL通信区（SQLCommunication Area，SQLCA）实现</li><li>主语言向SQL语句提供参数，主要用主变量实现</li><li>将SQL语句查询数据库的结果交由主语言处理，主要用主变量和游标实现</li></ul><h4 id="sql通信区">SQL通信区</h4><p>SQL语句执行后，系统反馈给应用的信息将被送到SQL通信区中。</p><ul><li>SQL通信区中变量SQLCODE用以存储每次执行SQL后返回的代码</li><li>应用每次执行完一条SQL语句后都应该测试SQLCODE的值</li></ul><h4 id="主变量">主变量</h4><p>SQL中使用的主语言程序变量简称为<strong>主变量</strong>。</p><ul><li>分为输入主变量和输出主变量<ul><li>输入主变量由应用程序赋值，SQL语句引用</li><li>输出主变量由SQL语句赋值，返回给应用程序</li></ul></li><li>一个主变量可以附带一个任选的指示变量<ul><li>指示变量是用以指示主变量的值或条件的整型变量</li></ul></li></ul><h4 id="游标">游标</h4><p>SQL面向集合，一条SQL语句可以产生或处理多条记录；主语言面向记录，一次只能处理一条记录，因此只用主变量不能完全满足SQL和主语言的协同。</p><p>游标是系统为用户开设的一个数据缓冲区，存放SQL的执行结果，每个游标区都有其名字。</p><ul><li>用户通过游标逐一获取记录并赋给主变量，交由主语言处理</li></ul><p>不用游标的SQL语句：</p><p>说明性语句、数据定义语句、数据控制语句、查询结果为单记录的选择语句、非CURRENT形式的增删改语句</p><p>使用游标的SQL语句：</p><p>多条记录的选择语句、CURRENT形式的UPDATE和DELETE语句。</p><h3 id="动态sql">8.1.2 动态SQL</h3><p>上述的嵌入式SQL语句中使用的主变量、查询目标列、条件等都是固定的，是静态SQL语句。但有些应用可能要到执行时才能够确定要提交的SQL语句，这就需要动态SQL语句。</p><h4 id="sql语句主变量">SQL语句主变量</h4><p>程序主变量包含SQL语句的内容，这样的变量称为SQL语句主变量。</p><h4 id="动态参数">动态参数</h4><p>动态参数通过PREPARE语句准备主变量和执行语句绑定数据或主变量来完成。</p><h2 id="过程化sql">8.2 过程化SQL</h2><p>过程化SQL是对SQL的扩展，使其增加了过程化语句功能。</p><p>过程化SQL的基本结构是块。所有的过程化SQL程序都是由块组成。这些块之间可以相互嵌套，每个块完成一个逻辑操作。</p><p>基本结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">定义部分：<span class="hljs-keyword">DECLARE</span> 变量、常量、游标、异常等<br><br>执行部分：<span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">SQL</span>语句、过程化<span class="hljs-keyword">SQL</span>的流程控制语句<br><span class="hljs-keyword">EXCEPTION</span> 异常处理<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>流程控制：IF-THEN-END IF、IF-THEN-ELSE-END IF</p><p>循环控制：LOOP-END LOOP、WHILE-LOOP-END LOOP、FOR-LOOP-END LOOP</p><p>错误处理：过程化SQL提供了完善的异常处理机制</p><h4 id="存储过程与函数">存储过程与函数</h4><p>过程化SQL块主要有两种类型：命名块和匿名块，上述均为匿名块，每次执行都要编译，不能存储到数据库中，也不能在其他过程化SQL块中调用。过程和函数是命名块，被编译后保存在数据库中，称为持久性存储模块，可以被反复调用。</p><p>存储过程是由过程化SQL语句编写的过程，经编译和优化后存储在数据库服务器中。</p><p>函数，也称自定义函数，是用户自己使用过程化SQL设计定义的，和存储过程不同的是必须指定返回的类型。</p><h2 id="odbc编程">8.3 ODBC编程</h2><p>提出和产生ODBC的原因是存在不同的数据库系统。</p><p>ODBC是微软公司开放体系的一部分，建立了一组访问数据库的应用程序编程接口规范（ApplicationProgramming Interface，API）。</p><ul><li>ODBC一方面规范应用开发，另一方面规范关系数据库管理系统应用接口</li></ul><p>ODBC由四部分组成：用户应用程序、ODBC驱动程序管理器、数据库驱动程序、数据源</p><h3 id="用户应用程序">用户应用程序</h3><p>使用ODBC来开发应用系统的程序简称为ODBC应用程序，包括内容：</p><ol type="1"><li>请求连接数据库</li><li>向数据源发送SQL语句</li><li>为SQL语句执行分配空间，定义所读取的数据格式</li><li>获取数据库操作结果或处理错误</li><li>进行数据处理并向用户提交处理结果</li><li>请求事务的提交和回滚操作</li><li>断开与数据源的连接</li></ol><h3 id="odbc驱动程序管理器">ODBC驱动程序管理器</h3><p>驱动程序管理器用来管理各种驱动程序。</p><p>ODBC驱动程序管理器管理应用程序和驱动程序之间的通信，主要功能包括：</p><ul><li><p>装载ODBC驱动程序</p></li><li><p>选择和连接正确的驱动程序</p></li><li><p>管理数据源（建立、配置和删除）</p></li><li><p>检查ODBC调用参数的合法性</p></li><li><p>记录ODBC函数的调用</p></li><li><p>当应用层需要时，返回驱动程序的有关信息</p></li></ul><h3 id="数据库驱动程序">数据库驱动程序</h3><p>ODBC通过数据库驱动程序来提供应用系统和数据库平台的独立性。</p><p>ODBC应用程序的操作通过驱动程序管理器提交给某个驱动程序，调用驱动程序支持的函数来存取数据库。</p><p>单束与多束：</p><ul><li>单束：数据源和应用程序在同一台机器上，驱动程序直接完成对数据文件的输入/输出操作，驱动程序相当于数据管理器</li><li>多束：支持网络环境下数据访问，驱动程序完成数据库访问请求的提交和结果集接受</li></ul><h3 id="odbc数据源管理">ODBC数据源管理</h3><p>数据源时最终用户需要访问的数据，包含了数据库位置和数据库类型等信息，是一种数据连接的抽象。</p><p>ODBC给每个被访问的数据源指定唯一的数据源名，映射到所有必要的、用来存取数据的低层软件。</p><p>在连接中，用数据源名来代表用户名、服务器名、所连接的数据库名等。最终用户无须知道数据库管理系统或其他数据管理软件、网络以及有关ODBC驱动程序的细节，数据源对最终用户是透明的。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第七章_数据库设计</title>
    <link href="/2023/03/07/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/03/07/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第七章-数据库设计">第七章 数据库设计</h1><h2 id="概述">7.1 概述</h2><p>数据库设计是指对于一个给定的应用环境，构造(设计)优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</p><ul><li><p>信息管理要求：在数据库中应该存储和管理哪些数据对象。</p></li><li><p>数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作。</p></li></ul><p>数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境。</p><p>高效率的运行环境：</p><ul><li>数据库数据的存取效率高</li><li>数据库存储空间的利用率高</li><li>数据库系统运行管理的效率高</li></ul><h3 id="数据库设计的特点">7.1.1 数据库设计的特点</h3><h4 id="数据库建设的基本规律">数据库建设的基本规律</h4><p>三分技术、七分管理、十二分基础数据</p><ul><li><p>管理：数据库建设项目管理、企业业务管理</p></li><li><p>基础数据：数据的收集、整理、组织和不断更新</p></li></ul><p>结构（数据）设计和行为（处理）设计相结合</p><ul><li>将数据库结构设计和数据处理设计密切结合</li><li>结构和行为分离的设计：<ul><li>传统软件工程：重行为设计</li><li>早期数据库设计：重结构设计</li></ul></li></ul><h3 id="数据库设计方法">7.1.2 数据库设计方法</h3><p>大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。</p><p>它要求多方面的知识和技术。主要包括：</p><ul><li><p>计算机的基础知识</p></li><li><p>软件工程的原理和方法</p></li><li><p>程序设计的方法和技巧</p></li><li><p>数据库的基本知识</p></li><li><p>数据库设计技术</p></li><li><p>应用领域的知识</p></li></ul><p>数据库设计方法：</p><ul><li>手工试凑法</li><li>规范设计法<ul><li>新奥尔良方法</li><li>基于E-R模型的数据库设计方法</li><li>3NF的设计方法</li><li>面向对象的数据库设计方法</li><li>统一建模语言（UML）方法</li></ul></li></ul><h3 id="数据库设计的基本步骤">7.1.3 数据库设计的基本步骤</h3><p>数据库设计的6个阶段：</p><ul><li>需求分析</li><li>概念结构设计：概念模型</li><li>逻辑结构设计：数据模型</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行和维护</li></ul><p>需求分析和概念设计独立于任何数据库管理系统；</p><p>逻辑设计和物理设计与选用的数据库管理系统密切相关。</p><p>参加数据库设计的人员</p><ul><li>系统分析人员和数据库设计人员<ul><li>自始至终参与数据库设计，其水平决定了数据库系统的 质量</li></ul></li><li>数据库管理员和用户代表<ul><li>主要参加需求分析与数据库的运行和维护</li></ul></li><li>应用开发人员<ul><li>包括程序员和操作员</li><li>在实施阶段参与进来，分别负责编制程序和准备软硬件 环境</li></ul></li></ul><h3 id="数据库设计过程中的各级模式">7.1.4数据库设计过程中的各级模式</h3><ul><li>需求分析阶段：综合分析应用要求</li><li>概念结构设计阶段：概念模式</li><li>逻辑结构设计阶段：逻辑模式与面向应用的外模式</li><li>物理结构设计阶段：内模式</li></ul><h2 id="需求分析">7.2 需求分析</h2><h4 id="数据字典">数据字典</h4><p>数据字典是关于数据库中数据的描述，即元数据，而非数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善的。它在数据库设计中占有重要地位。</p><p>数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。</p><ul><li>数据项：不可再分的数据单位</li><li>数据结构：由若干数据项组成，反映了数据之间的组合关系</li><li>数据流：数据结构在系统内传输的路径</li><li>数据存储：数据结构停留或保存的地方</li><li>处理过程：一般用判定表或判定树来描述</li></ul><p>需求分析阶段收集到的基础数据是下一步进行概念设计的基础。</p><h2 id="概念设计">7.3 概念设计</h2><p>将需求分析得到的用户需求抽象为信息结构的过程就是概念结构设计。</p><h3 id="概念结构设计">概念结构设计</h3><h4 id="实体与属性的划分">实体与属性的划分</h4><p>现实世界事物能作为属性的尽量作为属性对待以简化E-R图。</p><ul><li>作为属性，不能再具有需要描述的物质</li><li>属性不能与其他实体具有联系</li></ul><p>方法：自顶向下地进行需求分析，自底向上地设计概念结构</p><ul><li>首先设计各子系统E-R图，再进行集成、重构</li><li>各子系统E-R图的冲突：<ul><li>属性冲突：属性域、取值单位冲突</li><li>命名冲突：同名异义，异名同义</li><li>结构冲突</li></ul></li></ul><h3 id="e-r模型">E-R模型</h3><p>用实体-联系（E-R）图来描述现实世界的概念模型。</p><p>E-R图提供了表示实体型、属性和联系的方法。</p><ul><li>实体型用矩形表示，矩形内写明实体名</li><li>属性用椭圆形表示，用无向边将其与相应的实体型连接</li><li>联系用菱形表示，菱形内写明联系名，用无向边分别与有关实体型连接，同时在边旁标上联系的类型（1:1、1:n或m:n）</li></ul><p>E-R图的绘制：</p><p>先绘制实体属性图、实体联系图，再进行综合。</p><h4 id="e-r扩展">E-R扩展</h4><h5 id="isa联系">ISA联系</h5><p>某些实体型是某个实体型的子类型，这种父类-子类联系称为ISA联系。</p><p>ISA联系描述了实体型中实体的一种分类方法：</p><ul><li>分类属性<ul><li>使用分类属性的值把父实体型中的实体分派到子实体型中</li></ul></li><li>不相交约束和可重叠约束<ul><li>父类中的一个实体是否能同时属于多个子类中的实体集</li></ul></li><li>完备性约束<ul><li>父类中的一个实体是否必须是某一个子类中的实体<ul><li>是，称为完全特化，双线连接，否则为部分特化，单线连接</li></ul></li></ul></li></ul><h5 id="基数约束">基数约束</h5><p>基数约束是对实体之间一对一、一对多和多对多的细化。</p><p>约束使用一个数对min..max表示</p><ul><li>min = 1的约束为强制参与约束；min = 0的约束为非强制参与约束。</li></ul><h5 id="part-of联系">Part-of联系</h5><p>部分联系，表明某个实体型是另外一个实体型的一部分。</p><ul><li>非独占联系：整体被破坏，部分实体可以存在，用非强制参与联系表示<ul><li>称该部分实体为强实体型</li></ul></li><li>独占联系：整体被破坏，部分实体不能存在<ul><li>称该部分实体为弱实体型，用双矩形表示，用双菱形表示识别联系</li></ul></li></ul><h3 id="uml">UML</h3><p>暂略</p><h2 id="逻辑结构设计">7.4 逻辑结构设计</h2><p>逻辑结构设计的任务就是把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。</p><h3 id="e-r图向关系模型的转换">7.4.1 E-R图向关系模型的转换</h3><p>一般原则：</p><ul><li><p>一个实体型转换为一个关系模式，关系的属性和码就是实体的属性和码。</p></li><li><p>对于实体间的联系：</p><ul><li>1:1联系可以转换为一个独立的关系模式，也可以和任一端的关系模式合并</li><li>1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</li><li>m:n联系可以转换为一个关系模式，与该联系相连的各实体的码以及联系本身的属性均转换成关系的属性，各实体的码组成关系的码或其一部分</li><li>3个及以上实体间的一个多元联系可以转换为一个关系模式</li><li>具有相同码的关系模式可以合并</li></ul></li></ul><h3 id="数据模型的优化">7.4.2 数据模型的优化</h3><p>数据库逻辑设计的结果不是唯一的。</p><p>规范化理论指导的优化方法：</p><ol type="1"><li>确定数据依赖</li><li>对各个关系模式之间的数据依赖进行极小化处理，消除冗余联系</li><li>按照数据依赖的理论对关系模式逐一进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式</li><li>根据需求分析阶段得到的处理要求分析对于这样的应用环境这些模式是否合适，是否要对某些模式进行合并或分解<ul><li>并不是规范化程度越高的关系就越优</li></ul></li><li>对关系模式进行必要分解<ul><li>水平分解：把关系的元组分为若干子集合，定义每个子集合为一个子关系</li><li>垂直分解：把关系模式的属性分解为若干子集合，形成若干子关系模式</li></ul></li></ol><h3 id="设计用户子模式">7.4.3 设计用户子模式</h3><ul><li>使用更符合用户习惯的别名</li><li>可以对不同级别的用户定义不同的视图</li><li>简化用户对系统的使用</li></ul><h2 id="物理结构设计">7.5 物理结构设计</h2><p>数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。</p><p>为一个给定的逻辑模型选取最适合应用要求物理结构的过程，就是数据库的物理设计。其内容主要包括为关系模式选择存取方法，以及设计关系、索引等数据库文件的物理存储结构。</p><p>物理设计一般分为两步：</p><ol type="1"><li>确定数据库物理结构，在关系数据库中主要指存取方法和存储结构</li><li>对物理结构进行评价，评价的重点是时间和空间效率</li></ol><h3 id="关系模式存取方法">7.5.1 关系模式存取方法</h3><p>常用的存取方法为索引方法和聚簇方法。</p><ul><li>B+树索引存取方法</li><li>hash索引存取方法</li><li>聚簇存取方法<ul><li>为了提高某个或某些属性的查询速度，把这个或这些属性上具有相同值的元组集中存放在连续的物理块中称为聚簇，该属性或属性组称为聚簇码</li></ul></li></ul><h3 id="确定数据库的存储结构">7.5.2 确定数据库的存储结构</h3><p>确定数据库物理结构主要指确定数据的存放位置和存储结构，需要综合考虑存取时间、存取空间利用率和维护代价三方面因素。</p><h2 id="数据库的实施和维护">7.6 数据库的实施和维护</h2><h3 id="数据的载入和应用程序的调试">7.6.1数据的载入和应用程序的调试</h3><p>数据库实施阶段包括两项重要工作：数据的载入、应用程序的编码与调试</p><ul><li>组织数据入库是数据库实施阶段最主要的工作。<ul><li>数据装载办法：人工、计算机辅助数据入库</li></ul></li><li>数据库应用程序的设计应该与数据库设计同时进行</li></ul><h3 id="数据库的试运行">7.6.2 数据库的试运行</h3><ul><li>先输入小批量数据调试，合格后再输入大批量数据，逐步完成运行评价</li><li>做好数据库转储和恢复工作</li></ul><h3 id="数据库的运行和维护">7.6.3 数据库的运行和维护</h3><ul><li>数据库的转储和恢复</li><li>数据库的安全性、完整性控制</li><li>数据库性能的监督、分析和改造</li><li>数据库的重组织和重构造</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第六章_关系数据理论</title>
    <link href="/2023/03/06/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
    <url>/2023/03/06/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第六章-关系数据理论">第六章 关系数据理论</h1><h2 id="关系模式与范式">6.1 关系模式与范式</h2><h3 id="数据依赖">数据依赖</h3><p>数据依赖是一个关系内部属性和属性之间的一种约束关系，这种约束关系是通过属性间值的相等与否体现出来的数据间相关联系，是数据内在的性质，语义的体现。</p><p>最重要的数据依赖：</p><ul><li>函数依赖（Functional Dependency，FD）</li><li>多值依赖（Multi-Valued Dependency，MVD）</li></ul><h3 id="关系模式">关系模式</h3><p>在第2章中的五元组关系模式：R(U,D,DOM,F)</p><ul><li>R为符号化的元组语义</li><li>U为一组属性</li><li>D为属性组U的属性所来自的域</li><li>DOM为属性到域的映射</li><li>F为U上的一组数据依赖</li></ul><p>由于D、DOM与模式设计关系不大，本章中把关系模式看作三元组R&lt;U,F&gt;，当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系。</p><h4 id="第一范式1nf">第一范式（1NF）</h4><p>每一个分量都是不可分的数据项的关系模式。</p><p>1NF的问题：</p><p>例：U={Sno,Sdept,Mname,Cno,Grade} //学号、系、系主任名、课程号、成绩</p><ul><li><p>数据冗余</p><p>每个系的系主任名重复出现</p></li><li><p>更新异常</p><p>数据冗余使得更新数据库的代价较大</p></li><li><p>插入异常</p><p>无学生的系无法存入系和系主任的信息</p></li><li><p>删除异常</p><p>学生全部毕业，则系和系主任信息也被删除</p></li></ul><p>改进：分成三个关系模式：</p><ul><li><p>S(Sno,Sdept,Sno-&gt;Sdept)</p></li><li><p>SC(Sno,Cno,Grade,(Sno,Cno)-&gt;Grade)</p></li><li><p>DEPT(Sdept,Mname,Sdept-&gt;Mname)</p></li></ul><h2 id="规范化">6.2 规范化</h2><h3 id="函数依赖">6.2.1 函数依赖</h3><p>定义较为抽象，总结为：</p><ul><li>关系R中两个属性组X和Y，对于Y的任一取值有唯一X确定它，则Y函数依赖于X<ul><li>记为X-&gt;Y</li><li>Y包含于X，此时为平凡的函数依赖</li></ul></li><li>不存在X的真子集能函数确定Y，则Y完全函数依赖于X，否则为部分函数依赖<ul><li>完全函数依赖在箭头上写F，部分写P</li></ul></li><li>Z平凡函数依赖于Y，Y平凡函数依赖于X，则Z传递函数依赖于X</li></ul><p>以下为定义：</p><p>设R(U)是属性集U上的关系模式，X和Y是U的子集，若对R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则X函数确定Y或Y函数依赖于X，记作X-&gt;Y。</p><p>函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。</p><ul><li>X-&gt;Y，Y不包含于X，则称X-&gt;Y为非平凡的函数依赖，一般都讨论这样的函数依赖</li><li>X-&gt;Y，Y包含于X，则称X-&gt;Y为平凡的函数依赖，它对任意关系模式都必然成立</li><li>X-&gt;Y，X称为这个函数依赖的决定属性组，称为决定因素</li><li>X-&gt;Y，Y-&gt;X，记作X&lt;--&gt;Y</li></ul><p>在R(U)中，如果X-&gt;Y，并且对于X的任意真子集X'，都有X'不函数确定Y，则称Y对X完全函数依赖，记作X-&gt;^FY，</p><p>若X-&gt;Y，但Y不对X完全函数依赖，则称Y对X部分函数依赖，记作X-&gt;^PY</p><p>在R(U)中，如果X-&gt;Y不平凡，Y-&gt;Z不平凡，则称Z对X传递函数依赖，记为X-&gt;^{传递}Z</p><ul><li>如果X-&gt;Y平凡，此处为直接函数依赖</li></ul><h3 id="码">6.2.2 码</h3><p>设K是R&lt;U,F&gt;中的属性或属性组合，若U完全函数依赖于K，则K为R的候选码。</p><ul><li>若U部分函数依赖于K，则K称为超码。候选码是最小的超码。</li></ul><p>若候选码多于一个，则选定其中的一个为主码。</p><ul><li><p>包含在任何一个候选码中的属性称为主属性，反之为非主属性或非码属性。</p></li><li><p>整个属性组是码，称为全码</p></li></ul><p>关系模式R中属性或属性组X并非R的码，但是另一个关系模式的码，称X为R的外码。</p><h3 id="范式">6.2.3 范式</h3><p>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</p><p>高级范式真包含于低级范式，从高到低有5NF、4NF、BCNF、3NF、2NF、1NF。</p><p>一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程称为规范化。</p><p>定义抽象，小结：</p><ul><li>1NF：候选码能函数确定每个非主属性</li><li>2NF：候选码能完全函数确定每个非主属性</li><li>3NF：存在码能直接（而非传递）完全函数确定每个非主属性</li><li>BCNF：每个码都能函数确定任意非主属性</li></ul><h4 id="nf">2NF</h4><p>若R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R属于2NF。</p><h4 id="nf-1">3NF</h4><p>若R属于1NF，且每一个非主属性既不传递依赖于码，也不部分依赖于码，则R属于3NF。</p><h4 id="bcnf">BCNF</h4><p>关系模式R中，若每一个决定因素都包含码，则R属于BCNF。</p><ul><li>所有非主属性对每一个码都是完全函数依赖</li><li>所有主属性对每一个不包含它的码也是完全函数依赖</li><li>没有任何属性完全依赖于非码的任何一组属性</li></ul><h4 id="多值依赖">多值依赖</h4><p>设R(U)是属性集U上的一个关系模式，X，Y，Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X-&gt;-&gt;Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。</p><p>性质：</p><ul><li>对称性：X-&gt;-&gt;Y， 则X-&gt;-&gt;Z，其中Z=U-X-Y。</li><li>传递性：X-&gt;-&gt;Y，Y-&gt;-&gt;Z，则X-&gt;-&gt;Z-Y</li><li>函数依赖是多值依赖的特殊情况</li><li>若X-&gt;-&gt;Y，X-&gt;-&gt;Z，则X-&gt;-&gt;YZ，X-&gt;-&gt;Y交Z，X-&gt;-&gt;Y-Z，X-&gt;-&gt;Z-Y</li></ul><p>特点：</p><ul><li><p>多值依赖的有效性与属性集的范围有关</p></li><li><p>若函数依赖X-&gt;-&gt;Y在R(U)上成立，则对于任何Y‘包含于Y，均有X-&gt;-&gt;Y'成立。而多值依赖X-&gt;-&gt;Y若在R(U)上成立，却不能断言对于任何Y'包含于Y有X-&gt;-&gt;Y'成立。</p></li></ul><h4 id="nf-2">4NF</h4><p>限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</p><h3 id="规范化小结">6.2.4 规范化小结</h3><p>规范化的基本思想是逐步消除数据依赖的不合适部分，实质上是概念的单一化。</p><p>关系模式的规范化过程是通过对关系模式的分解来实现的。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第五章_数据库完整性</title>
    <link href="/2023/03/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    <url>/2023/03/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第五章-数据库完整性">第五章 数据库完整性</h1><p>数据库的完整性是指数据的正确性和相容性。</p><ul><li>数据的正确性是指数据是复合现实世界语义，反映当前实际情况的</li><li>数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的</li></ul><p>数据库管理系统为维护数据库完整性而实现的功能：</p><ul><li>提供定义完整性约束条件的机制</li><li>提供完整性检查的方法</li><li>进行违约处理</li></ul><p>关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能够为所有用户和应用提供一致的数据库完整性。</p><h2 id="实体完整性">5.1 实体完整性</h2><p>关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。</p><ul><li>对单属性构成的码，可以在列级定义，也可以在表级定义<ul><li>Sno CHAR(9) PRIMARY KEY</li><li>PRIMARY KEY (Sno)</li></ul></li><li>对多属性构成的码，只能在表级定义<ul><li>PRIMARY KEY(Sno, Cno)</li></ul></li></ul><p>实体完整性检查和违约处理</p><ul><li>检查主码的各个属性是否为空，有一个为空就拒绝插入或修改</li><li>检查主码值是否唯一，如果不唯一就拒绝插入或修改<ul><li>方法：全表扫描、B+树索引</li></ul></li></ul><h2 id="参照完整性">5.2 参照完整性</h2><p>关系模型的参照完整性在CREATE TABLE中用FOREIGNKEY来定义哪些列尾外码，用REFERENCES短语指明这些外码参照哪些表的主码。</p><p>参照完整性检查和违约处理</p><table><thead><tr class="header"><th>被参照表</th><th>参照表</th><th>违约处理</th></tr></thead><tbody><tr class="odd"><td>可能破坏参照完整性</td><td>插入元组</td><td>拒绝</td></tr><tr class="even"><td>可能破坏参照完整性</td><td>修改外码值</td><td>拒绝</td></tr><tr class="odd"><td>删除元组</td><td>可能破坏参照完整性</td><td>拒绝/级联删除/设置为空值</td></tr><tr class="even"><td>修改主码值</td><td>可能破坏参照完整性</td><td>拒绝/级联删除/设置为空值</td></tr></tbody></table><ul><li>拒绝（NO ACTION），一般为默认策略</li></ul><h2 id="用户定义的完整性">5.3 用户定义的完整性</h2><p>用户定义的完整性就是针对某一具体应用的数据必须满足的语义条件。</p><ul><li><p>属性上的约束条件</p><ul><li><p>非空（NOT NULL）</p></li><li><p>唯一（UNIQUE）</p></li><li><p>用CHECK语句指定列值条件</p><p><code>Sex CHAR(2) CHECK (Sex IN('男','女'))</code></p></li><li><p>修改或插入时检查；违约处理：拒绝执行</p></li></ul></li><li><p>元组上的约束条件</p><ul><li>用CHECK指定元组约束条件</li><li>修改或插入时检查；违约处理：拒绝执行</li></ul></li></ul><h2 id="完整性约束命名子句">5.4 完整性约束命名子句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>完整性约束条件名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>完整性约束条件<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student <br>(Sno <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">6</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span> (Sno <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">90000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">99999</span>), <br> Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C2 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br> Sage <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>), <br> Ssex <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C4 <span class="hljs-keyword">CHECK</span>(SSex <span class="hljs-keyword">IN</span>(<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>)), <br><span class="hljs-keyword">CONSTRAINT</span> StudentKey <span class="hljs-keyword">PRIMARY</span> KEY(Sno)<br>;)<br></code></pre></td></tr></table></figure><p>修改例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C3;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><h2 id="域中的完整性限制">5.5 域中的完整性限制</h2><p>域是一组具有相同数据类型的值的集合。</p><p>SQL中，可以用CREATEDOMAIN来创建一个域以及其应该满足的完整性约束条件以定义属性。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DOMAIN GenderDomain <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">CONSTRAINT</span> GD <span class="hljs-keyword">CHECK</span>(<span class="hljs-keyword">VALUE</span> <span class="hljs-keyword">IN</span>(<span class="hljs-string">&#x27;男&#x27;</span>，<span class="hljs-string">&#x27;女&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="断言">5.6 断言</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ASSERTION <span class="hljs-operator">&lt;</span>断言名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">CHECK</span>子句<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h2 id="触发器">5.7 触发器</h2><p>触发器（trigger）是用户定义在关系表上的一类由事件驱动的特殊过程。</p><ul><li>触发器又叫事件-条件-动作规则。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span><br>&#123;BEFORE<span class="hljs-operator">|</span>AFTER&#125; <span class="hljs-operator">&lt;</span>触发事件<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-comment">/* 指明触发器激活时间在事件前后 */</span><br><span class="hljs-keyword">REFERENCING</span> <span class="hljs-keyword">NEW</span><span class="hljs-operator">|</span><span class="hljs-keyword">OLD</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>变量<span class="hljs-operator">&gt;</span>  <span class="hljs-comment">/* 指明引用的变量 */</span><br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> &#123;<span class="hljs-type">ROW</span><span class="hljs-operator">|</span>STATEMENT&#125;<br>[<span class="hljs-keyword">WHEN</span> <span class="hljs-operator">&lt;</span>触发条件<span class="hljs-operator">&gt;</span>] <span class="hljs-operator">&lt;</span>触发动作体<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只有表的拥有者才能在表上创建触发器，且触发器数量有限</li><li>同一模式下，触发器名必须是唯一的，且触发器名和表名必须在同一模式下</li><li>触发器只能定义在基本表上，不能定义在视图上</li><li>触发事件可以是INSERT、DELETE或UPDATE，也可以是其组合</li><li>行级触发器每行都执行，语句级触发器只触发一次</li></ul><p>删除触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第四章_数据库安全性</title>
    <link href="/2023/03/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <url>/2023/03/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第四章-数据库安全性">第四章 数据库安全性</h1><h2 id="数据库安全性概述">4.1 数据库安全性概述</h2><p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</p><p>系统安全保护措施是否有效是数据库系统的主要技术指标之一。</p><h3 id="数据库的不安全因素">数据库的不安全因素</h3><ul><li>非授权用户对数据库的恶意存取和破坏</li><li>数据库中重要或敏感的数据被泄露</li><li>安全环境的脆弱性</li></ul><h3 id="安全标准简介">安全标准简介</h3><p>TCSEC/TDI</p><table><thead><tr class="header"><th>安全级别</th><th>定义</th></tr></thead><tbody><tr class="odd"><td>A1</td><td>验证设计</td></tr><tr class="even"><td>B3</td><td>安全域</td></tr><tr class="odd"><td>B2</td><td>结构化保护</td></tr><tr class="even"><td>B1</td><td>标记安全保护</td></tr><tr class="odd"><td>C2</td><td>受控的存取保护</td></tr><tr class="even"><td>C1</td><td>自主安全保护</td></tr><tr class="odd"><td>D</td><td>最小保护</td></tr></tbody></table><ul><li><p>D级，最低级别，一切不符合更高标准的系统均归于D组</p></li><li><p>C1：能够实现对用户和数据的分离，进行自主存取控制(DAC)</p></li><li><p>B1：对系统数据加以标记，并对被标记的主客体实施强制存取控制(MAC)以及审计</p></li><li><p>B1以上为安全产品</p></li></ul><p>CC（Common Criteria）：安全功能要求和安全保证要求</p><h2 id="数据库安全性控制">4.2 数据库安全性控制</h2><p>主要内容：</p><ul><li>用户身份鉴别</li><li>多层存取控制</li><li>审计</li><li>视图</li><li>数据加密</li></ul><h3 id="用户身份鉴别">4.2.1 用户身份鉴别</h3><p>常见方法：</p><ul><li>静态口令鉴别</li><li>动态口令鉴别</li><li>生物特征鉴别</li><li>智能卡鉴别</li></ul><h3 id="存取控制">4.2.2 存取控制</h3><p>存取控制机制的组成：</p><ul><li>定义用户权限<ul><li>提供适当语言以定义用户权限，编译后存储在数据字典中，称为安全规则</li></ul></li><li>合法权限检查<ul><li>根据安全规则进行合法权限检查</li></ul></li><li>定义用户权限和合法权限检查机制一起组成了数据库管理系统的存取控制子系统。</li></ul><p>C2级的数据库管理系统支持自主存取控制（Discretionary AccessControl，DAC）；</p><p>B1级的数据库管理系统支持强制存取控制（Mandatory AccessControl，MAC）。</p><ul><li>在自主存取控制中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，用户可将其拥有的存取权限转授给其他用户</li><li>在强制存取控制中，每个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取</li></ul><h4 id="自主存取控制">自主存取控制</h4><p>用户权限的两个要素：数据库对象和操作类型</p><ul><li>在数据库系统中，定义存取权限称为授权</li></ul><p>关系数据库系统中，存取控制的对象不仅有数据本身，还有数据库模式</p><table><thead><tr class="header"><th>对象类型</th><th>对象</th></tr></thead><tbody><tr class="odd"><td>数据</td><td>基本表和视图、属性列</td></tr><tr class="even"><td>数据库模式</td><td>模式、基本表、视图、索引</td></tr></tbody></table><p>SQL使用GRANT语句向用户授予权限，REVOKE语句收回已经授予用户的权限。</p><h5 id="grant">GRANT</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION]<br></code></pre></td></tr></table></figure><ul><li>如果制定了WITH GRANTOPTION子句，则授权的用户可以把这种权限转授。</li><li>GRANT ALL PRIVILEGES可以将全部操作权限授予用户</li><li>授予全部用户：TO PUBLIC</li><li>对属性列授权时必须明确指出相应的属性列名</li></ul><h5 id="revoke">REVOKE</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...[CASCADE<span class="hljs-operator">|</span>RESTRICT];<br></code></pre></td></tr></table></figure><ul><li>一般默认CASCADE，将收回全部直接或间接从该用户获得的对应权限，而RESTRICT只收回指定用户的权限</li></ul><h5 id="创建数据库模式的权限">创建数据库模式的权限</h5><p>创建数据库模式一类的数据库对象的授权由数据库管理员在创建用户时完成。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WITH</span>] [DBA<span class="hljs-operator">|</span>RESOURCE<span class="hljs-operator">|</span><span class="hljs-keyword">CONNECT</span>];<br></code></pre></td></tr></table></figure><ul><li>只有系统的超级用户才有权创建一个新的数据库用户</li><li>新创建的数据库用户有三种权限：CONNECT、RESOURCE、DBA，默认CONNECT<ul><li>CONNECT权限用户不能创建新用户、模式、基本表</li><li>RESOURCE权限用户可以创建基本表，不能创建新用户和模式</li><li>DBA权限用户是系统的超级用户，可以创建新用户、模式和基本表，拥有所有数据库对象的存取权限</li></ul></li></ul><h5 id="数据库角色-role">数据库角色 ROLE</h5><p>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。</p><ul><li>为一组具有相同权限的用户创建一个角色，简化授权的过程</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ROLE <span class="hljs-operator">&lt;</span>角色名<span class="hljs-operator">&gt;</span>;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">3</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> ADMIN OPTION]<br><br><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br></code></pre></td></tr></table></figure><ul><li>如果指定了WITH ADMIN OPTION，那么获得权限的用户可以转授该权限。</li></ul><h4 id="强制存取控制">强制存取控制</h4><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类。</p><ul><li><p>主体是系统中的活动实体，既包括数据管理系统所管理的实际用户，也包括代表用户的各进程</p></li><li><p>客体是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引等。</p></li><li><p>对于主体和客体，数据库管理系统为它们每个实例指派一个敏感度标记（label）</p><p>敏感度标记被分为若干级别，如绝密（TopSecret，TS），机密（Secret，S），可信（Confidential，C），公开（Public，P），TS&gt;=S&gt;=C&gt;=P</p><p>主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级</p><ul><li>仅当主体的许可证级别大于等于客体的密级时，该主体才能读取该客体</li><li>仅当主体的许可证级别小于等于客体的密级时，该主体才能写该客体</li><li>即用户只能读低于或等于自己许可的数据，创建高于或等于自己许可的数据，以防止高级用户将数据泄露给低级用户</li></ul></li><li><p>强制存取控制对数据本身加以的密级标识和数据时一个整体</p></li></ul><h5id="自主存取控制强制存取控制dacmac">自主存取控制+强制存取控制（DAC+MAC）</h5><p>先进行自主存取控制审查，在进行强制存取控制检查</p><h2 id="一些安全性保护办法">4.3 一些安全性保护办法</h2><h3 id="视图机制">4.3.1 视图机制</h3><p>把要保密的数据对无权存取的用户隐藏起来，为数据提供一定程度的安全保护。</p><h3 id="审计audit">4.3.2 审计（audit）</h3><p>审计功能把用户对数据库的所有操作自动记录下来放入审计日志（auditlog）。</p><ul><li>审计通常是很费时间和空间的，所以数据库系统往往都将审计设置成可选的</li><li>审计设置以及审计日志一般存储在数据字典中，必须开启审计开关（设置audit_trail为true），才能在系统表SYS_AUDITTRAIL中看到审计信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">AUDIT <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>;<br><br>NOAUDIT <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>审计一般可以分为用户级审计和系统级审计。</p><p>数据库安全审计系统提供了一种事后检查的安全机制。安全审计机制将特定用户或者特定对象相关的操作记录到系统审计日志中，作为后续对操作的查询分析和追踪的依据。通过审计机制，可以约束用户可能的恶意操作。</p><h3 id="数据加密">4.3.3 数据加密</h3><p>加密的基本思想是依据一定的算法将原始数据——明文（plaintext）变换为不可直接识别的格式——密文（cipher text）。</p><p>数据加密主要包括存储加密和传输加密。</p><ul><li>存储加密<ul><li>透明存储加密：内核级加密保护，对用户完全透明</li><li>非透明存储加密：通过多个加密函数实现</li></ul></li><li>传输加密<ul><li>链路加密：对传输数据在链路层进行加密，加密报文和报头</li><li>端到端加密：在发送端加密，接收端解密，加密报文</li></ul></li></ul><h3 id="其他安全性保护">4.3.4 其他安全性保护</h3><ul><li><p>推理控制：避免由低级数据推导出高级数据</p></li><li><p>隐蔽信道：间接信息传递</p></li><li><p>数据隐私：控制不愿他人知道或他人不便知道的个人数据的能力</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第三章_SQL</title>
    <link href="/2023/03/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%89%E7%AB%A0_SQL/"/>
    <url>/2023/03/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%89%E7%AB%A0_SQL/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第三章-sql">第三章 SQL</h1><p>结构化查询语言（Structured QueryLanguage，SQL）是关系数据库标准语言，功能包括</p><ul><li>数据库的查询</li><li>数据库模式创建</li><li>数据库数据的插入与修改</li><li>数据库安全性完整性定义与控制</li><li>……</li></ul><h2 id="sql概述">3.1 SQL概述</h2><h3 id="sql的特点">3.1.1 SQL的特点</h3><ul><li>综合统一<ul><li>集数据定义语言、数据操纵语言、数据控制语言于一体</li></ul></li><li>高度非过程化<ul><li>存取路径的选择以及SQL的操作过程由系统自动完成</li></ul></li><li>面向集合的操作方式<ul><li>操作对象、查找结果都可以是元组的集合</li></ul></li><li>以同一种语法结构提供多种使用方式<ul><li>能嵌入到C++、Java中</li></ul></li><li>语言简洁，易学易用<ul><li>数据查询：SELECT</li><li>数据定义：CREATE、DROP、ALTER</li><li>数据操纵：INSERT、UPDATE、DELETE</li><li>数据控制：GRANT、REVOKE</li></ul></li></ul><h3 id="sql的基本概念">3.1.2 SQL的基本概念</h3><h4 id="sql与三级模式">SQL与三级模式</h4><ul><li>内模式：存储文件</li><li>模式：基本表</li><li>外模式：视图</li></ul><p>用户可以用SQL对基本表和视图进行查询或其他操作。基本表和视图都是关系。</p><p>基本表是本事独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表，一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。</p><p>存储文件的逻辑结构组成了关系数据库的内模式，其逻辑结构对用户是隐蔽的。</p><p>视图是一个或几个基本表导出的表，它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据。这些数据仍存放在导出视图的基本表中，因而视图仅仅是一个虚表。用户可以在视图上再定义视图。</p><h2 id="数据定义">3.2 数据定义</h2><p>层次化的数据库对象命名机制：</p><p>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</p><p>SQL的数据定义：模式定义、表定义、视图定义和索引定义</p><table><thead><tr class="header"><th>操作对象</th><th>创建</th><th>删除</th><th>修改</th></tr></thead><tbody><tr class="odd"><td>模式</td><td>CREATE SCHEMA</td><td>DROP SCHEMA</td><td></td></tr><tr class="even"><td>表</td><td>CREATE TABLE</td><td>DROP TABLE</td><td>ALTER TABLE</td></tr><tr class="odd"><td>视图</td><td>CREATE VIEW</td><td>DROP VIEW</td><td></td></tr><tr class="even"><td>索引</td><td>CREATE INDEX</td><td>DROP INDEX</td><td>ALTER INDEX</td></tr></tbody></table><h3 id="模式">模式</h3><p>定义模式即定义了一个命名空间，在此空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">AUTHORIZATION</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-operator">&lt;</span>表定义子句<span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>视图定义子句<span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>授权定义子句<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure><p>不指定模式名时，模式名将隐含为用户名。</p><p>删除模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>CASCADE<span class="hljs-operator">|</span>RESTRICT<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><ol type="1"><li>CASCADE：删除模式的同时删除该模式中所有数据库对象</li><li>RESTRICT：如果该模式中定义了下属的数据库对象，则拒绝执行删除</li></ol><h3 id="基本表">基本表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]<br>[，<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]]<br>…<br>[，<span class="hljs-operator">&lt;</span>表级完整性约束条件<span class="hljs-operator">&gt;</span>]);<br></code></pre></td></tr></table></figure><p>列级完整性：PRIMARY KEY、UNIQUE、NOT NULL等</p><p>表级完整性：PRIMARY KEY(Sno, Cno)；FOREIGN KEY(Cno) REFERENCESCourse(Cno)</p><table><thead><tr class="header"><th>数据类型</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>CHAR(n),CHARACTER(n)</td><td>长度为n的定长字符串</td></tr><tr class="even"><td>VARCHAR(n)</td><td>最大长度为n的变长字符串</td></tr><tr class="odd"><td>CLOB</td><td>字符串大对象</td></tr><tr class="even"><td>BLOB</td><td>二进制大对象</td></tr><tr class="odd"><td>INT，INTEGER</td><td>长整数(4字节)</td></tr><tr class="even"><td>SMALLINT</td><td>短整数(2字节)</td></tr><tr class="odd"><td>BIGINT</td><td>大整数(8字节)</td></tr><tr class="even"><td>NUMERIC(p，d)</td><td>定点数，由p位数字(不包括符号、小数点)组成，小数后面有d位数字</td></tr><tr class="odd"><td>DECIMAL(p, d), DEC(p, d)</td><td>同NUMERIC</td></tr><tr class="even"><td>REAL</td><td>取决于机器精度的单精度浮点数</td></tr><tr class="odd"><td>DOUBLE PRECISION</td><td>取决于机器精度的双精度浮点数</td></tr><tr class="even"><td>FLOAT(n)</td><td>可选精度的浮点数，精度至少为n位数字</td></tr><tr class="odd"><td>BOOLEAN</td><td>逻辑布尔量</td></tr><tr class="even"><td>DATE</td><td>日期，包含年、月、日，格式为YYYY-MM-DD</td></tr><tr class="odd"><td>TIME</td><td>时间，包含一日的时、分、秒，格式为HH:MM:SS</td></tr><tr class="even"><td>TIMESTAMP</td><td>时间戳类型</td></tr><tr class="odd"><td>INTERVAL</td><td>时间间隔类型</td></tr></tbody></table><p>修改基本表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <br>[<span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>新列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [完整性约束]]<br>[<span class="hljs-keyword">ADD</span> <span class="hljs-operator">&lt;</span>表级完整性约束<span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">DROP</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [CASCADE<span class="hljs-operator">|</span> RESTRICT]]<br>[<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span><span class="hljs-operator">&lt;</span>完整性约束名<span class="hljs-operator">&gt;</span>[RESTRICT <span class="hljs-operator">|</span> CASCADE]]<br>[<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>]；<br></code></pre></td></tr></table></figure><ul><li><p>ADD用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件</p></li><li><p>DROP COLUMN用于删除表中列</p></li><li><p>DROP CONSTRAINT用于删除指定的完整性约束条件</p></li><li><p>ALTER COLUMN用于修改原有列定义，包括列名和数据类型</p></li></ul><h3 id="索引">索引</h3><p>作用：加快查询速度</p><p>建立索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>顺序<span class="hljs-operator">&gt;</span>]…);<br></code></pre></td></tr></table></figure><ul><li><p>顺序：</p><ul><li>升序：ASC</li><li>降序：DESC</li><li>缺省值：ASC</li></ul></li><li><p>UNIQUE：每个索引值只对应唯一的数据记录</p></li><li><p>CLUSTER：表示要建立的索引是聚簇索引</p></li></ul><p>修改索引：<code>ALTER INDEX &lt;旧名称&gt; RENAME TO &lt;新名称&gt;</code>;</p><p>删除索引：<code>DROP INDEX &lt;名称&gt;;</code></p><h2 id="数据查询">3.3 数据查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span><span class="hljs-operator">|</span><span class="hljs-keyword">DISTINCT</span>] <span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span>]…<br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表<span class="hljs-operator">/</span>视图名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>表<span class="hljs-operator">/</span>视图名<span class="hljs-operator">&gt;</span>]… <span class="hljs-operator">|</span> (<span class="hljs-keyword">SELECT</span>语句) [<span class="hljs-keyword">AS</span>] <span class="hljs-operator">&lt;</span>别名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件表达式<span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>条件表达式<span class="hljs-operator">&gt;</span>]]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]<br></code></pre></td></tr></table></figure><ul><li>DISTINCT：去除重复行，缺省为ALL</li><li>WHERE表示指定条件，作用于表<ul><li>BETWEEN AND（范围）、IN（集合）、LIKE（匹配字符）、ISNULL（空值）、AND OR（多重条件查询）、ORDER BY（升降排列）</li></ul></li><li>聚集函数只用于SELECT和GROUP BY中的HAVING子句<ul><li>COUNT、SUM、AVG、MAX、MIN（需要指定DISTINCT或ALL）</li></ul></li><li>GROUP BY按照某一列或多列的值分组<ul><li>指定属性值相同的元组为一组，然后对每一组作用聚集函数进行计算</li></ul></li></ul><table><thead><tr class="header"><th>查询条件</th><th>谓词</th></tr></thead><tbody><tr class="odd"><td>比较</td><td>=, &gt;, &lt;, &gt;=, &lt;=, !=, &lt;&gt;, !&gt;, !&lt;;NOT+上述比较运算符</td></tr><tr class="even"><td>确定范围</td><td>BETWEEN AND, NOT BETWEEN AND</td></tr><tr class="odd"><td>确定集合</td><td>IN, NOT IN</td></tr><tr class="even"><td>字符匹配</td><td>LIKE, NOT LIKE</td></tr><tr class="odd"><td>空值</td><td>IS NULL, IS NOT NULL</td></tr><tr class="even"><td>多重条件(逻辑运算)</td><td>AND, OR, NOT</td></tr></tbody></table><h4 id="字符匹配">字符匹配</h4><p>匹配串可以是一个完整的字符串，也可以含有通配符%(任意长度字符串)和_(任意单个字符)</p><p>用。</p><h4 id="空值">空值</h4><ul><li>产生：没赋值/修改/外连接/关系运算</li><li>判断：IS NULL / IS NOT NULL (注意IS一直有)</li><li>约束条件：NOT NULL / UNIQUE / PRIMARY KEY不能取空值</li><li>逻辑运算：TRUE FALSE UNKNOWN</li></ul><h4 id="聚集函数">聚集函数</h4><p>统计元组个数：COUNT(*)</p><p>统计一列中值的个数：COUNT([DISTINCT | ALL] <列名>)</p><p>计算一列值的总和(必须为数值型)：SUM([DISTINCT | ALL] <列名>)</p><p>计算一列值的平均值(必须为数值型)：AVG([DISTINCT | ALL] <列名>)</p><p>求最大最小值：MAX / MIN([DISTINCT | ALL] 列名)</p><h4 id="连接查询">连接查询</h4><p>连接查询即同时涉及两个以上表的查询，连接条件或连接谓词是连接两表的条件</p><p><列1> <比较运算符> <列2></p><p><列1> BETWEEN <列2> AND <列3></p><p>连接字段：连接谓词中的列名称。</p><ul><li><p>等值/自然连接：连接运算符为=。</p></li><li><p>自身连接：表与自己进行连接：需要给表起别名，并使用别名前缀以示区别。</p></li><li><p>多表连接</p></li></ul><p>连接操作的执行过程</p><ol type="1"><li>嵌套循环</li></ol><p>逐个对表1中每个元组执行遍历表2的连接操作。</p><ol start="2" type="1"><li>排序合并</li></ol><p>首先按连接属性对两表排序，然后查找表1中元组在表2中的连接，查找到大于表1字段值的元组后，查询不再继续。</p><ol start="3" type="1"><li>索引连接</li></ol><p>对表2按连接字段建立索引，依次查询表1中各元组的连接。</p><p>外连接：以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</p><p>SELECT <字段名> FROM <表名> LEFT JOIN <表名> ON <连接条件></p><h4 id="嵌套查询">嵌套查询</h4><p><字段名> IN/比较运算符 (ANY/ALL) <查询语句> (NOT) EXISTS<查询语句></p><h4 id="集合操作">集合操作</h4><ul><li>并 UNION、交 INTERSECT、差 EXCEPT</li></ul><p>参与集合操作的各查询结果的列数和各数据类型必须相同。</p><p>UNION：合并多个查询结果，去掉重复元组</p><p>UNION ALL：合并多个查询结果，保留重复元组</p><h4 id="派生表查询">派生表查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> (查询语句);<br></code></pre></td></tr></table></figure><p>若子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT语句子句后列名为其缺省属性。</p><h2 id="数据更新">3.4 数据更新</h2><ul><li><p>插入：INSERT INTO <表名> [<属性列>,…] VALUES (<常量>,…)</p><ul><li>指定要插入数据的表名及属性列，插入的元组在其余属性列取空值。</li><li>未指定属性列：插入完整元组，且属性列属性的顺序和表一致。</li><li>VALUES提供的值的个数与类型必须与INTO子句匹配。</li></ul></li><li><p>修改：UPDATE <表名> SET <列名>=<表达式>,… [WHERE 条件]</p></li><li><p>删除：DELETE FROM <表名> [WHERE 条件]</p></li></ul><h2 id="视图">3.5 视图</h2><p>视图是虚表，从一个或几个基本表导出，只存放定义而无数据，基表中数据变化，视图中数据也随之改变。</p><p>视图的更新是同步于基本表的，一般来说，行列子集视图可以更新，其他（如AVG）不可。</p><p>视图的作用：</p><ul><li>简化用户的操作</li><li>使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性<ul><li>外模式不变，即使模式变更也不影响</li></ul></li><li>对机密数据提供安全保护<ul><li>每个用户看到的视图不同</li></ul></li><li>可以更清晰地表达查询</li></ul><p>视图做不到的：</p><ul><li>部分特殊视图不允许更新</li><li>视图消解有局限性，有时不能正确地查询</li></ul><h3 id="建立视图">建立视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>,…)]<br><span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>子查询<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure><ul><li><p>WITH CHECKOPTION：对视图进行UPDATE、INSERT和DELETE时要保证更新的行满足视图定义中的谓词条件(即子查询中的条件表达式)。</p><ul><li>子查询可以是任意的select语句。</li></ul></li><li><p>行列子集视图：从单个表导出某些列，保留主码</p></li><li><p>组成视图的属性列名：全部省略或全部指定</p></li><li><p>实现增删改视图--&gt;增删改基本表：不写聚集函数</p></li></ul><p>关系数据库管理系统在执行CREATEVIEW的时候只是将视图定义存入数据字典，并不执行SELECT。查询时，按定义将其查出。</p><h3 id="删除视图">删除视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [CASCADE];<br></code></pre></td></tr></table></figure><p>CASCADE：级联地删除视图及其导出的视图。</p><h3 id="查询视图">查询视图</h3><p>用户查询视图与查询基本表一致。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第二章_关系数据库</title>
    <link href="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/03/02/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第二章-关系数据库">第二章 关系数据库</h1><h2 id="关系数据结构及其形式化定义">2.1 关系数据结构及其形式化定义</h2><h3 id="关系">2.1.1 关系</h3><h4 id="关系数据结构的形式化定义">关系数据结构的形式化定义</h4><ol type="1"><li>域（domain）</li></ol><p>域是一组具有相同数据类型的值的集合</p><ol start="2" type="1"><li>笛卡尔积（cartesian product）</li></ol><p>笛卡尔积是域上的一种集合运算。</p><p>给定一组域<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>，允许其中某些域是相同的，<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>的笛卡尔积为</p><p><span class="math inline">\(D_1\times D_2\times ...\timesD_n=\{(d_1,d_2,...,d_n)|d_i\in D_i,i=1,2,...,n\}\)</span></p><p>其中，每个元素<spanclass="math inline">\((d_1,d_2,...,d_n)\)</span>称作一个n元组（n-tuple），或简称元组。元组中的每一个值<spanclass="math inline">\(d_i\)</span>称为一个分量。</p><p>一个域允许的不同取值个数称为这个域的基数（cardinal number）。</p><p>若<span class="math inline">\(D_i\)</span>为有限集，其基数为<spanclass="math inline">\(m_i(i=1,2,...,n)\)</span>，则<spanclass="math inline">\(D_1\times D_2\times ...\timesD_n\)</span>的基数M为</p><p><span class="math inline">\(M=\prod_{i=1}^n m_i\)</span></p><ol start="3" type="1"><li>关系</li></ol><p><span class="math inline">\(D_1\times D_2\times ...\timesD_n\)</span>的子集称为在域<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>上的关系，表示为<spanclass="math inline">\(R(D_1,D_2,...,D_n)\)</span>。</p><p>这里R表示关系的名字，n是关系的目或度（degree），关系中的每个元素是关系中的元组，通常用t表示。</p><ul><li>当<spanclass="math inline">\(n=1\)</span>时，称该关系为一元关系（unaryrelation）</li><li>当<spanclass="math inline">\(n=2\)</span>时，称该关系为二元关系（binaryrelation）</li></ul><p>关系是笛卡尔积的有限子集，故关系是一张每行对应一个元组的二维表，表的每列对应一个域。每列的名字为属性，n目关系必有n个属性。</p><p>若关系中的某一属性组能唯一地标识一个元组而其子集不能，则称该属性组为候选码（candidatekey）。</p><p>若一个关系有多个候选码，则选定其中一个为主码（primary key）。</p><p>候选码地各个属性为主属性（primeattribute）。不包含在任何候选码中的属性称为非主属性或非码属性。</p><p>在最简单地情况下，候选码只包含一个属性，在最极端地情况下，关系模式地所有属性是这个关系模式地候选码，称为全码（all-key）。</p><h5 id="关系的三种类型">关系的三种类型</h5><p>基本表、查询表和视图表，其中基本表为实际存在的表，查询表是查询结果对应的表，视图表是由基本表或其他视图表导出的表，是虚表。</p><h5 id="基本关系的性质">基本关系的性质</h5><ol type="1"><li>列是同质的，每一列中的分量是同一类型的数据，来自同一个域</li><li>不同的列可来自同一个域，但有不同的属性名</li><li>列和行都是无序的</li><li>任意两个元组的候选码不能取相同值</li><li>每个分量都是不可分的数据项</li></ol><p>关系模型要求关系必须是规范化的，满足一定的规范条件。规范化的关系称为范式（NormalForm，NF）。</p><h3 id="关系模式与关系数据库">2.1.2 关系模式与关系数据库</h3><p>关系的描述称为关系模式，可以形式化地表示为<spanclass="math inline">\(R(U,D,DOM,F)\)</span>。</p><p>其中R是关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间关系的依赖关系集合。</p><p>其中，<span class="math inline">\(DOM(属性名)=域名\)</span>。</p><p>关系模式可以简记为<spanclass="math inline">\(R(U)或R(A_1,A_2,...,A_n)\)</span>。其中<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>为属性名。</p><p>关系数据库的型称为关系数据库模式，包括若干域的定义和在这些域上定义的若干关系模式，是对关系数据库的描述。</p><p>关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</p><h2 id="关系操作">2.2 关系操作</h2><h3 id="基本关系操作">2.2.1 基本关系操作</h3><p>关系操作的对象和结果都是集合，这种方式也称为一次一集合方式，相应地，非关系数据模型的数据操作方式则为一次一记录的方式。</p><p>关系模型中常用的关系操作包括查询(query)操作和插入(insert)、删除(delete)、修改(update)操作两部分。</p><p>查询操作是关系操作中最主要的部分，包括：</p><p>选择(select)、投影(project)、连接(join)、除(divide)、并(union)、差(except)、交(intersection)、笛卡尔积等。</p><p>查询操作中，选择、投影、并、差、笛卡尔积是5种基本操作，其他操作可用基本操作来定义和导出。</p><h3 id="关系数据语言的分类">2.2.2 关系数据语言的分类</h3><p>早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数（relationalgebra）和关系演算（relation calculus）。</p><ul><li>关系代数用对关系的运算来表达查询要求</li><li>关系演算则用谓词来表达查询要求<ul><li>关系演算按谓词变元的基本对象是元组还是域变量分为元组关系演算和域关系演算</li></ul></li></ul><p>一个关系数据语言能够表示关系代数可以表示的查询，称为具有完备的表达能力，简称关系完备性。已经证明关系代数、元组关系演算和域关系演算在表达能力上是等价的。</p><p>结构化查询语言（Structured QueryLanguage，SQL）介于关系代数和关系演算之间。</p><p>SQL兼具查询、数据定义、数据控制功能，是集查询、数据定义语言、数据操纵语言和数据控制语言为一体的关系数据语言。</p><ul><li>SQL是一种高度非过程化的语言。</li></ul><h2 id="关系的完整性">2.3 关系的完整性</h2><p>关系模型中有三类完整性约束：实体完整性（entityintegrity）、参照完整性（referentialintegrity）和用户定义的完整性（user-defined integrity）</p><h3 id="实体完整性">实体完整性</h3><p>实体完整性规则：若属性A（一个或一组属性）是基本关系R的主属性，则A不能取空值</p><h3 id="参照完整性">参照完整性</h3><p>设F是基本关系R的一个或一组属性，但不是关系R的码，<spanclass="math inline">\(K_S\)</span>是基本关系S的主码。如果F与<spanclass="math inline">\(K_s\)</span>对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。</p><p>参照完整性规则：若属性F是基本关系R的外码，它与基本关系S的主码<spanclass="math inline">\(K_s\)</span>相对应，则对于R中每个原则在F上的值必须或者取空值，或者等于S中某个元组的主码值。</p><h3 id="用户定义的完整性">用户定义的完整性</h3><p>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</p><h2 id="关系代数">2.4 关系代数</h2><p>关系代数用对关系的运算来表达查询。</p><ul><li>关系代数的运算又分为传统的集合运算和专门的关系运算两类<ul><li>集合运算符：并<span class="math inline">\(\cup\)</span>、差<spanclass="math inline">\(-\)</span>、交<spanclass="math inline">\(\cap\)</span>、笛卡尔积<spanclass="math inline">\(\times\)</span></li><li>专门关系运算符：选择<spanclass="math inline">\(\sigma\)</span>、投影<spanclass="math inline">\(\prod\)</span>、连接<spanclass="math inline">\(\Join\)</span>、除<spanclass="math inline">\(\div\)</span></li></ul></li></ul><h3 id="传统的集合运算">2.4.1 传统的集合运算</h3><p>传统的集合运算是二目运算，包括并、差、交、笛卡尔积4种运算</p><p>（1）并（union）：<span class="math inline">\(R\cup S=\{t|t\in R \veet\in S\}\)</span></p><p>（2）差（except）：<span class="math inline">\(R-S=\{t|t\in R\wedget\notin S\}\)</span></p><p>（3）交（intersection）：<span class="math inline">\(R\cap S=\{t|t\inR\wedge t\in S\}\)</span></p><p>（4）笛卡尔积（cartesian product）：<spanclass="math inline">\(R\times S=\{t_rt_s|t_r\in R\wedge t_s\inS\}\)</span></p><h3 id="专门的关系运算">2.4.2 专门的关系运算</h3><p>专门的关系运算包括选择、投影、连接、除运算等。</p><p>引入几个记号：</p><ul><li><p>设关系模式为 <spanclass="math inline">\(R(A_1,A_2,...,A_n)\)</span>，它的一个关系设为<spanclass="math inline">\(R\)</span>。<span class="math inline">\(t\inR\)</span> 表示 <span class="math inline">\(t\)</span> 是 <spanclass="math inline">\(R\)</span> 的一个元组。<spanclass="math inline">\(t[A_i]\)</span> 则表示元组 <spanclass="math inline">\(t\)</span> 中相应于属性 <spanclass="math inline">\(A_i\)</span> 的一个分量。</p></li><li><p>若 <spanclass="math inline">\(A=\{A_{i1},A_{i2},...,A_{ik}\}\)</span>，其中<span class="math inline">\(A_{i1},A_{i2},...,A_{ik}\)</span> 是 <spanclass="math inline">\(A_1,A_2,...,A_n\)</span> 中的一部分，称<spanclass="math inline">\(A\)</span>为属性列或属性组。<spanclass="math inline">\(t[A]=(t[A_{i1}],t[A_{i2}],...,t[A_{in}])\)</span>为元组<spanclass="math inline">\(t\)</span>在属性列<spanclass="math inline">\(A\)</span>上诸分量的集合，<spanclass="math inline">\(\overline{A}\)</span>则表示<spanclass="math inline">\(\{A_1,A_2,...,A_n\}\)</span>中去掉<spanclass="math inline">\(\{A_{i1},A_{i2},...,A_{in}\}\)</span>后剩余的属性组。</p></li><li><p><span class="math inline">\(R\)</span>为<spanclass="math inline">\(n\)</span>目关系，<spanclass="math inline">\(S\)</span>为m目关系。<spanclass="math inline">\(t_r\in R\)</span>，<spanclass="math inline">\(t_s\in S\)</span>，<spanclass="math inline">\(t_rt_s\)</span>称为元组的连接或串接。它是一个<spanclass="math inline">\(n+m\)</span>列的新元组，前<spanclass="math inline">\(n\)</span>个分量为<spanclass="math inline">\(R\)</span>中的一个<spanclass="math inline">\(n\)</span>元组，后<spanclass="math inline">\(m\)</span>个分量为<spanclass="math inline">\(S\)</span>中的一个<spanclass="math inline">\(m\)</span>元组。</p></li><li><p>给定一个关系<span class="math inline">\(R(X,Y)\)</span>，<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Z\)</span>为属性组。当<spanclass="math inline">\(t[X]=x\)</span>时，<spanclass="math inline">\(x\)</span>在<spanclass="math inline">\(R\)</span>中的象集定义为</p><p><span class="math inline">\(Z_=\{t[Z]|t\in R,t[X]=x\}\)</span></p><p>它表示<span class="math inline">\(R\)</span>在属性组<spanclass="math inline">\(X\)</span>上值为<spanclass="math inline">\(x\)</span>的诸元组在<spanclass="math inline">\(Z\)</span>上分量的集合。</p></li></ul><h4 id="专门关系运算的定义">专门关系运算的定义</h4><h5 id="选择selection">选择（selection）</h5><p>选择又称为限制（restriction），是在关系<spanclass="math inline">\(R\)</span>中选择满足给定条件的诸元组，记作<spanclass="math inline">\(\sigma _F(R)=\{t|t\in R\wedgeF(t)=true\}\)</span></p><p>其中<spanclass="math inline">\(F\)</span>表示选择条件，它是一个逻辑表达式，取逻辑值真或假。</p><h5 id="投影projection">投影（projection）</h5><p>关系 <span class="math inline">\(R\)</span> 上的投影是从 <spanclass="math inline">\(R\)</span>中选择出若干属性列组成新的关系，记作</p><p><span class="math inline">\(\prod _{A}(R)=\{t[A]|t\inR\}\)</span></p><p>其中 <span class="math inline">\(A\)</span> 为 <spanclass="math inline">\(R\)</span> 的属性列。</p><h5 id="连接join">连接（join）</h5><p>连接也称为<spanclass="math inline">\(\theta\)</span>连接。它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作</p><p><span class="math inline">\(R\Join _{A\theta B}S=\{t_rt_s|t_r\in R\ort_s\in S\or t_r[A]\theta t_s[B] \}\)</span></p><p>其中，<span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 分别为 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 上列数相等且可比的属性组，<spanclass="math inline">\(\theta\)</span>是比较运算符。连接运算从 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 的笛卡尔积 <spanclass="math inline">\(R\times S\)</span> 中选取 <spanclass="math inline">\(R\)</span> 关系在 <spanclass="math inline">\(A\)</span> 属性组上的值与 <spanclass="math inline">\(S\)</span> 关系在 <spanclass="math inline">\(B\)</span> 属性组上的值满足比较关系 <spanclass="math inline">\(\theta\)</span>的元组。</p><ul><li><p><span class="math inline">\(\theta\)</span> 为 =的连接运算称为等值连接，它是从关系 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 的笛卡尔积中选取 <spanclass="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span>属性值相等的那些元组。</p></li><li><p>自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中去除重复属性列</p><ul><li>一般的连接操作是从行的角度进行运算，自然连接还需要去除重复列，因而是同时从行和列的角度进行运算</li><li>自然连接中被舍弃的元组称为悬浮元组（danglingtuple），把悬浮元组也保存在结果关系中，而在其他属性值上写<spanclass="math inline">\(null\)</span>，这种连接称为外连接；只保留左关系的悬浮元组称为左外连接，反之为右外连接</li></ul></li></ul><h5 id="除运算division">除运算（division）</h5><p>//以下定义过于抽象，其实就是选择R(X,Y)中Y与S(Y,Z)中的Y具有相同值的所有对应X。</p><p>设关系 <span class="math inline">\(R\)</span> 除以关系 <spanclass="math inline">\(S\)</span> 的结果为关系 <spanclass="math inline">\(T\)</span>，则 <spanclass="math inline">\(T\)</span> 包含所有在 <spanclass="math inline">\(R\)</span> 但不在 <spanclass="math inline">\(S\)</span> 中的属性及其值，且 <spanclass="math inline">\(T\)</span> 的元组与 <spanclass="math inline">\(S\)</span> 的元组的所有组合都在 <spanclass="math inline">\(R\)</span> 中。</p><p>除法的象集定义：</p><p>给定关系 <span class="math inline">\(R(X,Y)\)</span> 和 <spanclass="math inline">\(S(Y,Z)\)</span>，其中<spanclass="math inline">\(X\)</span>、<spanclass="math inline">\(Y\)</span>、<spanclass="math inline">\(Z\)</span>为属性组。<spanclass="math inline">\(R\)</span> 中的 <spanclass="math inline">\(Y\)</span> 与 <spanclass="math inline">\(S\)</span> 中的 <spanclass="math inline">\(Y\)</span>可以有不同的属性名，但必须出自相同的域集。</p><p><span class="math inline">\(R\)</span> 与 <spanclass="math inline">\(S\)</span> 的除运算得到一个新的关系 <spanclass="math inline">\(P(X)\)</span>，<spanclass="math inline">\(P\)</span> 是 <spanclass="math inline">\(R\)</span> 中满足下列条件的元组在 <spanclass="math inline">\(X\)</span> 属性列上的投影：元组在 <spanclass="math inline">\(X\)</span> 上分量值 <spanclass="math inline">\(x\)</span> 的象集 <spanclass="math inline">\(Y_x\)</span> 包含 <spanclass="math inline">\(S\)</span> 在 <spanclass="math inline">\(Y\)</span> 上投影的集合。记作</p><p><span class="math inline">\(R\div S=\{t_r[X] |t_r\in R \and \prod_Y(S)\subseteq Y_X \}\)</span></p><p>除操作也是同时从行和列的角度进行运算。</p><p>关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。</p><h2 id="关系演算">2.5 关系演算</h2><p>不考，暂略</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第一章_绪论</title>
    <link href="/2023/03/01/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/03/01/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第一章-绪论">第一章 绪论</h1><h2 id="数据库系统概述">1.1 数据库系统概述</h2><h3 id="数据库的4个基本概念">1.1.1 数据库的4个基本概念</h3><p>数据、数据库、数据库管理系统、数据库系统</p><h4 id="数据data">数据（Data）</h4><p>数据是数据库中存储的基本对象，是描述事物的符号记录。</p><p>数据有多种表现形式，可以经过数字化后存入计算机。</p><p>数据的含义称为数据的语义，数据与其语义是不可分的。</p><h4 id="数据库databasedb">数据库（Database，DB）</h4><p>数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，可为各种用户共享。</p><p>数据库数据具有永久存储、有组织和可共享三个基本特点。</p><h4id="数据库管理系统database-management-systemdbms">数据库管理系统（DatabaseManagement System，DBMS）</h4><p>数据库管理系统是计算机的基础软件，主要功能包含以下几个方面：</p><h5 id="数据定义">(1) 数据定义</h5><p>提供数据定义语言（Data DefinitionLanguage，DDL），用以对数据库中的数据对象的组成与结构进行定义</p><h5 id="数据组织存储和管理">(2) 数据组织、存储和管理</h5><h5 id="数据操纵">(3) 数据操纵</h5><p>提供数据操纵语言（Data ManipulationLanguage，DML），用以操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。</p><h5 id="数据库的事务管理和运行管理">(4) 数据库的事务管理和运行管理</h5><h5 id="数据库的建立和维护">(5) 数据库的建立和维护</h5><h5 id="其他功能">(6) 其他功能</h5><p>包括数据库管理系统与网络中其他软件系统的通信功能，异构数据库之间的互访和互操作功能等。</p><h4 id="数据库系统database-systemdbs">数据库系统（DatabaseSystem，DBS）</h4><p>数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DatabaseAdministrator，DBA）组成的存储、管理、处理和维护数据的系统。</p><h3 id="数据库系统的特点">1.1.2 数据库系统的特点</h3><ul><li>文件系统管理数据的缺点：整体无结构，共享性低，冗余度高，独立性差</li></ul><h4 id="数据结构化">数据结构化</h4><p>数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。</p><p>整体结构化是指数据库中的数据不再仅仅针对一个应用，而是面向整个组织或企业；不仅数据内部是结构化的，而且整体是结构化的，数据之间是具有联系的。</p><h4id="数据的共享性高冗余度低且易扩充">数据的共享性高、冗余度低且易扩充</h4><p>数据共享可以大大减少数据冗余，节约存储空间，数据共享还能避免数据之间的不相容性与不一致性。</p><h4 id="数据独立性高">数据独立性高</h4><p>数据库的数据独立性包括数据的物理独立性和逻辑独立性。</p><ul><li><p>物理独立性是指用户的应用程序与数据库中数据的物理存储是相互独立的。</p></li><li><p>逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</p></li></ul><h4id="数据由数据库管理系统统一管理和控制">数据由数据库管理系统统一管理和控制</h4><p>为了保证数据库的并发共享与数据库中数据的正确与一致，数据库管理系统提供以下的数据控制功能：</p><h5 id="数据的安全性保护">(1) 数据的安全性保护</h5><p>保护数据以防止不合法使用造成的数据泄密和破坏。</p><h5 id="数据的完整性检查">(2) 数据的完整性检查</h5><p>数据的完整性指数据的正确性、有效性和相容性。</p><h5 id="并发控制">(3) 并发控制</h5><h5 id="数据库恢复">(4) 数据库恢复</h5><p>数据库管理系统必须具有将数据库从错误状态恢复到某一已知的正确状态的功能。</p><p>数据库是长期存储在计算机内有组织、大量、共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。</p><p>数据库系统的出现使信息系统从以加工数据的程序为中心转为围绕共享的数据库为中心的新阶段。</p><h2 id="数据模型">1.2 数据模型</h2><p>数据模型是对现实世界数据特征的抽象，是数据库系统的核心和基础。</p><p>数据模型分为两类，第一类为概念模型，第二类是逻辑模型和物理模型。</p><ul><li><p>概念模型也称信息模型，它按用户的观点来对数据和信息建模，主要用于数据库设计。</p></li><li><p>逻辑模型主要包括层次模型、网状模型、关系模型、面向对象数据模型和对象关系数据模型、半结构化数据模型等，它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。</p></li><li><p>物理模型是对数据最底层的抽象，描述数据在系统内部的表示和存取方式。物理模型的具体实现是数据库管理系统的任务，数据库设计人员要了解和选择物理模型，最终用户则不需考虑物理级细节。</p></li></ul><p>先将现实世界抽象为信息世界（概念模型），再将信息世界转换为机器世界。</p><h3 id="概念模型">1.2.1 概念模型</h3><p>概念模型是对现实世界的抽象，用于信息世界的建模。</p><h4 id="信息世界的基本概念">信息世界的基本概念</h4><ol type="1"><li>实体（entity）</li></ol><p>客观存在并可相互区别的事物称为实体。</p><ol start="2" type="1"><li>属性（attribute）</li></ol><p>实体所具有的某一特性。</p><ol start="3" type="1"><li>码（key）</li></ol><p>唯一标识实体的属性集称为码</p><ol start="4" type="1"><li>实体型（entity type）</li></ol><p>用实体及其属性名集合来抽象和刻画同类实体，称为实体型。</p><ol start="5" type="1"><li>实体集（entity set）</li></ol><p>同一类型实体的集合称为实体集。</p><ol start="6" type="1"><li>联系（relationship）</li></ol><p>实体内部的联系通常指组成实体的各属性之间的联系，实体之间的联系通常指不同实体集之间的联系。</p><p>实体之间的联系有一对一、一对多、多对多等多种类型。</p><h4id="概念模型的一种表示方法实体-联系方法entity-relationship-approach">概念模型的一种表示方法：实体-联系方法（Entity-Relationshipapproach）</h4><p>该方法用实体-联系图（E-Rdiagram）来描述现实世界的概念模型，E-R方法也称E-R模型。</p><h3 id="数据模型的组成要素">1.2.2 数据模型的组成要素</h3><p>数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成。</p><ol type="1"><li>数据结构</li></ol><p>数据结构描述数据库的组成对象以及对象之间的联系。</p><ol start="2" type="1"><li>数据操作</li></ol><p>数据操作是指对数据库中各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则。</p><ol start="3" type="1"><li>数据的完整性约束条件</li></ol><p>数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。</p><h3 id="常用的数据模型">1.2.3 常用的数据模型</h3><ul><li>层次模型（hierarchical model）</li><li>网状模型（network model）</li><li>关系模型（relational model）</li><li>面向对象数据模型（object oriented data model）</li><li>对象关系数据模型（object relational data model）</li><li>半结构化数据模型（semistructure data model）</li></ul><p>其中层次模型和网状模型称为格式化模型。</p><h4 id="层次模型">层次模型</h4><ol type="1"><li>有且只有一个结点没有双亲结点，该结点为根结点；</li><li>根以外的其他结点有且只有一个双亲结点。</li></ol><p>优点：结构简单清晰、查询效率高、完整性支持好</p><p>缺点：现实世界很多联系是非层次性的</p><h4 id="网状模型">网状模型</h4><ol type="1"><li>允许一个以上的结点没有双亲；</li><li>一个结点可以有一个以上的双亲。</li></ol><p>优点：直观地描述现实世界、存取效率高</p><p>缺点：结构复杂，因而DDL与DML也十分复杂</p><h2 id="数据库系统的结构">1.3 数据库系统的结构</h2><h3 id="数据库系统模式的概念">1.3.1 数据库系统模式的概念</h3><p>数据模型中，型（type）是对某一类数据的结构和属性的说明，值（value）是型的一个具体赋值。</p><p>模式（schema）是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体值。模式的一个具体值称为模式的一个实例。</p><p>模式是相对稳定的，实例时相对变动的。</p><h3 id="数据库系统的三级模式结构">1.3.2 数据库系统的三级模式结构</h3><p>数据库系统由外模式、模式和内模式三级构成。</p><ol type="1"><li>模式</li></ol><p>模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p><ol start="2" type="1"><li>外模式</li></ol><p>外模式也称子模式（subschema）或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用相关的数据的逻辑表示。</p><p>外模式通常是模式的子集。</p><ol start="3" type="1"><li>内模式</li></ol><p>内模式也称存储模式（storageschema），是数据物理结构和存储方式的描述，是数据库内部数据的组织方式。</p><p>一个数据库只有一个内模式</p><h3 id="数据库的二级映像功能与数据独立性">1.3.3数据库的二级映像功能与数据独立性</h3><ol type="1"><li>外模式/模式映像</li></ol><p>模式改变时，数据库管理员对各个外模式/模式映像作相应改变，使外模式保持不变，保证数据逻辑独立性。</p><ol start="2" type="1"><li>模式/内模式映像</li></ol><p>数据库存储结构改变时，数据库管理员对模式/内模式映像作相应改变，使模式保持不变，保证数据物理独立性。</p><p>数据与程序之间的独立性使得数据的定义和描述从应用程序中分离。数据的存取由数据库管理系统管理，简化了应用程序的编制，减少了应用程序的维护与修改。</p><ul><li>文件系统数据独立性是文件间相互独立，而数据库系统数据独立性是逻辑、物理独立性</li></ul><h2 id="数据库系统的组成">1.4 数据库系统的组成</h2><ol type="1"><li><p>硬件平台及数据库</p><ul><li>足够大的内存存放操作系统、数据库管理系统的核心模块、数据缓冲区和应用程序</li><li>足够大的磁盘存放数据库，足够大的磁带作数据备份</li><li>系统有较高的通道能力以提高数据传送率</li></ul></li><li><p>软件</p><ul><li>数据库管理系统</li><li>支持数据库管理系统运行的操作系统</li><li>具有与数据库接口的高级语言及其编译系统，便于开发应用程序</li><li>以数据库管理系统为核心的应用开发工具</li></ul></li><li><p>人员</p><ul><li><p>数据库管理员</p></li><li><p>系统分析员与数据库设计人员</p></li><li><p>应用程序员</p></li><li><p>用户</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-5_排序</title>
    <link href="/2022/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5_%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5_%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="排序">5. 排序</h1><p>夜阑月明人尽望，铁骑刀锋梦中伏。</p><span id="more"></span><h2 id="概念">5.1 概念</h2><ol type="1"><li><p>排序：重新排列表中元素，使之按关键字有序。</p></li><li><p>排序算法的稳定性：对于关键字相同的两个元素，使用算法排序后是否顺序变化。</p></li><li><p>内部排序：排序期间元素全部存放在内存。</p><p>外部排序：排序期间元素无法同时全部存放在内存。</p></li></ol><h2 id="排序算法">5.2 排序算法</h2><h3 id="插入排序">插入排序</h3><ol type="1"><li>直接插入排序：每次将一个元素按其关键字插入已经排序好的子序列。<ul><li>空间复杂度<span class="math inline">\(O(1)\)</span>，时间复杂度<spanclass="math inline">\(O(n^2)\)</span>。如果原顺序较好，时间复杂度可为<spanclass="math inline">\(O(n)\)</span>。</li><li>稳定排序，适用于顺序表和链表。</li></ul></li><li>二分插入排序：二分查找插入位置的插入排序。<ul><li>空间复杂度<span class="math inline">\(O(1)\)</span>，时间复杂度<spanclass="math inline">\(O(n^2)\)</span>。</li><li>稳定排序，适用于顺序表。</li></ul></li><li>希尔排序：取一个小于<span class="math inline">\(n\)</span>的值<spanclass="math inline">\(d\)</span>，将元素分为可有交集的<spanclass="math inline">\(d\)</span>组，所有距离为<spanclass="math inline">\(d\)</span>的倍数的元素分在一组，在各组内进行直接插入排序，然后取小于<spanclass="math inline">\(d\)</span>的值<spanclass="math inline">\(d&#39;\)</span>，重复，直到最后进行一次全表的直接插入排序。<ul><li>不稳定排序，适用于顺序表。</li></ul></li></ol><h3 id="交换排序">交换排序</h3><ol type="1"><li>冒泡排序：从后往前两两比较相邻元素的值，逆序则交换。重复直到一次遍历中不发生交换。<ul><li>空间复杂度<span class="math inline">\(O(1)\)</span>，时间复杂度<spanclass="math inline">\(O(n^2)\)</span>。</li><li>稳定排序，适用于顺序表和链表。</li></ul></li><li>快速排序：在表中任取一个元素，一次遍历将表分为小于该元素和大于该元素的两个部分，再对这两个部分分别进行快速排序。<ul><li>空间复杂度<span class="math inline">\(O(1)\)</span>，时间复杂度<spanclass="math inline">\(O(n^2)\)</span>。如果划分平均，时间复杂度可为<spanclass="math inline">\(O(n\log_2n)\)</span></li><li>不稳定排序，适用于顺序表。</li><li>快速排序是内部排序算法中平均性能最优的排序算法。</li></ul></li></ol><h3 id="选择排序">选择排序</h3><ol type="1"><li><p>简单选择排序：每次选取待排序元素中最小的元素作为有序子序列的最后一个元素。</p><p>实现：将后<spanclass="math inline">\(n-i+1\)</span>个元素中的最小者与第<spanclass="math inline">\(i\)</span>个元素交换。</p><ul><li>空间复杂度<span class="math inline">\(O(1)\)</span>，时间复杂度<spanclass="math inline">\(O(n^2)\)</span>。</li><li>不稳定排序，适用于顺序表和链表。</li></ul></li><li><p>堆排序：建堆，然后逐个输出元素。</p><ul><li>空间复杂度<span class="math inline">\(O(1)\)</span>，时间复杂度<spanclass="math inline">\(O(n\log_2n)\)</span>。</li><li>不稳定排序，适用于顺序表。</li></ul><p>堆是一种二叉树，一般用完全二叉树来实现。</p><ul><li>任意结点值大于其子结点值的堆是最大堆。</li><li>任意结点值小于其子结点值的堆是最小堆。</li></ul><p>插入：先把新结点放在最后，然后逐层比较其与父结点的值，如果违反定义就交换，直到无法交换。</p><p>删除：一般使用自顶向下堆化。</p><ul><li>自顶向下堆化：删除根结点，用最后一个结点取代它，然后逐层比较其与子结点的值使其下沉。</li><li>自底向上堆化：删除根节点，用更大的子结点取代它，重复（会产生空结点位置）</li></ul></li></ol><h3 id="归并排序">归并排序</h3><p>归并排序：将表分为多个表进行排序，然后合并。</p><p>二路归并排序：将表分为两个子表，对每个子表递归使用二路归并排序，然后合并。</p><ul><li>合并：每次选择两个子表中的较小者写入辅助数组。</li><li>空间复杂度<span class="math inline">\(O(n)\)</span>，时间复杂度<spanclass="math inline">\(O(n\log_2n)\)</span>。</li><li>稳定排序，适用于顺序表和链表。</li></ul><h3 id="基数排序">基数排序</h3><p>基数排序：基于关键字各位的大小进行排序。</p><ul><li>从最低位开始的基数排序：从最低位开始，每一位排序一次。</li><li>空间复杂度<span class="math inline">\(O(r)\)</span>，<spanclass="math inline">\(r\)</span>为进制数，时间复杂度<spanclass="math inline">\(O(d(n+r))\)</span>，<spanclass="math inline">\(d\)</span>为最大位数。</li><li>稳定排序，适用于顺序表和链表。</li></ul><p>基数排序的本质是将多关键字的排序算法用于单关键字。</p><h3 id="计数排序">计数排序</h3><p>对每个待排序元素，统计小于其的元素个数。</p><ul><li>计数数组长度为<spanclass="math inline">\(k\)</span>，空间复杂度<spanclass="math inline">\(O(n+k)\)</span>。<ul><li>当<span class="math inline">\(k=O(n)\)</span>，时间复杂度<spanclass="math inline">\(O(n)\)</span>。</li></ul></li><li>稳定排序，适用于顺序表。</li></ul><h2 id="内部和外部排序">5.3 内部和外部排序</h2><ol type="1"><li><p>内部排序算法考虑因素：</p><ul><li>元素个数。</li><li>元素初始状态。</li><li>关键字的结构与分布。</li><li>稳定性的要求。</li><li>存储空间及辅助空间大小。</li></ul><p>排序算法使用总结：</p><ul><li>元素数量：<ul><li>较小：直接插入排序、简单选择排序。</li><li>较大：选择时间复杂度为<spanclass="math inline">\(O(n\log_2n)\)</span>的算法。关键字可分解且位数少，用基数排序。</li></ul></li><li>稳定性要求：<ul><li>不稳定：希尔排序、快速排序、简单选择排序、堆排序</li></ul></li><li>初始状态：基本有序，则用直接插入、冒泡排序</li><li>信息量大：用链表。</li></ul></li><li><p>外部排序：大文件的排序。常用归并排序算法。</p><ul><li>败者树</li><li>置换-选择归并</li><li>最佳归并树</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-4_查找</title>
    <link href="/2022/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4_%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4_%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="查找">4. 查找</h1><p>夜阑月明人尽望，铁骑刀锋梦中伏。</p><span id="more"></span><h2 id="概念">4.1 概念</h2><ol type="1"><li><p>查找：在数据集合中寻找满足某种条件的数据元素的过程。</p></li><li><p>查找表：用于查找的数据集合。</p><ul><li><p>静态查找表：只读的查找表。常用顺序查找、二分查找、散列查找。</p></li><li><p>动态查找表：需要动态插入或删除的查找表。常用二叉排序树、散列查找。</p></li></ul></li><li><p>关键字：数据元素中唯一标识该元素的某个数据项的值。</p><p>查找长度：查找需要比较关键字次数。</p><p>平均查找长度，ASL：所有查找过程中查找长度的平均值。</p></li></ol><h2 id="查找算法">4.2 查找算法</h2><h3 id="线性查找">线性查找</h3><ol type="1"><li>顺序查找：适用于顺序表和链表。<ul><li>对无序线性表，查找成功的平均长度为<spanclass="math inline">\(\frac{n+1}2\)</span>，查找失败的平均长度为<spanclass="math inline">\(n+1\)</span>。</li><li>对有序线性表，可以通过比较来提前得知查找失败。</li></ul></li><li>二分查找：仅适用于有序顺序表，不适用于链表。<ul><li>查找成功的平均长度为<spanclass="math inline">\(\frac{n+1}{n}\log_2(n+1)-1\)</span>。</li></ul></li><li>分块查找：又称索引顺序查找。<ul><li>将查找表分为多个块内元素可以无序，块间有序的查找块。</li><li>建立索引表，记录每个块的最大值和第一个元素的地址。索引有序排列。</li><li>先查索引，后查块。</li></ul></li></ol><h3 id="树形查找">树形查找</h3><ol type="1"><li><p>二叉排序树</p><ul><li>查找：从根结点开始逐层向下比较。<ul><li>查找效率：取决于树的高度。平衡时为<spanclass="math inline">\(O(log_2n)\)</span>，极不平衡时为<spanclass="math inline">\(O(n)\)</span>。</li></ul></li><li>插入：递归<ol type="1"><li>若原二叉排序树为空，直接插入。</li><li>若关键字小于根节点，插入左子树，否则插入右子树。</li></ol></li><li>构造：从空树开始依次插入元素。</li><li>删除：<ul><li>若为叶结点，直接删除。</li><li>若只有一棵左子树或右子树，则让子树替代该结点位置。</li><li>若有左右两棵子树，则让其后继或前驱替代其位置，再删除其后继或前驱的原本结点。</li></ul></li></ul></li><li><p>二叉平衡树</p><ul><li><p>结点的平衡因子：左子树和右子树的高度差，只可以是<spanclass="math inline">\(-1,0,1\)</span>。</p></li><li><p>插入：按二叉排序树的方式插入，检查插入路径上的结点，对以离插入结点最近的，平衡因子绝对值大于0的结点为根的子树（最小不平衡子树）进行调整。</p><ul><li><p>LL平衡旋转（右旋）：</p><ul><li><p>原因：结点A左子结点B的左子树插入结点，A的平衡因子由1变成2。</p></li><li><p>过程：B取代A，A成为B的右子结点，B原本的右子树成为A的左子树。</p></li></ul></li><li><p>RR平衡选择（左旋）：</p><ul><li><p>原因：结点A右子结点B的右子树插入结点，A的平衡因子由-1变成-2。</p></li><li><p>过程：B取代A，A成为B的左子结点，B原本的左子树成为A的右子树。</p></li></ul></li><li><p>LR平衡旋转（先左后右双旋）：</p><ul><li>原因：结点A左子结点B的右子树插入结点，A的平衡因子由1变成2。</li><li>过程：先将B的右子结点C左旋到B，再将C右旋到A。</li></ul></li><li><p>RL平衡旋转（先右后左双旋）：</p><ul><li>原因：结点A右子结点B的左子树插入结点，A的平衡因子由-1变成-2。</li><li>过程：先将B的左子结点C右旋到B，再将C左旋到A。</li></ul></li></ul></li><li><p>构造：从空树开始依次插入元素。</p></li><li><p>删除：按二叉排序树的方式删除。找到最小不平衡子树进行调整。然后向根节点逐层回溯检查。</p></li></ul></li><li><p>红黑树：满足一定红黑性质的二叉排序树。</p><ul><li>红黑性质：<ul><li>每个结点是红的或黑的。</li><li>根结点是黑的。</li><li>叶结点都是黑的。引入<spanclass="math inline">\(n+1\)</span>个外部叶结点，使得每个内部结点的左右子结点非空。</li><li>不存在两个相邻的红结点。</li><li>对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。</li></ul></li><li>红黑树的性质：<ul><li>从根结点到叶结点的最长路径不大于最短路径的2倍。</li><li>有<spanclass="math inline">\(n\)</span>个内部结点的红黑树的高度<spanclass="math inline">\(h\le2\log_2(n+1)\)</span>。</li></ul></li><li>插入：<ol type="1"><li>按二叉排序树的方式插入，并设该结点为红色。</li><li>若其为根节点，则将其改为黑色，结束。</li><li>若其父结点为黑色，结束。</li><li>若其叔结点为红色，则将父结点和叔结点都改为黑色，将爷结点改为红色。然后将爷结点作为新结点进行循环调整。</li><li>其叔结点为黑色：<ul><li>该结点为爷结点的左子结点的左子结点：LL，并交换父结点和爷结点的颜色</li><li>该结点为爷结点的左子结点的右子结点：LR，并交换父结点和爷结点的颜色</li><li>该结点为爷结点的右子结点的左子结点：RL，并交换父结点和爷结点的颜色</li><li>该结点为爷结点的右子结点的右子结点：RR，并交换父结点和爷结点的颜色</li></ul></li></ol></li><li>删除</li></ul></li><li><p>B树：<spanclass="math inline">\(m\)</span>阶B树是所有结点的平衡因子均等于0的<spanclass="math inline">\(m\)</span>路平衡查找树。</p><ul><li>m阶B树满足的特性：<ul><li>树中每个结点至多有<spanclass="math inline">\(m\)</span>棵子树，即至多有<spanclass="math inline">\(m-1\)</span>个关键字。</li><li>非叶根结点至少有2棵子树，即至少有1个关键字。</li><li>除根结点以外的所有非叶结点至少有<span class="math inline">\([\fracm2]\)</span>棵子树，即至少有<span class="math inline">\([\fracm2]-1\)</span>个关键字。</li><li>非叶结点结构：<spanclass="math inline">\(n,P_0,K_1,P_1,....K_n,P_n\)</span>，<spanclass="math inline">\(K_i\)</span>为关键字，<spanclass="math inline">\(P_i\)</span>为指针。</li><li>所有叶结点都是外部结点，在同一层，实际不存在。</li></ul></li><li>查找：多路比较关键字。</li><li>高度：对一棵有<spanclass="math inline">\(n\)</span>个关键字，高度为<spanclass="math inline">\(h\)</span>、阶数为<spanclass="math inline">\(m\)</span>的B树：<ul><li><span class="math inline">\(n\le m^h-1,h\ge\log_m(n+1)\)</span></li><li><span class="math inline">\(h\le\log_{[\fracm2-1]}\frac{n+1}2+1\)</span></li></ul></li><li>插入：定位和插入，如果结点关键字多于<spanclass="math inline">\(m-1\)</span>，则需要进行分裂。<ul><li>分裂：<span class="math inline">\([\fracm2]\)</span>位置的关键字插入父结点，其右的关键字作为新结点。</li></ul></li><li>删除：定位和删除，如果结点关键字少于<spanclass="math inline">\([\frac m2]-1\)</span>，则需要进行合并。<ul><li>合并：如果兄弟结点关键字多于<span class="math inline">\([\fracm2]-1\)</span>，则调整其关键字进入父结点，原父结点中关键字进入原结点。否则合并父结点中关键字作为新结点。</li></ul></li></ul></li><li><p>B+树</p><ul><li>m阶B+树满足的特性：<ul><li>树中每个分支结点至多有<spanclass="math inline">\(m\)</span>棵子树。</li><li>非叶根结点至少有2棵子树，其他分支结点至少有<spanclass="math inline">\([\frac m2]\)</span>棵子树。</li><li>结点的子树个数和关键字个数相等。</li><li>所有叶结点包含全部关键字并指向相应记录的指针。</li><li>叶结点将关键字按大小排列并且相邻叶结点按大小顺序相互连接，支持顺序查找。</li><li>所有分支结点仅包含其子结点中关键字的最大值和指向子结点的指针。</li></ul></li></ul></li></ol><h3 id="散列查找">散列查找</h3><ol type="1"><li><p>散列函数：把查找表中的关键字映射为对应地址的函数。</p><p>散列表：根据关键字直接进行访问的数据结构。</p><ul><li>散列函数定义域包含全部关键字，值域依赖于散列表大小。</li><li>散列函数计算出的地址应尽可能均匀分布、减少冲突。</li><li>散列函数应尽量简单，计算时间短。</li></ul></li><li><p>常用散列函数：</p><ul><li>直接定址：取关键字的某个线性函数值<spanclass="math inline">\(H(x)=ax+b\)</span>。</li><li>除留余数：取一个不大于表长但接近表长的质数<spanclass="math inline">\(p\)</span>，取<spanclass="math inline">\(H(x)=x\mod p\)</span></li><li>数字分析：<span class="math inline">\(r\)</span>进制数的<spanclass="math inline">\(r\)</span>个数码在各位上出现的频率不相同，则选取数码分布较平均的位进行散列。</li><li>平方取中：取关键字的平方值的中间几位。</li></ul></li><li><p>处理冲突的方法：</p><ul><li>开放定址：空闲地址向非同义词开放。<ul><li>线性探测：冲突发生时，按序查看表中下一个空闲单元。</li><li>平方探测：冲突发生时，按序查看相对原址<spanclass="math inline">\(1,-1,2^2,-2^2,...\)</span>的下一个空闲单元。</li><li>双散列：第一个散列函数冲突，则使用第二个散列函数。</li><li>随机数</li></ul></li><li>拉链：同义词存于同一个链表中。</li></ul></li><li><p>散列表的查找效率取决于：散列函数、处理冲突办法、装填因子</p><ul><li>装填因子=记录数/表长。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-3_图</title>
    <link href="/2022/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/3_%E5%9B%BE/"/>
    <url>/2022/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/3_%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="图">3. 图</h1><p>夜阑月明人尽望，铁骑刀锋梦中伏。</p><span id="more"></span><h2 id="基础">3.1 基础</h2><h3 id="概念">概念</h3><ol type="1"><li><p>图：<span class="math inline">\(G=(V,E)\)</span>，其中<spanclass="math inline">\(V\)</span>为非空有限点集，<spanclass="math inline">\(E\)</span>为边集。</p><ul><li><span class="math inline">\(|V|\)</span>表示图中点的个数，<spanclass="math inline">\(|E|\)</span>表示边数。</li><li>子图：若<spanclass="math inline">\(G&#39;=(V&#39;,E&#39;)\)</span>中<spanclass="math inline">\(V&#39;\sub V,E&#39;\sub E\)</span>，则称<spanclass="math inline">\(G&#39;\)</span>为<spanclass="math inline">\(G\)</span>的子图。<ul><li>若<span class="math inline">\(V(G&#39;)=V(G)\)</span>，则称<spanclass="math inline">\(G&#39;\)</span>为<spanclass="math inline">\(G\)</span>的生成子图。</li></ul></li><li>有向图：边具有方向。</li><li>无向图：边不具有方向。</li><li>简单图：不存在重复边与顶点到自己的边的图。反之为多重图。</li><li>完全图：每个点之间都具有边。<ul><li>一个有<span class="math inline">\(n\)</span>个顶点的无向图，<spanclass="math inline">\(|E|\le\frac12n(n-1)\)</span>，若取等，它是无向完全图。</li><li>一个有<span class="math inline">\(n\)</span>个顶点的有向图，<spanclass="math inline">\(|E|\len(n-1)\)</span>，若取等，它是有向完全图。</li></ul></li><li>有权图：边上带有权值的图，也称为网。</li><li>稀疏图：边数很少的图，反之称为稠密图。</li></ul></li><li><p>顶点<span class="math inline">\(v\)</span>的度：</p><ul><li>无向图：与顶点相连的边的总数，记为<spanclass="math inline">\(TD(v)\)</span>。</li><li>有向图：入度<spanclass="math inline">\(ID(v)\)</span>为其入边数、出度<spanclass="math inline">\(OD(v)\)</span>为其出边数。度为<spanclass="math inline">\(TD(v)=ID(v)+OD(v)\)</span>。<ul><li>有向图所有点的入度和等于所有点的出度和等于边数。</li></ul></li><li>在有<span class="math inline">\(n\)</span>个顶点的图中，<spanclass="math inline">\(|E|\)</span>等于所有顶点度数的和的二分之一。</li><li>有向树：一个顶点的入度为0，其余顶点的入度为1的有向图。</li></ul></li><li><p>路径：一系列顶点<spanclass="math inline">\(P=i_1,...i_k\)</span>，<spanclass="math inline">\(\forall 1\le j\le k\)</span>，边<spanclass="math inline">\((i_j,i_{j+1})\)</span>在图G中，称<spanclass="math inline">\(P\)</span>为<spanclass="math inline">\(G\)</span>中一条<spanclass="math inline">\(i_1\)</span>到<spanclass="math inline">\(i_k\)</span>的路径。</p><p>回路：第一个顶点与最后一个顶点相同的路径。</p><ul><li><p>路径长度：路径上的边数。</p></li><li><p>简单路径：除了首尾顶点外所有顶点不重复。</p></li><li><p>简单回路：首尾为相同顶点的简单路径。</p></li></ul><p>距离：图中两个顶点间最短路径的长度。若不存在两个顶点间的路径则为<spanclass="math inline">\(\infin\)</span>。</p></li><li><p>连通：在无向图中，如果两点间存在路径，则两点连通。</p><p>连通图：在无向图中，若任意两顶点连通，则称该图为连通图。</p><p>连通分量：无向图的极大连通子图称为连通分量。</p><p>强连通：有向图中，若顶点对<spanclass="math inline">\(i,j\)</span>间存在<spanclass="math inline">\(i\)</span>到<spanclass="math inline">\(j\)</span>和<spanclass="math inline">\(j\)</span>到<spanclass="math inline">\(i\)</span>的路径，则这两个顶点强连通。</p><p>强连通图：有向图中所有顶点对间强连通，则该图为强连通图。</p><p>强连通分量：有向图的极大强连通子图为其强连通分量。</p></li><li><p>生成树：包含连通图中所有顶点的极小连通子图。</p><ul><li>最小生成树：对一个带权连通无向图，权值之和最小的生成树。<ul><li>若图存在权值相同的边，则最小生成树可能不唯一。</li><li>图的最小生成树的权值之和是唯一的。</li><li>最小生成树的边数为顶点数减一。</li></ul></li></ul></li></ol><h3 id="表示">表示</h3><ol type="1"><li>邻接矩阵：图<spanclass="math inline">\(G=(V,E)\)</span>的邻接矩阵为<spanclass="math inline">\(A(i,j)\)</span>，<span class="math inline">\(\langi,j\rang\in E\)</span>则<spanclass="math inline">\(A(i,j)\)</span>为1，否则为0。<ul><li>无向图的邻接矩阵为对称矩阵。</li><li>有向图中，第i行的累加为点i的出度，第i列的累加为点i的入度。</li><li>对加权图，将1替换为其权重，0替换为∞，此外，还需要记录各顶点信息的表与当前的边数。</li></ul></li><li>邻接表：顺序存储顶点结点，以每个顶点结点为首结点建立单链表，记录与其相连的顶点。<ul><li>当边数较少，邻接表减少了存储的需求。</li><li>对有向图，邻接表记录出边，而记录入边的为逆邻接表。</li></ul></li><li>邻接多重表：顺序存储顶点结点，顶点结点连接边结点构成链表。<ul><li>顶点结点记录该顶点第一条边。</li><li>边结点记录两个顶点与它们各自的下一条边。<ul><li>用于无向图</li></ul></li></ul></li><li>十字链表：顺序存储顶点结点，顶点结点连接边结点构成链表。<ul><li>顶点结点记录该顶点第一条入边和出边。</li><li>边结点记录入顶点和出顶点、入顶点的下一条入边、出顶点的下一条出边。<ul><li>用于有向图</li></ul></li></ul></li><li>图的基本操作：<ul><li>判断边<span class="math inline">\(\langx,y\rang\)</span>是否存在</li><li>列出某结点连接的其他顶点</li><li>插入/删除顶点</li><li>插入/删除边</li></ul></li></ol><h2 id="计算">3.2 计算</h2><h3 id="遍历">遍历</h3><ol type="1"><li>广度优先搜索</li><li>深度优先搜索</li></ol><h3 id="应用">应用</h3><ol type="1"><li><p>最小生成树</p><ul><li>基本性质：带权连通无向图<spanclass="math inline">\(G=(V,E)\)</span>，<spanclass="math inline">\(U\)</span>为顶点集<spanclass="math inline">\(V\)</span>的一个非空子集，若<spanclass="math inline">\((u,v)\)</span>是一条具有最小权值的边，其中<spanclass="math inline">\(u\in U,v\in V-U\)</span>，则必存在一棵包含边<spanclass="math inline">\((u,v)\)</span>的最小生成树。</li></ul><p>Prim算法：连通图<spanclass="math inline">\(G=(V,E)\)</span>，其最小生成树<spanclass="math inline">\(T\)</span>。</p><ol type="1"><li>初始化：向空树<spanclass="math inline">\(T\)</span>中添加图的任一顶点。</li><li>循环：从图中选择满足<span class="math inline">\(\{(u,v):u\in U,v\inV-U \}\)</span>且权值最小的边加入树<spanclass="math inline">\(T\)</span>。</li></ol><ul><li>时间复杂度为<spanclass="math inline">\(O(|V|^2)\)</span>，适合边稠密的图。</li></ul><p>Kruskal算法：连通图<spanclass="math inline">\(G=(V,E)\)</span>，其最小生成树<spanclass="math inline">\(T=(U,E_T)\)</span>。</p><ol type="1"><li>初始化：<spanclass="math inline">\(U=V,E_T=\varnothing\)</span>。</li><li>循环：按<span class="math inline">\(G\)</span>的边权递增顺序从<spanclass="math inline">\(E-E_T\)</span>中选择一条边，若该边加入<spanclass="math inline">\(T\)</span>后不构成回路，则将其加入，否则舍弃。直到<spanclass="math inline">\(E_T\)</span>中含有<spanclass="math inline">\(n-1\)</span>条边。</li></ol></li><li><p>单源最短路径，Dijkstra算法：求图中某一顶点到其他各顶点的最短路径。</p><ol type="1"><li>初始化：集合<span class="math inline">\(S=\{0 \}\)</span>，记录<spanclass="math inline">\(V-S\)</span>中每个顶点到源点<spanclass="math inline">\(v_0\)</span>的距离。</li><li>从顶点集合<span class="math inline">\(V-S\)</span>中选出与<spanclass="math inline">\(v_0\)</span>距离最短的点<spanclass="math inline">\(v_j\)</span>。</li><li>更新从<span class="math inline">\(v_0\)</span>出发到集合<spanclass="math inline">\(V-S\)</span>上每个顶点的距离为<spanclass="math inline">\(v_j\)</span>到其距离和原距离的较小者。</li><li>重复2和3，直到所有的顶点处于<spanclass="math inline">\(S\)</span>中。</li></ol><ul><li>边上带有负的权值时，Dijkstra算法不适用。</li></ul></li><li><p>各顶点之间最短距离，Floyd算法：</p></li><li><p>有向无环图：不存在环的有向图，相较二叉树存储可以共享子结点，节省存储空间。简称DAG图。</p><ul><li>用有向无环图表示工程，顶点表示活动，体现活动必须的先后关系。这称为顶点表示活动的网络，简称AOV网。</li></ul></li><li><p>拓扑排序：有向无环图的顶点序列，每个顶点只出现一次，不存在从后续结点到序列前部结点路径。</p><ul><li>过程：每次选择一个入度为0的顶点并输出，删除该顶点与所有以它为起点的有向边。<ul><li>每次检测入度为0的顶点都唯一，则拓扑排序唯一。</li></ul></li><li>邻接表拓扑排序时间复杂度<spanclass="math inline">\(O(|V|+|E|)\)</span>，邻接矩阵拓扑排序时间复杂度<spanclass="math inline">\(O(|V|^2)\)</span>。<ul><li>若邻接矩阵为三角矩阵则拓扑排序唯一，反之不一定成立。</li></ul></li></ul></li><li><p>用边表示活动的网络，AOE网：顶点表示时间，有向边表示活动，边权表示开销。</p><ul><li>关键路径：从源点到汇点的所有路径中，具有最大长度的路径。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-2_树</title>
    <link href="/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2_%E6%A0%91/"/>
    <url>/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2_%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树">2. 树</h1><p>夜阑月明人尽望，铁骑刀锋梦中伏。</p><span id="more"></span><h2 id="树基础">2.1 树基础</h2><h3 id="树-1">树</h3><ol type="1"><li>树：<span class="math inline">\(n\)</span>个结点的有限集合。当<spanclass="math inline">\(n=0\)</span>，称为空树。且一棵非空树满足：<ul><li>有且仅有一个称为根的结点；</li><li>非根结点可分为互不相交的有限集合，每个集合本身又是一棵树，并且是根的子树。</li></ul></li><li>术语：<ul><li>祖先、子孙：某个结点<spanclass="math inline">\(K\)</span>到根的路径上的所有其他结点为<spanclass="math inline">\(K\)</span>的祖先，<spanclass="math inline">\(K\)</span>是它们的子孙。</li><li>父/母亲、孩子：某个结点<spanclass="math inline">\(K\)</span>到根的路径上离<spanclass="math inline">\(K\)</span>最近的其他结点为其父/母亲，<spanclass="math inline">\(K\)</span>是它们的孩子。</li><li>兄弟、堂兄弟：父/母亲为同一个结点的结点称为兄弟，父/母亲为同一层结点的结点称为堂兄弟。</li><li>度：一个结点的孩子数称为该结点的度。树中结点的最大度数称为树的度。</li><li>分支结点、叶结点：度为0的结点为叶结点，否则为分支结点。</li><li>层次、深度/高度：根为1层，孩子为2层，类推。<ul><li>树的深度/高度为最大层数。</li><li>结点的高度是以其为根的子树的高度。</li></ul></li><li>有序树和无序树：结点的左右子树有顺序、不能互换的树为有序树，否则为无序树。</li><li>路径：两个结点之间经过的结点序列。路径长度为经过的边的长度。</li></ul></li><li>计算性质：需要的话现场算即可<ul><li>结点数为所有结点度数+1（子结点数+根结点）</li><li>度为<span class="math inline">\(m\)</span>的树中第<spanclass="math inline">\(i\)</span>层上至多有<spanclass="math inline">\(m^{i-1}\)</span>个结点（等比数列）</li><li>高为<span class="math inline">\(h\)</span>的<spanclass="math inline">\(m\)</span>叉树至多有<spanclass="math inline">\(\frac{(m^k-1)}{m-1}\)</span>个结点（等比数列）</li><li>度为<span class="math inline">\(m\)</span>、具有<spanclass="math inline">\(n\)</span>个结点的树的最小高度为<spanclass="math inline">\([\log_m(n(m-1)+1)]+1\)</span></li><li>度为<span class="math inline">\(m\)</span>、具有<spanclass="math inline">\(n\)</span>个结点的树的最大高度为<spanclass="math inline">\(n-m+1\)</span>。</li><li>高度<span class="math inline">\(h\)</span>、度为<spanclass="math inline">\(m\)</span>的树至少有<spanclass="math inline">\(h+m-1\)</span>个结点</li></ul></li></ol><h3 id="存储">存储</h3><ol type="1"><li>双亲表示法：使用数组存储结点，每个结点记录其值与双亲的下标。</li><li>孩子表示法：每个结点的孩子用一个线性单链表存储。</li><li>左孩子右兄弟表示法：第一个孩子的根作为左子结点，下一个兄弟的根作为右子结点。<ul><li>树、森林可使用左孩子右兄弟表示法转化为二叉树。</li></ul></li></ol><h2 id="二叉树">2.2 二叉树</h2><h3 id="定义">定义</h3><ol type="1"><li>二叉树中不存在度大于2的结点，且二叉树的子树有左右之分。<ul><li>和度为2的有序树的区别：当一个结点只有一个子结点，二叉树仍然区分左和右。</li></ul></li><li>特殊二叉树：<ul><li>满二叉树：高度为<span class="math inline">\(h\)</span>，且有<spanclass="math inline">\(2^h-1\)</span>个结点的二叉树。<ul><li>按层序为结点编号，则<spanclass="math inline">\(i\)</span>结点的父结点为<spanclass="math inline">\([\frac i2]\)</span>，左子结点为<spanclass="math inline">\(2i\)</span>，右子结点为<spanclass="math inline">\(2i+1\)</span>。</li></ul></li><li>完全二叉树：高度为<span class="math inline">\(h\)</span>、有<spanclass="math inline">\(n\)</span>个结点的二叉树，当它的每个结点都与高度为<spanclass="math inline">\(h\)</span>的满二叉树中编号为<spanclass="math inline">\(1\sim n\)</span>的结点一一对应，称其为完全二叉树。<ul><li><span class="math inline">\(i\le[\fraci1]\)</span>为分支结点，否则为叶结点。</li><li>叶结点只会在最高的2层。</li><li>度为1的结点最多有1个，它的子结点一定是左子结点，此时<spanclass="math inline">\(n\)</span>为偶数。</li><li>结点<span class="math inline">\(i\)</span>在<spanclass="math inline">\([\log_2n]+1\)</span>层（或<spanclass="math inline">\(\log_2(n+1)\)</span>向上取整，<spanclass="math inline">\(\log_2n\)</span>向上取整可能是错的）</li></ul></li><li>二叉排序树：任意结点左子树上所有结点的值小于原结点的值小于结点右子树上所有结点的值。</li><li>平衡二叉树：任意结点的左右子树高度差的绝对值不大于1，也称AVL树。</li><li>正则二叉树：树中只有度为0或2的结点。</li></ul></li><li>计算性质：设度为<spanclass="math inline">\(0,1,2\)</span>的结点数为<spanclass="math inline">\(n_0,n_1,n_2\)</span>。<ul><li>非空二叉树的叶结点数等于度为2的结点数+1：<spanclass="math inline">\(n_0=n_2+1\)</span></li></ul></li><li>遍历：<ul><li>先序：从根结点开始，对每个结点，按照根<spanclass="math inline">\(\rightarrow\)</span>左子树<spanclass="math inline">\(\rightarrow\)</span>右子树的顺序进行遍历。</li><li>中序：从根结点开始，对每个结点，按照左子树<spanclass="math inline">\(\rightarrow\)</span>根<spanclass="math inline">\(\rightarrow\)</span>右子树的顺序进行遍历。</li><li>后序：从根结点开始，对每个结点，按照左子树<spanclass="math inline">\(\rightarrow\)</span>右子树<spanclass="math inline">\(\rightarrow\)</span>根的顺序进行遍历。<ul><li>上述三种遍历可以使用递归/栈来实现。</li></ul></li><li>层序：逐层从左到右遍历。<ul><li>使用队列实现。</li></ul></li></ul></li><li>使用遍历序列构造二叉树：<ul><li>中序+先序</li><li>中序+后序</li><li>中序+层序</li><li>其余组合均无法唯一确定一棵二叉树。</li></ul></li></ol><h3 id="存储-1">存储</h3><ol type="1"><li><p>顺序存储：按照满二叉树结点编号位置存储二叉树结点，不存在的结点置0。</p></li><li><p>链式存储。</p><ul><li>在含有<spanclass="math inline">\(n\)</span>个结点的二叉链表中含有<spanclass="math inline">\(n+1\)</span>个空链域<spanclass="math inline">\(\rightarrow\)</span>线索二叉树。</li></ul></li><li><p>线索二叉树：添加左右标记位，记录是否有左右子树。</p><p>若无左子树，则左指针指向前驱结点，若无右子树，右指针指向后继结点。</p><ul><li>构建：在遍历过程中记录前驱结点，若无左指针则添加，若前驱无右指针则添加。</li><li>先序、中序、后序下查找前驱和后继。</li></ul></li></ol><h2 id="应用">2.3 应用</h2><h3 id="哈夫曼树">哈夫曼树</h3><ol type="1"><li><p>路径：从树上一个结点到另一个结点间的分支。</p><p>路径长度：路径上的分支数。</p><p>权：结点被赋予的数值。</p><p>结点的带权路径长度：从树的根到一个结点的路径长度和该结点权的乘积。</p><p>树的带权路径长度：树中所有叶结点的带权路径长度之和。</p></li><li><p>哈夫曼树：含有n个带权叶结点的、带权路径长度最小的二叉树。</p><ul><li>构造哈夫曼树：<ol type="1"><li>将n个结点视为n个仅含一个结点的树。</li><li>构造一个新结点，选取根的权值最小的两棵树作为其左右子树，新结点的权为两树根权之和。</li><li>重复2直至只剩下一棵树。</li></ol></li></ul></li><li><p>哈夫曼编码：利用二叉树来设计二进制前缀编码。</p><ul><li>固定长度编码：每个字符用相等长度二进制表示。</li><li>可变长度编码：不同字符可以用不同长度二进制表示。<ul><li>前缀编码：没有一个编码是其他编码的前缀。</li></ul></li></ul><p>示例：0表示A，10表示B，110表示C，111表示D。</p><ul><li>使用字符出现的频度作为权，将每个字符作为结点构建哈夫曼树，进行编码。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-1_线性表</title>
    <link href="/2022/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1_%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2022/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1_%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表">1. 线性表</h1><p>夜阑月明人尽望，铁骑刀锋梦中伏。</p><span id="more"></span><h2 id="线性表基础">1.1 线性表基础</h2><h3 id="定义">定义</h3><ol type="1"><li>线性表：具有相同数据类型的<spanclass="math inline">\(n\)</span>个数据元素的有限序列。<ul><li><span class="math inline">\(n\)</span>为表长，当<spanclass="math inline">\(n=0\)</span>，该表为空表。</li></ul></li><li>基本操作：<ul><li>初始化/销毁</li><li>求表长</li><li>判空</li><li>按值查找位</li><li>按位查找值</li><li>插入/删除</li></ul></li></ol><h3 id="顺序存储">顺序存储</h3><ol type="1"><li>线性表的顺序存储，又称顺序表。<ul><li>用一组地址空间连续的存储单元依次存储线性表中的数据元素。</li></ul></li><li>基本操作：<ul><li>按值查找位：遍历表，时间复杂度<spanclass="math inline">\(O(n)\)</span>。</li><li>按位查找值：随机访问，时间复杂度<spanclass="math inline">\(O(1)\)</span>。</li><li>插入/删除：执行操作并移动操作位置后的所有元素，时间复杂度<spanclass="math inline">\(O(n)\)</span>。</li></ul></li><li>评价：<ul><li>只存储数据元素，存储密度高，但需要连续存储空间，不灵活。</li><li>访问<span class="math inline">\(O(1)\)</span>，但插入、删除<spanclass="math inline">\(O(n)\)</span>。</li></ul></li></ol><h3 id="链式存储">链式存储</h3><ol type="1"><li><p>单链表：通过一组链表结点存储线性表。</p><ul><li><p>每个链表结点包含数据元素与后继指针，表尾元素后继为空。</p></li><li><p>头指针：链表的起始地址。</p><ul><li>头结点：指针指向第一个数据元素。</li><li>有头结点时，头指针指向头结点，头结点指针指向空表示链表为空。</li><li>无头结点时，头指针为第一个数据元素，为空时表示链表为空。</li></ul></li><li><p>基本操作：</p><ul><li>查找、求表长：遍历表，时间复杂度<spanclass="math inline">\(O(n)\)</span>。</li><li>插入/删除：先查找<spanclass="math inline">\(O(n)\)</span>后操作<spanclass="math inline">\(O(1)\)</span>，时间复杂度<spanclass="math inline">\(O(n)\)</span>。</li></ul></li><li><p>循环单链表：表尾元素后继为头结点。</p><ul><li>常设尾指针，此时头插与尾插时间复杂度均为<spanclass="math inline">\(O(1)\)</span>。</li></ul></li></ul></li><li><p>双链表：通过一组链表结点存储线性表。</p><ul><li>每个链表结点包含数据元素、前驱指针与后继指针，表头元素前驱为空，表尾元素后继为空。</li><li>循环双链表：表头元素前驱为表尾元素，表尾元素后继为头结点。</li></ul></li><li><p>静态链表：用顺序存储的方式来存储链表，不同于顺序表的是，每个结点额外存储下一个元素的位置。</p></li></ol><h3 id="数组">数组</h3><ol type="1"><li>具有相同数据类型的<spanclass="math inline">\(n\)</span>个数据元素的有限序列，线性表的推广。<ul><li>每个数据元素称为一个数组元素</li><li>每个元素的序号称为该元素的下标</li></ul></li><li>多维数组：元素为数组的数组。<ul><li>特殊矩阵压缩存储：<ul><li>上/下三角矩阵：按行或列序依次存储上/下三角元素到一维数组中。</li><li>对称矩阵：转化为上/下三角矩阵。</li><li>三对角矩阵：非零元素集中在以主对角线为中心的3条对角线上的矩阵。<ul><li>按行或列序依次存储到一维数组中。</li></ul></li><li>稀疏矩阵：非零元素数远小于矩阵元素数。<ul><li>三元组存储：<spanclass="math inline">\((行,列,值)\)</span>。也需要保存矩阵的行数、列数(和非零元素数)。</li><li>十字链表</li></ul></li></ul></li></ul></li></ol><h3 id="字符串">字符串</h3><ol type="1"><li>字符串，简称串，零个或多个字符组成的有限序列。<ul><li>长度为0的串称为空串。</li></ul></li><li>模式匹配：查找子串位置。<ul><li>KMP算法：使用最长公共前后缀进行匹配。</li></ul></li></ol><h2 id="栈">1.2 栈</h2><h3 id="定义-1">定义</h3><ol type="1"><li>栈：只允许在一端进行插入/删除的线性表。<ul><li>栈顶：线性表允许进行插入/删除的端点。</li><li>栈底：线性表不允许进行插入/删除的端点。</li></ul></li><li>基本操作：<ul><li>初始化/销毁</li><li>判空</li><li>压栈/出栈</li><li>读栈顶元素</li></ul></li><li>卡特兰数公式：当<spanclass="math inline">\(n\)</span>个不同元素按一定顺序压栈，出栈序列的排列数为<spanclass="math inline">\(\frac1{n+1}C_{2n}^n\)</span>。</li></ol><h3 id="存储">存储</h3><ol type="1"><li>使用顺序表依次存储栈中元素，并记录栈顶元素位置。<ul><li>共享栈：将两个栈的栈底设为一个顺序存储空间的两端，两个栈顶向中间延伸。</li></ul></li><li>使用链表存储栈。</li></ol><h3 id="应用">应用</h3><ol type="1"><li>括号匹配、表达式求值</li><li>递归算法非递归化</li><li>函数调用</li></ol><h2 id="队列">1.3 队列</h2><h3 id="定义-2">定义</h3><ol type="1"><li>队列：只允许在一端进行插入、另一端进行删除的线性表。<ul><li>队头：允许删除的一端</li><li>队尾：允许插入的一端</li></ul></li><li>基本操作：<ul><li>初始化/销毁</li><li>判空</li><li>入队/出队</li><li>读队头元素</li></ul></li><li>双端队列：只允许在两端进行插入/删除的线性表。<ul><li>输入受限：一端插入，两端删除</li><li>输出受限：两端插入，一端删除</li></ul></li></ol><h3 id="存储-1">存储</h3><ol type="1"><li>使用顺序表依次存储队列中元素，记录队头和队尾位置。<ul><li>已出队位置空间浪费<spanclass="math inline">\(\rightarrow\)</span>循环队列</li><li>循环队列：队头/尾到顺序表上限后到0位继续操作。<ul><li>判满与判空<ul><li>计数</li><li>一种方法：队尾=队头即空，(队尾+1)%表长=队头即满（会牺牲一个存储位置）</li></ul></li></ul></li></ul></li><li>队列的链式存储也称链队列。</li></ol><h3 id="应用-1">应用</h3><ol type="1"><li>层次遍历</li><li>缓冲区</li><li>资源的队列管理</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-0_绪论</title>
    <link href="/2022/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/0_%E7%BB%AA%E8%AE%BA/"/>
    <url>/2022/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/0_%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论">0. 绪论</h1><p>夜阑月明人尽望，铁骑刀锋梦中伏。</p><span id="more"></span><h2 id="数据结构">0.1 数据结构</h2><h3 id="概念">概念</h3><ol type="1"><li>数据：信息的载体，能被计算机程序识别和处理的符号集合。</li><li>数据元素：数据的的基本单位。</li><li>数据项：构成数据元素的不可分割的最小单位。</li><li>数据对象：具有相同性质的数据元素的集合。</li><li>数据类型：一个值的集合和定义在此集合上的一组操作的总称。<ul><li>原子类型：其值不可再分的数据类型</li><li>结构类型：其值可以再分解为若干分量的数据类型</li><li>抽象数据类型：一个数学模型及定义在该数学模型上的一组操作</li></ul></li><li>数据结构：相互之间存在一种或多种特定关系的数据元素的集合。</li></ol><h3 id="数据结构三要素">数据结构三要素</h3><p>数据元素相互之间的关系称为结构，包括逻辑结构、存储结构和数据的运算。</p><ol type="1"><li>逻辑结构：<ul><li>线性结构：<ul><li>线性表：栈、队列、数组</li></ul></li><li>非线性结构：<ul><li>集合</li><li>树</li><li>图</li></ul></li></ul></li><li>存储结构：<ul><li>顺序存储</li><li>链式存储</li><li>索引存储</li><li>散列存储</li></ul></li><li>数据的运算：定义取决于逻辑结构，实现取决于物理结构。</li></ol><h2 id="算法">0.2 算法</h2><h3 id="概念-1">概念</h3><p>算法是对特定问题求解步骤的一种描述。</p><ul><li>算法的五个重要特性：<ul><li>有穷性：有穷步数，有穷时间</li><li>确定性：相同输入，相同输出</li><li>可行性：可由已定义的有限次运算实现</li><li>输入</li><li>输出</li></ul></li><li>好的算法的目标：<ul><li>正确性</li><li>可读性</li><li>健壮性：能对非法输入进行处理</li><li>高效率、低存储</li></ul></li></ul><h3 id="度量">度量</h3><ol type="1"><li>时间复杂度：算法中所有语句的频度和的数量级。</li><li>空间复杂度：算法所需存储空间。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成概述</title>
    <link href="/2022/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/11/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成概述">计算机组成概述</h1><p>夜阑月明人尽望，铁骑刀锋梦中伏。</p><span id="more"></span><h2 id="计算机系统概述">1. 计算机系统概述</h2><h3 id="层次结构">层次结构</h3><ol type="1"><li>计算机系统由硬件和软件系统共同构成。硬件指有形的物理设备，软件指运行的程序和相关的数据。</li><li>计算机系统某一功能如果既可以用硬件实现，又可以用软件实现，则称软硬件在该逻辑功能上等价。</li></ol><h4 id="硬件">硬件</h4><ol type="1"><li><p>存储程序的基本思想：将程序和数据存于主存储器中，计算机执行程序时逐条运行指令。</p></li><li><p>存储程序计算机又称为冯·诺伊曼计算机，这类计算机具有三个基本原则：</p><ul><li><p>二进制</p></li><li><p>存储程序</p></li><li><p>五个基本组成部分：主存储器、算术逻辑单元、控制单元、输入设备、输出设备</p></li></ul></li><li><p>存储程序的工作方式：程序执行前，将第一条指令的地址存放在程序计数器PC。</p><ul><li><p>根据PC取指令。</p></li><li><p>指令译码，PC自增。</p></li><li><p>取操作数，执行指令，送回结果。</p></li><li><p>循环上述步骤。</p></li></ul></li></ol><h4 id="软件">软件</h4><ol type="1"><li><p>软件按功能可分为系统软件和应用软件，其中系统软件主要有操作系统、数据库管理系统等。</p></li><li><p>软件语言按级别分为机器语言、汇编语言和高级语言。</p><ul><li><p>机器语言是计算机唯一可以直接识别和执行的语言，每条指令以二进制编码。</p></li><li><p>汇编语言用字符串取代二进制编码，便于理解。</p></li><li><p>高级语言更方便程序员进行编写。</p></li></ul></li><li><p>软件语言转化需要翻译程序，包括汇编器、解释器和编译器。</p><ul><li>汇编器将汇编语言翻译成机器语言。</li><li>解释器将源程序中语句按执行顺序逐条翻译为机器语言。</li><li>编译器将高级语言编译为汇编语言或机器语言。</li></ul></li></ol><h3 id="性能指标">性能指标</h3><ol type="1"><li><p>机器字长：计算机进行一次整型运算能够处理的二进制数据位数。</p></li><li><p>数据通路带宽：数据总线一次所能并行传送信息的位数。</p></li><li><p>主存容量</p><ul><li>内存地址存储器，MAR的位数反映了存储单元的个数。</li><li>内存数据存储器，MDR的位数反映了存储单元的字长。</li></ul></li><li><p>运算速度</p><ul><li><p>吞吐量是系统单位时间处理请求数量，响应时间是发出请求到系统对请求作出响应的时间。</p></li><li><p>时钟周期是CPU工作最小的时间单位，主频是时钟周期的倒数，即每秒的时钟周期数。</p></li><li><p>CPI，Cycle PerInstruction：执行一条指令需要的时钟周期数。</p></li><li><p>IPS，Instruction PerSecond：每秒执行指令数，IPS=主频/平均CPI。</p></li><li><p>CPU执行时间：一个程序执行的时间。CPU执行时间=程序执行的CPU时钟周期数/主频。</p></li><li><p>FLOPS，Floating-point Operations Per Second：每秒浮点运算数。</p><ul><li>M，<span class="math inline">\(10^6\)</span></li><li>G，<span class="math inline">\(10^9\)</span></li><li>T，<span class="math inline">\(10^{12}\)</span></li><li>P，<span class="math inline">\(10^{15}\)</span></li><li>E，<span class="math inline">\(10^{18}\)</span></li><li>Z，<span class="math inline">\(10^{21}\)</span></li><li>京=亿亿=<span class="math inline">\(10^{16}\)</span></li><li>在描述存储时，K、M通常用2的幂次表示，而描述频率时，通常用10的幂次表示。</li></ul></li></ul></li></ol><h2 id="数据的表示和运算">2. 数据的表示和运算</h2><h3 id="表示">表示</h3><ol type="1"><li>十进制数与<span class="math inline">\(k\)</span>进制数的相互转换：<ul><li><span class="math inline">\(k\)</span>进制<spanclass="math inline">\(\rightarrow\)</span>十进制：<spanclass="math inline">\(k\)</span>进制数<spanclass="math inline">\(a_n...a_0.a_{-1}...a_{-m}=a_n\timesk^n+...+a_0\times k^0+a_{-1}\times k^{-1}+...+a_{-m}\timesk^{-m}\)</span></li><li>十进制<span class="math inline">\(\rightarrow\)</span><spanclass="math inline">\(k\)</span>进制：基数乘除法<ul><li>整数部分除<spanclass="math inline">\(k\)</span>取余数，先取得的余数为低位，商为0时结束</li><li>小数部分乘<spanclass="math inline">\(k\)</span>取整数，先取得的整数为高位，乘积为1.0时结束。</li></ul></li></ul></li><li>数的二进制编码称为机器数，机器数的实际值称为真值。<ul><li>为什么要采用二进制编码：易于物理表示、与逻辑真假对应、便于逻辑门计算。</li><li>定点表示默认小数点在机器数的某位前或某位后。浮点表示则编码给出小数点位置。</li></ul></li><li>定点编码：<span class="math inline">\(n\)</span>位二进制编码<ul><li>原码：<span class="math inline">\(y=\begin{cases}x, 0\le x\le2^{n-1}-1\\2^{n-1}-x,-2^{n-1}\le x\le0 \end{cases}\)</span></li><li>反码：<span class="math inline">\(y=\begin{cases}x, 0\le x\le2^{n-1}-1\\2^n+x-1,-2^{n-1}\le x\lt0 \end{cases}\)</span></li><li>移码：<span class="math inline">\(y=k+x，-k\le x\lt2^n-k\)</span></li><li>补码：<span class="math inline">\(y=\begin{cases}x, 0\le x\le2^{n-1}-1\\2^n+x,-2^{n-1}\le x\lt0 \end{cases}\)</span></li></ul></li><li>浮点编码：IEEE 754标准<ul><li>单精度浮点数，32位：1位符号，8位阶码（偏置值127），23位尾数<ul><li>阶码为128（移码值255）时<ul><li>尾数小数全为0，则为正/负无穷大</li><li>尾数小数不为0，则为非数<span class="math inline">\(NaN\)</span></li></ul></li><li>阶码为-127（移码值0）时<ul><li>尾数小数全为0，则为0</li><li>尾数小数为<span class="math inline">\(f\)</span>，移码值为<spanclass="math inline">\(e\)</span>，<spanclass="math inline">\(N=(-1)^m2^{e-126}(0.f)\)</span></li></ul></li><li>一般情况：<spanclass="math inline">\(N=(-1)^m2^{e-127}(1.f)\)</span>，其中<spanclass="math inline">\(m\)</span>为符号位，<spanclass="math inline">\(e\)</span>为阶码移码值，<spanclass="math inline">\(f\)</span>为尾数小数。</li></ul></li><li>双精度浮点数，64位：1位符号，11位阶码，52位尾数</li></ul></li></ol><h3 id="运算">运算</h3><h4 id="基本部件">基本部件</h4><ol type="1"><li><p>全加器Full Adder，FA：<spanclass="math inline">\(\oplus\)</span>表示异或</p><ul><li><p>输入：进位<span class="math inline">\(C\)</span>、输入位<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>计算</p></li><li><p>输出：结果位<span class="math inline">\(S=X\oplus Y\oplusC\)</span>，进位<span class="math inline">\(C&#39;=(X\and C)\or(X\andY)\or(C\and Y)\)</span></p></li></ul></li><li><p>串行进位加法器：串联全加器，将上一个全加器的输出进位作为下一个全加器的输入进位。</p></li><li><p>全先行进位加法器：提前计算每个全加器的输入进位，加速串行进位加法器的执行。</p><ul><li><spanclass="math inline">\(C_i=X_iC_{i-1}+Y_iC_{i-1}+X_iY_i\)</span>，设<spanclass="math inline">\(P_i=X_i+Y_i,G_i=X_iY_i\)</span>。<ul><li><span class="math inline">\(C_1=G_1+P_1C_0\)</span></li><li><spanclass="math inline">\(C_2=G_2+P_2C_1=G_2+P_2G_1+P_2P_1C_0\)</span></li><li><span class="math inline">\(...\)</span></li></ul></li><li>计算快，但电路复杂。</li></ul></li><li><p>部分先行进位加法器：串联多个全先行进位加法器。</p></li><li><p>带标志加法器：</p><ul><li>溢出标志<span class="math inline">\(OF=C_n\oplusC_{n-1}\)</span>。</li><li>符号标志<span class="math inline">\(SF\)</span>为和的符号。</li><li>零标志<span class="math inline">\(ZF=1\)</span>当且仅当和为0。</li><li>进位标志<span class="math inline">\(CF=C_{out}\oplusC_{in}\)</span>。</li></ul></li></ol><h4 id="运算实现">运算实现</h4><ol type="1"><li><p>定点数移位：</p><ul><li>逻辑移位：左移时低位补0，右移时高位补0。</li><li>算数移位：左移时低位补0，右移时高位补符号位</li></ul></li><li><p>定点数加减：</p><ul><li>原码：加法同号求和，异号求差；减法对减数符号取反，然后执行原码加法。</li><li>补码：加法直接相加；减法将减数的负数的补码与被减数相加。<ul><li>溢出判断：符号位相同且相加后符号位变化则溢出；最高位和次高位的进位不同则溢出。</li></ul></li></ul></li><li><p>定点数乘法：逐位求积并对每一位的积求和。</p><ul><li><p>设乘数<span class="math inline">\(X\)</span>，被乘数<spanclass="math inline">\(Y\)</span>均为无符号<spanclass="math inline">\(n\)</span>位二进制数，则设<spanclass="math inline">\(2n\)</span>位乘积寄存器，初始全0。</p><ul><li>当<span class="math inline">\(Y_i\)</span>为0，部分积右移一位。</li><li>当<span class="math inline">\(Y_i\)</span>为1，部分积前n位加上<spanclass="math inline">\(X\)</span>，并右移一位。</li></ul></li><li><p>布斯算法：带有符号位的乘法</p><p><span class="math inline">\(\begin{aligned}X\times Y&amp;=X\timesY_nY_{n-1}...Y_2Y_1\\&amp;=X\times(-Y_n\times2^{n-1}+Y_{n-1}\times(2^{n-1}-2^{n-2})+...+Y_1\times(2-2^0))\\&amp;=X\times((Y_{n-1}-Y_n)\times2^{n-1}+...+(Y_0-Y_1)\times2^0)\\&amp;=2^n\times\Sigma_{i=0}^{n-1}(X\times(Y_i-Y_{i+1})\times2^{-(n-i)})\end{aligned}\)</span></p><ul><li><span class="math inline">\(Y_0=0\)</span></li><li>根据<spanclass="math inline">\(Y_{i},Y_{i+1}\)</span>来确定部分积加上<spanclass="math inline">\(X,-X\)</span>或<spanclass="math inline">\(0\)</span>，右移部分积。重复<spanclass="math inline">\(n\)</span>次。</li></ul></li></ul></li><li><p>定点数除法：</p><ul><li><p>被除数为0，除数不为0时商为0；除数为0时异常。</p></li><li><p>恢复余数的除法过程：</p><ol type="1"><li>在被除数前面加n位符号位扩展至2n位，存储在余数和商寄存器中</li><li>将余数和商左移，判断是否够减（同号相减，异号相加，变号则不够减）<ul><li>如果够，上商为1；不够，恢复余数，上商为0。</li></ul></li><li>重复</li><li>如果除数和被除数不同号，则将商替换为其相反数</li><li>余数存在余数寄存器中</li></ol></li><li><p>不恢复余数的除法过程：</p><ol type="1"><li><p>在被除数前面加n位符号位扩展至2n位，存储在余数和商寄存器中</p></li><li><p>若除数与被除数符号相同则作减法，否则作加法，如果余数和除数符号相同，上商为1，否则商为0；</p><ul><li><p>如果余数和除数符号相同，余数<spanclass="math inline">\(R_{i+1}=2R_i-Y\)</span>，否则，<spanclass="math inline">\(R_{i+1}=2R_i+Y\)</span>；</p><p>如果新的余数和除数符号相同，商为1，否则，商为0</p></li></ul></li><li><p>重复。</p></li></ol></li></ul></li><li><p>浮点数加减：检查0，对齐尾数（放大偏小的阶码），加减有效值，规格化结果。</p><ul><li>阶值上溢：正阶值超过可能的最大允许阶值，标记为<spanclass="math inline">\(+\infin\)</span>或<spanclass="math inline">\(-\infin\)</span></li><li>阶值下溢：负阶值小于可能的最小允许阶值，报告为0</li><li>有效值上溢：右规，同号两个有效值相加导致最高有效值的进位，需重新对齐以修正</li><li>有效值下溢：左规，有效值对齐过程中，有数字移出右端最低位而丢失，需四舍五入</li></ul></li><li><p>浮点数乘除：</p><ul><li>乘法：检查0，阶值求和并减去一个偏移量，有效值相乘，规格化结果和舍入。</li><li>除法：检查0，阶值相减并加上一个偏移量，有效值相除，规格化结果和舍入。</li></ul></li></ol><h2 id="存储器">3. 存储器</h2><h3 id="概述">概述</h3><ol type="1"><li><p>存储器：由一定数量的单元构成，每个单元可以被唯一标识，并有存储一个数值的能力。</p><ul><li>地址：单元的唯一标识符</li><li>地址空间：可唯一标识的单元总数</li><li>寻址能力：存储在每个单元中信息的位数<ul><li>大多数存储器是字节寻址的，而执行科学计算的计算机通常是64位寻址的</li></ul></li><li>位元：半导体存储器的基本元件，用于存储一位数据</li></ul></li><li><p>存储器的特性：</p><ul><li>存储介质：半导体存储器、磁表面存储器（磁盘、磁带）、磁芯存储器、光存储器（光盘）。</li><li>存取方式：随机存取（RAM、ROM）、串行存取（顺序存取：磁带；直接存取：磁盘、光盘）</li><li>易失性：断电后信息消失的存储器为易失存储器（RAM），否则为非易失存储器。</li><li>破坏性读取：读取数据时是否会破坏数据。</li></ul></li><li><p>存储器性能指标：</p><ul><li>存储容量：存储字数<spanclass="math inline">\(\times\)</span>字长</li><li>单位成本：每位的价格</li><li>存储速度/数据传输速率（每秒传输信息位数）<ul><li>存取时间：读取时间和写入时间。</li><li>存取周期：存储器进行一次读写操作加上恢复操作所需的全部时间。</li><li>主存带宽：即数据传输速率。</li></ul></li></ul></li><li><p>计算机中的存储器：高速缓冲存储器、主存储器、辅助存储器。</p></li></ol><h3 id="物理存储器">物理存储器</h3><ol type="1"><li><p>随机存储器，Random Access Memory，RAM。</p><ul><li><p>动态RAM，DRAM：使用电容充电的方式存储数据，根据电荷阈值确定1或0。</p><ul><li>破坏性读取，数据密度高，功耗小，价格低。</li><li>电荷会逐渐消失，需要周期刷新数据存储。<ul><li>集中刷新：停止读写内存并刷新每一行；刷新时无法操作内存。</li><li>分散刷新：每个存储周期内，当读写操作完成时进行刷新。会增加每个存储周期的时间。</li><li>异步刷新：每一行各自以一定的时间间隔刷新；效率高，较常用。</li></ul></li><li>同步DRAM，SDRAM：与处理器的数据交互同步与外部的时钟信号。</li><li>双速率SDRAM，DDR：每个时钟周期发送两次数据，分别在时钟脉冲的上升沿和下降沿。</li></ul></li><li><p>静态RAM，SRAM：使用晶体管的触发器、逻辑门存储数据。</p><ul><li>存取快于DRAM，数据密度低，功耗大，价格贵。</li><li>非破坏性读取，有电源就可以一直维持数据。</li></ul></li></ul></li><li><p>只读存储器，Read-OnlyMemory，ROM：非易失；需要先擦除后写入，因此写比读慢。</p><ul><li><p>掩模式ROM，MROM：不可写入。</p></li><li><p>可编程ROM，PROM：可以使用电信号等专门设备写入一次。</p></li><li><p>可擦除PROM，EPROM：光擦除，电写入，更贵但能多次改写。</p></li><li><p>电EPROM，EEPROM：随时写入。更贵，密度低于EPROM。</p></li><li><p>快闪存储器，FlashMemory：块级电擦除，密度与EPROM相同，价格在EPROM和EEPROM间。</p></li><li><p>固态硬盘，Solid State Drive：由Flash芯片和控制单元组成。</p><ul><li>与硬磁盘存储器相比：抗振性好、无噪声、能耗低、发热少。</li><li>磨损均衡：闪存的擦写次数有限，如果集中在几个闪存块进行读写，会导致其磨损较快。<ul><li>动态磨损均衡：写入时自动选择较新的闪存块。</li><li>静态磨损均衡：SSD自动检测并进行数据分配，使得平时的读写在较新的闪存块进行。</li></ul></li></ul></li></ul></li><li><p>存储芯片内部结构：存储体、读写电路、地址译码器、控制电路。</p><ul><li>存储体，又称存储矩阵，由行、列选择线来选择访问单元，这一过程称为字选。</li><li>地址译码器，将地址转换为译码输出线的高电平来驱动读写电路。<ul><li>单译码：只有一个行译码器，同一行中的各单元被同时读取输出，缺点是译码输出线太多。</li><li>双译码：具有行、列译码器。</li></ul></li><li>读写电路：控制选择的单元的读取或写入，具有放大信息的作用。</li><li>控制电路：<ul><li>片选控制：存储器往往由多个存储芯片构成，需要进行芯片选择。<ul><li>线选：高位地址线直连芯片，当电位为0时选择该芯片（1位地址决定一个芯片）。</li><li>译码片选：高位地址译码器选片（n位地址选择<spanclass="math inline">\(2^n\)</span>个芯片）。</li></ul></li><li>读写控制：根据命令选择读/写。</li></ul></li></ul></li><li><p>机械硬盘，Hard DiskDrive：由涂有可磁化材料的非磁性材料构成的圆形盘片。</p><ul><li>硬盘结构：<ul><li>磁盘驱动器：驱动磁盘转动并在盘面上通过磁头进行读写。</li><li>磁盘控制器：接受主机命令并向磁盘驱动器发出信号。</li><li>存储区：多个盘片<ul><li>每个盘片有两个盘面，每个盘面有一个读写磁头。</li><li>每个盘面上有多个同心圆结构的磁道，相邻磁道间存在间隙。</li><li>每个磁道分为多个扇区，相邻扇区间存在间隙，相邻多个扇区组合成簇，按簇读写。</li><li>不同盘片相同位置的磁道构成柱面。</li></ul></li></ul></li><li>记录密度：<ul><li>道密度：沿磁盘半径方向单位长度上的磁道数。</li><li>位密度：磁道单位长度上的位数。</li><li>面密度：盘面单位面积上的位数，位密度和道密度的乘积。</li></ul></li><li>磁盘容量：<ul><li>非格式化容量：可用磁化单元总数，记录面数<spanclass="math inline">\(\times\)</span>柱面数<spanclass="math inline">\(\times\)</span>每条磁道的磁化单元数。</li><li>格式化容量：按某种特定格式能容纳的量，记录面数<spanclass="math inline">\(\times\)</span>柱面数<spanclass="math inline">\(\times\)</span>每道扇区数<spanclass="math inline">\(\times\)</span>每扇区容量。</li></ul></li><li>存取时间：寻道时间+旋转延迟+传输时间。<ul><li>寻道时间：磁头定位到指定磁道的时间。<ul><li>寻道算法：<ul><li>先来先服务 FCFS</li><li>最短寻道时间优先 SSTF</li><li>扫描/电梯 SCAN：磁头按照一个方向移动到边缘，然后返回</li><li>循环扫描 CSCAN：磁头只在往一个方向移动时进行读写，返回时不处理</li><li>电梯 LOOK：SCAN时，如果方向上没有请求就返回</li><li>循环电梯 CLOOK：CSCAN时，如果方向上没有请求就返回</li></ul></li></ul></li><li>旋转延迟：等待响应扇区的起始处到达磁头所需的时间。<ul><li>通常使用平均旋转延迟（旋转半周的时间）进行计算</li></ul></li><li>传输时间：数据传输速率<spanclass="math inline">\(rN\)</span>，其中磁盘转速<spanclass="math inline">\(r\)</span>转每秒，每条磁道容量<spanclass="math inline">\(N\)</span>字节。<ul><li>需要传输<span class="math inline">\(b\)</span>字节，则传输时间<spanclass="math inline">\(\frac{b}{rN}\)</span>。</li></ul></li></ul></li><li>磁盘地址：柱面（磁道）号，盘面（磁头）号，扇区号。</li></ul></li><li><p>冗余磁盘阵列，Redundant Array of Independent Disks，RAID：</p><ul><li>RAID0：无冗余、无校验磁盘阵列，通过多个磁盘进行存储提高读写速度</li><li>RAID1：镜像磁盘阵列，通过磁盘镜像提高安全性</li><li>RAID2：海明码磁盘阵列</li><li>RAID3：位交叉奇偶校验磁盘阵列</li><li>RAID4：块交叉奇偶校验磁盘阵列</li><li>RAID5：无独立校验的奇偶校验磁盘阵列</li></ul></li></ol><h3 id="高速缓冲存储器">高速缓冲存储器</h3><ol type="1"><li><p>内存墙：CPU的速度比内存快，且两者差距不断扩大。</p></li><li><p>程序访问的局部性原理：处理器频繁访问主存中相同位置或者相邻存储位置的现象。</p><ul><li>时间局部性：在相对较短的时间周期内，重复访问特定的信息。</li><li>空间局部性：在相对较短的时间内，访问相邻存储位置的数据。<ul><li>顺序局部性：数据被线性排列访问时，出现的一种空间局部性特殊情况。</li></ul></li></ul></li><li><p>高速缓冲存储器，Cache Memory。由SRAM组成，集成在CPU中。</p></li><li><p>工作流程：Cache和主存分块。当CPU试图访问主存中的某个字时，首先检查这个字是否在Cache中。</p><ul><li><p>命中：把这个字返回给CPU。</p></li><li><p>未命中：将包含这个字的主存中的固定大小的块读入Cache，再从Cache中将字传输给CPU。</p></li></ul></li><li><p>时间计算：命中率<spanclass="math inline">\(p\)</span>，Cache访问时间<spanclass="math inline">\(T_C\)</span>，主存访问时间<spanclass="math inline">\(T_M\)</span>，平均访问时间<spanclass="math inline">\(T_A\)</span>。</p><ul><li><span class="math inline">\(T_A=T_C+(1-p)T_M\)</span>。</li><li><span class="math inline">\(p\)</span>越大，<spanclass="math inline">\(T_C\)</span>越小，效果越好。</li><li><span class="math inline">\(T_A\lt T_M\)</span>的条件是<spanclass="math inline">\(p\gt \frac{T_C}{T_M}\)</span>。</li><li>Cache增大使得<span class="math inline">\(p\)</span>增大，但<spanclass="math inline">\(T_C\)</span>也增加。</li></ul></li><li><p>主存和Cache映射：假设Cache有<spanclass="math inline">\(2^c\)</span>行，主存<spanclass="math inline">\(2^m\)</span>块。</p><ul><li><p>直接映射：主存中每一块映射到固定的Cache行，主存地址高<spanclass="math inline">\(m-c\)</span>位作为标记。</p><ul><li>主存第<span class="math inline">\(j\)</span>块映射到第<spanclass="math inline">\(i\)</span>行：<spanclass="math inline">\(i=j\;mod\;2^c\)</span>。</li><li>即主存地址由<span class="math inline">\(m-c\)</span>位标记，<spanclass="math inline">\(c\)</span>位行号和块内地址组成。<ul><li>查找时，先根据行号查Cache，然后比对标记。</li></ul></li><li>缺点：抖动现象（Thrashing），程序重复访问两个需要映射到同一行中且来自不同块的字，则这两个块不断被交换到Cache中导致命中率下降。</li></ul></li><li><p>关联映射：一个主存块可以装入Cache任意一行</p><ul><li>将块装入空行，满之后根据特定算法进行替换。</li><li>缺点：搜索需要遍历每一行，适合小容量Cache。</li></ul></li><li><p>组关联映射：Cache分为多个组，主存块装入固定组的任意行。</p><ul><li>假设有<span class="math inline">\(2^s\)</span>组，则主存地址前<spanclass="math inline">\(m-s\)</span>位为标记，接下来<spanclass="math inline">\(s\)</span>位为组号。</li><li><span class="math inline">\(k=c-s\)</span>，又称<spanclass="math inline">\(2^k\)</span>路组关联映射。</li></ul></li><li><p>替换算法：随机 RAND，先进先出 FIFO，近期最少使用LRU，最不经常使用 LFU。</p><ul><li><p>LRU：假设最近使用过的内存块更可能被再次使用，替换掉最长时间未被访问的内存块。</p><ul><li>实现：2路组关联映射。<ol type="1"><li>每行包含一个USE位。</li><li>在同一组中的行被访问时，将其USE值设为1，将另一行的USE位设为0。</li><li>新数据块读入时，替换USE值为0的数据块。</li></ol></li><li>实现：4路组关联映射<ol type="1"><li>每行包含两个USE位。</li><li>在同一组中的行被访问时，将其USE值清0，其余非空行的USE值+1。</li><li>新数据块读入时，替换USE值最大的数据块。</li></ol></li></ul></li><li><p>LFU：假设访问越频繁的数据块越有可能被再次使用，替换掉被访问次数最少的数据块。</p><ul><li>实现：为每一行设置计数器。</li></ul></li></ul></li></ul></li><li><p>Cache写策略</p><ul><li><p>写直达：所有写操作同时对Cache和主存进行。</p><ul><li>优点：确保主存中数据总是和Cache中一致。</li><li>缺点：产生大量主存访问，减慢写的操作。</li></ul></li><li><p>写回法：先更新Cache，被替换时，若修改则写回主存。</p><ul><li><p>利用一个使用位表示块是否被修改。</p></li><li><p>优点：减少了访问主存的次数。</p></li><li><p>缺点：部分主存数据可能不是最新的。</p></li></ul></li></ul></li></ol><h3 id="主存储器">主存储器</h3><ol type="1"><li><p>CPU访问主存过程：存储地址寄存器MAR、存储数据寄存器MDR。</p><ul><li>CPU将待访问单元地址传输到MAR中。</li><li>MAR通过地址线将地址传输到主存中的地址寄存器。<ul><li>DRAM地址引脚复用：行地址与列地址通过相同的引脚两次输入。</li><li>DRAM芯片行列数优化：<ul><li>减少地址线数：行数和列数差最小。</li><li>减少刷新开销：行数小于等于列数。</li></ul></li></ul></li><li>地址译码器进行译码，选中主存单元。</li><li>CPU通过控制线将读写信号传输到主存的控制电路。<ul><li>读操作，主存将选中单元的数据通过数据线传输到MDR；</li><li>写操作，主存将MDR的数据通过数据线传输到选中单元。</li></ul></li></ul></li><li><p>多模块存储器：空间并行技术，利用多个结构相同的存储模块的并行工作来提高吞吐率。</p><ul><li><p>单体多字存储器：每个存储单元存储多个字，从而一次能读取多个字，取出多条指令。</p><ul><li>仅当指令和数据在主存中连续存放时能有效提高存取速度。</li></ul></li><li><p>多体并行存储器：由多个存储器模块组成。</p><ul><li><p>高位交叉编址：高位地址为模块号，低位地址为内地址。</p><ul><li>内地址在对应模块中译码，实际上为顺序存储。</li></ul></li><li><p>低位交叉编址：低位地址为模块号，高位地址为内地址。</p><ul><li><p>高地址在对应模块中译码，程序往往连续存放在不同模块中。因此称为<strong>交叉存储器</strong>。</p></li><li><p>启动方式：</p><ul><li>轮流启动：每隔一定时间启动各个存储模块，模块数应大于存取周期/总线周期。</li><li>同时启动</li></ul></li></ul></li></ul></li></ul></li><li><p>主存容量扩展：</p><ul><li>位扩展：地址线不变，数据线增加<ul><li>使用8块4K * 1bit的芯片组成4K * 8bit的存储器</li></ul></li><li>字扩展：地址线增加，数据线不变<ul><li>使用4个16K * 8bit的芯片组成64K * 8bit的存储器</li></ul></li><li>字、位同时扩展：地址线和数据线都增加<ul><li>使用8个16K * 4bit的芯片组成64K * 8bit的存储器</li></ul></li></ul></li><li><p>虚拟存储器：将主存和辅存的地址空间统一编址。</p><ul><li>用户编程使用的地址称为逻辑地址，实际的主存单元地址称为物理地址。</li><li>使用逻辑地址时，首先判断该地址对应的内容是否装入主存，若在则直接访问，否则进行装入。<ul><li>虚拟存储器只能使用写回法。</li></ul></li></ul></li></ol><h2 id="处理器">4. 处理器</h2><h3 id="组成">组成</h3><ol type="1"><li><p>中央处理器，Central ProcessingUnit，CPU，包含运算器和控制器。</p><ul><li>运算器主要包含算术逻辑单元、通用寄存器、程序状态字寄存器等，负责运算和条件测试。</li><li>控制器主要包含PC、IR、指令译码器ID、MAR、MDR、时序电路等。负责取指、译码和执行。</li></ul></li><li><p>控制器可根据产生微操作控制信号的方式，分为硬布线控制器和微程序控制器。</p><ul><li>硬布线控制器由组合逻辑门电路和触发器构成，也称组合逻辑控制器。运行快，但是复杂难修改。</li><li>微程序控制器将机器指令转化为微程序存入控制存储器，产生微操作控制信号。运行慢，但灵活。</li></ul></li><li><p><strong>微命令</strong>是控制部件向执行部件发出的控制命令，执行部件收到微命令后执行的操作称为<strong>微操作</strong>。</p><ul><li>微命令有相容性和互斥性之分。</li><li>微指令是若干微命令的集合，微指令包含微操作码和微地址码（下一条微指令地址）。</li><li>微指令格式：<ul><li>水平型：程序短，并行强，缺点是指令长，难编写。<ul><li>直接编码：控制字段的每一位都代表一个微指令</li><li>字段直接编码：控制字段分为多个段，每个段独立编码。<ul><li>互斥的指令在不同段中编码，每个段还需要保留一个值表示该段不执行。</li></ul></li><li>字段间接编码：一个字段的某些微指令需要由另一个字段的某些微指令来解释。</li></ul></li><li>垂直型：类似机器指令，指令短，易编写，缺点是程序长，执行慢。</li></ul></li><li>微周期是从控制存储器中取出并执行一条微指令所需的时间，通常为一个时钟周期。</li></ul></li><li><p>微程序控制器的结构：起始和转移地址形成部件、微指令地址寄存器、微指令寄存器、控制存储器。</p><ul><li>后继微指令地址：<ul><li>微指令的下地址字段，这种方式也称为断定方式。</li><li>机器指令操作码。</li><li>计数器自增。</li><li>硬件产生入口地址。</li></ul></li></ul></li><li><p>CPU数据通路包含组合逻辑部件、时序逻辑部件，一般有单总线、多总线、专用数据通路等结构。</p><ul><li>组合逻辑部件：输出仅取决于输入的部件，如译码器、多路选择器、加法器、三态门</li><li>时序逻辑部件：各类寄存器和存储器</li></ul></li><li><p>多处理器</p><ul><li>单指令流单数据流：SISD</li><li>单指令流多数据流：SIMD</li><li>多指令流单数据流：MISD</li><li>多指令流多数据流：MIMD</li></ul></li><li><p>硬件多线程：</p><ul><li>细粒度：多个线程轮流执行指令。</li><li>粗粒度：连续几个时钟周期执行同一线程。</li><li>同时：同时发射多个不同线程的指令。</li></ul></li><li><p>多核处理器：多个处理单元集成在单个CPU，每个处理单元称为一个核。</p></li><li><p>共享内存多处理器：SMP</p><ul><li>统一存储访问</li><li>非统一存储访问：主存被分配</li></ul></li></ol><h3 id="指令">指令</h3><h4 id="基础">基础</h4><ol type="1"><li><p>机器指令：计算机执行某种操作的命令。</p><ul><li><p>指令集：一台计算机所有指令的集合，也称指令系统。</p></li><li><p>指令集架构，Instruction Set Architecture，ISA：</p><ul><li><p>指令格式，指令寻址方式，操作类型。</p></li><li><p>操作数类型，操作数寻址方式和存储方式。</p></li><li><p>可访问的寄存器，存储空间的大小和编址。</p></li><li><p>指令执行的控制方式。</p></li></ul></li><li><p>指令操作类型：</p><ul><li><p>数据传送</p></li><li><p>算术和逻辑运算</p></li><li><p>跳转、调用指令</p></li><li><p>输入/输出指令</p></li></ul></li><li><p>指令寻址方式：</p><ul><li>顺序寻址：PC加1</li><li>跳跃寻址：转移类指令，修改PC值</li></ul></li><li><p>操作数寻址方式：</p><ul><li>隐含寻址：操作数地址为固定的寄存器</li><li>立即寻址：指令中给出操作数本身</li><li>直接寻址：指令给出操作数真实地址</li><li>间接寻址：指令给出地址的主存单元存储了操作数地址</li><li>寄存器寻址：指令给出操作数所在寄存器</li><li>寄存器间接寻址：指令给出寄存器，寄存器中为操作数所在主存单元地址</li><li>相对寻址：常用于转移指令，指令给出的形式地址值加上PC值形成有效地址</li><li>基址寻址：基址寄存器中内容加上指令给出的形式地址形成有效地址，面向OS</li><li>变址寻址：变址寄存器中内容加上指令给出的形式地址形成有效地址，面向用户</li><li>堆栈寻址：隐含使用堆栈中值作为地址</li></ul></li></ul></li><li><p>x86汇编：</p><ul><li><p>寄存器：x86处理器中有8个32位的通用寄存器，除了EBP、ESP，其他寄存器可灵活使用。</p><ul><li>EAX：累加器，低16位为AX</li><li>EBX：基地址寄存器，低16位为BX</li><li>ECX：计数寄存器，低16位为CX</li><li>EDX：数据寄存器，低16位为DX</li><li>ESI、EDI：变址寄存器</li><li>EBP：堆栈基指针</li><li>ESP：堆栈顶指针</li></ul></li><li><p>Intel格式汇编指令：</p><ul><li>mov eax, 100：将100存于eax中</li><li>mov ebx, eax：将eax中的内容复制到ebx中</li><li>mov [ebx-8],eax：将eax中的内容复制到以ebx中内容减8为地址的主存单元</li></ul></li></ul></li><li><p>CISC和RISC：</p><ul><li>复杂指令系统计算机，CISC：<ul><li>指令系统复杂，指令200条以上，指令长度不固定、格式多，使用频度差距大</li><li>指令执行时间差距大，多数指令需多个时钟周期完成</li><li>多采用微程序控制</li></ul></li><li>精简指令系统计算机，RISC：<ul><li>选取高频度简单指令，组合实现复杂功能</li><li>指令长度固定，格式少</li><li>硬布线控制，少用微程序控制</li></ul></li></ul></li></ol><h4 id="执行">执行</h4><ol type="1"><li><p>指令周期：CPU取出并执行一条指令的全部时间</p><ul><li>取指周期：根据PC内容读取指令代码到IR中。</li><li>间址周期：取操作数的有效地址</li><li>执行周期：取操作数，执行指令</li><li>中断周期：处理中断请求</li></ul></li><li><p>指令流水线：</p><ul><li><p>假设指令的执行过程为取指、译码、寻址、访存、写回，指令流水线就是在前一条指令的某个阶段（如取指）完成后，下一条指令的对应阶段（取指）与前一条指令的下一阶段（译码）同时进行。</p></li><li><p>对指令集的要求：</p><p>指令长度尽量一致，格式尽量规整；使用load/store指令访存；数据和指令存储边界对齐。</p></li><li><p>流水线的实现：</p><ul><li>流水段个数取决于指令的执行过程段数。</li><li>流水段的长度取决于最长的执行阶段长度。</li></ul></li><li><p>流水线冒险：</p><ul><li>结构冒险：不同指令同时争用统一功能部件。<ul><li>可以使后一条指令暂停或用多个功能部件。</li></ul></li><li>数据冒险：后面指令使用前面指令的结果。，也称RAW冲突。<ul><li>延迟后一条指令；转发（旁路）：生成的计算结果直接转发到ALU。</li></ul></li><li>控制冒险：转移指令和返回指令造成控制冲突。<ul><li>插入nop指令；分支预测。</li></ul></li></ul></li><li><p>流水线性能指标：</p><ul><li>吞吐率：<span class="math inline">\(TP=\frac n{T_k}\)</span>，<spanclass="math inline">\(n\)</span>为任务数，<spanclass="math inline">\(T_k\)</span>是花费的时间。</li><li>加速比：<spanclass="math inline">\(S=\frac{T_0}{T_k}\)</span>，<spanclass="math inline">\(T_0\)</span>是原本花费的时间，<spanclass="math inline">\(T_k\)</span>是使用流水线后花费的时间。</li></ul></li><li><p>高级指令流水线技术：</p><ul><li>多发射：同时执行多条指令。<ul><li>超标量流水线：也称动态多发射，同时执行多条指令。使用分支预测可以实现乱序执行。</li><li>超长指令字：编译时挖掘指令并行性，形成超长指令。</li></ul></li><li>超流水线：增加流水线级数使更多指令在流水线中。</li></ul></li></ul></li></ol><h2 id="总线与io">5. 总线与I/O</h2><h3 id="总线">总线</h3><ol type="1"><li><p>总线：为多个组件使用的公共信息传输线路。</p><ul><li><p>特点：</p><ul><li>分时：同一时刻只有一个部件使用总线发送信息</li><li>共享：总线上可以挂接多个部件。</li></ul></li><li><p>设备：</p><ul><li>主设备：发出总线请求，具有总线控制权的设备</li><li>从设备：只能响应总线命令的设备</li></ul></li><li><p>分类：</p><ul><li>片内总线、系统总线、I/O总线、通信总线</li><li>同步总线（按时钟进行同步）、异步总线</li><li>串行总线、并行总线（有多条双向传输的数据线）</li></ul></li><li><p>结构：</p><ul><li><p>单总线：CPU、主存、I/O设备都在一组总线上</p></li><li><p>双总线：主存总线和I/O总线</p></li><li><p>三总线：主存总线、I/O总线、DMA总线</p></li><li><p>南桥和北桥：</p><pre><code class=" mermaid">graph LRCPU--处理器总线---北桥--存储总线---主存北桥--桥间接口---南桥南桥---PCI总线---E总线</code></pre></li></ul></li><li><p>性能标准：</p><ul><li>总线时钟周期、总线时钟频率</li><li>总线传输周期、总线工作频率</li><li>总线位宽：能够同时传输的数据位数</li><li>总线带宽：单位时间传输的数据位数</li></ul></li><li><p>地址总线：CPU指定主存或I/O端口地址</p></li><li><p>数据总线：CPU从中读取信息</p></li><li><p>控制总线：传递信号、命令</p></li></ul></li><li><p>总线事务：</p><ul><li>请求：主设备（CPU或DMA）发出总线传输请求，获得控制权。</li><li>仲裁：决定将下一个传输周期的控制权给予某个申请者。</li><li>寻址：根据主设备提供的地址和命令启动从设备。</li><li>传输：主设备和从设备进行数据交换。</li><li>释放：主设备撤出，让出总线。</li></ul><p>总线定时：</p><ul><li>同步定时：使用统一时钟信号来协调发送和接收者。</li><li>异步定时：不使用统一时钟，而是使用请求和回答信号进行协调。<ul><li>全互锁：主设备请求后一定要收到回答后，才撤销请求；主设备撤销请求后，从设备才能撤销回答。</li><li>半互锁：主设备请求后一定要收到回答后，才撤销请求；从设备发出回答后一段时间撤销回答</li><li>不互锁：主设备请求后一段时间，撤销请求；从设备发出回答后一段时间撤销回答</li></ul></li><li>半同步定时：既使用统一时钟，又检测响应信号</li><li>分离定时：请求过程和回答过程分离，两个过程中主从设备互换。</li></ul></li></ol><h3 id="io">I/O</h3><ol type="1"><li><p>I/O接口：主机和外设的借口。</p><ul><li>主要功能：<ul><li>设备选择：地址译码</li><li>通信控制：状态/控制寄存器</li><li>数据缓冲：数据缓冲寄存器</li></ul></li><li>数据线：传送读/写数据、状态/控制信息和中断类型号。</li><li>地址线：传送要访问I/O接口中的寄存器地址。</li><li>控制线：传送读/写控制信号、中断与响应信号、握手信号。</li></ul><p>I/O端口：可直接被CPU访问的寄存器，主要包含数据、状态和控制端口。</p><ul><li>每个端口对应一个端口地址，编址方式分为独立和统一：<ul><li>独立编址：I/O端口的地址空间独立于主存地址空间。</li><li>统一编址：将I/O端口的地址映射到主存地址空间中。</li></ul></li></ul></li><li><p>I/O方式：</p><ul><li>程序查询方式：设置设备状态寄存器，持续或周期查询状态。</li><li>程序中断方式</li><li>DMA方式</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机专业基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络概述</title>
    <link href="/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概述">计算机网络概述</h1><p>夜阑月明人尽望，铁骑刀锋梦中伏。</p><span id="more"></span><h2 id="计算机网络架构">1. 计算机网络架构</h2><ol type="1"><li><p>计算机网络由若干结点和连接这些结点的链路组成。</p><p>结点：可以是计算机、集线器、交换机或路由器等。</p><p>链路：从一个结点到相邻结点的物理线路。</p><ul><li>互连网：网络之间通过路由器互连构成的网络。</li><li>互联网：当前全球最大的、由众多网络互连而成的网络，采用TCP/IP协议族作为通信规则。</li></ul></li><li><p>不同角度下计算机网络的组成：</p><ul><li>组成部分：硬件、软件、协议</li><li>工作方式：边缘部分（用户主机）、核心部分（大量网络和路由器）</li><li>功能组成：通信子网（传输介质、通信设备和网络协议）、资源子网（软硬件资源、数据资源）</li></ul></li><li><p>功能：数据通信、资源共享、负载均衡、分布式处理。</p></li><li><p>分类：</p><ul><li>范围：个人区域网（PAN）、局域网（LAN）、城域网（MAN）、广域网（WAN）</li><li>传输方式：广播式、点对点</li><li>结构：总线形、星形、环形、网状</li></ul></li><li><p>电路交换：数据通过一条专用的物理路径传输。</p><ul><li>需要先建立连接，数据传输时独占，传输结束后释放。</li></ul><p>报文交换：用户数据加上地址等信息封装成报文进行传输。</p><ul><li>报文是数据交换的单位。</li><li>存储转发：报文先传输到相邻结点，全部存储后查找转发表转发到下一个结点，重复到目的地。</li></ul><p>分组交换：将较长的报文分成较小的数据段，加上控制信息（首部）形成分组进行传输。</p></li><li><p>性能指标：</p><ul><li>数据传输速率</li><li>带宽：数据信道的最高数据传输速率</li><li>吞吐量：单位时间通过某个网络的实际数据量</li><li>时延：数据从网络的一端到另一端的总时间。<ul><li>4个组成部分：发送时延（数据进入链路）、传播时延（数据在信道传播）、处理时延（存储转发）、排队时延</li></ul></li><li>信道利用率：信道有数据通过的时间所占比例。</li></ul></li><li><p>网络架构：网络分层及各层协议的集合。</p><ul><li>协议数据单元：在某一层中传输的数据单元（PDU），第n层记为n-PDU。<ul><li>物理层PDU为bit流，数据链路层PDU为帧，网络层PDU为分组，传输层PDU为报文段。</li></ul></li></ul><p>协议：对等实体间数据交换的规则。</p><ul><li>三要素：语法、语义、同步（时序）</li></ul><p>服务访问点（Service AccessPoint，SAP）：相邻两层间交换信息的接口。</p><p>服务：下层为相邻的上层提供的功能调用。</p><ul><li>分类：<ul><li>面向连接、无连接</li><li>可靠、不可靠</li><li>有应答、无应答</li></ul></li></ul></li><li><p>OSI参考模型：开放系统互连参考模型</p><ul><li>物理层</li><li>数据链路层：SDLC、HDLC、PPP、STP、帧中继</li><li>网络层：IP、IPX、ICMP、IGMP、ARP、RARP、RIP、OSPF</li><li>传输层：TCP、UDP</li><li>会话层</li><li>表示层</li><li>应用层：FTP、SMTP、HTTP</li></ul></li><li><p>TCP/IP模型：</p><ul><li>网络接入层</li><li>网络层</li><li>传输层</li><li>应用层</li></ul></li></ol><h2 id="物理层">2. 物理层</h2><ol type="1"><li><p>通信基础概念：</p><ul><li><p>数据：传送信息的实体</p></li><li><p>信号：数据的电气或电磁表现</p><ul><li>模拟数据/信号的取值是连续的，数字数据/信号的取值是离散的。</li></ul></li><li><p>码元：数字信号的计量单位</p><ul><li>二进制中只有0和1两种码元。</li></ul></li><li><p>信源：产生和发送数据的源头</p></li><li><p>信宿：接收数据的终点</p></li><li><p>信道：信号的传输介质</p><ul><li>模拟信道、数字信道</li><li>无线信道、有线信道</li></ul></li><li><p>噪声源：信道上的噪声及分散在通信系统其他各处的噪声的集中表示</p></li><li><p>传输方式：</p><ul><li>串行传输：逐位按序传输</li><li>并行传输：若干位通过多个信道同时传输</li></ul></li><li><p>通信方式：</p><ul><li>单向通信：发送方和接收方</li><li>半双工通信：通信双方可发送和接收，但任何一方不能同时发送和接收</li><li>全双工通信：通信双方可同时发送和接收</li></ul></li><li><p>数据传输速率：</p><ul><li>码元传输速率，又称波特率：单位时间传输码元数，1波特表示每秒1码元</li><li>信息传输速率，又称比特率：单位时间传输二进制码元数</li></ul></li><li><p>带宽：</p><ul><li>模拟信号系统中，带宽表示信道能传输信号的频率范围，是最大频率与最小频率的差</li><li>计算机网络中，带宽表示通信线路最高数据传输速率</li></ul></li><li><p>信道的极限容量：</p><ul><li><p>码间串扰：信号中高频分量不能通过信道导致接收端收到信号波形失去码元间界限。</p></li><li><p>奈氏准则：</p><p>在没有噪声、带宽有限信道中，为了避免码间串扰，极限码元传输速率为<spanclass="math inline">\(2W\)</span>波特，其中<spanclass="math inline">\(W\)</span>为信道带宽（Hz）。用<spanclass="math inline">\(V\)</span>表示每个码元的离散电平数目（码元数），极限数据率为<spanclass="math inline">\(2W\log_2V\)</span>。</p></li><li><p>香农定理：</p><p>信道的极限数据传输速率为<spanclass="math inline">\(W\log_2(1+S/N)\)</span>。</p><p>其中<span class="math inline">\(W\)</span>为信道的频率带宽，<spanclass="math inline">\(S\)</span>为信道内所能传输信号的平均功率，<spanclass="math inline">\(N\)</span>为信道内的高斯噪声功率</p><p>信噪比<span class="math inline">\(S/N\)</span>的分贝表示：<spanclass="math inline">\(10\log_{10}(S/N)\)</span>dB。</p></li></ul></li><li><p>编码：将数据转化为数字信号；调制：将数据转化为模拟信号</p><ul><li>数字数据编码为数字信号：<ul><li>归零编码，RZ：高电平表示1，低电平表示0，每个码元中间跳变到0电平。</li><li>非归零编码，NRZ：不归零，每个周期内全是高电平或低电平。</li><li>反向非归零编码，NRZI：用电平的跳变表示0，不变表示1。</li><li>曼切斯特编码：每个码元中间都跳变，从高到低表示1，从低到高表示0。</li><li>差分曼切斯特编码：每个码元中间都跳变作为时钟信号，码元开始处跳变为0。</li></ul></li><li>模拟数据编码为数字信号：采样、量化和编码。<ul><li>采样：周期性扫描，将连续信号转化为离散信号。<ul><li>采样定理：原始信号频率<spanclass="math inline">\(f\)</span>，则采样频率必须大于等于<spanclass="math inline">\(2f\)</span>才能完整保留模拟信息。</li></ul></li><li>量化：将采样到的电平值取整</li><li>编码：将量化后的值转化为二进制编码</li></ul></li><li>数字数据调制为模拟信号（举例）：<ul><li>调幅，AM：0为<span class="math inline">\(y=0\)</span>，1为<spanclass="math inline">\(y=\sin x\)</span>。</li><li>调频，FM：0为<span class="math inline">\(y=\sinf_1x\)</span>，1为<span class="math inline">\(y=\sinf_2x\)</span>。</li><li>调相，PM：0为<span class="math inline">\(y=\sin x\)</span>，1为<spanclass="math inline">\(y=\sin (x+\pi)\)</span></li></ul></li><li>模拟数据调制为模拟信号</li></ul></li></ul></li><li><p>传输介质：</p><ul><li>导向传输介质：如电磁波沿着固体介质导向传播。</li><li>非导向传输介质：如无线电波、微波、红外线。</li></ul><p>双绞线：两根并排绞合、相互绝缘的铜导线。</p><ul><li>屏蔽双绞线，STP：在双绞线外加上一层金属丝编织的屏蔽层。<ul><li>非屏蔽双绞线，UTP</li></ul></li><li>价格便宜，可进行模拟和数字传输。</li><li>距离远时，模拟信号需要放大器放大，数字信号需要中继器整形。</li><li>局域网基本都采用双绞线。</li></ul><p>同轴电缆：由内导体、绝缘层、网状编织屏蔽层、塑料外层构成。</p><ul><li><spanclass="math inline">\(50\Omega\)</span>同轴电缆常用于传送基带数字信号，早期局域网使用广泛。</li><li><spanclass="math inline">\(75\Omega\)</span>同轴电缆常用于传送宽带信号，有线电视系统使用广泛。</li><li>抗干扰性强，可用于传送较高速率数据。</li></ul><p>光纤：由低折射率的包层和高折射率的纤芯构成。</p><ul><li>多模光纤：让多个角度入射的多条光线传输。<ul><li>光源为发光二极管，光线在折射中逐渐展宽，造成失真，适用于近距离传输。</li></ul></li><li>单模光纤：光纤的直径为光的波长，光线一直向前传播而不进行多次反射，适用于远距离。</li></ul></li><li><p>物理层确定的接口的特性：</p><ul><li>机械特性：接口所用接线器的形状、尺寸、引脚数目和排列、固定和锁定装置等。</li><li>电气特性：接口电缆的各条线的电压范围、传输速率和距离限制。</li><li>功能特性：某条线上某一电平的意义、每条线的功能。</li><li>过程特性：不同功能的可能事件的顺序。</li></ul></li><li><p>物理层设备：</p><ul><li>中继器：整形、放大并转发信号。<ul><li>原理是信号的再生，而不是简单的放大。</li><li>不能连接两个具有不同速率的局域网，使用中继器连接的几个网段仍是一个局域网。</li><li>5-4-3规则：在采用粗同轴电缆的10BASE5以太网标准中，互相串联的中继器不超过4个，并且4个中继器串联的5段通信介质中，只有3段可以挂接计算机。</li></ul></li><li>集线器：一个多端口的中继器。<ul><li>由集线器组成的网络是共享式的，逻辑上是总线形网络。</li><li>集线器将收到的帧转发到其他所有接口。</li></ul></li></ul></li></ol><h2 id="数据链路层">3. 数据链路层</h2><ol type="1"><li><p>三个基本问题：</p><ul><li>封装成帧：也称组帧，在一段数据的前后添加首部和尾部形成帧。</li><li>透明传输：无论数据的位如何组合，都可以无错地进行传输。</li><li>差错检测：位错（循环冗余校验，CRC）、帧错（确认和重传）</li></ul></li><li><p>两种信道：点对点信道（常用PPP）、广播信道（有线常用CSMA/CD，无线CSMA/CA）</p></li><li><p>链路：从一个结点到相邻结点的物理线路。</p><p>数据链路：链路以及实现通信协议的软硬件。</p><p>帧：数据链路层对等实体间进行逻辑通信的协议数据单元。</p></li><li><p>为网络层提供的服务：</p><ul><li>无确认的无连接服务</li><li>有确认的无连接服务</li><li>有确认的面向连接服务<ul><li>连接的建立、维持和释放称为链路管理。</li></ul></li></ul></li><li><p>组帧方法：</p><ul><li>字符计数法：在首部用一个字段记录该帧的字节数<ul><li>计数字段若出错，则会使整个帧以及之后的内容都读取错误</li></ul></li><li>字节填充法：用特定字节来界分一帧的开始和结束</li><li>零位填充法：使用一个特殊的位串来界分一帧的开始和结束，对数据内可能重复的位串进行零填充<ul><li>HDLC协议标志串01111110，则数据中每有连续5个1，就在其后添加一个0，这由机器实现。</li></ul></li><li>违规编码法：使用数据中没有采用的编码方法来编码标志。<ul><li>目前常用的是零位填充和违规编码。</li></ul></li></ul></li><li><p>差错控制：</p><ul><li><p>自动重传请求，ARQ：检测到差错后重传</p><ul><li>检错编码：<ul><li>奇校验码：附加一个检验位，数据中1的个数为奇数则取0</li><li>偶校验码：附加一个检验位，数据中1的个数为偶数则取0</li><li>循环冗余校验：m位数据，在数据后补r位0，除以给定r+1位串，取r位余数作为校验码。</li></ul></li></ul></li><li><p>前向纠错，FEC：检测到错误并纠正</p><ul><li><p>纠错编码：海明码</p><ol type="1"><li><p>n位数据，k位检验，则<span class="math inline">\(n+k\le2^k-1\)</span>。</p><p>设数据位<span class="math inline">\(D_n...D_1\)</span>，检验位<spanclass="math inline">\(P_k...P_1\)</span>，海明码为<spanclass="math inline">\(H_{n+k}...H_1\)</span>。</p></li><li><p><span class="math inline">\(P_i\)</span>的位置为<spanclass="math inline">\(2^{i-1}\)</span>（即二进制中只在第i位为1的数），数据位按原序插入。</p></li><li><p><spanclass="math inline">\(P_i\)</span>由海明码中所有二进制表示的第i位为1的下标的位进行异或计算；</p><p><spanclass="math inline">\(D_i\)</span>由其海明码下标中所有为1的位对应的<spanclass="math inline">\(P_j\)</span>检验。</p></li></ol></li></ul></li></ul></li><li><p>流量控制：由接收方控制发送方的发送速率。</p><p>自动重传请求，ARQ：停止等待、后退N帧、选择重传</p><ul><li>滑动窗口：发送方维持一组连续的发送的帧，称为发送窗口。接收方也维持一组连续的接收帧序号，称为接收窗口。接收到帧后返回应答信号，发送方收到后移动发送窗口。<ul><li>停止等待协议，S-W：单帧滑动窗口<ul><li>发送的帧交替用0和1来标识，接收到相同序号的帧即重复</li></ul></li><li>后退N帧协议，GBN：发送窗口内的某个帧超时未确认，就重传这个帧以及已经发送的后续帧<ul><li>用<spanclass="math inline">\(2^n\)</span>个编号来标识帧，一般发送窗口<spanclass="math inline">\(2^n-1\)</span>，接收窗口1。</li><li>累计确认：最后确认的帧之前的帧都被接收</li><li>如果在前部的帧有差错，后续的帧都要被丢弃</li></ul></li><li>选择重传协议，SR：只重传出现差错或超时未确认的帧<ul><li>用<spanclass="math inline">\(2^n\)</span>个编号来标识帧，一般发送窗口<spanclass="math inline">\(2^{n-1}\)</span>，接收窗口<spanclass="math inline">\(2^{n-1}\)</span>。</li><li>出错后发送否定帧，发送方收到后立即重传。</li></ul></li></ul></li><li>信道利用率：一个发送周期内，有效发送数据时间与周期时间之比。</li></ul></li><li><p>介质访问控制：</p><ul><li><p>信道划分：一条物理信道传输多方信号</p><ul><li><p>频分复用，FDM：信道总频带划分为子频带，子频带作为子信道，相邻信道间有隔离频段。</p></li><li><p>时分复用，TDM：传输时间分为时间片，按时间片周期分配时间。</p><ul><li>统计时分复用，STDM：动态分配时间片。</li></ul></li><li><p>波分复用，WDM：即光的频分复用，在一根光纤中传输不同波长光信号。</p></li><li><p>码分复用，CDM：用不同的编码来区分各路信号。既共享频率，也共享时间。</p><ul><li><p>码分多址，CDMA：</p><p>每个位用m位的向量表示，一个发送方指定一个m位01向量。不同发送方的向量正交。公共信道上将不同发送方的向量线性相加传输，在接收方进行分离。</p></li><li><p>主要用于无线通信。</p></li></ul></li></ul></li><li><p>随机访问介质访问控制：随机发送信息的控制协议。</p><ul><li><p>ALOHA：站点直接发送信息，超时未确认就认为发生了冲突，等待一段时间后重传。</p><ul><li>时隙ALOHA：时间划分为一段段时隙，只能在时隙开始时发送帧。</li></ul></li><li><p>载波监听多路访问，CSMA：</p><ul><li><p>1-坚持CSMA：</p><p>站点要发送数据时，先监听信道，若空闲则发送数据；若信道忙则继续监听至信道空闲。</p></li><li><p>非坚持CSMA：</p><p>站点要发送数据时，先监听信道，若空闲则发送数据；若信道忙则等待随机时间再监听。</p></li><li><p>p-坚持CSMA：</p><p>站点要发送数据时，先监听信道，若空闲则以p的概率发送数据，否则等待下一个时隙再监听。</p></li></ul></li><li><p>载波监听多路访问/冲突检测，CSMA/CD：适用于总线形、半双工，用于有线局域网</p><p>发送前监听信道，空闲则发送，发送过程中监听信道，若有冲突则停止发送，等待随机时间后重发。</p><ul><li>电磁波传播速率有限，导发送站检测到信道空闲时未必真的空闲，因此会发送冲突。</li><li>争用期：最多经过两个站点间传播时延的两倍时间，就能确认是否发生冲突（一来一往）</li><li>最短帧长：争用期内可发送的数据长度。（<spanclass="math inline">\(传播时延\times2\times数据传输速率\)</span>）<ul><li>短于最短帧长的帧为无效帧。</li></ul></li><li>确定冲突后重传时机：截断二进制指数退避算法<ol type="1"><li>确定基本退避时间，一般取争用期时间。</li><li><spanclass="math inline">\(k=\min(重传次数,10)\)</span>，从离散整数集合<spanclass="math inline">\({0,2^0,...,2^{k}-1}\)</span>中随机取一个数<spanclass="math inline">\(r\)</span>，推迟<spanclass="math inline">\(r\)</span>倍基本退避时间重传。</li><li>重传16次失败，认为网络太拥挤，报告错误。</li></ol></li></ul></li><li><p>载波监听多路访问/冲突避免，CSMA/CA：用于无线局域网</p><ul><li>确认重传：站点发送后，必须收到确认才能发送下一帧</li><li>完成发送后必须等待一段时间（帧间间隔，IFS）才能发送下一帧。<ul><li>短IFS，SIFS：最短，分隔属于一次对话的各帧</li><li>点协调IFS，PIFS</li><li>分布式协调IFS，DIFS：最长，用于异步帧竞争访问的时延</li></ul></li><li>虚拟载波监听：源站将它要占用信道的持续时间通知给其他站</li></ul><ol type="1"><li>检测到信道空闲，等待DIFS后发送整个数据帧。</li><li>执行退避算法，选取一个随机退避值，当信道忙时，退避计时器不变，空闲时计时器进行倒计时。</li><li>退避计时器为0时发送整个帧并等待确认。</li><li>收到确认后，若要发送下一个帧，就从步骤2继续。</li><li>设置重传计时器，超时未收到确认则重传。</li></ol><ul><li>隐蔽站：当同一个AP内的两个站距离太远，彼此检测到信道空闲后发送数据会导致冲突。</li><li>信道预约：源站发送前先监听信道，若空闲则等待DIFS后广播RTS（请求发送）帧，AP接收后等待SIFS后向源站发送CTS（允许发送）帧，源站接收后等待SIFS，发送数据帧。</li></ul></li></ul></li><li><p>轮询访问：令牌传递协议</p><ul><li>同一时间、同一链路只有一个结点可以发送数据</li><li>适合高负载广播信道</li></ul><ol type="1"><li>网络空闲时只有令牌帧在循环传递。</li><li>令牌传递到需要发送数据的站点时，站点修改一个标志位，附加数据并发送令牌帧。</li><li>令牌循环传递，站点转发并检查数据的目的地址，若是自己就复制一份数据。</li><li>传递到源站点后不再转发该数据，同时检测返回的帧是否出错，出错则重传。</li></ol></li></ul></li><li><p>局域网拓扑：</p><ul><li>以太网，IEEE802.3：总线形，使用CSMA/CD进行访问控制。<ul><li>MAC地址：48位，每个网络适配器唯一。</li></ul></li><li>令牌环，IEEE802.5</li><li>光纤分布数字接口，FDDI，IEEE802.8</li><li>无线局域网，IEEE802.11</li></ul></li><li><p>点对点协议，PPP：用户计算机与ISP通信所用的数据链路层协议。</p><ul><li>组成部分：链路控制协议、网络控制协议、数据报封装</li></ul></li><li><p>数据链路层设备：</p><ul><li><p>网桥：网桥连接的各个网段具有不同的冲突域。（仍属于同一个网络，不分割广播域）</p></li><li><p>交换机：多接口的网桥。</p><ul><li>交换机接口连接主机或交换机时，以全双工方式工作，使得每对主机都能无冲突地传输数据。<ul><li>用户通信独占带宽，使得N个用户的总容量为N倍带宽，而集线器是1/N。</li></ul></li><li>交换机接口连接集线器时，使用CSMA/CD协议并以半双工方式工作。</li><li>即插即用，内部帧转发表通过自学习算法，基于网络中各主机的通信逐步建立。</li></ul><p>交换方式：</p><ul><li>直通交换：只检查帧的MAC地址以决定转发目的地</li><li>存储转发：先将帧存储到高速缓存中，并检查数据正确，再进行转发</li></ul><p>交换表：MAC地址+连通该地址的接口</p><ul><li>自学习方式：接收到一帧，记录其源地址与接口，查表，若有则转发，若无则广播</li></ul></li></ul></li></ol><h2 id="网络层">4. 网络层</h2><ol type="1"><li><p>网络层提供主机到主机的通信服务，将分组从源主机经过多个网段、链路传输到目的主机。</p><ul><li><p>异构网络互连：将多个计算机网络相互连接起来。通常指用路由器进行网络连接和路由选择。</p><ul><li>物理层：集线器</li><li>数据链路层：网桥、交换机</li><li>网络层：路由器<ul><li>路由选择：根据路由协议构造并动态维护路由表。</li><li>分组转发：根据转发表将分组从合适的端口转发。</li></ul></li><li>网络层以上：网关</li></ul><p>IP网络：使用IP协议将各种网络模拟为一个统一的虚拟互连网络。</p></li><li><p>网络层服务方式：虚电路、数据报</p><ul><li>虚电路：两台主机通信，先建立网络层连接，即虚电路，固定物理路径。分组沿虚电路传递。</li><li>数据报：将报文分成分组，找到最佳路由后尽快转发各个分组。</li></ul></li><li><p>软件定义网络，SDN：路由器只需接收、查表、转发，表的生成由软件完成。</p><ul><li>SDN提供的编程接口称为北向接口。</li><li>SDN控制器与转发设备的双向接口称为南向接口。</li><li>SDN内部控制器之间的通信接口称为东西向接口。</li></ul></li><li><p>拥塞：出现过量的分组而引起网络性能下降。</p></li></ul></li><li><p>IPv4：</p><ul><li><p>IP数据报：首部+数据</p><ul><li>首部的固定长度共20B，后面还有一些可选字段<ul><li>版本（4位）：4</li><li>首部长度（4位）：一般为5（5*32位，20B）</li><li>总长度（16位）：不能超过数据链路层的MTU（最大传输单元）大小，单位为B</li><li>标识（16位）：计数器，每产生一个数据报加1，不用于排序。分片时复制标识</li><li>标志（3位）：低位为MF，MF=1表示后面还有分片；中位为DF，DF=0表示允许分片</li><li>片偏移（13位）：指出片在原数据报的相对位置，单位为8B</li><li>生存时间（8位）：可通过的路由器数最大值，路由器转发前减1，然后判断为0则丢弃</li><li>协议（8位）：6为TCP，17为UDP</li><li>首部检验和（16位）</li><li>源IP地址（4B）</li><li>目的IP地址（4B）</li></ul></li></ul></li><li><p>IPv4地址：32位，网络号+主机号</p><ul><li>点分十进制表示：每8位用一个十进制数表示，每个数之间用点间隔</li></ul></li><li><p>网络地址转换，NAT：将私有IP地址转化为公有IP地址。</p><ul><li>NAT转换表：本地IP+端口和公共IP+端口的映射。</li></ul></li><li><p>子网：IP地址为网络号+子网号+主机号</p><ul><li>子网掩码：一连串1，后续全0，与IP地址作与运算得出子网地址。</li><li>默认网关：子网与外部网络连接的设备，如果目的地址不在子网中则发送到默认网关。</li><li>无分类编址，CIDR：IP地址分为网络前缀+主机号，记网络为”IP地址/前缀位数“。<ul><li>路由聚合：根据IP地址的公共前缀以二叉线索树的方式构建路由表。</li></ul></li><li>主机号全0和全1的地址不能分配。</li></ul></li><li><p>分组转发：</p><ul><li>特定主机路由，a.b.c.d/32</li><li>默认路由：0.0.0.0/0，通常用于路由器到互联网的路由</li><li>分组转发过程：<ol type="1"><li>从IP分组的首部提取目的IP地址</li><li>若有特定主机路由，则按照该路由转发分组，否则下一步</li><li>计算子网，查找转发表，若查找到则进行转发，否则下一步</li><li>如果有默认路由，则转发给默认路由，否则出错</li></ol></li><li>查表得到下一个路由器的IP地址后，需要先将其转换为MAC地址，再进行数据链路层传输。</li></ul></li><li><p>地址解析协议，ARP：IP地址到MAC地址的映射。</p><ul><li>ARP协议包含了IP地址的内容，因此是网络层的协议。</li><li>每台主机都有一个ARP高速缓存。</li><li>发送IP数据报过程：<ol type="1"><li>查ARP表，若有对应MAC地址，则写入MAC帧进行传输，否则下一步</li><li>广播ARP请求，目的主机返回IP和MAC的映射信息。</li></ol></li></ul></li><li><p>动态主机配置协议，DHCP：动态分配IP，即插即用连网。</p><ul><li>使用C/S模式，因而是应用层协议。</li><li>基于UDP。</li><li>使用DHCP服务器分配IP：<ol type="1"><li>客户广播DHCP发现消息，源地址0.0.0.0</li><li>DHCP服务器广播DHCP提供消息，包含提供的IP地址，源地址为DHCP服务器地址</li><li>客户若接受该IP地址，则广播DHCP请求，源地址0.0.0.0</li><li>DHCP服务器广播DHCP确认消息，源地址为DHCP服务器地址</li></ol></li><li>可以有多个DHCP服务器，客户只会回复一个DHCP提供消息</li></ul></li><li><p>网络控制报文协议，ICMP：用于报告差错和异常情况。</p><ul><li>网络层协议。</li><li>分为差错报文和询问报文</li><li>差错报文类型：<ul><li>终点不可达：数据报不能交付</li><li>源点抑制：因为拥塞而丢弃数据报</li><li>时间超过：路由器判断数据报生存时间为0</li><li>参数问题：首部存在错误的值</li><li>重定向：路由器把改变路由的报文发送给主机</li></ul></li><li>不发送ICMP差错报文的情况：<ul><li>不对ICMP报文发送ICMP报文</li><li>第一个分片后的所有分片都不发送ICMP报文</li><li>不对多播数据报发送ICMP报文</li><li>不对特殊地址（127.0.0.0 0.0.0.0）发送ICMP报文</li></ul></li><li>询问报文分为回送请求和回答、时间戳请求和回答、地址掩码请求和回答、路由器询问和回答</li><li>PING（应用层）使用了ICMP的回送请求和回答报文。</li></ul></li></ul></li><li><p>IPv6：128位地址</p><ul><li>IPv6数据报：<ul><li>基本首部，40B：<ul><li>版本（4位）：6</li><li>通信量类（8位）：区分类别或优先级</li><li>流标号（20位）：同一个流的数据报具有相同流标号</li><li>有效载荷长度（16位）：除基本首部外字节数</li><li>下一个首部（8位）：无扩张首部时表示协议，否则为第一个扩展首部类型</li><li>跳数限制（8位）：每次转发减一，减为0则丢弃</li><li>源地址和目的地址（各128位）</li></ul></li><li>IPv6不允许分片，首部长度固定，不含有检验和字段</li></ul></li><li>IPv6地址：<ul><li>冒号十六进制表示：每16位用一个十六进制数表示，每个十六进制数用冒号分隔</li><li>目的地址类型：<ul><li>单播</li><li>多播</li><li>任播：数据报交付给一台计算机，转发给一组计算机</li></ul></li><li>地址分类：<ul><li>未指明地址：全0，记为::/128</li><li>环回地址：1，记为::1/128</li><li>多播地址：11111111，记为FF00::/8</li><li>本地链路单播地址：1111111010，记为FE80::/10</li><li>其他IPv6地址</li></ul></li><li>IPv6可以直接从后64位地址中取出硬件地址，而不用ARP协议</li></ul></li><li>IPv4向IPv6过渡：可采用双协议栈和隧道技术</li></ul></li><li><p>路由算法：找到源路由器到目的路由器的最佳路径。</p><ul><li>静态路由：网络管理员手工配置路由</li><li>动态路由：动态调整路由表</li></ul><p>距离-向量路由算法：单源最短路径算法</p><p>链路状态路由算法：Dijkstra最短路径算法</p></li><li><p>路由选择协议：</p><ul><li>内部网关协议，IGP：自治系统内部的路由协议，如RIP和OSPF。</li><li>外部网关协议，EGP：不同自治系统间的路由协议，如BGP-4。</li></ul></li><li><p>路由信息协议，RIP：分布式的基于距离向量的路由选择协议。</p><ul><li>规定：<ol type="1"><li>每个路由器都要维护从它自身到其他每个目的网络的距离记录，即距离向量。</li><li>使用跳数来衡量到达目的网络的距离，到直连的网络距离为1，每经过一个路由器加1。</li><li>好的路由即距离短的路由。</li><li>一条路径最多包含15个路由器。</li><li>路由表项：目的网络+距离+下一跳路由器地址</li></ol></li><li>每个路由器不断与相邻的路由器将还路由表信息。<ul><li>初始时路由器只知道相邻的路由器，迭代多次后收敛。</li></ul></li><li>RIP使用UDP传送数据，端口520，是应用层协议，RIP路径未必时间最短。</li><li>距离向量算法：<ol type="1"><li>对于地址为X的相邻路由器传来的RIP报文，先修改每个表项，使距离加1，下一跳改为X。</li><li>遍历每个表项：<ul><li>若目的地址不在路由表中，添加该表项</li><li>目的地址在路由表中，下一跳为X，则更新该表项</li><li>目的地址在路由表中，下一跳非X，则比较两者距离，选择更新</li></ul></li><li>默认180s未收到相邻路由器的更新路由表，则设此路由器不可达，把距离设为16</li></ol></li><li>优点：实现简单，若发现更短的路由，更新消息传播快</li><li>缺点：限制网络规模，若网络出现故障，较长时间才能将信息传送到所有路由器</li></ul></li><li><p>开放最短路径优先，OSPF协议：</p><ul><li>当链路状态变化，向自治系统中所有路由器发送信息（与本路由器相邻的所有路由器的链路状态）<ul><li>最终每个路由器建立一个全网的拓扑结构图，使用Dijkstra算法求最短路径，给出下一跳地址</li></ul></li><li>OSPF是网络层协议，直接使用IP数据报传递信息，协议字段为89。</li><li>分组类型：<ul><li>问候分组：发现和维持邻站的可达性<ul><li>每10s交换一次，超过40s认为不可达</li></ul></li><li>数据库描述分组：给出自己链路状态数据库中的信息</li><li>链路状态请求分组：请求对方某些链路状态项目信息</li><li>链路状态更新分组：对全网更新链路状态</li><li>链路状态确认分组：确认链路状态更新</li></ul></li><li>特点：<ul><li>每条路由可以设定代价，可以把通信量分配给具有相同代价的路径</li><li>支持鉴别可信赖的路由器</li><li>支持子网划分和无分类编址</li></ul></li></ul></li><li><p>边界网关协议，BGP：不同自治系统AS间交换路由信息的协议，常用于互联网的网关之间。</p><ul><li>基于TCP，是应用层协议。</li><li>每个AS选择至少一个路由器作为BGP发言人，与其他AS的BGP发言人建立TCP连接，交换信息</li><li>报文类型：<ul><li>打开报文</li><li>更新报文</li><li>保活报文</li><li>通知报文</li></ul></li><li>先使用打开报文建立关系，若邻站接受则返回保活报文，并周期用保活报文维持关系</li></ul></li><li><p>多播：发送一次分组可到达多个路由器，需要多播路由器的支持</p><ul><li>IP多播地址：1110开始的每一个地址标志一个多播组，主机可以随时加入或离开多播组。</li><li>IP多播地址到MAC多播地址：IP地址的后32为转换为6位十六进制数，MAC地址前6位为01-00-5E</li></ul><p>网际组管理协议，IGMP：主机加入某个多播组时，发送报文告诉多播路由器</p></li><li><p>移动IP：移动站以固定的IP地址在不同网络漫游</p><ul><li>当移动站从原网络移动到另一个网络中时，将其在另一个网络中的IP告诉原网络，作为转交地址。</li></ul></li><li><p>网络层设备：路由器</p><ul><li>路由选择：维护路由表，表项包含目的IP、子网掩码、下一跳IP、接口</li><li>分组转发：根据转发表处理分组，将其从合适的接口转发</li></ul></li></ol><h2 id="传输层">5. 传输层</h2><ol type="1"><li><p>传输层提供主机进程间的逻辑通信。</p></li><li><p>端口：用于标识主机中的应用进程</p><ul><li>熟知端口号，0～1023，被互联网地址指派机构（IANA）指派给重要应用，如HTTP端口为80。</li><li>登记端口号，1024～49151</li><li>客户端口号，49151～65535</li></ul><p>套接字：IP:端口</p></li><li><p>用户数据报协议，UDP</p><ul><li>首部：8B，每个字段2B。<ul><li>源端口</li><li>目的端口</li><li>长度：首部和数据的总长度</li><li>检验和：全0则不检验</li></ul></li></ul></li><li><p>传输控制协议，TCP：可靠、有序、无丢失、不重复</p><ul><li><p>面向连接、一对一、全双工、面向字节流</p></li><li><p>首部：20B，后续可选增加，长度为4B的整数倍。</p><ul><li>源端口和目的端口，各2B</li><li>序号，4B：本报文段中数据的第一个字节在字节流中编号</li><li>确认号，4B：期望收到对方下一个报文段的第一个数据字节的序号</li><li>数据偏移，4位：即首部长度，最大为60B</li><li>保留，6位：置0</li><li>紧急位URG：URG=1表示其为紧急数据</li><li>确认位ACK：连接建立后所有传送的报文段都必须把ACK置1</li><li>推送位PSH：接收方收到PSH=1的报文段后尽快交付给接收进程，而不是等缓存填满</li><li>复位位RST：RST=1可用于拒绝非法报文段或重新建立连接</li><li>同步位SYN</li><li>终止位FIN</li><li>窗口，2B：从本报文确认号开始，接收方允许发送的数据量</li><li>检验和，2B</li><li>紧急指针，2B：URG=1时有效，指出紧急数据字节数</li><li>选项：长度可变</li><li>填充：使报文首部长度为4B的整数倍</li></ul></li><li><p>连接管理：发起连接的为Client，被动建立连接的是Server</p><ul><li>连接建立：3次握手<ul><li>Client发送请求报文，首部SYN=1，序号seq=x，报文不携带数据，消耗序号<ul><li>Client状态：CLOSED<spanclass="math inline">\(\rightarrow\)</span>SYN-SENT</li></ul></li><li>Server如果同意，发回确认报文，SYN=1，ACK=1，确认号ack=x+1<ul><li>Server状态：LISTEN<spanclass="math inline">\(\rightarrow\)</span>SYN-RCVD</li></ul></li><li>Client再次确认，ACK=1，ack=y+1，seq=x+1<ul><li>Client和Server状态都变为ESTABLISHED</li></ul></li></ul></li><li>连接释放：4次挥手<ul><li>Client发送释放报文，FIN=1，seq=u，报文不携带数据，消耗序号<ul><li>Client状态：ESTABLISHED<spanclass="math inline">\(\rightarrow\)</span>FIN-WAIT-1</li></ul></li><li>Server发回确认，ACK=1，ack=u+1，seq=v<ul><li>Server状态：ESTABLISHED<spanclass="math inline">\(\rightarrow\)</span>CLOSE-WAIT</li><li>Client(收到后)状态：FIN-WAIT-1</li></ul></li><li>Server释放连接，FIN=1，ack=u+1<ul><li>Server状态：CLOSE-WAIT<spanclass="math inline">\(\rightarrow\)</span>LAST-ACK</li></ul></li><li>Client发回确认，ACK=1，seq=u+1，ack=v+1<ul><li>Client状态：FIN-WAIT-2<spanclass="math inline">\(\rightarrow\)</span>TIME-WAIT<spanclass="math inline">\(\rightarrow\)</span>CLOSED</li><li>Server(收到后)状态：CLOSED</li></ul></li></ul></li></ul></li><li><p>可靠传输：</p><ul><li>序号</li><li>确认：默认使用累计确认</li><li>重传：超时计数、冗余确认（每当有失序报文段到达，发送冗余ACK）</li></ul></li><li><p>流量控制：滑动窗口</p></li><li><p>拥塞控制：发送方维持一个拥塞窗口</p><p>慢开始和拥塞避免：</p><ul><li>慢开始算法：指数增大拥塞窗口</li><li>拥塞避免算法：线性增大拥塞窗口<ul><li>慢开始门限：根据窗口大小是否小于慢开始门限决定使用慢开始还是拥塞避免算法</li></ul></li><li>网络拥塞处理：慢开始门限减半，拥塞窗口设置为1，重新开始</li></ul><p>快重传和快恢复：</p><ul><li>快重传：发送方连续收到3个冗余ACK，就立即重传</li><li>快恢复：发送方连续收到3个冗余ACK，将慢开始门限和窗口大小设为当前窗口大小的一半</li></ul></li></ul></li></ol><h2 id="应用层">6. 应用层</h2><ol type="1"><li><p>网络应用模型：</p><ul><li>客户/服务器模型C/S：Web、文件传输协议、远程登录、电子邮件</li><li>P2P：每个结点都同时具有下载和上传的功能。</li></ul></li><li><p>域名系统DNS：UDP</p><ul><li><p>层次域名空间：标号.标号.标号</p><ul><li>标号英文不区分大小写</li><li>标号中标点符号只能使用连字符（-）</li><li>低级域名写在左侧</li><li>标号不超过63个字符，完整域名不超过255个字符</li></ul><p>顶级域名：由互联网名称与数字地址分配机构（ICANN）管理。</p><ul><li>国家（.cn .us）</li><li>通用顶级域名（.com .org .edu）</li><li>基础结构域名（用于反向域名解析）</li></ul></li><li><p>域名服务器</p><ul><li><p>根域名服务器：知道所有顶级域名服务器的域名和IP地址</p></li><li><p>顶级域名服务器：管理所有在该顶级域名下的二级域名</p></li><li><p>权限域名服务器：将管理的主机名转化为IP地址、</p></li><li><p>本地域名服务器：DNS查询请求发送给DNS地址的本地域名服务器</p></li></ul></li><li><p>域名解析过程：递归查询、迭代查询（客户询问后，返回对应IP或下一步查询的服务器）</p><ul><li>主机向本地域名服务器进行递归查询</li><li>本地域名服务器向其他域名服务器一般使用迭代查询</li></ul></li></ul></li><li><p>文本传输协议FTP：提供交互式访问，允许指明文件的类型和格式，允许文件具有存取权限。</p><ul><li>采取C/S架构，使用控制端口21、数据端口20建立两个TCP连接（带外传送）。</li><li>一个FTP服务器可以为多个客户进程服务：主进程负责接收新请求，子进程负责处理单个请求。</li><li>工作方式：<ul><li>控制连接：监听21号端口，接收和发送控制信息。</li><li>数据连接：文件列表等数据也是通过数据连接传输的。<ul><li>PORT模式：客户要读取数据时，发送PORT命令和端口号，服务器收到后使用20端口连接客户，发送数据。</li><li>PASV模式：客户发送PASV命令，服务器发送端口号给客户，客户连接服务器接收数据。</li></ul></li></ul></li></ul><p>网络文件系统NFS允许进程打开一个远程文件读取数据。</p></li><li><p>电子邮件：</p><ul><li>组成：用户代理、邮件服务器、电子邮件协议<ul><li>用户代理：用户和电子邮件系统的接口。</li><li>邮件协议：发送协议（SMTP）、读取协议（POP3、IMAP）</li></ul></li><li>收发过程：<ul><li>用户代理使用SMTP将邮件发送给发送端邮件服务器。</li><li>发送端邮件服务器把邮件放入邮件缓存队列等待发送。</li><li>发送端邮件服务器与接收端邮件服务器建立TCP连接，依次发送邮件缓存队列中的邮件。</li><li>接收端邮件服务器把邮件放入用户邮箱。</li></ul></li><li>邮件的首部：To、Subject、From</li><li>多用途互联网邮件扩展MIME：将其他二进制对象转化为SMTP能发送的7位ASCII码与解码。</li><li>简单邮件传输协议SMTP：端口号25。<ul><li>建立TCP连接，接收方发出220 SERVICEready，客户发送HELO和主机名。</li><li>发送：<ul><li>先发送MAIL和发件人地址，服务器准备好则返回250OK，附带可选的RCPT回复。</li><li>确认后，客户发送DATA，服务器返回354，此时客户开始传输数据，用<code>&lt;CRLF&gt;</code>结束。</li><li>客户发送QUIT，服务器返回221，释放连接。</li></ul></li></ul></li><li>邮局协议POP：TCP，C/S，端口号110。服务方式包括“下载并删除”、“下载并保留”。</li><li>互联网报文存取协议IMAP：允许用户代理只获得报文的一部分。</li></ul><p>现代电子邮件往往使用HTTP为主。</p></li><li><p>万维网：统一资源定位符URL、超文本传输协议HTTP、超文本标记语言HTML</p><ul><li>URL：<code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code></li></ul></li><li><p>HTTP是在网络上传输HTML的协议，用于浏览器、服务器通信。</p><ul><li><p>HTTP协议是无状态协议，服务器不记得曾经服务过的客户。</p></li><li><p>浏览器请求页面的流程：</p><ol type="1"><li><p>与服务器建立TCP连接；</p></li><li><p>发送HTTP请求；</p></li><li><p>接受HTTP响应，显示网页。</p></li></ol></li><li><p>HTTP/1.0短链接，HTTP/1.1长连接。</p></li><li><p>浏览器发送的HTTP请求结构：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.sina.com.cn<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>M/5.0 xxx<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>**/**<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9,en-US;q=0.8<br></code></pre></td></tr></table></figure><ul><li><p>第一行使用GET请求获取路径为/的资源，使用HTTP/1.1协议；</p></li><li><p>从第二行开始，每行都是Header：Value的HTTP头，常用的HTTP头：</p><ul><li><p>Host:表示请求的主机名，因为一个服务器上可能运行着多个网站，因此，Host表示浏览器正在请求的域名；</p></li><li><p>User-Agent: 标识客户端本身，例如Chrome浏览器的标识类似M/5.0 ...Chrome/79，IE浏览器的标识类似M/5.0 (Windows NT ...) likeGecko；</p></li><li><p>Accept：表示浏览器能接收的资源类型，如text/<em>，image/</em>或者<em>/</em>表示所有；</p></li><li><p>Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</p></li><li><p>Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate,br。</p></li></ul></li></ul></li><li><p>服务器的响应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>21932<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=300<br></code></pre></td></tr></table></figure><ul><li><p>第一行是协议的版本+空格+数字+空格+文本。</p><p>数字表示响应代码，其中2xx表示成功，3xx表示重定向，4xx表示客户端引发的错误，5xx表示服务端引发的错误。数字给程序识别，文本则是给开发者调试使用。常用的响应代码：</p><p>200 OK：表示成功；</p><p>301 Moved Permanently：表示该URL已经永久重定向；</p><p>302 Found：表示该URL需要临时重定向；</p><p>304 NotModified：表示该资源没有修改，客户端可以使用本地缓存的版本；</p><p>400 Bad Request：表示客户端发送了一个错误的请求，例如参数无效；</p><p>401 Unauthorized：表示客户端因为身份未验证而不允许访问该URL；</p><p>403 Forbidden：表示服务器因为权限问题拒绝了客户端的请求；</p><p>404 Not Found：表示客户端请求了一个不存在的资源；</p><p>405 Method Not Allowed</p><p>500 Internal ServerError：表示服务器处理时内部出错，例如因为无法连接数据库；</p><p>503 Service Unavailable：表示服务器此刻暂时无法处理请求。</p></li><li><p>从第二行开始，服务器每一行均返回一个HTTP头，服务器常返回的HTTP头有：</p><p>Content-Type：表示该响应内容的类型，例如text/html，image/jpeg；</p><p>Content-Length：表示该响应内容的长度（字节数）；</p><p>Content-Encoding：表示该响应压缩算法，例如gzip；</p><p>Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒。</p></li><li><p>HTTP请求和响应都由HTTPHeader和Body组成，Header每行都以，如果有两个连续的，那么后面即是HTTPBody。浏览器读取HTTPBody，并根据Content-Type、Content-Encoding等解压后显示网页、图像等内容。</p></li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机专业基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性代数总结二</title>
    <link href="/2022/10/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%80%BB%E7%BB%93%E4%BA%8C/"/>
    <url>/2022/10/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%80%BB%E7%BB%93%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>踏遍青山人未老，风景这边独好。</p><span id="more"></span><h1 id="线性代数总结二">线性代数总结二</h1><h2 id="解方程组">3. 解方程组</h2><h3 id="方程组表示与定义">3.1 方程组表示与定义</h3><ol type="1"><li><p>三种表示方法：</p><ul><li><p>一般表示：<spanclass="math inline">\(\begin{cases}a_{11}x_1+...+a_{1n}x_n=b_1\\...\\a_{m1}x_n+...+a_{mn}x_n=b_n\end{cases}\)</span></p></li><li><p>向量表示：<spanclass="math inline">\(x_1\alpha_1+x_2\alpha_2+...+x_n\alpha_n=\mathbfb\)</span></p><p>其中<spanclass="math inline">\(\alpha_i=\left(\begin{array}{}a_{1i}\\a_{2i}\\...\\a_{mi}\end{array}\right),1\le i\le n,\mathbfb=\left(\begin{array}{}b_{1}\\b_{2}\\...\\b_{m}\end{array}\right)\)</span></p></li><li><p>矩阵表示：<span class="math inline">\(\mathbf A\mathbf x=\mathbfb\)</span></p><p>其中<span class="math inline">\(\mathbf A=\left(\begin{array}{cccc}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;...&amp;a_{2n}\\...&amp;...&amp;&amp;...\\a_{m1}&amp;a_{m2}&amp;...&amp;a_{mn}\end{array}\right),\mathbf x=\left(\begin{array}{}x_{1}\\x_{2}\\...\\x_n\end{array}\right)\mathbfb=\left(\begin{array}{}b_{1}\\b_{2}\\...\\b_{m}\end{array}\right)\)</span></p></li></ul></li><li><p>称<span class="math inline">\(\mathbf A\)</span>为系数矩阵，<spanclass="math inline">\(\mathbf x\)</span>为未知向量，<spanclass="math inline">\(\mathbf b\)</span>为右端向量，矩阵<spanclass="math inline">\(\mathbf B=(\mathbf A\;\mathbfb)\)</span>称为该方程组的增广矩阵。</p></li><li><p><span class="math inline">\(n\)</span>元<spanclass="math inline">\(n\)</span>个方程的线性方程组<spanclass="math inline">\(\begin{cases}a_{11}x_1+...+a_{n1}x_n=b_1\\...\\a_{n1}x_n+...+a_{nn}x_n=b_n\end{cases}\)</span>，其系数行列式$ D=|</p><spanclass="math display">\[\begin{array}{cccc}  a_{11}&amp;a_{12}&amp;...&amp;a_{1n}\\a_{21}&amp;a_{22}&amp;...&amp;a_{2n}\\  ...&amp;...&amp;&amp;...\\a_{n1}&amp;a_{n2}&amp;...&amp;a_{nn}\end{array}\]</span><p>|$。</p></li><li><p>右端为零的线性方程组称为齐次线性方程组。</p></li><li><p>代替未知向量使方程组成立的向量为该方程组的解向量，这样的解向量的集合称为方程组的解集。</p><ul><li>具有相同解集的两个方程组称为同解方程组。</li><li>若方程组的解<spanclass="math inline">\(x_1=...=x_n=0\)</span>，则称其为零解，也称平凡解。<ul><li>齐次线性方程组必有零解，非齐次线性方程组都是非零解。</li><li>含有<span class="math inline">\(n\)</span>个未知数<spanclass="math inline">\(n\)</span>个方程的齐次线性方程组若有非零解，则其系数行列式为0。</li></ul></li></ul></li></ol><h3 id="解的结构">3.2 解的结构</h3><ol type="1"><li><p>可解性：线性方程组有解的充要条件是系数矩阵的秩等于增广矩阵的秩。</p><ul><li><span class="math inline">\(r(\mathbf A)=r(\mathbfB)=n\)</span>时，方程组有唯一解，<span class="math inline">\(r(\mathbfA)=r(\mathbf B)\lt n\)</span>时，方程组有无穷多组解。</li></ul></li><li><p>齐次线性方程组解的结构：<span class="math inline">\(\mathbfA\mathbf x=\theta,\mathbf A\in\mathbf R^{m\times n}\)</span></p><ul><li>若<spanclass="math inline">\(\alpha_1,\alpha_2\)</span>是上述方程组的解，则其线性组合也是该方程组的解。<ul><li>能线性表示出齐次线性方程组所有解的极大无关组称为该齐次线性方程组的<strong>基础解系</strong>。</li><li>齐次线性方程组的某一个解称为方程组的<strong>特解</strong>，所有解的集合称为方程组的<strong>通解</strong>。</li></ul></li><li>若<span class="math inline">\(r(\mathbf A)=n\)</span>，则<spanclass="math inline">\(\mathbf A\mathbfx=\theta\)</span>只有零解；若<span class="math inline">\(r(\mathbf A)\ltn\)</span>，则<span class="math inline">\(\mathbf A\mathbfx=\theta\)</span>有非零解。<ul><li>若<spanclass="math inline">\(m=n\)</span>，方程组有非零解的充要条件是<spanclass="math inline">\(|\mathbf A|=0\)</span>。</li><li>若<span class="math inline">\(m\lt n\)</span>，方程组有非零解。</li></ul></li></ul></li><li><p>非齐次线性方程组解的结构：<span class="math inline">\(\mathbfA\mathbf x=\mathbf b,\mathbf A\in\mathbf R^{m\times n},\mathbfb\ne\theta\)</span></p><p>若<span class="math inline">\(\mathbf A\eta=\mathbf b\)</span>，<spanclass="math inline">\(\alpha_1,...,\alpha_r\)</span>为<spanclass="math inline">\(\mathbf A\mathbfx=\theta\)</span>的基础解系，则<span class="math inline">\(\mathbfA\mathbf x=\mathbf B\)</span>的通解可表示为<spanclass="math inline">\(\eta+k_1\alpha_1+...+k_r\alpha_r\)</span>。</p></li></ol><h3 id="求解">3.3 求解</h3><ol type="1"><li><p>行列式求解<span class="math inline">\(n\)</span>元<spanclass="math inline">\(n\)</span>个方程的线性方程组：Crammer法则</p><p>若系数行列式<spanclass="math inline">\(D\ne0\)</span>，则方程组有唯一解<spanclass="math inline">\(x_j=\frac{D_j}D\)</span>。</p><p><span class="math inline">\(D_j\)</span>为将<spanclass="math inline">\(D\)</span>的第<spanclass="math inline">\(j\)</span>列元素换成方程组右端常数项<spanclass="math inline">\(b_1,...,b_n\)</span>所得行列式。</p></li><li><p>齐次线性方程组：将系数矩阵行初等变换为行简化梯形矩阵。</p><ul><li><p>非零行的起始1对应的<spanclass="math inline">\(x_i\)</span>称为非自由变量，共<spanclass="math inline">\(r\)</span>个；其他<spanclass="math inline">\(x_j\)</span>称为自由变量，共<spanclass="math inline">\(n-r\)</span>个。</p></li><li><p>对自由变量取<span class="math inline">\(n-r\)</span>组数据<spanclass="math inline">\((1,...,0),...,(0,...,1)\)</span>，可得<spanclass="math inline">\(n-r\)</span>组非自由变量的值。</p></li><li><p>这<spanclass="math inline">\(n-r\)</span>个解向量就是方程组的一个基础解系。</p></li><li><p>方程的通解可记为：<spanclass="math inline">\(k_1\alpha_1+...+k_{n-r}\alpha_{n-r}\)</span>，其中<spanclass="math inline">\(k_1,...,k_{n-r}\in\R\)</span>为任意常数。</p><ul><li><p>解矩阵：在行简化梯形矩阵中加入自由变量行，该行对应自由变量位置为-1，其余值为0。</p><p>自由变量列向量取负即为解向量。</p></li></ul></li></ul></li><li><p>非齐次线性方程组：将增广矩阵行初等变换为行简化梯形矩阵。</p><ul><li>非自由变量取最后一列值，自由变量值取0，即可得<spanclass="math inline">\(\eta\)</span>。</li></ul></li></ol><h2 id="特征值与相似变换">4. 特征值与相似变换</h2><h3 id="特征值与特征向量">4.1 特征值与特征向量</h3><ol type="1"><li><p>设<span class="math inline">\(\mathbf A\)</span>是实数域<spanclass="math inline">\(\R\)</span>或复数域<spanclass="math inline">\(\C\)</span>上的一个方阵，<spanclass="math inline">\(\lambda\in\C\)</span>，若存在非零向量<spanclass="math inline">\(\xi\)</span>使得<spanclass="math inline">\(\mathbf A\xi=\lambda\xi\)</span>，</p><p>则称<span class="math inline">\(\lambda\)</span>为矩阵<spanclass="math inline">\(\mathbf A\)</span>的特征值，<spanclass="math inline">\(\xi\)</span>称为<spanclass="math inline">\(\mathbf A\)</span>的属于特征值<spanclass="math inline">\(\lambda\)</span>的特征向量。</p><ul><li><p>特征矩阵：<span class="math inline">\(\lambda\mathbf E-\mathbfA\)</span></p></li><li><p>特征多项式：<span class="math inline">\(|\lambda\mathbf E-\mathbfA|\)</span></p></li><li><p>特征方程：<span class="math inline">\(|\lambda\mathbf E-\mathbfA|=0\)</span></p></li><li><p>特征根：特征方程的解</p></li><li><p>迹：<span class="math inline">\(tr(\mathbfA)=\Sigma_{i=1}^na_{ii}\)</span>为矩阵<spanclass="math inline">\(\mathbf A=(a_{ij})_{n\timesn}\)</span>的迹。</p></li></ul></li><li><p>计算矩阵<span class="math inline">\(\mathbfA\)</span>的特征值与特征向量：</p><ol type="1"><li>计算全部特征根，即为<span class="math inline">\(\mathbfA\)</span>的特征值</li><li>对每个特征值<spanclass="math inline">\(\lambda_i\)</span>，求齐次线性方程组<spanclass="math inline">\((\lambda_i\mathbf E-\mathbf A)\mathbfx=\theta\)</span>的一个基础解系<spanclass="math inline">\(\alpha_1,...,\alpha_{s_i}\)</span></li><li><span class="math inline">\(\mathbf A\)</span>属于<spanclass="math inline">\(\lambda_i\)</span>的全部特征向量为<spanclass="math inline">\(k_1\alpha_1+...+k_{s_i}\alpha_{s_i}\)</span></li></ol><p>由上述定义可得：</p><ul><li><p>设方阵有特征值<span class="math inline">\(\lambda\)</span>，<spanclass="math inline">\(\xi_1,\xi_2\)</span>为属于<spanclass="math inline">\(\lambda\)</span>的特征向量，则它们的非零线性组合仍是属于<spanclass="math inline">\(\lambda\)</span>的特征向量。</p><ul><li><p>属于不同特征值的特征向量线性无关。</p></li><li><p>特征值的特征向量数不超过特征值在特征方程中的重数。</p></li></ul></li><li><p>若<span class="math inline">\(f(x)\)</span>为<spanclass="math inline">\(x\)</span>的多项式，矩阵<spanclass="math inline">\(\mathbf A\)</span>有特征值<spanclass="math inline">\(\lambda\)</span>，则<spanclass="math inline">\(f(\mathbf A)\)</span>有特征值<spanclass="math inline">\(f(\lambda)\)</span>。</p><ul><li><span class="math inline">\(|a\mathbf A+b\mathbfE|=0\)</span>，则<span class="math inline">\(\mathbfA\)</span>有特征值<span class="math inline">\(-\frac ba\)</span>。</li></ul></li><li><p>若<span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(\mathbf A\)</span>的特征值为<spanclass="math inline">\(\lambda_1,...\lambda_n\)</span>，则有<spanclass="math inline">\(tr(\mathbf A)=\Sigma_{i=1}^n\lambda_i,|\mathbfA|=\prod_{i=1}^n\lambda_i\)</span>。</p><ul><li>相似矩阵有相同的迹和行列式。</li></ul></li><li><p>块对角矩阵<span class="math inline">\(diag(\mathbfA_1,...,\mathbf A_m)\)</span>的特征值为<spanclass="math inline">\(\mathbf A_1,...,\mathbfA_m\)</span>的所有特征值。</p></li></ul></li></ol><h3 id="相似变换与对角化">4.2 相似变换与对角化</h3><ol type="1"><li><p>同阶方阵<span class="math inline">\(\mathbf A\)</span>和<spanclass="math inline">\(\mathbf B\)</span>，若存在可逆矩阵<spanclass="math inline">\(\mathbf P\)</span>，使<spanclass="math inline">\(\mathbf B=\mathbf P^{-1}\mathbf A\mathbfP\)</span>，则称<span class="math inline">\(\mathbfA\)</span>相似于<span class="math inline">\(\mathbfB\)</span>，记为<span class="math inline">\(\mathbf A\sim\mathbfB\)</span>。</p><p>称<span class="math inline">\(\mathbf B\)</span>为<spanclass="math inline">\(\mathbf A\)</span>的相似矩阵，<spanclass="math inline">\(\mathbf P\)</span>为<spanclass="math inline">\(\mathbf A\)</span>到<spanclass="math inline">\(\mathbf B\)</span>的相似变换矩阵。</p><ul><li><p>相似矩阵有相同的特征多项式和特征值。</p></li><li><p>性质：</p><ul><li><span class="math inline">\(\mathbf A\sim\mathbf B\)</span>，则<spanclass="math inline">\(|\mathbf A|=|\mathbf B|\)</span>，故<spanclass="math inline">\(\mathbf A\)</span>与<spanclass="math inline">\(\mathbf B\)</span>的可逆性相同。</li><li><span class="math inline">\(\mathbf A\sim\mathbf B\)</span>，且<spanclass="math inline">\(\mathbf A\)</span>或<spanclass="math inline">\(\mathbf B\)</span>可逆，则<spanclass="math inline">\(\mathbf A^{-1}\sim\mathbf B^{-1}\)</span>。</li><li><span class="math inline">\(\mathbf A\sim\mathbf B\)</span>，则<spanclass="math inline">\(\mathbf A^n\sim\mathbf B^n,k\mathbf A\sim k\mathbfB,n\in\N,k\in\R\)</span>。<ul><li><span class="math inline">\(\mathbf A\sim\mathbf B\)</span>，则<spanclass="math inline">\(\mathbf A^*\sim\mathbf B^*\)</span>。（<spanclass="math inline">\(\mathbf A^{-1}=\frac1{|\mathbf A|}\mathbfA^*\)</span>）</li></ul></li><li><span class="math inline">\(\mathbf A\sim\mathbf B\)</span>，则<spanclass="math inline">\(f(\mathbf A)\sim f(\mathbf B)\)</span>，其中<spanclass="math inline">\(f(x)=a_nx^n+...+a_1x+a_0\)</span>为任意多项式。</li></ul></li></ul></li><li><p>对角化：若方阵<span class="math inline">\(\mathbfA\)</span>相似于一个对角矩阵，则称<span class="math inline">\(\mathbfA\)</span>可对角化。</p><ul><li><p><spanclass="math inline">\(n\)</span>阶矩阵可对角化的充要条件是有<spanclass="math inline">\(n\)</span>个线性无关的特征向量。</p><p>对角矩阵的主对角线由特征值按任意顺序构成，相似变换矩阵由属于相应特征值的特征向量构成。</p><ul><li>若<span class="math inline">\(n\)</span>阶矩阵有<spanclass="math inline">\(n\)</span>个互不相同的特征值，则矩阵可对角化。</li><li><spanclass="math inline">\(n\)</span>阶矩阵可对角化的充要条件为每个<spanclass="math inline">\(k_i\)</span>重特征值<spanclass="math inline">\(\lambda_i\)</span>对应的特征矩阵<spanclass="math inline">\(\lambda_i\mathbf E-\mathbf A\)</span>的秩为<spanclass="math inline">\(n-k_i\)</span>。</li></ul></li><li><p>矩阵<span class="math inline">\(\mathbfA\)</span>对角化的过程：</p><ol type="1"><li><p>计算特征值<spanclass="math inline">\(\lambda_1(s_1\)</span>重<spanclass="math inline">\(),\lambda_2(s_2\)</span>重<spanclass="math inline">\(),...,\lambda_m(s_m\)</span>重<spanclass="math inline">\()\)</span>。</p></li><li><p>对每个特征值，解<span class="math inline">\((\lambda_i\mathbfE-\mathbf A)\mathbf x=\theta\)</span>得基础解系<spanclass="math inline">\(\alpha_{i1},...,\alpha_{ir_i}\)</span>。</p><ul><li>若存在<span class="math inline">\(r_i\lts_i\)</span>，则矩阵不可对角化。</li></ul></li><li><p><span class="math inline">\(\mathbfP=(\alpha_{11},...,\alpha_{1s_1},...,\alpha_{ms_m})\)</span>，则</p><p><span class="math inline">\(\mathbf P^{-1}\mathbf A\mathbfP=diag(\lambda_1,...,\lambda_1,\lambda_2,...,\lambda_2,...,\lambda_m,...,\lambda_m)\)</span>，其中<spanclass="math inline">\(\lambda_i\)</span>有<spanclass="math inline">\(s_i\)</span>个。</p></li></ol></li></ul></li></ol><h2 id="对称矩阵与二次型">5. 对称矩阵与二次型</h2><ol type="1"><li><p>实对称矩阵：具有对称性的实矩阵称为实对称矩阵。</p><ul><li><p>性质：</p><ul><li><p>实对称矩阵的特征值为实数。</p></li><li><p>实对称矩阵属于不同特征值的特征向量相互正交。</p></li><li><p>对实对称矩阵<span class="math inline">\(\mathbfA\)</span>，存在同阶的正交矩阵<span class="math inline">\(\mathbfP\)</span>，使得<span class="math inline">\(\mathbf P^{-1}\mathbfA\mathbf P\)</span>为实对角矩阵。</p></li><li><p>合同变换：</p><p>设<span class="math inline">\(\mathbf A,\mathbfB\)</span>为两个同阶方阵，若存在一个可逆矩阵<spanclass="math inline">\(\mathbf P\)</span>使得<spanclass="math inline">\(\mathbf B=\mathbf P^T\mathbf A\mathbfP\)</span>，则称<span class="math inline">\(\mathbfA\)</span>合同于<span class="math inline">\(\mathbf B\)</span>。</p><ul><li>称<span class="math inline">\(\mathbf B\)</span>为<spanclass="math inline">\(\mathbf A\)</span>的合同矩阵，<spanclass="math inline">\(\mathbf P\)</span>为<spanclass="math inline">\(\mathbf A\)</span>到<spanclass="math inline">\(\mathbf B\)</span>的合同变换矩阵，记为<spanclass="math inline">\(\mathbf A\simeq\mathbf B\)</span>。</li></ul></li><li><p>存在正交矩阵将实对称矩阵合同变换对角化。</p></li></ul></li></ul><p>实二次型：含有<span class="math inline">\(n\)</span>个实变量<spanclass="math inline">\(x_1,...,x_n\)</span>的在某个数域上的二次齐次多项式。</p><ul><li><p>矩阵表示：<span class="math inline">\(f(x_1,...,x_n)=\mathbfx^T\mathbf A\mathbf x\)</span>，其中<span class="math inline">\(\mathbfx=(x_1,x_2,...,x_n)^T,\mathbf A=(a_{ij})_{n\times n}\)</span>。</p><ul><li><span class="math inline">\(\mathbf A\)</span>称为二次型<spanclass="math inline">\(f\)</span>的矩阵，<spanclass="math inline">\(\mathbf A\)</span>的秩称为二次型<spanclass="math inline">\(f\)</span>的秩。</li></ul></li><li><p>二次型的标准形：只包含变量平方项的二次型<spanclass="math inline">\(d_1y_1^2+...+d_ny_n^2\)</span>，称为原二次型的标准形。</p><ul><li><p>二次型标准化方法：合同变换法、配方法。</p></li><li><p>二次型的规范形：系数<span class="math inline">\(d_i\in\{-1,0,1\}\)</span>的标准形。</p></li></ul></li><li><p>存在非退化线性变换将实二次型化为标准形。</p></li></ul><p>实对称矩阵和实二次型的关系：</p><ul><li><p>实二次型的矩阵是实对称矩阵。</p></li><li><p>实二次型的非退化线性变换和实对称矩阵的合同变换等价。</p></li></ul></li><li><p>惯性定理：无论对二次型进行怎样的可逆线性变换，其正项个数<spanclass="math inline">\(p\)</span>和负项个数<spanclass="math inline">\(q\)</span>都不变。</p><ul><li><span class="math inline">\(p\)</span>称为正惯性系数，<spanclass="math inline">\(q\)</span>称为负惯性系数。<spanclass="math inline">\(p+q\)</span>为二次型的秩。</li></ul><p>正定二次型：</p><ul><li>称<span class="math inline">\(n\)</span>元二次型<spanclass="math inline">\(f(x_1,...,x_n)=\mathbf x^T\mathbf A\mathbfx\)</span>为正定二次型，当且仅当对<spanclass="math inline">\(\forall\mathbf x\neq\mathbf 0\)</span>，有<spanclass="math inline">\(\mathbf x^T\mathbf A\mathbf x\gt0\)</span>。<ul><li>称正定二次型对应的矩阵<span class="math inline">\(\mathbfA\)</span>为正定矩阵。</li></ul></li><li>称<span class="math inline">\(n\)</span>元二次型<spanclass="math inline">\(f(x_1,...,x_n)=\mathbf x^T\mathbf A\mathbfx\)</span>为半正定二次型，当且仅当对<spanclass="math inline">\(\forall\mathbf x\neq\mathbf 0\)</span>，有<spanclass="math inline">\(\mathbf x^T\mathbf A\mathbf x\ge0\)</span>。<ul><li>称半正定二次型对应的矩阵<span class="math inline">\(\mathbfA\)</span>为半正定矩阵。</li></ul></li></ul><p>负定二次型：</p><ul><li>称<span class="math inline">\(n\)</span>元二次型<spanclass="math inline">\(f(x_1,...,x_n)=\mathbf x^T\mathbf A\mathbfx\)</span>为负定二次型，当且仅当对<spanclass="math inline">\(\forall\mathbf x\neq\mathbf 0\)</span>，有<spanclass="math inline">\(\mathbf x^T\mathbf A\mathbf x\lt0\)</span>。<ul><li>称负定二次型对应的矩阵<span class="math inline">\(\mathbfA\)</span>为负定矩阵。</li></ul></li><li>称<span class="math inline">\(n\)</span>元二次型<spanclass="math inline">\(f(x_1,...,x_n)=\mathbf x^T\mathbf A\mathbfx\)</span>为半负定二次型，当且仅当对<spanclass="math inline">\(\forall\mathbf x\neq\mathbf 0\)</span>，有<spanclass="math inline">\(\mathbf x^T\mathbf A\mathbf x\le0\)</span>。<ul><li>称半负定二次型对应的矩阵<span class="math inline">\(\mathbfA\)</span>为半负定矩阵。</li></ul></li></ul><p>实二次型正定的充要条件：</p><ul><li>正惯性系数等于阶数。</li><li>特征值都大于0。</li><li>全部顺序主子式都大于0。</li></ul><p>实二次型正定的必要条件：</p><ul><li><span class="math inline">\(a_{ii}\gt0,i=1,...,n\)</span>。</li><li><span class="math inline">\(|\mathbf A|\gt0\)</span>。</li></ul><p>实二次型半正定的充要条件：</p><ul><li>特征值大于等于0。</li><li>正惯性系数等于秩。</li><li>各阶主子式非负。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性代数总结一</title>
    <link href="/2022/10/01/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%80%BB%E7%BB%93%E4%B8%80/"/>
    <url>/2022/10/01/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%80%BB%E7%BB%93%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>踏遍青山人未老，风景这边独好。</p><span id="more"></span><h1 id="线性代数总结一">线性代数总结一</h1><h2 id="行列式">1. 行列式</h2><h3 id="行列式定义">1.1 行列式定义</h3><p><spanclass="math inline">\(n^2\)</span>个可进行加法和乘法运算的元素排成<spanclass="math inline">\(n\)</span>行<spanclass="math inline">\(n\)</span>列，称为<spanclass="math inline">\(n\)</span>阶行列式，用<spanclass="math inline">\(|a_{ij}|_{n\times n}\)</span>或<spanclass="math inline">\(A,B,C\)</span>表示。</p><ul><li>余子式：行列式<span class="math inline">\(D\)</span>中去除<spanclass="math inline">\(a_{ij}\)</span>所在行列得到的行列式<spanclass="math inline">\(M_{ij}\)</span>称为元素<spanclass="math inline">\(a_{ij}\)</span>的余子式。</li><li>代数余子式：<spanclass="math inline">\(A_{ij}=(-1)^{i+j}M_{ij}\)</span>称为元素<spanclass="math inline">\(a_{ij}\)</span>的代数余子式。</li><li>顺序主子式：<span class="math inline">\(|a_{ij}|_{k\times k},k\len\)</span>为行列式<span class="math inline">\(|a_{ij}|_{n\timesn}\)</span>的顺序主子式。</li><li><span class="math inline">\(k\)</span>阶主子式：<spanclass="math inline">\(|a_{ij}|_{n\times n}\)</span>的任意<spanclass="math inline">\(k\)</span>行<spanclass="math inline">\(k\)</span>列构成的行列式。</li><li>行列式的转置：<span class="math inline">\(A=|a_{ij}|_{n\timesn}\)</span>，则它的转置为<spanclass="math inline">\(A^T=|b_{ij}|_{n\timesn},b_{ij}=a_{ji}\)</span>。</li></ul><h3 id="行列式的值">1.2 行列式的值</h3><p><span class="math inline">\(2,3\)</span>阶行列式：对角线法则</p><p><spanclass="math inline">\(n\)</span>阶行列式：行列式的值等于其任意行/列展开式的值。</p><ul><li>第<span class="math inline">\(1\)</span>行的展开式：<spanclass="math inline">\(D_{n}=a_{11}A_{11}+...+a_{1n}A_{1n}=\Sigma_{j=1}^na_{1j}A_{1j}\)</span>。</li><li>第<span class="math inline">\(i\)</span>行的展开式：<spanclass="math inline">\(D_n=\Sigma_{j=1}^na_{ij}A_{ij}=\Sigma_{j=1}^n(-1)^{i+j}a_{ij}M_{ij}\)</span>。</li></ul><p>根据<spanclass="math inline">\(n\)</span>阶行列式值的定义，行列式的值有如下性质：</p><ol type="1"><li>行列式与它的转置行列式的值相等。</li><li>对调两行/列的位置，行列式的值相差一个负号。<ul><li>两行/列相等的行列式的值为0。</li></ul></li><li>行列式任一行/列元素的公因子可以提出到行列式外。<ul><li>两行/列对应元素成比例的行列式值为0。</li></ul></li><li>若行列式的第<spanclass="math inline">\(i\)</span>行的每一个元素都可以表示成两数之和，则该行列式可以表示为两个行列式的和。<ul><li>将行列式的任一行乘以<spanclass="math inline">\(k\)</span>加到另一行上去，行列式的值不变。<ul><li>行列式任一行/列元素与另一行/列元素的代数余子式对应乘积之和为0。即，设<span class="math inline">\(A=|a_{ij}|_{n\timesn}\)</span>，有<spanclass="math inline">\(\Sigma_{k=1}^na_{ik}A_{jk}=\begin{cases}A,i=j\\0,i\nej\end{cases}\)</span>。</li></ul></li></ul></li></ol><p>特殊行列式的值：通过定义与性质化简</p><ol type="1"><li><p>三角行列式：对角线上/下方的元素均为0的行列式。</p><ul><li><p>值为对角线上元素的积。</p><ul><li>副对角线的三角行列式的值为副对角线上元素的积乘以<spanclass="math inline">\((-1)^{\frac{n(n-1)}2}\)</span>。</li></ul></li></ul></li><li><p>反对称行列式：第<span class="math inline">\(i\)</span>行<spanclass="math inline">\(j\)</span>列的元素是第<spanclass="math inline">\(j\)</span>行<spanclass="math inline">\(i\)</span>列的元素的负数。</p><ul><li>奇数阶的反对称行列式的值为0。</li></ul></li><li><p>范德蒙德行列式：<spanclass="math inline">\(D_n(x_1,...,x_n)=\left|\begin{array}{}1&amp;1&amp;...&amp;1\\ x_1&amp;x_2&amp;...&amp;x_n\\...&amp;...&amp;&amp;...\\x_1^{n-1}&amp;x_2^{n-1}&amp;...&amp;x_n^{n-1}\end{array}\right|\)</span>=<spanclass="math inline">\(\prod_{1\le i\le j\le n}(x_j-x_i)\)</span>。</p><ul><li>计算方式：逆序将第<span class="math inline">\(i\)</span>行乘以<spanclass="math inline">\(-x_1\)</span>加到第<spanclass="math inline">\(i+1\)</span>行。</li></ul></li><li><p>拉普拉斯展开式：<span class="math inline">\(m\)</span>阶矩阵<spanclass="math inline">\(A\)</span>，<spanclass="math inline">\(n\)</span>阶矩阵<spanclass="math inline">\(B\)</span>， <spanclass="math inline">\(\left|\begin{array}{}A&amp;C\\O&amp;B\end{array}\right|=\left|\begin{array}{}A&amp;O\\C&amp;B\end{array}\right|=|A||B|\)</span>，<spanclass="math inline">\(\left|\begin{array}{}C&amp;A\\B&amp;O\end{array}\right|=\left|\begin{array}{}O&amp;A\\B&amp;C\end{array}\right|=(-1)^{mn}|A||B|\)</span>。</p></li></ol><p>行列式值的几何意义：把行列式看成<spanclass="math inline">\(n\)</span>个<spanclass="math inline">\(n\)</span>阶向量，行列式的值就是这<spanclass="math inline">\(n\)</span>个向量构成的几何体的体积。</p><h3 id="题目思路">1.3 题目思路</h3><ol type="1"><li><p>行列式按任意行/列展开计算。</p></li><li><p>行列式按行列式值的性质进行变换。</p><p>记法：</p><ul><li><p>以数<span class="math inline">\(k\)</span>乘以第<spanclass="math inline">\(j\)</span>行/列加到第<spanclass="math inline">\(i\)</span>行/列记为<spanclass="math inline">\(r_i+kr_j\)</span>/<spanclass="math inline">\(c_i+kc_j\)</span>，</p></li><li><p>交换第<span class="math inline">\(i\)</span>行/列和第<spanclass="math inline">\(j\)</span>行/列记为<spanclass="math inline">\(r_i\leftrightarrow r_j\)</span>/<spanclass="math inline">\(c_i\leftrightarrow c_j\)</span>，</p></li><li><p>第<span class="math inline">\(i\)</span>行/列提取公因子<spanclass="math inline">\(k\)</span>记为<spanclass="math inline">\(\frac1kr_i\)</span>/<spanclass="math inline">\(\frac1kc_i\)</span>。</p></li></ul></li><li><p>余子式/代数余子式的线性组合：<spanclass="math inline">\(k_1A_{i1}+...+k_nA_{in}\)</span>即将第<spanclass="math inline">\(i\)</span>行替换为<spanclass="math inline">\(k_1,...,k_n\)</span>的新行列式的值。</p></li></ol><h2 id="矩阵">2. 矩阵</h2><h3 id="定义与运算">2.1 定义与运算</h3><h4 id="矩阵-1">矩阵</h4><p>由<span class="math inline">\(m\times n\)</span>个数<spanclass="math inline">\(a_{ij}\)</span>排成<spanclass="math inline">\(m\)</span>行<spanclass="math inline">\(n\)</span>列的数表，称为<spanclass="math inline">\(m\)</span>行<spanclass="math inline">\(n\)</span>列矩阵，简称<spanclass="math inline">\(m\times n\)</span>矩阵。</p><ul><li><p>通常表示为<span class="math inline">\(\mathbf A=(a_{ij})_{m\timesn}\)</span>，也可记为<span class="math inline">\(\mathbf A_{m\timesn}\)</span>。</p></li><li><p>这<span class="math inline">\(m\timesn\)</span>个数都是矩阵的元素，元素都是实数的矩阵称为实矩阵，都是复数的矩阵称为复矩阵。<span class="math inline">\(\mathbf R^{m\times n}\)</span>或<spanclass="math inline">\(\mathbf M_{m\times n}(\mathbfR)\)</span>表示全体<span class="math inline">\(m\timesn\)</span>实矩阵的集合。</p><ul><li>如果两个矩阵的行数和列数相等，且对应元素相等，则称这两个矩阵相等。</li></ul></li></ul><h4 id="运算">运算</h4><p>线性运算：</p><ol type="1"><li><p>加减法：<span class="math inline">\(\mathbf A=(a_{ij})_{m\timesn}\)</span>，<span class="math inline">\(\mathbf B=(b_{ij})_{m\timesn}\)</span>，则<span class="math inline">\(\mathbf A\pm\mathbfB=(a_{ij}\pm b_{ij})_{m\times n}\)</span>。</p></li><li><p>数乘：<span class="math inline">\(\mathbf A=(a_{ij})_{m\timesn}\)</span>，则<span class="math inline">\(k\mathbf A=(ka_{ij})_{m\timesn}\)</span>。</p></li></ol><p>乘法：<span class="math inline">\(\mathbf A=(a_{ij})_{m\timesn}\)</span>，<span class="math inline">\(\mathbf B=(b_{ij})_{m\timesn}\)</span>，则<span class="math inline">\(\mathbf A\times\mathbfB\)</span>定义为<span class="math inline">\(\mathbf C=(c_{ij})_{m\timesn}\)</span>，<spanclass="math inline">\(c_{ij}=\Sigma_{k=1}^la_{ik}b_{kj}\)</span>。</p><ul><li>矩阵乘法不满足交换律和消去律，但满足结合律和分配律。</li></ul><p>转置：把<span class="math inline">\(m\times n\)</span>矩阵<spanclass="math inline">\(\mathbf A\)</span>的行列互换后得到的<spanclass="math inline">\(n\times m\)</span>矩阵称为<spanclass="math inline">\(\mathbf A\)</span>的转置矩阵，记为<spanclass="math inline">\(\mathbf A^T\)</span>。</p><ul><li><p><span class="math inline">\((\mathbf A^T)^T=\mathbf A,(\mathbfA+\mathbf B)^T=\mathbf A^T+\mathbf B^T,(k\mathbf A)^T=k\mathbfA^T\)</span></p></li><li><p><span class="math inline">\((\mathbf A\mathbf B)^T=\mathbfB^T\mathbf A^T\)</span></p></li></ul><h4 id="方阵">方阵</h4><p><span class="math inline">\(m=n\)</span>时，<spanclass="math inline">\(m\times n\)</span>矩阵称为<spanclass="math inline">\(n\)</span>阶方阵，可记为<spanclass="math inline">\(\mathbf A_n\)</span>。</p><ul><li>矩阵的幂：<span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(\mathbf A\)</span>，<spanclass="math inline">\(\mathbf A^k\)</span>为<spanclass="math inline">\(k\)</span>个<span class="math inline">\(\mathbfA\)</span>连乘，称为<span class="math inline">\(\mathbfA\)</span>的<span class="math inline">\(k\)</span>次幂，它仍为<spanclass="math inline">\(n\)</span>阶方阵。</li><li>矩阵多项式：<span class="math inline">\(f(\mathbf A)=a_0\mathbfE+a_1\mathbf A+...+a_m\mathbf A^m\)</span>仍为<spanclass="math inline">\(n\)</span>阶方阵，称为矩阵多项式。<ul><li>满足<span class="math inline">\(f(\mathbf A)=\mathbfO\)</span>的矩阵称为矩阵方程<span class="math inline">\(f(\mathbfX)=\mathbf O\)</span>的解。</li></ul></li></ul><p>行列式<span class="math inline">\(|a_{ij}|_{n\timesn}\)</span>称为方阵<span class="math inline">\(\mathbfA_n\)</span>的行列式，记为<span class="math inline">\(|\mathbfA|\)</span>。</p><ul><li>如果<span class="math inline">\(|\mathbf A|\ne0\)</span>，称<spanclass="math inline">\(\mathbfA\)</span>为非异矩阵，否则称其为奇异矩阵或退化矩阵。</li><li><span class="math inline">\(|\mathbf A\mathbf B|=|\mathbf A||\mathbfB|\)</span></li><li><span class="math inline">\(|k\mathbf A|=k^n|\mathbfA|\)</span></li></ul><h4 id="特殊矩阵">特殊矩阵</h4><ol type="1"><li><p>零矩阵：所有元素为0的矩阵，记为<spanclass="math inline">\(\mathbf O\)</span>或<spanclass="math inline">\(\mathbf O_{m\times n}\)</span>。</p></li><li><p>对角矩阵：<span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(\mathbf A\)</span>，<spanclass="math inline">\(\forall i\nej,a_{ij}=0\)</span>，称其为对角矩阵，可记为<spanclass="math inline">\(diag(a_{11},...,a_{nn})\)</span>。</p></li><li><p>数量矩阵：<spanclass="math inline">\(a_{11}=...=a_{nn}=k\)</span>的对角矩阵。<spanclass="math inline">\(k=1\)</span>时，称为单位矩阵，记为<spanclass="math inline">\(\mathbf E\)</span>或<spanclass="math inline">\(\mathbf I\)</span>。</p></li><li><p>三角矩阵：<span class="math inline">\(\forall i\gtj,a_{ij}=0\)</span>的方阵为上三角矩阵，<spanclass="math inline">\(\forall i\ltj,a_{ij}=0\)</span>的方阵为下三角矩阵。</p></li><li><p>对称与反对称：<span class="math inline">\(\foralli,j\)</span>有<spanclass="math inline">\(a_{ij}=a_{ji}\)</span>的方阵为对称矩阵，<spanclass="math inline">\(\forall i,j\)</span>有<spanclass="math inline">\(a_{ij}=-a_{ji}\)</span>的方阵为反对称矩阵。</p></li></ol><h4 id="矩阵分块">矩阵分块</h4><p><span class="math inline">\(m\times n\)</span>矩阵<spanclass="math inline">\(\mathbf A\)</span>，在行的方向分为<spanclass="math inline">\(s\)</span>块，列的方向分为<spanclass="math inline">\(t\)</span>块，就得到<spanclass="math inline">\(\mathbf A\)</span>的<spanclass="math inline">\(s\times t\)</span>分块矩阵。</p><ul><li>记作<span class="math inline">\(\mathbf A=(\mathbf A_{kl})_{s\timest}\)</span>，<span class="math inline">\(\mathbfA_{kl}\)</span>称为<span class="math inline">\(\mathbfA\)</span>的子块。</li></ul><p>运算：</p><ol type="1"><li>加减法：<span class="math inline">\(\mathbf A=(\mathbfA_{kl})_{s\times t},\mathbf B=(\mathbf B_{kl})_{s\timest}\)</span>对应子块均同型，则<span class="math inline">\(\mathbfA\pm\mathbf B=(\mathbf A_{kl}\pm\mathbf B_{kl})_{s\timest}\)</span>。</li><li>数乘：<span class="math inline">\(\mathbf A=(\mathbfA_{kl})_{s\times t}\)</span>，则<span class="math inline">\(k\mathbfA=(k\mathbf A_{kl})_{s\times t}\)</span>。</li><li>乘法：若将<span class="math inline">\(\mathbf A=(a_{ij})_{m\timesn}\)</span>和<span class="math inline">\(\mathbf B=(b_{ij})_{n\timesp}\)</span>分块为<span class="math inline">\(r\times s\)</span>和<spanclass="math inline">\(s\times t\)</span>矩阵，且<spanclass="math inline">\(\mathbf A\)</span>的列分块法和<spanclass="math inline">\(\mathbf B\)</span>的行分块法相同，则<spanclass="math inline">\(\mathbf A\mathbf B=\mathbf C=(\mathbfC_{kl})_{r\times t},\mathbf C_{kl}=\Sigma_{i=1}^s\mathbf A_{ki}\mathbfB_{il}\)</span>。<ul><li>分块乘法和不分块乘法的结果是相同的。</li></ul></li><li>转置：<span class="math inline">\(s\times t\)</span>分块矩阵<spanclass="math inline">\(\mathbf A=(\mathbf A_{kl})_{s\timest}\)</span>的转置矩阵<span class="math inline">\(\mathbf A^T=(\mathbfB_{lk})_{t\times s},\mathbf B_{lk}=\mathbf A_{kl}^T\)</span>。</li></ol><p>常见分块方式：</p><ol type="1"><li>分块对角矩阵：只有对角线上子块非零的矩阵，也称准对角矩阵。</li><li>按行/列分块</li></ol><h3 id="初等变换">2.2 初等变换</h3><h4 id="基础定义">基础定义</h4><ol type="1"><li><p>对调、数乘、倍加变换统称为矩阵的初等变换。</p><ul><li><p>对调变换：互换矩阵的<spanclass="math inline">\(i,j\)</span>两行或列，记为<spanclass="math inline">\(r_i\leftrightarrow r_j\)</span>或<spanclass="math inline">\(c_i\leftrightarrow c_j\)</span>。</p></li><li><p>数乘变换：用任意数<spanclass="math inline">\(k\ne0\)</span>乘以矩阵的任一行或列，记为<spanclass="math inline">\(kr_i\)</span>或<spanclass="math inline">\(kc_i\)</span>。</p></li><li><p>倍加变换：把矩阵的第<spanclass="math inline">\(i\)</span>行或列的<spanclass="math inline">\(k\)</span>倍加到第<spanclass="math inline">\(j\)</span>行或列，记为<spanclass="math inline">\(r_j+kr_i\)</span>或<spanclass="math inline">\(c_j+kc_i\)</span>。</p></li></ul></li><li><p>对矩阵进行初等行变换，相当于左乘一个初等矩阵；进行初等列变换，相当于右乘一个初等矩阵。</p><ul><li><p>初等对调矩阵：单位矩阵的第<spanclass="math inline">\(i\)</span>行和第<spanclass="math inline">\(j\)</span>行对调的矩阵<spanclass="math inline">\(\mathbf E(i,j)\)</span>。</p></li><li><p>初等数乘矩阵：单位矩阵的第<spanclass="math inline">\(i\)</span>个1换成<spanclass="math inline">\(k\)</span>的矩阵<spanclass="math inline">\(\mathbf E(i(k))\)</span>。</p></li><li><p>初等倍加矩阵：单位矩阵第<spanclass="math inline">\(i\)</span>行第<spanclass="math inline">\(j\)</span>列改成<spanclass="math inline">\(k\)</span>的矩阵<spanclass="math inline">\(\mathbf E(i,j(k))\)</span>。</p></li></ul></li><li><p>等价矩阵：</p><p><span class="math inline">\(\mathbfA\)</span>经过有限次初等行/列变换能转化为<spanclass="math inline">\(\mathbf B\)</span>，称它们行/列等价；</p><p><span class="math inline">\(\mathbfA\)</span>经过有限次初等变换能转化为<span class="math inline">\(\mathbfB\)</span>，称它们等价，记为<span class="math inline">\(\mathbfA\rightarrow \mathbf B\)</span>。</p><ul><li><p>矩阵等价是等价关系。</p></li><li><p>具有行等价关系的矩阵对应线性方程组具有相同的解。</p></li></ul></li><li><p>梯形矩阵与标准形：</p><ul><li><p>行梯形矩阵：零行全在下方，从第一行起，每行第一个非零元素前零的个数逐行增加的矩阵。</p></li><li><p>行简化梯形矩阵：非零行的第一个非零元素为1，且1所在列的其余元素均为0的行梯形矩阵。</p></li><li><p>类似地定义列梯形矩阵和列简化梯形矩阵。</p></li><li><p>标准形矩阵：既是行简化梯形矩阵，又是列简化梯形矩阵。</p></li></ul></li><li><p>矩阵的化简：矩阵可以有限次初等行/列变换为行/列简化梯形矩阵，有限次初等变换为标准形。</p><ul><li><p>矩阵的分解：秩为<span class="math inline">\(r\)</span>的<spanclass="math inline">\(m\times n\)</span>矩阵<spanclass="math inline">\(\mathbf A\)</span>，存在<spanclass="math inline">\(m\)</span>阶可逆矩阵<spanclass="math inline">\(\mathbf P\)</span>和<spanclass="math inline">\(n\)</span>阶可逆矩阵<spanclass="math inline">\(\mathbf Q\)</span>使得<spanclass="math inline">\(\mathbf P\mathbf\Lambda\mathbf Q=\mathbfA\)</span>，其中<span class="math inline">\(\mathbf\Lambda=diag(\mathbfE_r,\mathbf O)\)</span>。</p></li><li><p>任一<span class="math inline">\(n\)</span>阶可逆矩阵<spanclass="math inline">\(\mathbf A\)</span>可以表示为有限个<spanclass="math inline">\(n\)</span>阶初等矩阵的乘积。</p></li></ul></li></ol><h4 id="矩阵的秩">矩阵的秩</h4><p>矩阵的<span class="math inline">\(k\)</span>阶子式：任取矩阵的<spanclass="math inline">\(k\)</span>行和<spanclass="math inline">\(k\)</span>列交界的<spanclass="math inline">\(k^2\)</span>个元素按原序排成的<spanclass="math inline">\(k\)</span>阶行列式。</p><ol type="1"><li><p>矩阵的秩：矩阵非零子式的最高阶数<spanclass="math inline">\(r\)</span>，记为<spanclass="math inline">\(rank\mathbf A=r\)</span>。</p><ul><li>规定零矩阵的秩为0。</li><li><span class="math inline">\(0\le r(\mathbf A_{m\times n})\le\min(m,n)\)</span>。</li><li><span class="math inline">\(r(k\mathbf A)=r(\mathbfA),k\ne0\)</span>。</li><li><span class="math inline">\(r(\mathbf A)=r(\mathbf A^T)=r(\mathbfA^T\mathbf A)=r(\mathbf A\mathbf A^T)\)</span>。</li><li>秩等于阶数的方阵<span class="math inline">\(\mathbfA\)</span>称为满秩矩阵，此时<span class="math inline">\(|\mathbfA|\ne0\)</span>。</li></ul></li><li><p>初等变换与矩阵的秩：</p><ul><li><p>初等变换不改变矩阵的秩。</p></li><li><p>行梯形矩阵的秩等于它的非零行行数。</p></li><li><p>任意满秩矩阵都可以经过有限次初等行/列变换为单位矩阵。</p><ul><li>任意满秩矩阵可以表示为有限个初等矩阵的乘积。</li></ul></li></ul></li><li><p>求矩阵的秩：</p><ul><li><p>定义求解。</p></li><li><p>转化为行/列梯形矩阵求非零行/列数。</p></li></ul></li></ol><h4 id="可逆矩阵">可逆矩阵</h4><p><span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(\mathbf A\)</span>，若存在方阵<spanclass="math inline">\(\mathbf B\)</span>有<spanclass="math inline">\(\mathbf A\mathbf B=\mathbf B\mathbf A=\mathbfE\)</span>，称<span class="math inline">\(\mathbfA\)</span>为可逆矩阵，<span class="math inline">\(\mathbfB\)</span>是<span class="math inline">\(\mathbfA\)</span>的逆矩阵，记为<span class="math inline">\(\mathbfA^{-1}\)</span>。</p><p>根据定义可得矩阵可逆的基本性质：若<span class="math inline">\(\mathbfA\)</span>可逆，则有</p><ol type="1"><li><span class="math inline">\(\mathbf A^{-1}\)</span>可逆，<spanclass="math inline">\((\mathbf A^{-1})^{-1}=\mathbf A\)</span>。</li><li>数<span class="math inline">\(k\ne0\)</span>，<spanclass="math inline">\(k\mathbf A\)</span>可逆，<spanclass="math inline">\((k\mathbf A)^{-1}=k^{-1}\mathbfA^{-1}\)</span>。</li><li><span class="math inline">\(\mathbf A^T\)</span>可逆，<spanclass="math inline">\((\mathbf A^T)^{-1}=(\mathbfA^{-1})^T\)</span>。</li><li>若<span class="math inline">\(\mathbf A,\mathbfB\)</span>为同阶可逆矩阵，<span class="math inline">\(\mathbf A\mathbfB\)</span>可逆，<span class="math inline">\((\mathbf A\mathbfB)^{-1}=\mathbf B^{-1}\mathbf A^{-1}\)</span>。</li><li><span class="math inline">\(|\mathbf A||\mathbfA^{-1}|=1\)</span>，故<span class="math inline">\(|\mathbfA|\ne0\)</span>，<span class="math inline">\(\mathbfA\)</span>为满秩矩阵，<span class="math inline">\(|\mathbfA^{-1}|=|\mathbf A|^{-1}\)</span>。</li></ol><p>求可逆矩阵：</p><ol type="1"><li>根据定义求解</li><li>伴随矩阵：<span class="math inline">\(\mathbf A^{-1}=\frac1{|\mathbfA|}\mathbf A^*\)</span><ul><li><span class="math inline">\(\mathbf A^*=(A_{ij})_{n\timesn}^T\)</span>称为<span class="math inline">\(\mathbfA\)</span>的伴随矩阵。<ul><li><span class="math inline">\(\mathbf A\mathbf A^*=\mathbf A^*\mathbfA=|\mathbf A|\mathbf E\)</span>。</li><li><span class="math inline">\(r(\mathbfA^*)=\begin{cases}n,\;r(\mathbf A)=n\\1,\;r(\mathbfA)=n-1\\0,\;r(\mathbf A)\lt n-1 \end{cases}\)</span>。</li></ul></li><li><span class="math inline">\(n\)</span>阶方阵<spanclass="math inline">\(\mathbf A\)</span>有<spanclass="math inline">\(|\mathbf A^*|=|\mathbf A|^{n-1}\)</span>。</li><li>分块对角矩阵<span class="math inline">\(\mathbf A=diag(\mathbfA_{11},...,\mathbf A_{ss})\)</span>，有<spanclass="math inline">\(\mathbf A^{-1}=diag(\mathbfA_{11}^{-1},...,\mathbf A_{ss}^{-1})\)</span>。</li></ul></li><li>初等变换：任意可逆矩阵可只经过初等行/列变换为单位矩阵。<ul><li>初等行变换求可逆矩阵：<span class="math inline">\((\mathbfA\;\mathbf E)\)</span>初等行变换为<span class="math inline">\((\mathbfE\;\mathbf A^{-1})\)</span>。</li><li>初等列变换求可逆矩阵：<spanclass="math inline">\(\left(\begin{array}{}\mathbf A\\\mathbfE\end{array}\right)\)</span>初等行变换为<spanclass="math inline">\(\left(\begin{array}{}\mathbf E\\\mathbfA^{-1}\end{array}\right)\)</span>。</li></ul></li></ol><h3 id="向量">2.3 向量</h3><h4 id="基础定义-1">基础定义</h4><ol type="1"><li><p>向量：<span class="math inline">\(n\)</span>个数<spanclass="math inline">\(a_1,...,a_n\)</span>组成的有序数组称为<spanclass="math inline">\(n\)</span>维行或列向量，简称<spanclass="math inline">\(n\)</span>维向量。</p><ul><li><p><span class="math inline">\(a_i\)</span>称为向量的第<spanclass="math inline">\(i\)</span>个分量，分量都是实数的向量为实向量，都是复数的向量为复向量。</p><p>实向量的全体用<span class="math inline">\(\mathbfR^n\)</span>表示，复向量的全体用<span class="math inline">\(\mathbfC^n\)</span>表示。</p><ul><li>所有分量为0的向量称为零向量，记为<spanclass="math inline">\(\theta\)</span>或<spanclass="math inline">\(\mathbf 0\)</span>。</li><li>如果两个向量的分量个数相等，对应分量相等，则称这两个向量相等。</li></ul></li></ul></li><li><p>向量组：若干个同维数的行/列向量所组成的集合。</p><ul><li>含有限个向量的有序向量组与矩阵一一对应。</li></ul></li></ol><h4 id="向量内积与正交">向量内积与正交</h4><ol type="1"><li><p>向量内积：<span class="math inline">\(n\)</span>维向量<spanclass="math inline">\(\alpha=(a_1,..,a_n)^T,\beta=(b_1,...,b_n)^T\)</span>，</p><p>若<spanclass="math inline">\(\alpha,\beta\)</span>为实向量，则称<spanclass="math inline">\(a_1b_1+...+a_nb_n\)</span>为<spanclass="math inline">\(\alpha,\beta\)</span>的实内积，</p><p>若<spanclass="math inline">\(\alpha,\beta\)</span>为复向量，则称<spanclass="math inline">\(a_1\overline b_1+...+a_n\overlineb_n\)</span>为<spanclass="math inline">\(\alpha,\beta\)</span>的复内积，</p><p>统称为向量的内积，记为<spanclass="math inline">\((\alpha,\beta)\)</span>。</p><p>称<spanclass="math inline">\(||\alpha||=\sqrt{(\alpha,\alpha)}\)</span>为向量<spanclass="math inline">\(\alpha\)</span>的长度或模，模为1的向量为单位向量。</p><ul><li><spanclass="math inline">\((\alpha,\beta)=(\beta,\alpha)\)</span></li><li><spanclass="math inline">\(k(\alpha,\beta)=(k\alpha,\beta)\)</span></li><li><spanclass="math inline">\((\alpha+\gamma,\beta)=(\alpha,\beta)+(\gamma,\beta)\)</span></li><li><span class="math inline">\((\alpha,\alpha)\ge0\)</span></li><li><spanclass="math inline">\((\alpha,\alpha)=0\iff\alpha=\theta\)</span></li></ul></li><li><p>正交：若<spanclass="math inline">\((\alpha,\beta)=0\)</span>，则称<spanclass="math inline">\(\alpha,\beta\)</span>正交或垂直。</p><ul><li>若<spanclass="math inline">\(\alpha,\beta\)</span>均为非零实向量，则称<spanclass="math inline">\(\arccos\frac{(\alpha,\beta)}{||\alpha||||\beta||}\)</span>为向量<spanclass="math inline">\(\alpha,\beta\)</span>的夹角。</li></ul></li><li><p>正交向量组：不含零向量的、向量两两正交的向量组。</p><ul><li>法正交组/标准正交向量组：向量均为单位向量的正交向量组。</li><li>正交向量组必线性无关。</li></ul></li><li><p>正交矩阵：若实方阵<span class="math inline">\(\mathbfA\)</span>满足<span class="math inline">\(\mathbf A^T\mathbf A=\mathbfE\)</span>，则称<span class="math inline">\(\mathbfA\)</span>为正交矩阵。</p><p>正交矩阵<span class="math inline">\(\mathbf A\)</span>的性质：</p><ul><li><span class="math inline">\(\mathbf A^T=\mathbf A^{-1}\)</span></li><li><span class="math inline">\(|\mathbf A|^2=1\)</span></li><li><span class="math inline">\(\mathbfA\)</span>的行/列向量构成标准正交行/列向量组。</li></ul></li></ol><h4 id="线性相关性">线性相关性</h4><ol type="1"><li><p>线性组合和线性表示：</p><p>给定<span class="math inline">\(n\)</span>维向量组<spanclass="math inline">\(A:\alpha_1,...,\alpha_m\)</span>和同维向量<spanclass="math inline">\(\beta\)</span>，若<spanclass="math inline">\(\beta=k_1\alpha_1+...+k_m\alpha_m\)</span>，</p><p>称<span class="math inline">\(\beta\)</span>是向量组<spanclass="math inline">\(A\)</span>的一个线性组合，或称<spanclass="math inline">\(\beta\)</span>可由向量组<spanclass="math inline">\(A\)</span>线性表示。</p><ul><li>此时方程组<spanclass="math inline">\(x_1\alpha+...+x_m\alpha_m=\beta\)</span>有解。</li></ul><p>两个向量组<span class="math inline">\(A,B\)</span>，若<spanclass="math inline">\(A\)</span>中每个向量都可由<spanclass="math inline">\(B\)</span>线性表示，则称向量组<spanclass="math inline">\(A\)</span>可由向量组<spanclass="math inline">\(B\)</span>线性表示。</p><p>等价向量组：如果两个向量组可以相互线性表示，则称这两个向量组<strong>等价</strong>。</p></li><li><p>线性相关：给定向量组<spanclass="math inline">\(A:\alpha_1,...,\alpha_m\)</span>，</p><p>若存在不全为0的实数<spanclass="math inline">\(k_1,...,k_m\)</span>使<spanclass="math inline">\(k_1\alpha_1+...+k_m\alpha_m=\theta\)</span>，称向量组<spanclass="math inline">\(A\)</span>线性相关，否则线性无关。</p><ul><li>一个向量线性相关的充要条件为它是零向量。<ul><li>包含零向量的向量组必线性相关。</li></ul></li><li>向量组的部分向量线性相关，则这个向量组线性相关。</li><li>线性无关的向量组的部分向量线性无关。</li><li>向量组线性相关的充要条件是，存在一个向量可以由其他向量线性表示。<ul><li>向量组<span class="math inline">\(A\)</span>线性无关，向量组<spanclass="math inline">\(B:A,\beta\)</span>线性相关，则<spanclass="math inline">\(\beta\)</span>可由<spanclass="math inline">\(A\)</span>唯一地线性表示。</li></ul></li></ul></li><li><p>极大无关组：向量组的一个线性无关部分组，任意添加原向量组中其他向量构成的向量组都线性相关，则该部分组为原向量组的一个极大线性无关组，简称极大无关组。</p><ul><li>向量组中任一向量可由其极大无关组线性表示。</li><li>向量组与它的极大无关组等价。向量组的各个极大无关组等价且含有相同向量数。<ul><li>两个向量组等价的充要条件为它们的极大无关组等价。</li></ul></li></ul><p>向量组的秩：向量组的极大无关组所含向量个数。</p><ul><li>仅含零向量的向量组的秩为0。</li></ul><p>矩阵的行向量组的秩称为其行秩，列向量组的秩称为其列秩。</p><ul><li>矩阵的秩与行秩、列秩相等。<ul><li>向量组线性无关的充要条件为其构成的矩阵的秩为向量个数。</li><li><span class="math inline">\(n\)</span>个<spanclass="math inline">\(n\)</span>维向量线性无关的充要条件为其行列式不为0。</li><li>向量个数大于维数的向量组线性相关。</li></ul></li><li><span class="math inline">\(r(\mathbf A+\mathbf B)\le r(\mathbfA)+r(\mathbf B)\)</span>。</li><li><span class="math inline">\(r(\mathbf A\mathbf B)\le \min\{r(\mathbfA),r(\mathbf B)\}\)</span>。</li><li>若<span class="math inline">\(\mathbf A,\mathbf B\)</span>均为<spanclass="math inline">\(n\)</span>阶方阵，则<spanclass="math inline">\(r(\mathbf A\mathbf B)\ge r(\mathbf A)+r(\mathbfB)-n\)</span>。</li></ul></li></ol><h4 id="线性变换">线性变换</h4><p>称<span class="math inline">\(\mathbf x=(x_1,...,x_n)^T,\mathbfy=(y_1,...y_n)^T\)</span>，<span class="math inline">\(\mathbfP=(c_{ij})_{n\times n}\)</span>可逆，称<spanclass="math inline">\(\mathbf x=\mathbf P\mathbf y\)</span>为由<spanclass="math inline">\(\mathbf x\)</span>到<spanclass="math inline">\(\mathbf y\)</span>的一个线性变换。</p><ul><li>若系数行列式<span class="math inline">\(|\mathbfP|=|c_{ij}|_{n\timesn}\ne0\)</span>，称该线性变换为非异线性变换或非退化线性变换。</li><li>若系数行列式等于0，称该线性变换为奇异线性变换或退化线性变换。</li><li>若<span class="math inline">\(\mathbfP\)</span>为正交矩阵，称该线性变换为正交变换。</li></ul>]]></content>
    
    
    <categories>
      
      <category>线性代数</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Geternitier的博客</title>
    <link href="/2022/06/30/%E5%A4%A9%E9%A9%AC%E6%AD%8C/"/>
    <url>/2022/06/30/%E5%A4%A9%E9%A9%AC%E6%AD%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="天马歌">天马歌</h3><span id="more"></span><p>唐·李白</p><p>天马来出月支窟，背为虎文龙翼骨。<br />嘶青云，振绿发， 兰筋权奇走灭没。<br />腾昆仑，历西极，四足无一蹶。<br />鸡鸣刷燕晡秣越，神行电迈蹑慌惚。<br />天马呼，飞龙趋， 目明长庚臆双凫。<br />尾如流星首渴乌，口喷红光汗沟朱。 曾陪时龙蹑天衢，羁金络月照皇都。<br />逸气棱棱凌九区，白璧如山谁敢沽。<br />回头笑紫燕，但觉尔辈愚。<br />天马奔， 恋君轩，駷跃惊矫浮云翻。<br />万里足踯躅，遥瞻阊阖门。<br />不逢寒风子，谁采逸景孙。<br />白云在青天，丘陵远崔嵬。 盐车上峻坂，倒行逆施畏日晚。<br />伯乐翦拂中道遗，少尽其力老弃之。<br />愿逢田子方，恻然为我悲。<br />虽有玉山禾，不能疗苦饥。<br />严霜五月凋桂枝，伏枥衔冤摧两眉。<br />请君赎献穆天子，犹堪弄影舞瑶池。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常微分方程</title>
    <link href="/2022/04/01/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    <url>/2022/04/01/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>踏遍青山人未老，风景这边独好。</p><span id="more"></span><h1 id="五-常微分方程">五 常微分方程</h1><h2 id="概念">1. 概念</h2><ol type="1"><li><p>微分方程：表示未知函数、未知函数的导数以及自变量之间的关系的方程。</p><p>微分方程的阶：微分方程中出现的未知函数的最高阶导数或偏导数的阶数。</p><p>常微分方程：未知函数为一元函数的微分方程。</p><p>偏微分方程：未知函数为多元函数的微分方程。</p><p>一阶齐次微分方程：形如<spanclass="math inline">\(\frac{dy}{dx}=f(\frac yx)\)</span>的方程。</p><ul><li>齐次微分方程：方程中每一项<spanclass="math inline">\(x,y\)</span>的次数相等。</li></ul><p><span class="math inline">\(n\)</span>阶线性微分方程：<spanclass="math inline">\(y^{(n)}+p_1(x)y^{(n-1)}+……+p_n(x)y=f(x)\)</span>。</p><p><span class="math inline">\(n\)</span>阶常系数线性微分方程：<spanclass="math inline">\(y^{(n)}+p_1y^{(n-1)}+……+p_ny=f(x)\)</span>。</p><p><span class="math inline">\(n\)</span>阶齐次线性微分方程：<spanclass="math inline">\(y^{(n)}+p_1(x)y^{(n-1)}+……+p_n(x)y=0\)</span>。</p><ul><li>齐次线性微分方程：<spanclass="math inline">\(y\)</span>的每一阶导数的次数相等。</li></ul></li><li><p>微分方程的解：代入未知函数，使得微分方程恒成立的函数。</p><ul><li><p>通解：一般地，如果<spanclass="math inline">\(n\)</span>阶微分方程有解<spanclass="math inline">\(y=\varphi(x,C_1,……,C_n)\)</span>，其中<spanclass="math inline">\(C_1\sim C_n\)</span>为<spanclass="math inline">\(\varphi\)</span>中<spanclass="math inline">\(n\)</span>个独立的任意常数，则称<spanclass="math inline">\(y=\varphi(x,C_1,……,C_n)\)</span>为微分方程的通解。</p></li><li><p>隐式通解，通积分：用隐函数的形式<spanclass="math inline">\(\Phi(x,y;C_1,...,C_n)=0\)</span>给出的通解。</p></li></ul><p><span class="math inline">\(n\)</span>阶微分方程的初始条件：当<spanclass="math inline">\(x=x_0\)</span>时，<spanclass="math inline">\(y=y_0,\frac{dy}{dx}=y&#39;_0,...,\frac{d^{n-1}y}{dx^{n-1}}=y_0^{(n-1)}\)</span>。</p><ul><li>求满足初始条件的微分方程的解的问题称为初值问题。</li></ul></li></ol><h2 id="一阶微分方程">2. 一阶微分方程</h2><ol type="1"><li><p>变量分离方程：形如<spanclass="math inline">\(\frac{dy}{dx}=f(x)g(y)\)</span>的微分方程，其中<spanclass="math inline">\(f(x),g(y)\)</span>为连续函数。</p><ul><li>若<spanclass="math inline">\(g(y)\neq0\)</span>，原方程的隐式通解为<spanclass="math inline">\(\int\frac{dy}{g(y)}=\int f(x)dx+C\)</span>。</li><li>若存在<span class="math inline">\(g(y_0)=0\)</span>，则<spanclass="math inline">\(y_0\)</span>为方程的奇解，需要额外补充。</li></ul><p>可化为变量分离方程的微分方程：</p><ul><li><spanclass="math inline">\(\frac{dy}{dx}=f(ax+by+c)\)</span>，令<spanclass="math inline">\(u=ax+by+c\)</span>，代入得<spanclass="math inline">\(\frac{du}{dx}=a+bf(u)\)</span>。</li><li><span class="math inline">\(\frac{dy}{dx}=\varphi(\fracyx)\)</span>，令<span class="math inline">\(u=\fracyx\)</span>，代入得<spanclass="math inline">\(\frac{du}{dx}=\frac{\varphi(u)-u}x\)</span>。</li><li><spanclass="math inline">\(\frac{dy}{dx}=f(\frac{a_1x+b_1y+c_1}{a_2x+b_2y+c_2})\)</span>，其中<spanclass="math inline">\(a_1b_2-a_2b_1\neq0\)</span>，令<spanclass="math inline">\(u=a_1x+b_1y+c_1,v=a_2x+b_2y+c_2\)</span></li></ul></li><li><p>一阶线性微分方程：形如<spanclass="math inline">\(\frac{dy}{dx}+P(x)y=Q(x)\)</span>的方程。</p><ul><li>当<spanclass="math inline">\(Q(x)\equiv0\)</span>，称为一阶齐次线性微分方程，变量分离得通解为<spanclass="math inline">\(y=Ce^{-\int P(x)dx}\)</span></li></ul><p>一阶齐次线性微分方程的求解：</p><ul><li>两边乘以<span class="math inline">\(e^{\intP(x)dx}\)</span>，推导得<span class="math inline">\(y=e^{-\intP(x)dx}(C+\int(Q(x)e^{\int P(x)dx})dx)\)</span>。</li></ul><p>伯努利方程：<spanclass="math inline">\(\frac{dy}{dx}+P(x)y=Q(x)y^a\)</span>，其中<spanclass="math inline">\(P(x),Q(x)\)</span>为连续函数，<spanclass="math inline">\(a\neq0,1\)</span>。</p><ul><li>当<span class="math inline">\(y\neq0\)</span>，取<spanclass="math inline">\(u=y^{1-a}\)</span>，原式化为一阶线性微分方程<spanclass="math inline">\(\frac{du}{dx}+(1-a)P(x)u=(1-a)Q(x)\)</span>。</li><li>当<span class="math inline">\(a\gt0\)</span>，<spanclass="math inline">\(y=0\)</span>也满足方程，需补充。</li></ul></li><li><p>全微分方程：</p><p>若存在可微函数<spanclass="math inline">\(\lambda(x,y)\)</span>，使得<spanclass="math inline">\(d\lambda(x,y)=P(x,y)dx+Q(x,y)dy\)</span>，则<spanclass="math inline">\(P(x,y)dx+Q(x,y)dy\)</span>称为恰当微分，称<spanclass="math inline">\(P(x,y)dx+Q(x,y)dy=0\)</span>为全微分方程（也称恰当方程）。</p><ul><li>显然，<spanclass="math inline">\(\lambda(x,y)=C\)</span>即全微分方程的隐式通解。</li></ul><p>积分因子：若微分方程同时在两边乘一个可微函数后转化为全微分方程，该可微函数称为积分因子。</p><ul><li>对方程<span class="math inline">\(P(x,y)dx+Q(x,y)dy=0\)</span>，若<ul><li><span class="math inline">\(\frac{\frac{\partial Q}{\partialx}-\frac{\partial P}{\partialy}}Q=\phi(x)\)</span>，则方程具有积分因子<spanclass="math inline">\(\mu(y)=\exp(-\int\phi(x)dx)\)</span></li><li><span class="math inline">\(\frac{\frac{\partial Q}{\partialx}-\frac{\partial P}{\partialy}}Q=\varphi(y)\)</span>，则方程具有积分因子<spanclass="math inline">\(\mu(y)=\exp(\int\varphi(x)dx)\)</span></li></ul></li></ul></li></ol><h2 id="高阶微分方程">3. 高阶微分方程</h2><ol type="1"><li><p>可降阶的高阶微分方程：</p><ul><li>形如<spanclass="math inline">\(y^{(n)}=f(x)\)</span>的微分方程：设<spanclass="math inline">\(y_1=y^{(n-1)}\)</span>，<spanclass="math inline">\(\frac{dy_1}dx=f(x)\)</span>，反复积分<spanclass="math inline">\(n\)</span>次。</li><li>形如<spanclass="math inline">\(f(x,y’,y’’)=0\)</span>的微分方程：设<spanclass="math inline">\(y’=p(x),y’’=\frac{dp}{dx}\)</span>，求解后积分。</li><li>形如<spanclass="math inline">\(f(y,y’,y’’)=0\)</span>的微分方程：设<spanclass="math inline">\(y’=p\)</span>，<spanclass="math inline">\(y&#39;&#39;=\frac{dp}{dy}\frac{dy}{dx}\)</span>，解得<spanclass="math inline">\(p\)</span>，以<spanclass="math inline">\(\frac{dy}{dx}=p\)</span>进而求解。</li></ul></li><li><p><span class="math inline">\(n\)</span>阶线性微分方程：<spanclass="math inline">\(y^{(n)}+p_1(x)y^{(n-1)}+……+p_n(x)y=f(x)\)</span>。</p><ul><li>当<span class="math inline">\(f(x)\equiv0\)</span>，该方程为<spanclass="math inline">\(n\)</span>阶齐次线性微分方程。</li></ul></li><li><p>朗斯基行列式：</p><p>设<span class="math inline">\(y_1(x),y_2(x),……,y_n(x)\)</span>是<spanclass="math inline">\([a,b]\)</span>上的<spanclass="math inline">\((n-1)\)</span>阶可微函数，行列式<spanclass="math inline">\(W(x)=\left|\begin{matrix}y_1(x)&amp;y_2(x)&amp;...&amp;y_n(x)\\y_1&#39;(x)&amp;y_2&#39;(x)&amp;...&amp;y_n&#39;(x)\\...\\y_1^{n-1}(x)&amp;y_2^{n-1}(x)&amp;...&amp;y_n^{n-1}(x)\end{matrix}\right|\)</span></p><p>称为<spanclass="math inline">\(y_1(x),……,y_n(x)\)</span>的朗斯基行列式。</p><p>函数组的线性无关性：</p><p>设函数<spanclass="math inline">\(y_1(x),……,y_n(x)\)</span>为齐次线性微分方程的解，它们在区间<spanclass="math inline">\([a,b]\)</span>上有定义，若其朗斯基行列式<spanclass="math inline">\(W(x)\)</span>恒等于0，则称<spanclass="math inline">\(y_1(x),……,y_n(x)\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上线性相关，否则称它们在<spanclass="math inline">\([a,b]\)</span>上线性无关。</p><p>刘维尔公式：</p><p>设<span class="math inline">\(y_1(x),y_2(x)\)</span>是方程<spanclass="math inline">\(y’’+p(x)y’+q(x)y=0\)</span>的两个解，则它们的朗斯基行列式满足</p><p><spanclass="math inline">\(W(x)=W(x_0)\exp(-\int_{x_0}^xp(x)dx)\)</span>，其中<spanclass="math inline">\(x_0\)</span>为<spanclass="math inline">\([a,b]\)</span>上任意一点。</p></li><li><p>二阶齐次线性微分方程解的结构：</p><p><spanclass="math inline">\(y_1(x),y_2(x)\)</span>是方程的两个线性无关解，则<spanclass="math inline">\(y=C_1y_1(x)+C_2y_2(x)\)</span>是方程的通解，其中<spanclass="math inline">\(C_1,C_2\)</span>为两个独立的任意常数。</p><p><spanclass="math inline">\(n\)</span>阶齐次线性微分方程解的结构：</p><p><spanclass="math inline">\(y_1(x),y_2(x),...,y_n(x)\)</span>是方程的<spanclass="math inline">\(n\)</span>个线性无关解，则<spanclass="math inline">\(y=C_1y_1(x)+...+C_ny_n(x)\)</span>为方程的通解，其中<spanclass="math inline">\(C_1,C_2,……,C_n\)</span>是任意常数。</p></li><li><p>二阶非齐次线性微分方程解的结构：</p><ul><li><p><spanclass="math inline">\(y_1^*(x)\)</span>是非齐次线性微分方程<spanclass="math inline">\(y&#39;&#39;+p(x)y&#39;+q(x)y=f(x)\)</span>的一个特解，<spanclass="math inline">\(y_2^*(x)\)</span>是其对应的齐次线性微分方程的解，则<spanclass="math inline">\(y^*(x)=y_1^*(x)+y_2^*(x)\)</span>是非齐次线性微分方程的解。</p></li><li><p><spanclass="math inline">\(y_1^*(x),y_2^*(x)\)</span>是非齐次线性微分方程<spanclass="math inline">\(y’’+p(x)y’+q(x)y=f(x)\)</span>的两个特解，则<spanclass="math inline">\(y_1^*(x)-y_2^*(x)\)</span>是对应的齐次线性微分方程的解。</p></li><li><p>设<spanclass="math inline">\(y^*(x)\)</span>是非齐次线性微分方程的一个特解，又<spanclass="math inline">\(C_1y_1(x)+C_2y_2(x)\)</span>是对应的齐次线性微分方程的通解，则非齐次线性微分方程的通解<spanclass="math inline">\(y(x)=C_1y_1(x)+C_2y_2(x)+y^*(x)\)</span>。</p></li><li><p>设函数<spanclass="math inline">\(y_1(x),y_2(x)\)</span>分别是非齐次线性微分方程<spanclass="math inline">\(y’’+p(x)y’+q(x)y=f_1(x)\)</span>和<spanclass="math inline">\(y’’+p(x)y’+q(x)y=f_2(x)\)</span>的解，则函数<spanclass="math inline">\(y=y_1(x)+y_2(x)\)</span>是非齐次线性微分方程<spanclass="math inline">\(y’’+p(x)y’+q(x)y=f_1(x)+f_2(x)\)</span>的解。</p></li></ul></li><li><p>常数变易法：</p><p>若函数<spanclass="math inline">\(C_1(x),C_2(x)\)</span>满足方程组<spanclass="math inline">\(\begin{cases}C_1’(x)y_1(x)+C_2’(x)y_2(x)=0\\C_1’(x)y_1’(x)+C_2’(x)y_2’(x)=f(x)\end{cases}\)</span>，其中<spanclass="math inline">\(y_1(x)\)</span>和<spanclass="math inline">\(y_2(x)\)</span>为齐次线性微分方程的两个线性无关的解，则非齐次线性微分方程有特解<spanclass="math inline">\(y^*=C_1(x)y_1(x)+C_2(x)y_2(x)\)</span>。</p></li><li><p>二阶常系数齐次线性微分方程：<spanclass="math inline">\(y&#39;&#39;+py&#39;+qy=0\)</span>。</p><p><span class="math inline">\(y=e^\lambda x\)</span>为方程<spanclass="math inline">\(y’’+py’+q=0\)</span>的解的充分必要条件是<spanclass="math inline">\(\lambda\)</span>满足特征方程<spanclass="math inline">\(\lambda^2+p\lambda+q=0\)</span>。</p><ul><li><p>若特征方程有两个不等的实根<spanclass="math inline">\(\lambda_1\)</span>和<spanclass="math inline">\(\lambda_2\)</span>，则方程的通解为<spanclass="math inline">\(y=C_1e^{\lambda_1x}+C_2e^{\lambda_2x}\)</span>。</p></li><li><p>若特征方程有两个相等的实根<spanclass="math inline">\(\lambda\)</span>，则方程的通解为<spanclass="math inline">\(y=(C_1+C_2x)e^{\lambda x}\)</span>。</p></li><li><p>若特征方程有一对复根<spanclass="math inline">\(\lambda_1=a+bi,\lambda_2=a-bi\)</span>，其中<spanclass="math inline">\(b\neq0\)</span>，则方程的通解为<spanclass="math inline">\(y=e^{ax}(C_1\cos bx+C_2\sinbx)\)</span>。</p></li></ul></li><li><p>二阶常系数非齐次线性微分方程：<spanclass="math inline">\(y&#39;&#39;+py&#39;+qy=f(x)\)</span>。</p><ul><li><p>待定系数法：</p><p>设<span class="math inline">\(f(x)=(a_0x^m+a_1x^{m-1}+……+a_m)e^{\mux}\)</span>，其中<span class="math inline">\(\mu\)</span>及<spanclass="math inline">\(a_i(i=1,……,m)\)</span>为实常数，</p><p>则方程有形如<span class="math inline">\(y^*=x^k(A_0x^m+……+A_m)e^{\mux}\)</span>的特解，</p><p>其中<span class="math inline">\(k\)</span>为<spanclass="math inline">\(\mu\)</span>是特征方程<spanclass="math inline">\(F(\lambda)=\lambda^2+p\lambda+q=0\)</span>根的重数(当<spanclass="math inline">\(\mu\)</span>不是特征根时，规定<spanclass="math inline">\(k=0\)</span>)，而<spanclass="math inline">\(A_0,...,A_m\)</span>为待定常数。</p></li><li><p>更一般的，有设<span class="math inline">\(f(x)=[A_s(x)\cosbx+B_t(x)\sin bx]e^{ax}\)</span>，</p><p>其中<span class="math inline">\(a,b\)</span>为实常数，而<spanclass="math inline">\(A_s(x),B_t(x)\)</span>为<spanclass="math inline">\(x\)</span>的<spanclass="math inline">\(s\)</span>次，<spanclass="math inline">\(t\)</span>次多项式，</p><p>令<spanclass="math inline">\(m=\max\{s,t\}\)</span>，则方程有形如<spanclass="math inline">\(y^*=x^ke^{ax}[P_m(x)\cos bx+Q_m(x)\sinbx]\)</span>的特解，</p><p>其中<span class="math inline">\(k\)</span>为<spanclass="math inline">\(a+bi\)</span>是特征方程<spanclass="math inline">\(F(\lambda)=\lambda^2+p\lambda+q=0\)</span>根的重数，<spanclass="math inline">\(P_m(x),Q_m(x)\)</span>是关于<spanclass="math inline">\(x\)</span>的<spanclass="math inline">\(m\)</span>次多项式。</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>微积分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_8_信息熵</title>
    <link href="/2022/03/08/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_8%20%E4%BF%A1%E6%81%AF%E7%86%B5/"/>
    <url>/2022/03/08/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_8%20%E4%BF%A1%E6%81%AF%E7%86%B5/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_8-信息熵">DataScience_8 信息熵</h1><h2 id="信息熵">8.1 信息熵</h2><p>信息度量的三个性质：单调性、非负性、可加性</p><ol type="1"><li>单调性：确定性越高的事件的信息量越低</li><li>非负性：非负性是从随机性引入信息度量的必然</li><li>可加性：事件总不确定性可表示为各事件不确定性和</li></ol><h3 id="信息熵-1">信息熵</h3><p><span class="math inline">\(H(X)=-\Sigma_{x\in\mathcalX}p(x)logp(x)\)</span></p><ul><li>非负性</li><li>期望性：<spanclass="math inline">\(H(X)=E(log(1/p(X)))\)</span></li><li>对数底可换：<spanclass="math inline">\(H_b(X)=log_baH_a(X)\)</span></li></ul><h3 id="联合熵">联合熵</h3><p>两个离散随机变量<spanclass="math inline">\(X,Y\)</span>，其联合熵<spanclass="math inline">\(H(X,Y)=-\Sigma_x\Sigma_yp(x,y)log[p(x,y)]\)</span></p><ul><li>联合熵不小于每个独立的熵。</li><li>联合熵不大于每个独立熵的和。</li></ul><h3 id="条件熵">条件熵</h3><p>在已知随机变量<spanclass="math inline">\(X\)</span>的条件下，描述随机变量<spanclass="math inline">\(Y\)</span>所需的信息量。</p><p><spanclass="math inline">\(H(Y|X)=\Sigma_xp(x)H(Y|X=x)=-\Sigma_{x,y}p(x,y)logp(y|x)\)</span>。</p><ul><li>当Y的值完全取决于X的值，条件熵为0。</li><li>独立的随机变量的条件熵等于自身的熵。<spanclass="math inline">\(H(Y|X)=H(X)\)</span>。</li><li>链式法则：<spanclass="math inline">\(H(X,Y)=H(X)+H(Y|X)\)</span>。</li><li>贝叶斯公式：<spanclass="math inline">\(H(Y|X)=H(X|Y)-H(X)+H(Y)\)</span>。</li></ul><h3 id="相对熵">相对熵</h3><p>又称KL散度，两个概率分布P和Q差别的非对称性的度量。P为真实分布，Q为假设分布。</p><p><span class="math inline">\(D_{KL}(P||Q)=-\SigmaP(x)log\frac{Q(x)}{P(x)}\)</span></p><ul><li>非负性：<spanclass="math inline">\(D_{KL}(P||Q)\ge0,D_{KL}(P||Q)=0\)</span>当且仅当<spanclass="math inline">\(P=Q\)</span></li><li>不对称性：<span class="math inline">\(D_{KL}(P||Q)\neD_{KL}(Q||P)\)</span></li></ul><h3 id="交叉熵">交叉熵</h3><p>基于相同事件测度的两个概率分布<spanclass="math inline">\(p\)</span>和<spanclass="math inline">\(q\)</span>的交叉熵是指当基于一个非真实的概率分布<spanclass="math inline">\(q\)</span>进行编码时，在事件集合中唯一标识一个事件所需要的信息量。</p><p><span class="math inline">\(H(p,q)=-\Sigma p(x)logq(x)\)</span></p><ul><li>交叉熵和相对熵：<spanclass="math inline">\(H(p,q)=H(p)+D_{KL}(P||Q)\)</span></li></ul><h2 id="信息变化">8.2 信息变化</h2><h3 id="互信息">互信息</h3><p>两个随机变量的互信息是变量间相互依赖性的量度。</p><p><span class="math inline">\(I(X;Y)=\Sigma_{y\in Y}\Sigma_{x\inX}p(x,y)log(\frac{p(x,y)}{p(x)p(y)})\)</span></p><p>其中<span class="math inline">\(p(x,y)\)</span>是<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>的联合概率分布函数，而<spanclass="math inline">\(p(x),p(y)\)</span>分别是<spanclass="math inline">\(X,Y\)</span>的边缘概率分布函数。</p><h3 id="信息增益">信息增益</h3><p>即相对熵。</p><p>对于离散型随机变量：<span class="math inline">\(Gain(P,Q)=-\SigmaP(x)ln\frac{Q(x)}{P(x)}\)</span></p><p>对于连续型随机变量：<spanclass="math inline">\(Gain(P,Q)=\int_{-\infin}^{\infin}p(x)ln\frac{p(x)}{q(x)}dx\)</span></p><h4 id="信息增益率">信息增益率</h4><p>属性的信息增益和该属性熵的比值：对于数据集合<spanclass="math inline">\(T\)</span>中的属性<spanclass="math inline">\(P\)</span>，</p><p><spanclass="math inline">\(GainRatio(T,P)=\frac{Gain(T,P)}{Entropy(T,P)}\)</span>。</p><p>当<span class="math inline">\(Entropy(T,P)=0\)</span>，<spanclass="math inline">\(P\)</span>的信息增益率无意义。</p><ul><li>属性值为连续数值型，可以用信息增益率来代替信息增益。</li></ul><h3 id="基尼系数">基尼系数</h3><p><spanclass="math inline">\(Gini(D)=1-\Sigma_{i=1}^mp_i^2\)</span></p><p>其中m表示数据集D中类别C的个数，<spanclass="math inline">\(p_i\)</span>表示<spanclass="math inline">\(D\)</span>中一个记录属于<spanclass="math inline">\(C\)</span>的概率。</p><h2 id="最大熵">8.3 最大熵</h2><h3 id="最大熵原理">最大熵原理</h3><p>一个正确的概率分布应该满足下述条件：</p><ol type="1"><li>服从样本数据中的已知的统计证据</li><li>使熵最大化</li></ol><h3 id="最大熵模型">最大熵模型</h3><p>设满足所有约束条件的模型集合为<spanclass="math inline">\(E_{\overlineP}(f_i)=EP(f_i),i=1,2,...,M\)</span></p><p>定义在条件概率分布<spanclass="math inline">\(P(Y|X)\)</span>上的条件熵为<spanclass="math inline">\(H(P)=-\Sigma_{x,y}\overlineP(x)P(y|x)logP(y|x)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_7_线性模型</title>
    <link href="/2022/03/07/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_7%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/03/07/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_7%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_7-线性模型">DataScience_7 线性模型</h1><h2 id="回归分析">7.1 回归分析</h2><p>回归分析的主要内容和步骤：</p><ol type="1"><li>将变量分为自变量和因变量</li><li>找出回归模型描述变量间关系</li><li>对回归模型进行统计检验</li><li>通过检验后，使用回归模型，根据自变量预测因变量</li></ol><p>只有一个自变量的称为一元回归，两个及以上自变量的称为多元回归。</p><p>按照回归曲线的形态，回归也可分为线性和非线性回归。</p><h3 id="一元线性回归">7.1.1 一元线性回归</h3><p>若散点呈直线趋势，则认为<spanclass="math inline">\(x,y\)</span>的关系可以用一元线性回归模型描述，将数据描述成下述方程：</p><p><span class="math inline">\(y=a+bx+e\)</span>。</p><p>称上式为总体一元线性回归方程。<spanclass="math inline">\(a+bx\)</span>表示<spanclass="math inline">\(y\)</span>随<spanclass="math inline">\(x\)</span>的变化而线性变化的部分，<spanclass="math inline">\(e\)</span>是一切随机因素影响的总和，称为随机误差。对于<spanclass="math inline">\(x\)</span>某一确定的值，对应<spanclass="math inline">\(y\)</span>值虽然有波动，但<spanclass="math inline">\(e\)</span>的期望值为0。</p><ul><li>通常假设<span class="math inline">\(e\simN(0,\sigma^2)\)</span>。</li></ul><h4 id="最小二乘估计">最小二乘估计</h4><p>计算参数<span class="math inline">\(a,b\)</span>，使得<spanclass="math inline">\(Q(a,b)=\Sigma_{i=1}^ne_i^2=\Sigma_{i=1}^n(y_i-a-bx_i)^2\)</span>最小。</p><h4 id="回归显著性检验">回归显著性检验</h4><p>检验<span class="math inline">\(y\)</span>和<spanclass="math inline">\(x\)</span>是否存在线性关系。</p><p>分解偏差平方和并进行比较。</p><ul><li><p>总偏差平方和：<spanclass="math inline">\(S_T=\Sigma_{i=1}^n(y_i-\overliney)^2\)</span></p></li><li><p>回归偏差平方和：<spanclass="math inline">\(S_R=\Sigma_{i=1}^n(\hat{y_i}-\overliney)^2\)</span></p></li><li><p>随机误差：<spanclass="math inline">\(S_e=\Sigma_{i=1}^n(\hat{y_i}-y_i)^2\)</span></p></li><li><p><span class="math inline">\(S_T=S_R+S_e\)</span></p></li></ul><p><span class="math inline">\(S_R\)</span>应该尽量大，<spanclass="math inline">\(S_e\)</span>应该尽量小。</p><p>且有<span class="math inline">\(\frac{S_e}{\sigma^2}\sim\mathcalX^2(n-2)\)</span>，<spanclass="math inline">\(\frac{S_R}{\sigma^2}\sim\mathcalX^2(1)\)</span>。</p><p>构造统计量<span class="math inline">\(F=\frac{S_R}{\frac{S_e}{(n-2)}}\sim F(1,n-2)\)</span>，给定显著性水平<spanclass="math inline">\(\alpha\)</span>，当<spanclass="math inline">\(F\geF_\alpha(1,n-2)\)</span>，认为样本数据具有显著的相关性。</p><h3 id="广义线性回归">7.1.2 广义线性回归</h3><p>转化为线性化问题。</p><ol type="1"><li>双曲线：<span class="math inline">\(\frac1y=a+\fracbx,y&#39;=\frac1y,x&#39;=\frac bx,y&#39;=a+x&#39;\)</span></li><li>指数：<spanclass="math inline">\(y=ae^{bx},y&#39;=lny,a&#39;=lna,y&#39;=a&#39;+bx\)</span></li><li>对数：<spanclass="math inline">\(y=a+blnx,x&#39;=lnx,y=a+bx&#39;\)</span></li><li>幂函数：<spanclass="math inline">\(y=ax^b,y&#39;=lny,x&#39;=lnx,a&#39;=lna,y&#39;=a&#39;+bx&#39;\)</span></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_6_高维数据</title>
    <link href="/2022/03/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_6%20%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/03/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_6%20%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_6-高维数据">DataScience_6 高维数据</h1><h2 id="数据几何学">6.1 数据几何学</h2><h3 id="线性空间">6.1.1 线性空间</h3><h4 id="线性空间-1">线性空间</h4><p>非空集合V称为数域的一个线性空间，当V满足数域上下述八条运算法则：</p><ol type="1"><li><span class="math inline">\(\forall \mathbf u,\mathbf v,\mathbfw\in\mathbf V:(\mathbf u+\mathbf v)+\mathbf w=\mathbf u+(\mathbfv+\mathbf w)\)</span></li><li><span class="math inline">\(\forall \mathbf u,\mathbf v\in\mathbfV:\mathbf u+\mathbf v=\mathbf v+\mathbf u\)</span></li><li>存在元素<span class="math inline">\(\mathbf 0\)</span>：<spanclass="math inline">\(\forall \mathbf u \in\mathbf V:\mathbf u+\mathbf0=\mathbf u\)</span></li><li>对任意的<span class="math inline">\(\mathbfu\)</span>存在负元素<span class="math inline">\(-\mathbfu\)</span>，使得<span class="math inline">\(\mathbf u+(-\mathbfu)=0\)</span></li><li>对于数域中的<span class="math inline">\(1\)</span>，有<spanclass="math inline">\(1\mathbf u=\mathbf u\)</span></li><li><span class="math inline">\(\forall k,l\in \mathbb R,\forall \mathbfu\in\mathbf V,(kl)\mathbf u=k(l\mathbf u)\)</span></li><li><span class="math inline">\(\forall k,l\in \mathbb R,\forall \mathbfu\in\mathbf V,(k+l)\mathbf u=k\mathbf u+l\mathbf u\)</span></li><li><span class="math inline">\(\forall k\in \mathbb R,\forall \mathbfu,\mathbf v\in\mathbf V,k(\mathbf u+\mathbf v)=k\mathbf u+k\mathbfv\)</span></li></ol><h4 id="线性表示">线性表示</h4><p>对于<span class="math inline">\(\mathbf V\)</span>中的一组向量<spanclass="math inline">\(\mathbf u_1,...,\mathbf u_n\)</span>，对于<spanclass="math inline">\(\mathbf v\)</span>，如果存在<spanclass="math inline">\(k_1,...,k_n\)</span>使得<spanclass="math inline">\(\mathbf v=k_1\mathbf u_1+...+k_n\mathbfu_n\)</span>，则称<span class="math inline">\(\mathbfv\)</span>可以被向量组<span class="math inline">\(\mathbfu_1,...,\mathbf u_n\)</span>线性表示。</p><ul><li>如果<span class="math inline">\(\mathbf v\)</span>可以被向量组<spanclass="math inline">\(\mathbf u_1,...,\mathbfu_n\)</span>线性表示，那么系数<spanclass="math inline">\(k_1,...,k_n\)</span>唯一。</li></ul><h4 id="基">基</h4><p>若存在<span class="math inline">\(n\)</span>个线性无关的向量<spanclass="math inline">\(\mathbf u_1,...,\mathbfu_n\)</span>，使得线性空间<span class="math inline">\(\mathbfV\)</span>中任一向量都能被其线性表示，则称<spanclass="math inline">\(\mathbf u_1,...,\mathbf u_n\)</span>为<spanclass="math inline">\(\mathbf V\)</span>的一组基，<spanclass="math inline">\(\mathbf V\)</span>为<spanclass="math inline">\(n\)</span>维线性空间。</p><h4 id="线性映射与线性变换">线性映射与线性变换</h4><p><span class="math inline">\(f\)</span>是线性空间<spanclass="math inline">\(U\)</span>到<spanclass="math inline">\(V\)</span>的映射，若它是线性映射，则满足：</p><ol type="1"><li><span class="math inline">\(\forall \mathbf u,\mathbf u&#39;\inU,f(\mathbf u+\mathbf u&#39;)=f(\mathbf u)+f(\mathbfu&#39;)\)</span></li><li><span class="math inline">\(\forall k\in\mathbb R,\forall \mathbfu\in U,f(k\mathbf u)=kf(\mathbf u)\)</span></li></ol><p>线性变换是线性空间到自身空间的线性映射。</p><ul><li><span class="math inline">\(\mathbf u_1,...,\mathbfu_n\)</span>为<span class="math inline">\(\mathbfV\)</span>的一组基，<spanclass="math inline">\(v_1,...,v_n\)</span>是<spanclass="math inline">\(\mathbf V\)</span>任意<spanclass="math inline">\(n\)</span>个变量，存在唯一的线性变换矩阵<spanclass="math inline">\(A\)</span>使得<spanclass="math inline">\(A[\mathbf u_1,...,\mathbf u_n]^T=[\mathbfv_1,...,\mathbf v_n]^T\)</span>。</li></ul><h4 id="特征值与特征向量">特征值与特征向量</h4><p>看线代去罢。</p><h3 id="维度灾难">6.1.2 维度灾难</h3><p>当空间维度增加时，分析和组织高维空间时，因体积指数增加而遇到各种问题的场景。</p><ul><li>特征维度增加，更易找到分类的超平面</li><li>给定训练样本，维度增加容易带来过拟合</li><li>维度增加，需要的样本数量呈指数增长。</li></ul><h4 id="j-l引理">J-L引理</h4><p>对给定的<spanclass="math inline">\(\varepsilon\in(0,1)\)</span>以及N维欧氏空间中的<spanclass="math inline">\(m\)</span>个点<spanclass="math inline">\(\{x_1,……,x_m\}\)</span>，对于任意满足条件的<spanclass="math inline">\(n&gt;\frac{logm}{\frac{\varepsilon^2}2-\frac{\varepsilon^3}3}\)</span>的正整数<spanclass="math inline">\(n\)</span>，存在一个线性映射<spanclass="math inline">\(f:R^N\rightarrow R^n\)</span>，将这<spanclass="math inline">\(m\)</span>个点，从高维空间<spanclass="math inline">\(R^N\)</span>中映射到低维空间<spanclass="math inline">\(R^n\)</span>中，同时基本上保持了点集成员两两之间的距离，即对于任意两个点<spanclass="math inline">\(x_i,x_j：1\le i\lt j\le m\)</span>，都有<spanclass="math inline">\((1-𝜀)|x_i-x_j|^2\le|f(x_i)-f(x_j)|^2\le(1+𝜀)|x_i-x_j|^2\)</span>。更进一步的，这个线性映射<spanclass="math inline">\(f\)</span>还可以在随机多项式时间内求出。</p><ul><li>直观含义：一个高维空间中的点集，可以被线性嵌入地位空间，同时其空间结构只遭受较小形变，所用算法只需要随机多项式时间。</li></ul><h2 id="数据降维">6.2 数据降维</h2><h3 id="常用降维方法">6.2.1 常用降维方法</h3><p>线性判别分析（LDA）、判别分析（DA）、局部线性嵌入（LLE）</p><h3 id="主成分分析">6.2.2 主成分分析</h3><p>原始数据：<span class="math inline">\(m\)</span>条<spanclass="math inline">\(n\)</span>维数据，组成<spanclass="math inline">\(n\times m\)</span>矩阵<spanclass="math inline">\(X\)</span>。</p><p>计算步骤</p><ol type="1"><li>对<spanclass="math inline">\(X\)</span>的每一行进行0均值化，即减去该行的均值。</li><li>求出<span class="math inline">\(X\)</span>的协方差矩阵<spanclass="math inline">\(C=\frac1mXX^T\)</span>，该矩阵为<spanclass="math inline">\(n\times n\)</span>的。</li><li>计算<span class="math inline">\(C\)</span>的特征值和特征向量<spanclass="math inline">\(C\beta_i=\lambda_i\beta_i,i=1,...,n,\lambda_1\ge...\ge\lambda_n\)</span>。</li><li>特征向量单位化：<spanclass="math inline">\(p_i=\frac{\beta_i}{|\beta_i|},i=1,...,n\)</span>，<spanclass="math inline">\(P^T=(p_1,...p_n)\)</span>。</li><li>取前<spanclass="math inline">\(k\)</span>大的特征值及其对应的单位特征向量，<spanclass="math inline">\(Q^T=(p_1,...,p_k)\)</span>。</li><li>降维：<span class="math inline">\(Y=QX\)</span>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_5_多维分布</title>
    <link href="/2022/03/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_5%20%E5%A4%9A%E7%BB%B4%E5%88%86%E5%B8%83/"/>
    <url>/2022/03/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_5%20%E5%A4%9A%E7%BB%B4%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_5-多维分布">DataScience_5 多维分布</h1><h2 id="多维概率分布">5.1 多维概率分布</h2><h3 id="二维随机变量联合分布">5.1.1 二维随机变量联合分布</h3><h4 id="二维随机变量">二维随机变量</h4><p>设样本空间<span class="math inline">\(\Omega=e,X=X(e)\)</span>和<spanclass="math inline">\(Y=Y(e)\)</span>是定义在<spanclass="math inline">\(\Omega\)</span>上的随机变量，它们构成的一个变量<spanclass="math inline">\((X,Y)\)</span>称为二维随机变量或二维随机向量。</p><h4 id="联合分布">联合分布</h4><p>设<span class="math inline">\((X,Y)\)</span>为二维随机变量，<spanclass="math inline">\(x,y\)</span>是任意实数，称二元函数<spanclass="math inline">\(F(x,y)=P(X\le x\cap Y\le y)=P(X\le x,Y\ley)\)</span>为二维随机变量<spanclass="math inline">\((X,Y)\)</span>的联合分布函数。</p><h4 id="概率分布律">概率分布律</h4><p>设二维离散随机变量<spanclass="math inline">\((X,Y)\)</span>所有可能取值为<spanclass="math inline">\((x_i,y_j)(i,j=1,2,...)\)</span>，则称<spanclass="math inline">\(P(X=x_i,Y=y_j)=p_{ij}\)</span>为设二维离散随机变量<spanclass="math inline">\((X,Y)\)</span>的概率分布律，简称分布律。</p><h4 id="概率密度函数">概率密度函数</h4><p>设二维随机变量<spanclass="math inline">\((X,Y)\)</span>的分布函数为<spanclass="math inline">\(F(x,y)\)</span>，如果存在非负函数<spanclass="math inline">\(f(x,y)\)</span>，使得对于<spanclass="math inline">\(\forall x,y\in \mathbb R\)</span>，都有<spanclass="math inline">\(F(x,y)=\int_{-\infin}^x\int_{-\infin}^yf(s,t)dsdt\)</span>。则称<spanclass="math inline">\((X,Y)\)</span>为二维连续随机变量，并称非负函数<spanclass="math inline">\(f(x,y)\)</span>为<spanclass="math inline">\((X,Y)\)</span>的概率密度函数，或称<spanclass="math inline">\(f(x,y)\)</span>为<spanclass="math inline">\(X,Y\)</span>的联合概率密度。</p><h3 id="二维随机变量边缘分布">5.1.2 二维随机变量边缘分布</h3><h4 id="边缘分布">边缘分布</h4><p>设<spanclass="math inline">\((X,Y)\)</span>为二维随机变量，称一维随机变量<spanclass="math inline">\(X,Y\)</span>的概率分布为二维随机变量<spanclass="math inline">\((X,Y)\)</span>关于<spanclass="math inline">\(X,Y\)</span>对应的边缘分布，分别记作<spanclass="math inline">\(F_X(x),F_Y(y)\)</span>。</p><h4 id="边缘分布律">边缘分布律</h4><p>设二维随机变量<spanclass="math inline">\((X,Y)\)</span>的分布律为<spanclass="math inline">\(p_{ij}\)</span>，那么对于随机变量<spanclass="math inline">\(X,Y\)</span>，其各自的分布律对于固定的<spanclass="math inline">\(i,j=1,2,...\)</span>满足<spanclass="math inline">\(P(X=x_i)=\Sigma_jp_{ij}=p_{i·}\)</span>，则称<spanclass="math inline">\(p+{i·}\)</span>为随机变量<spanclass="math inline">\((X,Y)\)</span>的边缘分布律。</p><h4 id="边缘密度">边缘密度</h4><p>设二维随机变量<spanclass="math inline">\((X,Y)\)</span>的概率密度为<spanclass="math inline">\(f(x,y)\)</span>，边缘概率密度<spanclass="math inline">\(f_X(x),f_Y(y)\)</span>定义为：</p><p><spanclass="math inline">\(f_X(x)=\int_{-\infin}^{+\infin}f(x,y)dy,f_Y(y)=\int_{-\infin}^{+\infin}f(x,y)dx\)</span>。</p><h3 id="条件分布">5.1.3 条件分布</h3><h4 id="条件概率">条件概率</h4><p>离散：</p><p>设<spanclass="math inline">\((X,Y)\)</span>为二维离散型随机变量，其分布律为<spanclass="math inline">\(p_{ij}\)</span>，其边缘概率分别为<spanclass="math inline">\(p_{i·},p_{·j}\)</span>，则其条件概率为：</p><p><spanclass="math inline">\(P(X=x_i|Y=y_j)=\frac{P(X=x_i,Y=y_j)}{P(Y=y_j)}=\frac{p_{ij}}{p_{·j}}\)</span>，</p><p><spanclass="math inline">\(P(Y=y_j|X=x_i)=\frac{P(X=x_i,Y=y_j)}{P(X=x_i)}=\frac{p_{ij}}{p_{i·}}\)</span>。</p><p>连续：</p><p>设<spanclass="math inline">\((X,Y)\)</span>为二维连续型随机变量，其概率密度为<spanclass="math inline">\(f(x,y)\)</span>，其边缘概率分别为<spanclass="math inline">\(f_X(x),f_Y(y)\)</span>。则条件概率密度定义为：<spanclass="math inline">\(f_{X|Y}(x|y)=\frac{f(x,y)}{f_Y(y)},f_{Y|X}(y|x)=\frac{f(x,y)}{f_X(x)}\)</span>。</p><h4 id="独立性">独立性</h4><p>离散：</p><p>设<spanclass="math inline">\((X,Y)\)</span>为二维离散型随机变量，其分布律为<spanclass="math inline">\(p_{ij}\)</span>，其边缘概率分别为<spanclass="math inline">\(p_{i·},p_{·j}\)</span>，且对任意<spanclass="math inline">\(i,j\)</span>有<spanclass="math inline">\(p_{ij}=p_{i·}p_{·j}\)</span>，则称随机变量<spanclass="math inline">\(X,Y\)</span>相互独立。</p><p>连续：</p><p>设<spanclass="math inline">\((X,Y)\)</span>为二维连续型随机变量，其概率密度为<spanclass="math inline">\(f(x,y)\)</span>，其边缘概率分别为<spanclass="math inline">\(f_X(x),f_Y(y)\)</span>，且对任意<spanclass="math inline">\(x,y\)</span>有<spanclass="math inline">\(f(x,y)=f_X(x)f_Y(y)\)</span>，则称随机变量<spanclass="math inline">\(X,Y\)</span>相互独立。</p><h3 id="多维分布的矩">5.1.4 多维分布的矩</h3><p>回顾：随机变量<spanclass="math inline">\(X,Y\)</span>相互独立，则<spanclass="math inline">\(E(XY)=E(X)E(Y),D(X+Y)=D(X)+D(Y)\)</span>。</p><h4 id="混合矩">混合矩</h4><p>设一批数据为<spanclass="math inline">\((X_1,Y_1),...,(X_n,Y_n)\)</span>, 则其<spanclass="math inline">\(k+l\)</span>的混合矩为<spanclass="math inline">\(\frac{\Sigma_{i=1}^nX_i^kY_j^l}{n}\)</span></p><p><spanclass="math inline">\(X,Y\)</span>为随机变量，则其混合矩为：<spanclass="math inline">\(E(X^kY^l)\)</span></p><h4 id="混合中心距">混合中心距</h4><p>设一批数据为<spanclass="math inline">\((X_1,Y_1),...,(X_n,Y_n)\)</span>, 则其<spanclass="math inline">\(k+l\)</span>的混合中心矩为<spanclass="math inline">\(\frac{\Sigma_{i=1}^n(X_i-\overlineX)^k(Y_j-\overline Y)^l}{n}\)</span></p><p><spanclass="math inline">\(X,Y\)</span>为随机变量，则其混合矩为：<spanclass="math inline">\(E((X-EX)^k(Y-EY)^l)\)</span></p><h4 id="协方差">协方差</h4><p>随机变量<span class="math inline">\(X,Y\)</span>的协方差<spanclass="math inline">\(Cov(X,Y)=E((X-EX)(Y-EY))=E(XY)-E(X)E(Y)\)</span>。</p><ul><li><spanclass="math inline">\(Cov(X+Y,Z)=Cov(X,Z)+Cov(Y,Z)\)</span></li><li><span class="math inline">\(D(X+Y)=D(X)+D(Y)+2Cov(X,Y)\)</span></li><li><span class="math inline">\(D(X-Y)=D(X)+D(Y)-2Cov(X,Y)\)</span></li></ul><p>显然，当随机变量<spanclass="math inline">\(X,Y\)</span>相互独立，<spanclass="math inline">\(Cov(X,Y)=0\)</span>。</p><p>协方差的数值会受到<spanclass="math inline">\(X,Y\)</span>的单位的影响<spanclass="math inline">\(\rightarrow\)</span>相关系数。</p><h4 id="相关系数">相关系数</h4><p>设随机变量<spanclass="math inline">\(X,Y\)</span>的数学期望和方差都存在，称<spanclass="math inline">\(\rho_{XY}=\frac{Cov(X,Y)}{\sqrt{D(X)D(Y)}}\)</span>为随机变量<spanclass="math inline">\(X,Y\)</span>的相关系数，也记作<spanclass="math inline">\(corr(X,Y)\)</span>。</p><ul><li><p>Schwarz不等式：<spanclass="math inline">\(Cov(X,Y)^2\le\sigma_X^2\sigma_Y^2\)</span></p></li><li><p>归一性：<spanclass="math inline">\(|\rho_{XY}|\le1\)</span></p></li><li><p>线性相关定理：<spanclass="math inline">\(|\rho_{XY}|=1\)</span>的充要条件是<spanclass="math inline">\(X,Y\)</span>几乎处处线性相关。</p><ul><li>即存在常数<span class="math inline">\(a\ne0,b\)</span>，使得<spanclass="math inline">\(Y=aX+b\)</span>几乎处处成立。</li></ul></li></ul><h3 id="常用二维分布">5.1.5 常用二维分布</h3><h4 id="二维均匀分布">二维均匀分布</h4><p>设G为平面上的有界区域，面积为<spanclass="math inline">\(A\)</span>，若二维随机变量<spanclass="math inline">\((X,Y)\)</span>具有概率密度<spanclass="math inline">\(f(x,y)=\frac1A,(x,y)\in G\)</span>，其他<spanclass="math inline">\(f(x,y)=0\)</span>，称<spanclass="math inline">\((X,Y)\)</span>在G上二维均匀分布。</p><h4 id="二维正态分布">二维正态分布</h4><p>服从参数为<spanclass="math inline">\(\mu_1,\mu_2,\sigma_1,\sigma_2,\rho\)</span>的二维正态分布的随机变量<spanclass="math inline">\(X,Y\)</span>的概率密度为：</p><p><spanclass="math inline">\(f(x,y)=\frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}e^{-\frac1{2(1-\rho^2)}(\frac{(x-\mu_1)^2}{\sigma_1^2}-2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}+\frac{(y-\mu_2)^2}{\sigma_2^2})},-\infin&lt;x,y&lt;+\infin\)</span>。</p><p>显然，边缘密度函数为<spanclass="math inline">\(f_X(x)=\frac1{\sqrt{2\pi\sigma_1}}e^{-\frac{(x-\mu_1)^2}{2\sigma_1^2}},f_Y(y)=\frac1{\sqrt{2\pi\sigma_2}}e^{-\frac{(y-\mu_2)^2}{2\sigma_2^2}}\)</span>，</p><p>即<span class="math inline">\(X\sim N(\mu_1,\sigma_1^2),Y\simN(\mu_2,\sigma_2^2)\)</span>且与<spanclass="math inline">\(\rho\)</span>无关。</p><h2 id="函数的概率分布">5.2 函数的概率分布</h2><p>基本解法：随机变量<span class="math inline">\(Y\)</span></p><ul><li><span class="math inline">\(Y\)</span>离散，写出<spanclass="math inline">\(Y\)</span>的可能取值，找出<spanclass="math inline">\(Y=y_i\)</span>的等价事件<spanclass="math inline">\(X\in D\)</span>，<spanclass="math inline">\(P(Y=y_i)=P(X\in D)\)</span>。</li><li><span class="math inline">\(Y\)</span>连续，写出<spanclass="math inline">\(Y\)</span>的分布函数<spanclass="math inline">\(F_Y(y)=P_Y(Y\le y)\)</span>，找出<spanclass="math inline">\(Y\le y\)</span>的等价事件<spanclass="math inline">\(X\in D\)</span>，求得<spanclass="math inline">\(F_Y(y)=P(X\in D)\)</span>，再求概率密度函数<spanclass="math inline">\(f_Y(y)\)</span>。</li></ul><p>定理：</p><p><span class="math inline">\(X\)</span>的密度函数为<spanclass="math inline">\(f_X(x)\)</span>，<spanclass="math inline">\(-\infin\lt x\lt\infin\)</span>，<spanclass="math inline">\(Y=g(X)\)</span>，<spanclass="math inline">\(g(x)\)</span>严格单调，则<spanclass="math inline">\(Y\)</span>的概率密度为<spanclass="math inline">\(f_Y(y)=f_x(h(y))|h&#39;(y)|,a\lt t\ltb\)</span>。</p><p>其中<spanclass="math inline">\(a=min(g(-\infin),g(\infin)),b=max(g(-\infin),g(\infin))\)</span>，<spanclass="math inline">\(h(x)\)</span>为<spanclass="math inline">\(g(x)\)</span>的反函数。</p><p>定理：</p><p><span class="math inline">\(Y=g(X)\)</span>为随机变量<spanclass="math inline">\(X\)</span>的函数，<spanclass="math inline">\(g\)</span>为连续函数，则</p><ol type="1"><li><span class="math inline">\(X\)</span>离散，分布律为<spanclass="math inline">\(p_k,k=1,2,...\)</span>，如果级数<spanclass="math inline">\(\Sigma_{k=1}^\infing(x_k)p_k\)</span>绝对收敛，则<spanclass="math inline">\(E(Y)=E(g(X))=\Sigma_{k=1}^\infing(x_k)p_k\)</span>。</li><li><span class="math inline">\(X\)</span>连续，密度函数<spanclass="math inline">\(f(x)\)</span>，<spanclass="math inline">\(\int_{-\infin}^{+\infin}g(x)f(x)dx\)</span>绝对收敛，则<spanclass="math inline">\(E(Y)=E(g(X))=\int_{-\infin}^{+\infin}g(x)f(x)dx\)</span>。</li></ol><h2 id="相关性分析和独立性检验">5.3 相关性分析和独立性检验</h2><h3 id="pearson相关系数">5.3.1 Pearson相关系数</h3><p>两个样本<span class="math inline">\(X,Y\)</span>的Pearsonr相关系数通常使用<spanclass="math inline">\(X,Y\)</span>的相关系数除以两者的标准差来计算。</p><p>Pearson r的性质：</p><ol type="1"><li><p><span class="math inline">\(r\in[-1,1]\)</span>，当<spanclass="math inline">\(r\gt0\)</span>，<spanclass="math inline">\(Y\)</span>与<spanclass="math inline">\(X\)</span>正相关，<spanclass="math inline">\(r\)</span>越大表示线性关系越强；</p><p><span class="math inline">\(r=1\)</span>，<spanclass="math inline">\(X,Y\)</span>存在严格线性相关关系；</p><p><span class="math inline">\(r&lt;0\)</span>，<spanclass="math inline">\(Y\)</span>与<spanclass="math inline">\(X\)</span>负相关，<spanclass="math inline">\(r\)</span>越小，线性关系越强；</p><p><span class="math inline">\(r=-1\)</span>，<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>存在严格线性相关关系。</p></li><li><p><span class="math inline">\(r\)</span>具有对称性，<spanclass="math inline">\(r_{XY}=r_{YX}\)</span>。</p></li><li><p><span class="math inline">\(r\)</span>与<spanclass="math inline">\(X,Y\)</span>的尺度、和原点无关，即将原有样本数据经线性变换后不改变<spanclass="math inline">\(r\)</span>值。</p></li><li><p><span class="math inline">\(r\)</span>只描述<spanclass="math inline">\(X,Y\)</span>之间的线性关系，即使存在某种完全的非线性关系也可能<spanclass="math inline">\(r=0\)</span>.</p></li><li><p><spanclass="math inline">\(r\)</span>只描述线性关系，不描述因果关系。</p></li></ol><p>Pearson r计算公式：</p><p><spanclass="math inline">\(r_{XY}=\frac{n\Sigma_iX_iY_i-\Sigma_iX_i\Sigma_iY_i}{\sqrt{n\Sigma_iX_i^2-(\Sigma_iX_i)^2}\sqrt{n\Sigma_iY_i^2-(\Sigma_iY_i)^2}}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_4_推断统计</title>
    <link href="/2022/03/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_4%20%E6%8E%A8%E6%96%AD%E7%BB%9F%E8%AE%A1/"/>
    <url>/2022/03/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_4%20%E6%8E%A8%E6%96%AD%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_4-推断统计">DataScience_4 推断统计</h1><p>参数估计与假设检验</p><h2 id="参数估计">4.1 参数估计</h2><p>参数估计是在抽样分布的基础上，从总体中抽取样本，根据样本统计量来估计和推断所关心的未知参数的方法。</p><ul><li>两种基本形式：点估计、区间估计</li></ul><p>估计量：用于估计总体参数的随机变量。</p><p>估计值：估计参数时计算出的统计量的具体值。</p><h3 id="点估计">4.1.1 点估计</h3><p>依据样本<spanclass="math inline">\(X=(X_1,...,X_n)\)</span>估计总体分布所含的未知参数<spanclass="math inline">\(\theta\)</span>或<spanclass="math inline">\(\theta\)</span>的函数<spanclass="math inline">\(h(\theta)\)</span>。</p><p>一般<span class="math inline">\(\theta\)</span>或<spanclass="math inline">\(\theta\)</span>的函数<spanclass="math inline">\(h(\theta)\)</span>是总体的某个数字特征，如数学期望、方差、相关系数等。</p><h4 id="矩估计">矩估计</h4><p>用样本原点矩的值估计总体矩。</p><p>随机变量X服从某总体分布，其中包含k个未知参数<spanclass="math inline">\(\theta_1,...,\theta_k\)</span>，<spanclass="math inline">\(\mu_l=E(X^l)\)</span>为总体的l阶矩。<spanclass="math inline">\(X_1,...,X_n\)</span>为来自X的样本，<spanclass="math inline">\(A_l\)</span>为样本的l阶矩，求解方程组<spanclass="math inline">\(A_i=\mu_i,i=1,...,k\)</span>得到估计值<spanclass="math inline">\(\theta_1,...,\theta_k\)</span>。</p><p>矩估计定理：</p><p>设随机变量X的数学期望<spanclass="math inline">\(\mu\)</span>和方差<spanclass="math inline">\(\sigma^2\)</span>都存在，且<spanclass="math inline">\(\sigma^2\gt0\)</span>。<spanclass="math inline">\(\mu,\sigma^2\)</span>均未知。<spanclass="math inline">\(X_1,...,X_n\)</span>为来自X的样本，则<spanclass="math inline">\(\mu,\sigma^2\)</span>的估计量<spanclass="math inline">\(\hat\mu=\overline X,\hat{\sigma^2}=\frac 1n\Sigma_{i=1}^n(X_i-\overline X)^2\)</span></p><p>优先采取阶数更低的估计值。</p><h4 id="极大似然估计">极大似然估计</h4><p>x为样本值，<spanclass="math inline">\(\theta\)</span>是需要估计的总体参数，<spanclass="math inline">\(L(\theta)\)</span>为似然函数，则<spanclass="math inline">\(\hat\theta=arg_\theta maxL(\theta)\)</span>。</p><ol type="1"><li>X为离散随机变量，<spanclass="math inline">\(P(X=x)={(x;\theta)}\)</span>，则<spanclass="math inline">\(L(\theta)=\prod_{i=1}^nP(x;\theta)\)</span>。</li><li>X为连续随机变量，概率密度为<spanclass="math inline">\(f(x;\theta)\)</span>，则<spanclass="math inline">\(L(\theta)=\prod_{i=1}^nf(x;\theta)\)</span>。</li></ol><p>泊松分布极大似然估计定理：<spanclass="math inline">\(\hat\lambda=\overline x\)</span></p><p>指数分布极大似然估计定理：<spanclass="math inline">\(\hat\lambda=\frac 1 {\overline{X}}\)</span></p><p>正态分布极大似然估计定理：<spanclass="math inline">\(\hat\mu=\overline X,\hat{\sigma^2}=\frac 1n\Sigma_{i=1}^n(X_i-\overline X)^2\)</span></p><p>均匀分布极大似然估计定理：<span class="math inline">\(X\sim \mathbbU(a,b)\)</span>，<spanclass="math inline">\(a=min(X_i),b=max(X_i)\)</span>。</p><h3 id="评估分析">4.1.2 评估分析</h3><p>参数估计量和估计方法的评价标准：</p><ul><li>无偏性</li><li>有效性</li><li>一致性</li></ul><h4 id="无偏性">无偏性</h4><p>无偏估计：估计量抽样分布的数学期望等于被估总体参数。</p><p>示例：</p><p>设总体的均值为<span class="math inline">\(\mu\)</span>，方差为<spanclass="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(X_1,...,X_n\)</span>为总体一样本，</p><p>样本均值为<span class="math inline">\(\overline X=\frac 1 n\Sigma_{i=1}^nX_i\)</span>，样本方差为<spanclass="math inline">\(S^2=\frac 1 {n-1}\Sigma_{i=1}^n(X_i-\overlineX)\)</span>，则</p><p><span class="math inline">\(E(\overline X)=\mu,Var(\overline X)=\frac{\sigma^2} n,E(S^2)=\sigma^2\)</span>。</p><p>所以<span class="math inline">\(\overline X,S^2\)</span>为<spanclass="math inline">\(\mu\)</span>和<spanclass="math inline">\(\sigma^2\)</span>的无偏估计。</p><p>设总体X的k阶矩<spanclass="math inline">\(\mu_k=E(X^k)\)</span>，<spanclass="math inline">\(k\ge1\)</span>，无论总体服从什么分布，k阶样本矩<spanclass="math inline">\(A_k=\frac 1n\Sigma_{i=1}^nX_i^k\)</span>都是k阶总体矩<spanclass="math inline">\(\mu_k\)</span>的无偏估计量。</p><p>一个参数可以有多个无偏估计。</p><h4 id="有效性">有效性</h4><p>对于某总体未知参数的两个无偏估计量，相应抽样分布的方差越小则越有效。</p><h4 id="一致性">一致性</h4><p>随着样本容量增大，估计量越来越接近总体参数。</p><h3 id="区间估计">4.1.3 区间估计</h3><p>设总体X的分布<spanclass="math inline">\(F(x;\theta)\)</span>中含有未知参数<spanclass="math inline">\(\theta\)</span>，若存在参数的两个估计量<spanclass="math inline">\(\underline\theta(X_1,...,X_n),\overline\theta(X_1,...,X_n)\)</span>，对于给定的<spanclass="math inline">\(\alpha\in(0,1)\)</span>，有<spanclass="math inline">\(P\{\underline\theta\lt\theta\lt\overline\theta\}=1-\alpha\)</span>。</p><p>则<spanclass="math inline">\((\underline\theta,\overline\theta)\)</span>为总体参数<spanclass="math inline">\(\theta\)</span>的置信水平为<spanclass="math inline">\(1-\alpha\)</span>的置信区间，<spanclass="math inline">\(\underline\theta,\overline\theta\)</span>分别称为置信下限和置信上限。</p><h4 id="单总体均值区间估计">单总体均值区间估计</h4><p><spanclass="math inline">\(X_1,...,X_n\)</span>为来自总体的一个样本，计算总体均值<spanclass="math inline">\(\mu\)</span>的置信水平为<spanclass="math inline">\(1-\alpha\)</span>的置信区间。</p><ol type="1"><li>总体近似服从正态分布，<spanclass="math inline">\(\sigma^2\)</span>已知：</li></ol><p><span class="math inline">\(\frac{\overline X-\mu}{\sigma/\sqrtn}\sim N(0,1)\)</span>，置信区间为<span class="math inline">\((\overlineX-\frac\sigma{\sqrt n}z_{\frac\alpha 2},\overline X+\frac\sigma{\sqrtn}z_{\frac\alpha 2})\)</span>。</p><ol start="2" type="1"><li>总体近似服从正态分布，<spanclass="math inline">\(\sigma^2\)</span>未知：</li></ol><p><span class="math inline">\(\frac{\overline X-\mu}{S/\sqrt n}\simt(n-1)\)</span>，置信区间为<span class="math inline">\((\overlineX-\frac S{\sqrt n}t_{\frac\alpha 2}(n-1),\overline X+\frac S{\sqrtn}t_{\frac\alpha 2}(n-1))\)</span>。</p><ol start="3" type="1"><li>总体不服从正态分布，但样本容量较大：</li></ol><p><span class="math inline">\(\frac{\overline X-\mu}{S/\sqrt n}\simN(0,1)\)</span>，置信区间为<span class="math inline">\((\overlineX-\frac S{\sqrt n}z_{\frac\alpha 2},\overline X+\frac S{\sqrtn}z_{\frac\alpha 2})\)</span>。</p><h4 id="单总体方差区间估计">单总体方差区间估计</h4><p><spanclass="math inline">\(X_1,...,X_n\)</span>为来自总体的一个样本，计算总体方差<spanclass="math inline">\(\sigma^2\)</span>的置信水平为<spanclass="math inline">\(1-\alpha\)</span>的置信区间，<spanclass="math inline">\(\mu\)</span>未知。</p><p><span class="math inline">\(\frac{(n-1)S^2}{\sigma^2}\sim\mathcalX^2(n-1)\)</span>，有<span class="math inline">\(P\{\mathcalX^2_{1-\frac\alpha2}(n-1)\}\lt\frac{(n-1)S^2}{\sigma^2}\lt P\{\mathcalX^2_{\frac\alpha2}(n-1)\}\)</span></p><p>则置信区间为<span class="math inline">\((\frac{(n-1)S^2}{\mathcalX^2_{\frac\alpha2}(n-1)},\frac{(n-1)S^2}{\mathcalX^2_{1-\frac\alpha2}(n-1)})\)</span>。</p><h4 id="双总体均值差区间估计">双总体均值差区间估计</h4><p><span class="math inline">\(X_1,...,X_{n_1}\)</span>和<spanclass="math inline">\(Y_1,...,Y_{n_2}\)</span>是来自某两个总体的样本，且两样本独立。对于给定的置信水平<spanclass="math inline">\(\alpha\)</span>，计算关于两总体均值差<spanclass="math inline">\(\mu_1-\mu_2\)</span>的置信水平为<spanclass="math inline">\(1-\alpha\)</span>的置信区间。</p><ol type="1"><li>两总体近似服从正态分布<spanclass="math inline">\(N(\mu_1,\sigma_1^2)\)</span>和<spanclass="math inline">\(N(\mu_2,\sigma_2^2)\)</span>，<spanclass="math inline">\(\mu_1,\mu_2\)</span>未知，<spanclass="math inline">\(\sigma_1^2,\sigma_2^2\)</span>已知。</li></ol><p><span class="math inline">\(\overline X-\overline Y\simN(\mu_1-\mu_2,\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2})\)</span></p><ol start="2" type="1"><li>两总体近似服从正态分布<spanclass="math inline">\(N(\mu_1,\sigma_1^2)\)</span>和<spanclass="math inline">\(N(\mu_2,\sigma_2^2)\)</span>，<spanclass="math inline">\(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2\)</span>未知，但<spanclass="math inline">\(\sigma_1^2=\sigma_2^2\)</span>。</li></ol><p><span class="math inline">\(\frac{(\overline X-\overlineY)-(\mu_1-\mu_2)}{S_w\sqrt{1/n_1+2/n_2}}\sim t(n_1+n_2-2)\)</span></p><ol start="3" type="1"><li>两总体不服从正态分布，但样本量较大。</li></ol><p><span class="math inline">\(\overline X-\overline Y\simN(\mu_1-\mu_2,\frac{S_1^2}{n_1}+\frac{S_2^2}{n_2})\)</span></p><h4 id="双总体方差比区间估计">双总体方差比区间估计</h4><p><span class="math inline">\(X_1,...,X_{n_1}\)</span>和<spanclass="math inline">\(Y_1,...,Y_{n_2}\)</span>是来自某两个总体的样本，且两样本独立。对于给定的置信水平<spanclass="math inline">\(\alpha\)</span>，计算关于两总体方差比<spanclass="math inline">\(\frac{\sigma_1^2}{\sigma_2^2}\)</span>的置信水平为<spanclass="math inline">\(1-\alpha\)</span>的置信区间。</p><p>估计条件：两总体近似服从正态分布<spanclass="math inline">\(N(\mu_1,\sigma_1^2)\)</span>和<spanclass="math inline">\(N(\mu_2,\sigma_2^2)\)</span>，<spanclass="math inline">\(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2\)</span>未知。</p><p><spanclass="math inline">\(\frac{S_1^2/S_2^2}{\sigma_1^2/\sigma_2^2}\simF(n_1-1,n_2-1)\)</span></p><h2 id="假设检验">4.2 假设检验</h2><p>在样本的基础上对总体的某种结论作出判断。</p><h3 id="参数假设检验">4.2.1 参数假设检验</h3><p>参数假设检验是对总体分布中未知参数的假设检验。</p><p>检验方法参考区间估计。</p><h3 id="非参数假设检验">4.2.2 非参数假设检验</h3><p>对未知分布函数类型或其某些特征提出的假设进行检验。</p><h4 id="符号检验">符号检验</h4><p>两个总体，从总体分布<spanclass="math inline">\(F(x),G(x)\)</span>中分别取容量为<spanclass="math inline">\(n\)</span>的样本<spanclass="math inline">\(X_1,...,X_n\)</span>和<spanclass="math inline">\(Y_1,...,Y_n\)</span>，检验<spanclass="math inline">\(H_0:F(x)=G(x),H_1:F(x)\ne G(x)\)</span>。</p><p>首先将样本数据配对排列，当<span class="math inline">\(x_i\gty_i,n_+\)</span>加一，<span class="math inline">\(x_i\lty_i,n_-\)</span>加一。</p><p>计算临界值<span class="math inline">\(c_1,c_2\)</span>，如果<spanclass="math inline">\(c_1\le n_+\le c_2\)</span>，不拒绝原假设：</p><p><span class="math inline">\(P(n_+\lec_1)=\Sigma_{i=0}^{c_1}C_n^i(0.5)^n\le\frac\alpha2\)</span></p><p><span class="math inline">\(P(n_+\gec_2)=\Sigma_{i=c_2}^{n}C_n^i(0.5)^n\le\frac\alpha2\)</span></p><h4 id="秩和检验">秩和检验</h4><p>双总体非参数假设检验。</p><p>两总体中分别取容量为<spanclass="math inline">\(n_1,n_2\)</span>的样本，检验假设：</p><p><span class="math inline">\(H_0:F(x)=G(x),H_1:F(x)\neG(x)\)</span></p><p>若原假设<spanclass="math inline">\(H_0\)</span>成立，将两总体的观察值放在一起并排序，两样本的数据应该均匀分散在队列中。</p><p>样本数据的秩是该数据在混合排序后的序号，若几个样本数据相同，则每个数据的秩取为这几个数据的序号的平均数。求出每个观察值的秩，将属于<spanclass="math inline">\(X\)</span>的样本数据的秩求和为<spanclass="math inline">\(R_1\)</span>，总体<spanclass="math inline">\(Y\)</span>的秩和为<spanclass="math inline">\(R_2\)</span>。</p><p>假设<span class="math inline">\(R_1\le R_2\)</span>，取<spanclass="math inline">\(T=R_1\)</span>作为统计量，根据给定<spanclass="math inline">\(\alpha\)</span>查表得临界值<spanclass="math inline">\(T_1,T_2\)</span>，若<spanclass="math inline">\(T\)</span>在两者之间，则不能拒绝原假设<spanclass="math inline">\(H_0\)</span>，两样本间总体差异不显著。</p><p>大样本逼近：样本容量较大时，<spanclass="math inline">\(T\)</span>近似服从<spanclass="math inline">\(N(\mu,\sigma^2)\)</span>，其中</p><p><spanclass="math inline">\(\mu=\frac{n_1(n_1+n_2+1)}{2},\sigma^2=\frac{n_1n_2(n_1+n_2+1)}{12}\)</span>。则<spanclass="math inline">\(U=\frac{T-\mu}{\sigma}\sim N(0,1)\)</span>。</p><p>秩和检验的拒绝域为<span class="math inline">\(|U|\gtz_{\frac\alpha2}\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_3_抽样分布</title>
    <link href="/2022/03/03/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_3%20%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"/>
    <url>/2022/03/03/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_3%20%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_3-抽样分布">DataScience_3 抽样分布</h1><h2 id="数据抽样">3.1 数据抽样</h2><h3 id="抽样方法">3.1.1 抽样方法</h3><ul><li><p>简单随机抽样：每个样本点被抽样的概率相等</p></li><li><p>系统抽样：排列所有单位，随机抽取一个单位为初始单位，再按一定规则抽取其他单位</p><ul><li>如<span class="math inline">\(r+nk\)</span></li></ul></li><li><p>整群抽样：抽取群而不是个体</p></li><li><p>分层抽样：样本分层，每层抽样</p></li></ul><h3 id="矩与抽样">3.1.2 矩与抽样</h3><p>抽样分布：统计量的分布</p><h4 id="统计量抽样收敛定理">统计量抽样收敛定理</h4><p>设<span class="math inline">\(\mu\)</span>和<spanclass="math inline">\(\sigma^2\)</span>分别为总体的均值和方差，<spanclass="math inline">\(X_1,...,X_n\)</span>为总体一样本，样本均值为<spanclass="math inline">\(\overline X=\frac 1 n\Sigma_{i=1}^nX_i\)</span>，样本方差为<spanclass="math inline">\(S^2=\frac 1 {n-1}\Sigma_{i=1}^n(X_i-\overlineX)^2\)</span>，则有：</p><ol type="1"><li><span class="math inline">\(E(\overline X)=\mu\)</span></li><li><span class="math inline">\(D(\overline X)=\frac {\sigma^2}n\)</span></li><li><span class="math inline">\(E(S^2)=\sigma^2\)</span></li></ol><h2 id="极限定理">3.2 极限定理</h2><h3 id="矩的不等式">3.2.1 矩的不等式</h3><h4 id="马尔科夫不等式">马尔科夫不等式</h4><p>设随机变量X非负且具有数学期望<spanclass="math inline">\(E(X)\)</span>，<span class="math inline">\(\forall\varepsilon\gt0\)</span>，有<spanclass="math inline">\(P(X\ge\varepsilon)\le\frac{E(X)}\varepsilon\)</span>。</p><ul><li><span class="math inline">\(E(X)\ge\varepsilonP(X\ge\varepsilon)\)</span></li></ul><h4 id="切比雪夫不等式">切比雪夫不等式</h4><p>设随机变量X具有数学期望<spanclass="math inline">\(E(X)=\mu\)</span>，方差<spanclass="math inline">\(D(X)=\sigma^2\)</span>，则<spanclass="math inline">\(\forall \varepsilon\gt0\)</span>，有</p><p><spanclass="math inline">\(P(|X-\mu|\ge\varepsilon)\le\frac{\sigma^2}{\varepsilon^2}\)</span>或等价于<spanclass="math inline">\(P(|X-\mu|\lt\varepsilon)\ge1-\frac{\sigma^2}{\varepsilon^2}\)</span></p><p>方差为0的充要条件：<spanclass="math inline">\(P(X=E(X))=1\)</span>。</p><h3 id="大数定律">3.2.2 大数定律</h3><h4 id="伯努利大数定律">伯努利大数定律</h4><p><span class="math inline">\(X_n\sim\mathbb B(n,p)\)</span>，<spanclass="math inline">\(\forall\varepsilon\gt0\)</span>，有<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(|\frac{x_n}{n}-p|\lt\varepsilon)=1\)</span>。</p><h4 id="切比雪夫大数定律">切比雪夫大数定律</h4><p>设<spanclass="math inline">\(X_1,...,X_n\)</span>为独立（可以非同分布）随机变量，有相同的数学期望<spanclass="math inline">\(\mu\)</span>和有限的方差<spanclass="math inline">\(\sigma_i^2\)</span>，</p><p><span class="math inline">\(\forall \varepsilon\gt0\)</span>，有<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(|\frac1n\Sigma_{i=1}^nX_i-\frac1n\Sigma_{i=1}^nEX_i|\lt\varepsilon)=1\)</span>。</p><h4 id="辛钦大数定律">辛钦大数定律</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>为<spanclass="math inline">\(X\)</span>的独立同分布随机变量，<spanclass="math inline">\(E(X)=\mu\)</span>存在，</p><p><span class="math inline">\(\forall\varepsilon\gt0\)</span>，有<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(|\frac1n\Sigma_{i=1}^nX_i-\mu|&lt;\varepsilon)=1\)</span>。</p><h4 id="弱大数定律">弱大数定律</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>为<spanclass="math inline">\(X\)</span>的独立同分布随机变量，<spanclass="math inline">\(E(X)\)</span>存在，则<spanclass="math inline">\(\overline X_n\)</span>依概率收敛于<spanclass="math inline">\(EX\)</span>，</p><p><span class="math inline">\(\forall\varepsilon\gt0\)</span>，有<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(|\frac1n\Sigma_{i=1}^nX_i-EX|&lt;\varepsilon)=1\)</span>。</p><p>大数定律告诉我们可以用频率近似替代概率，用样本均值近似替代总体均值。</p><h3 id="中心极限定理">3.2.3 中心极限定理</h3><h4 id="德莫弗-拉普拉斯中心极限定理">德莫弗-拉普拉斯中心极限定理</h4><p><span class="math inline">\(X_n\sim\mathbb B(n,p)\)</span>，则<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(\frac{X_n-np}{\sqrt{np(1-p)}}\lex)=\frac1{\sqrt{2\pi}}\int_{-\infin}^xe^{-\frac{t^2}2}dt\)</span></p><h4 id="独立同分布中心极限定理">独立同分布中心极限定理</h4><p>设<spanclass="math inline">\(X_1,...,X_n\)</span>为独立（可以非同分布）随机变量，有相同的数学期望<spanclass="math inline">\(\mu\)</span>和方差<spanclass="math inline">\(\sigma^2\)</span>，随机变量之和<spanclass="math inline">\(Y_n=\frac{\Sigma_{i=1}^nX_i-n\mu}{\sqrtn\sigma}\)</span>，则有<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(Y_n\lex)=\int_{-\infin}^x\frac1{\sqrt{2\pi}}e^{-\frac{t^2}2}dt\)</span>。</p><h4 id="均值抽样分布定理">均值抽样分布定理</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>是总体<spanclass="math inline">\(\mathbb N(\mu,\sigma^2)\)</span>的样本，<spanclass="math inline">\(\overline X\)</span>是样本均值，则有<spanclass="math inline">\(\overline X\sim\mathbbN(\mu,\frac{\sigma^2}n)\)</span>。</p><h2 id="常用抽样分布">3.3 常用抽样分布</h2><h3 id="伽马函数">3.3.0 伽马函数</h3><p><spanclass="math inline">\(\Gamma(x)=\int_0^{+\infin}t^{x-1}e^{-t}dt(x\gt0)\)</span>，其中负整数和0是它的一阶极点。</p><ul><li><p><span class="math inline">\(\Gamma(n)=(n-1)!\)</span>，<spanclass="math inline">\(n\in\mathbb N^*\)</span></p></li><li><p>对<span class="math inline">\(x\in(0,1)\)</span>，有<spanclass="math inline">\(\Gamma(x)\Gamma(1-x)=\frac\pi{sin\pix}\)</span>，可得<spanclass="math inline">\(\Gamma(\frac12)=\sqrt\pi\)</span></p></li></ul><h4 id="伽马分布">伽马分布</h4><p><spanclass="math inline">\(f(x)=\frac{\beta^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\betax},x\gt0\)</span></p><ul><li>数学期望：<span class="math inline">\(\frac\alpha\beta\)</span></li><li>方差：<span class="math inline">\(\frac\alpha{\beta^2}\)</span></li></ul><p>x越大，伽马函数越趋近于Stirling公式，当x够大，可以用Stirling公式计算伽马函数值：</p><p><spanclass="math inline">\(\Gamma(x)\sim\sqrt{2\pi}e^{-x}x^{x-\frac12}\)</span></p><h3 id="卡方分布">3.3.1 卡方分布</h3><p>设<span class="math inline">\(X_1,...,X_n\)</span>是<spanclass="math inline">\(\mathbbN(0,1)\)</span>的独立同分布随机变量，则称随机变量<spanclass="math inline">\(\mathcalX^2=\Sigma_{i=1}^nX_i^2\)</span>服从自由度为n的<spanclass="math inline">\(\mathcal X^2\)</span>分布，记为<spanclass="math inline">\(\mathcal X^2(n)\)</span>。</p><ul><li>概率密度：<span class="math inline">\(f(x)=\frac1{2^{\fracn2}\Gamma(\frac n2)}x^{\frac n2-1}e^{-\frac x2},x\gt0\)</span>。</li><li>卡方分布是<span class="math inline">\(\alpha=\fracn2,\beta=\frac12\)</span>的伽马分布特例。</li><li>数学期望：n</li><li>方差：2n</li></ul><p>可加性：</p><p>设<span class="math inline">\(X_1\sim\mathcalX^2(n_1),X_2\sim\mathcal X^2(n_2)\)</span>，且<spanclass="math inline">\(X_1,X_2\)</span>相互独立，则<spanclass="math inline">\(X_1+X_2\sim\mathcal X^2(n_1+n_2)\)</span>。</p><h4 id="方差抽样分布定理">方差抽样分布定理</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>是总体<spanclass="math inline">\(\mathbbN(\mu,\sigma^2)\)</span>的样本，样本方差为<spanclass="math inline">\(S^2\)</span>，则有<spanclass="math inline">\(\frac{(n-1)S^2}{\sigma^2}\sim\mathcalX^2(n-1)\)</span>。</p><h3 id="t分布">3.3.2 t分布</h3><p>设<span class="math inline">\(X\sim\mathbb N(0,1),Y\sim\mathcalX^2(n)\)</span>，且<spanclass="math inline">\(X,Y\)</span>相互独立，称随机变量<spanclass="math inline">\(t=\frac X{\sqrt{\fracYn}}\)</span>服从自由度为n的t分布。</p><ul><li><p>概率密度函数：<spanclass="math inline">\(f(x)=\frac{\Gamma(\frac{n+1}2)}{\sqrt{n\pi}\Gamma(\frac2n)}(1+\frac{x^2}n)^{-\frac{n+1}2}\)</span></p></li><li><p>数字特征：<span class="math inline">\(T=\fracXY\)</span>，有<span class="math inline">\(E(T)=0,D(T)=\fracn{n-2}\)</span></p></li><li><p>上<span class="math inline">\(\alpha\)</span>分位点：</p><p>对于给定的<spanclass="math inline">\(\alpha\in(0,1)\)</span>，称满足<spanclass="math inline">\(P(t\gt t_\alpha(n))=\alpha\)</span>的<spanclass="math inline">\(t_\alpha(n)\)</span>为<spanclass="math inline">\(t(n)\)</span>分布的上<spanclass="math inline">\(\alpha\)</span>分位点。</p></li><li><p><span class="math inline">\(t\)</span>分布关于<spanclass="math inline">\(x=0\)</span>对称，故<spanclass="math inline">\(t_\alpha(n)=-t_{1-\alpha}(n)\)</span>。</p></li></ul><p><span class="math inline">\(t\)</span>分布的正态收敛性：<spanclass="math inline">\(t(n)\)</span>分布的概率密度<spanclass="math inline">\(f(x)\)</span>趋于标准正态分布的概率密度：</p><p><spanclass="math inline">\(\lim_{n\rightarrow\infin}f(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}2}\)</span>。</p><h4 id="均值抽样分布定理t分布">均值抽样分布定理（t分布）</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>是总体<spanclass="math inline">\(\mathbbN(\mu,\sigma^2)\)</span>的样本，总体方差未知，<spanclass="math inline">\(\overline X\)</span>是样本均值，<spanclass="math inline">\(S^2\)</span>为样本方差，则有<spanclass="math inline">\(\frac{\overline X-\mu}{S/\sqrt{n}}\simt(n-1)\)</span>。</p><h3 id="f分布">3.3.3 F分布</h3><p>设<span class="math inline">\(X\sim\mathcal X^2(n_1),Y\sim\mathcalX^2(n_2)\)</span>，且<spanclass="math inline">\(X,Y\)</span>相互独立，则随机变量<spanclass="math inline">\(F=\frac{\frac X{n_1}}{\fracY{n_2}}=\frac{n_2X}{n_1Y}\)</span>服从自由度为<spanclass="math inline">\(n_1,n_2\)</span>的F分布，记为<spanclass="math inline">\(F(n_1,n_2)\)</span>，其中<spanclass="math inline">\(n_1\)</span>为第一自由度，<spanclass="math inline">\(n_2\)</span>为第二自由度。</p><ul><li><p>数学期望：<spanclass="math inline">\(\frac{n_2}{n_2-2}\)</span>。</p></li><li><p>倒数对称性：<spanclass="math inline">\(F_{1-\alpha}(n_1,n_2)=\frac1{F_\alpha(n_2,n_1)}\)</span>。</p></li></ul><h4 id="正态分布逼近定理">正态分布逼近定理</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>与<spanclass="math inline">\(Y_1,...,Y_n\)</span>分别来自正态总体<spanclass="math inline">\(\mathbb N(\mu_1,\sigma_1^2)\)</span>和<spanclass="math inline">\(\mathbb N(\mu_2,\sigma_2^2)\)</span>，则</p><p><span class="math inline">\(\frac{\overline X-\overlineY-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}\simN(0,1)\)</span>。</p><h4 id="方差抽样分布定理f分布">方差抽样分布定理（F分布）</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>与<spanclass="math inline">\(Y_1,...,Y_n\)</span>分别来自正态总体<spanclass="math inline">\(\mathbb N(\mu_1,\sigma_1^2)\)</span>和<spanclass="math inline">\(\mathbbN(\mu_2,\sigma_2^2)\)</span>，样本方差为<spanclass="math inline">\(S_1^2\)</span>和<spanclass="math inline">\(S_2^2\)</span>，则有<spanclass="math inline">\(\frac{(S_1^2)/(S_2^2)}{(\sigma_1^2)/(\sigma_2^2)}\simF(n_1-1,n_2-1)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_2_数据抽象</title>
    <link href="/2022/03/02/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_2%20%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"/>
    <url>/2022/03/02/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_2%20%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_2-数据抽象">DataScience_2 数据抽象</h1><h2 id="概率">2.1 概率</h2><h3 id="随机试验">2.1.1 随机试验</h3><p>如果一个试验满足以下3个条件：</p><ol type="1"><li>试验可以在相同的条件下重复进行</li><li>试验的所有可能结果明确可知，且不止一个</li><li>每一次试验会出现哪一个结果，事先并不能确定</li></ol><p>则称此试验为随机试验，简称试验。</p><p>大量重复试验中具有某种规律性的事件称为<strong>随机事件</strong>，简称事件。</p><h3 id="样本空间">2.1.2 样本空间</h3><p>随机试验中的每一个可能出现的试验结果称为该试验的一个样本点，全体样本点组成的集合称为该试验的样本空间。</p><ul><li><p>样本空间的任意一个子集是一个随机事件。</p></li><li><p>样本空间<spanclass="math inline">\(\Omega\)</span>包含所有样本点，称为必然事件，<spanclass="math inline">\(\varnothing\)</span>为不可能事件。</p></li><li><p>包含一个样本点的随机事件成为基本事件，包含多个样本点的随机事件称为复合事件。</p></li></ul><p>事件的关系和计算</p><ol type="1"><li><span class="math inline">\(A\subseteqB\)</span>，事件B包含事件A，即事件A发生必然导致事件B发生。</li><li><span class="math inline">\(A=B\)</span>，事件A与B相等。</li><li><span class="math inline">\(A\cap B\)</span>或<spanclass="math inline">\(AB\)</span>，事件A和B同时发生，称为A与B的交/积事件。<ul><li><spanclass="math inline">\(AB\neq\varnothing\)</span>，称A和B相容</li><li><span class="math inline">\(AB=\varnothing\)</span>，称A和B互斥</li></ul></li><li><span class="math inline">\(A\cupB\)</span>，事件A和B至少有一个发生，称为A与B的交/积事件。</li><li><spanclass="math inline">\(A-B\)</span>，事件A发生而B不发生，称为A与B的差事件。</li><li><span class="math inline">\(\overlineA\)</span>，事件A不发生，称为事件A的逆事件或对立事件。</li><li>如果<spanclass="math inline">\(\bigcup_{i=1}^nA_i=\Omega\)</span>，称这有限个事件<spanclass="math inline">\(A_i\)</span>构成一个完备事件组。</li></ol><h3 id="概率-1">2.1.3 概率</h3><p>公理化定义：</p><p>设随机试验的样本空间为<spanclass="math inline">\(\Omega\)</span>，如果对每一个事件A都有一个确定的实数<spanclass="math inline">\(P(A)\)</span>，且满足：</p><ol type="1"><li><p>非负性：<span class="math inline">\(P(A)\ge 0\)</span></p></li><li><p>规范性：<span class="math inline">\(P(\Omega) =1\)</span></p></li><li><p>可列可加性：<span class="math inline">\(P(\bigcup_{i=1}^\infinA_i)=\Sigma_{i=1}^\infin P(A_i)\)</span></p></li></ol><p>则称<span class="math inline">\(P(A)\)</span>为事件A的概率。</p><h4 id="古典概型">古典概型</h4><p>样本空间有穷且每个样本点等可能，这种概率模型称为古典概型。</p><h4 id="几何概型">几何概型</h4><p>样本空间是个可度量的有界区域，每个样本点等可能，这种概率模型称为几何概型。</p><h4 id="概率的性质">概率的性质</h4><ol type="1"><li><p>有界性：任意事件A，<span class="math inline">\(0\leP(A)\le1\)</span>，<span class="math inline">\(P(\varnothing) =0\)</span>，<span class="math inline">\(P(\Omega)=1\)</span>。</p></li><li><p>单调性：<span class="math inline">\(A\subseteqB\)</span>，则<spanclass="math inline">\(P(B-A)=P(B)-P(A)\)</span>，<spanclass="math inline">\(P(B)\ge P(A)\)</span>。</p></li></ol><h4 id="概率公式">概率公式</h4><ol type="1"><li><p><span class="math inline">\(P(\overlineA)=1-P(A)\)</span></p></li><li><p>加法公式：<span class="math inline">\(P(A\cupB)=P(A)+P(B)-P(AB)\)</span></p></li><li><p>减法公式：<spanclass="math inline">\(P(A-B)=P(A)-P(AB)=P(A\overlineB)\)</span></p></li><li><p>条件概率公式：<spanclass="math inline">\(P(B|A)=\frac{P(AB)}{P(A)}\)</span></p><p>若<spanclass="math inline">\(P(A)\gt0\)</span>，称已知A发生的条件下，B发生的概率为条件概率，记为<spanclass="math inline">\(P(B|A)\)</span>。</p></li><li><p>乘法公式：如果<spanclass="math inline">\(P(A)\gt0\)</span>，<spanclass="math inline">\(P(AB)=P(A)P(B|A)\)</span></p></li><li><p>全概率公式：若<span class="math inline">\(\bigcup_{i=1}^nA_i=\Omega\)</span>且<spanclass="math inline">\(A_iA_j=\varnothing\)</span>，<spanclass="math inline">\(P(A_i)\gt0\)</span>，则对任意事件B，</p><p><spanclass="math inline">\(B=\bigcup_{i=1}^nA_iB,P(B)=\Sigma_{i=1}^nP(A_i)P(B|A_i)\)</span></p></li><li><p>贝叶斯公式：若<span class="math inline">\(\bigcup_{i=1}^nA_i=\Omega\)</span>且<spanclass="math inline">\(A_iA_j=\varnothing\)</span>，<spanclass="math inline">\(P(A_i)\gt0\)</span>，则对任意事件B，只要<spanclass="math inline">\(P(B)\gt0\)</span>，就有<spanclass="math inline">\(P(A_j|B)=\frac{P(A_j)P(B|A_j)}{\Sigma_{i=1}^nP(A_i)P(B|A_i)}\)</span></p></li></ol><h3 id="独立性">2.1.4 独立性</h3><p>事件是否发生对另一个事件的概率没有影响，这样的两个事件为相互独立事件。</p><p>事件A和事件B相互独立时，<spanclass="math inline">\(P(AB)=P(A)P(B)\)</span>。</p><ul><li>事件A和事件B相互独立时，<span class="math inline">\(\overlineA\)</span>与<span class="math inline">\(B\)</span>、<spanclass="math inline">\(A\)</span>与<span class="math inline">\(\overlineB\)</span>、<span class="math inline">\(\overline A\)</span>与<spanclass="math inline">\(\overline B\)</span>也相互独立。</li><li>事件A和事件B相互独立时，<spanclass="math inline">\(P(A)\gt0\)</span>，则有<spanclass="math inline">\(P(B|A)=P(B)\)</span>。</li></ul><h2 id="随机变量">2.2 随机变量</h2><p>给定样本空间，若对于每一个样本点都有唯一确定的实数X与之对应，则称X是一个随机变量。</p><p>随机变量X的概率分布函数：<span class="math inline">\(F(x)=P(X\lex)\)</span></p><ul><li>分布函数性质：非负性；单调不减；右连续；左极限为0，右极限为1</li></ul><h3 id="离散随机变量">离散随机变量</h3><p>随机变量的取值为可列个，则称其为离散随机变量。</p><h3 id="连续随机变量">连续随机变量</h3><p>对于随机变量<span class="math inline">\(X\)</span>及其分布函数<spanclass="math inline">\(F(x)\)</span>，如果存在非负可积函数<spanclass="math inline">\(f(x)\)</span>满足<spanclass="math inline">\(\forall x:F(x)=\int_{-\infin}^xf(t)dt\)</span>，则称<spanclass="math inline">\(X\)</span>为连续随机变量，<spanclass="math inline">\(f(x)\)</span>为<spanclass="math inline">\(X\)</span>的概率密度函数。</p><p>连续随机变量的性质：</p><ol type="1"><li>如果<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x\)</span>处连续，那么<spanclass="math inline">\(F&#39;(x)=f(x)\)</span>。</li><li>连续随机变量<spanclass="math inline">\(X\)</span>的任意一点概率为0，即<spanclass="math inline">\(P(X=x)=0\)</span>。</li></ol><h2 id="数据动力学">2.3 数据动力学</h2><p>数据科学借鉴了物理学的矩的概念，用数据分布代替物理量分布，用概率密度代替物理密度函数。矩是对变量分布和形态特点的一组度量。</p><p>原点矩：给定一批数据<spanclass="math inline">\(x_1,x_2,...,x_n\)</span>，其<spanclass="math inline">\(k\)</span>阶原点矩<spanclass="math inline">\(A_k=\frac{1}{n}\Sigma_{i=1}^nx_i^k\)</span>。</p><ul><li>我们称1阶原点矩为算术平均值，2阶原点矩为数据集的转动惯量。</li></ul><h3 id="数学期望">数学期望</h3><p>离散随机变量的数学期望：<spanclass="math inline">\(E(X)=\Sigma_{i=1}^\infin x_ip_i\)</span>。</p><p>连续随机变量的数学期望：<spanclass="math inline">\(E(X)=\int_{-\infin}^{+\infin}xf(x)dx\)</span></p><ul><li>要求<span class="math inline">\(\Sigma_{i=1}^\infinx_ip_i\)</span>和<spanclass="math inline">\(\int_{-\infin}^{+\infin}xf(x)dx\)</span>绝对收敛。</li></ul><p>数学期望的性质：</p><ol type="1"><li>常数<span class="math inline">\(C\)</span>，<spanclass="math inline">\(E(C)=C\)</span></li><li>常数<span class="math inline">\(C\)</span>及随机变量<spanclass="math inline">\(X\)</span>，<spanclass="math inline">\(E(CX)=CE(X)\)</span></li><li>设随机变量<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>，<spanclass="math inline">\(E(X+Y)=E(X)+E(Y)\)</span></li><li>设随机变量<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>独立，<spanclass="math inline">\(E(XY)=E(X)E(Y)\)</span></li></ol><p>中心矩：</p><p>给定随机变量X，若<spanclass="math inline">\(E((X-EX)^k)\)</span>存在，则其k阶中心矩的定义为<spanclass="math inline">\(E((X-EX)^k)\)</span>。</p><ul><li>2阶中心矩即方差，记为<spanclass="math inline">\(\sigma^2(X)\)</span>或<spanclass="math inline">\(D(X)\)</span>或<spanclass="math inline">\(Var(X)\)</span>。</li><li><spanclass="math inline">\((\sigma^2(X))^{\frac{1}{2}}\)</span>即标准差，记为<spanclass="math inline">\(\sigma(X)\)</span>。</li><li><span class="math inline">\(D(X)=E(X^2)-E(X)^2\)</span></li></ul><p>方差的性质：</p><ol type="1"><li><span class="math inline">\(C\)</span>为常数，<spanclass="math inline">\(D(C)=0\)</span>。</li><li>设<span class="math inline">\(X\)</span>为随机变量，<spanclass="math inline">\(C\)</span>为常数，则<spanclass="math inline">\(D(C+X)=D(X),D(CX)=C^2D(X)\)</span>。</li><li>随机变量<span class="math inline">\(X\)</span>与<spanclass="math inline">\(Y\)</span>相互独立，<spanclass="math inline">\(D(X+Y)=D(X)+D(Y),D(X-Y)=D(X)-D(Y)\)</span>。</li></ol><h2 id="概率分布">2.4 概率分布</h2><h3 id="数学工具">2.4.0 数学工具</h3><p>#### 泰勒展开</p><p>若<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=a\)</span>处无穷可微，则当<spanclass="math inline">\(x\rightarrow a\)</span>时，有<spanclass="math inline">\(f(x)=\Sigma_{n=0}^\infin\frac{f^{(n)}(a)}{n!}(x-a)^n\)</span>。</p><p><span class="math inline">\(\Sigma_{n=0}^\infin\frac{f^{(n)}(a)}{n!}(x-a)^n\)</span>称为<spanclass="math inline">\(f(x)\)</span>的泰勒级数。若<spanclass="math inline">\(a=0\)</span>则称为麦克劳林级数。</p><h4 id="矩生成函数">矩生成函数</h4><p>随机变量X的矩生成函数<spanclass="math inline">\(M_X(s)\)</span>定义为：<spanclass="math inline">\(M_X(s)=E[e^{sX}]\)</span>。</p><p>如果存在常数<span class="math inline">\(\delta\)</span>使得<spanclass="math inline">\(M_X(s)\)</span>对于任意<spanclass="math inline">\(s\in[-\delta,\delta]\)</span>有穷，则称<spanclass="math inline">\(M_X(s)\)</span>存在。</p><p>矩生成定理：</p><p>假设随机变量X的矩生成函数<spanclass="math inline">\(M_X(s)\)</span>存在，则<spanclass="math inline">\(E[X^k]=\frac{d^k}{ds^k}M_X(s)|_{s=0}\)</span>。</p><p>矩生成函数的唯一性定理：</p><p>对于两个随机变量X和Y，假设存在常数<spanclass="math inline">\(\delta\)</span>使得<spanclass="math inline">\(M_X(s)\)</span>和<spanclass="math inline">\(M_Y(s)\)</span>对于任意<spanclass="math inline">\(s\in[-\delta,\delta]\)</span>存在且相等，则X和Y的分布函数相等。</p><p>矩生成函数可加性定理：</p><p><spanclass="math inline">\(X_1,X_2,...,X_n\)</span>为独立随机变量，则<spanclass="math inline">\(M_{X_1+X_2+...+X_n}(s)=M_{X_1}(s)M_{X_2}(s)...M_{X_n}(s)\)</span>。</p><h3 id="离散概率分布">2.4.1 离散概率分布</h3><h4 id="伯努利分布">伯努利分布</h4><p>随机变量<span class="math inline">\(X\)</span>，<spanclass="math inline">\(P(X=k)=p^kq^{1-k}\)</span>，且满足<spanclass="math inline">\(k=0,1,p\in(0,1),q=1-p\)</span>，</p><p>则称<span class="math inline">\(X\)</span>服从参数为<spanclass="math inline">\(p\)</span>的伯努利分布，记为<spanclass="math inline">\(X\sim Bern(p)\)</span>。</p><p>数学期望：<span class="math inline">\(p\)</span></p><p>方差：<span class="math inline">\(p(1-p)\)</span></p><p>矩生成函数：<span class="math inline">\(M_X(s)=q+pe^s\)</span></p><h4 id="二项分布">二项分布</h4><p>随机变量<span class="math inline">\(X\)</span>，<spanclass="math inline">\(P(X=k)=(_k^n)p^k(1-p)^{n-k},k=0,1,...,n\)</span>，</p><p>称<span class="math inline">\(X\)</span>服从参数<spanclass="math inline">\(n\)</span>，<spanclass="math inline">\(p\)</span>的二项分布，记为<spanclass="math inline">\(X\sim \mathbb B(n,p)\)</span>。</p><p>数学期望：<span class="math inline">\(np\)</span></p><p>方差：<span class="math inline">\(np(1-p)\)</span></p><p>矩生成函数：<spanclass="math inline">\(M_X(s)=(q+pe^s)^n\)</span></p><p>二项分布可加性：</p><p>二项分布随机变量<span class="math inline">\(X\sim \mathbbB(m,p)\)</span>和<span class="math inline">\(Y\sim \mathbbB(n,p)\)</span>相互独立，则有<span class="math inline">\(X+Y\sim\mathbbB(m+n,p)\)</span>。</p><h4 id="泊松分布">泊松分布</h4><p>随机变量<span class="math inline">\(X\)</span>，<spanclass="math inline">\(P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda},k=0,1,...,n,\lambda\gt0\)</span>，</p><p>称<span class="math inline">\(X\)</span>服从参数为<spanclass="math inline">\(\lambda\)</span>的泊松分布，记作<spanclass="math inline">\(X\sim\pi(\lambda)\)</span>。</p><p>数学期望：<span class="math inline">\(\lambda\)</span></p><p>方差：<span class="math inline">\(\lambda\)</span></p><p>矩生成函数：<spanclass="math inline">\(M_X(s)=e^{\lambda(e^s-1)}\)</span></p><p>泊松逼近定理：</p><p>设<span class="math inline">\(\lambda\gt 0\)</span>是一个常数，<spanclass="math inline">\(n\)</span>为正整数，若<spanclass="math inline">\(np\)</span>近似<spanclass="math inline">\(\lambda\)</span>，则对于任一固定的非负整数k，有</p><p><spanclass="math inline">\(\lim_{n\rightarrow\infin}(_k^n)p_n^k(1-p_n)^{n-k}=\frac{\lambda^k}{k!}e^{-\lambda}\)</span>。</p><h4 id="几何分布">几何分布</h4><p>随机变量X，<spanclass="math inline">\(P(X=k)=q^{k-1}p,k=1,2,...,q=1-p\)</span>，</p><p>称X服从参数为p的几何分布，记作<spanclass="math inline">\(X\sim\mathbb G(p)\)</span>。</p><ul><li>几何分布的无记忆性：<span class="math inline">\(P(X\gt m+n|X\gtm)=P(X\gt n)\)</span></li></ul><p>数学期望：<span class="math inline">\(\frac 1 p\)</span></p><p>方差：<span class="math inline">\(\frac{1-p}{p^2}\)</span></p><p>矩生成函数：<spanclass="math inline">\(M_X(s)=\frac{pe^s}{1-(1-p)e^s}\)</span></p><h4 id="超几何分布">超几何分布</h4><p>随机变量<span class="math inline">\(X\)</span>，<spanclass="math inline">\(P(X=k)=\frac{C_M^kC_{N-M}^{n-k}}{C_N^n},k=1,2,...,n,N,M,n\in\mathbb Z,M\ge N,n\ge N\)</span>，</p><p>称<span class="math inline">\(X\)</span>服从参数为<spanclass="math inline">\(N,M,n\)</span>的超几何分布，记为<spanclass="math inline">\(X\sim\mathbb H(N,M,n)\)</span>。</p><ul><li>形象描述：<span class="math inline">\(N\)</span>件产品中有<spanclass="math inline">\(M\)</span>件次品，随机抽取<spanclass="math inline">\(n\)</span>件产品，恰有<spanclass="math inline">\(k\)</span>件次品的概率。</li></ul><p>数学期望：<span class="math inline">\(n\frac M N\)</span></p><p>方差：<span class="math inline">\(n\frac M N\frac {N-M} N\frac{N-n}{N-1}\)</span></p><h3 id="连续概率分布">2.4.2 连续概率分布</h3><h4 id="均匀分布">均匀分布</h4><p><span class="math inline">\(X\sim\mathbbU(a,b)\)</span>，概率密度函数<span class="math inline">\(f(x)=\frac1{b-a},a\lt x\lt b\)</span>。</p><p>数学期望：<span class="math inline">\(\frac {a+b} 2\)</span></p><p>方差：<span class="math inline">\(\frac {(b-a)^2} {12}\)</span></p><h4 id="指数分布">指数分布</h4><p><span class="math inline">\(X\sim\mathbbE(\lambda)\)</span>，概率密度函数<spanclass="math inline">\(f(x)=\lambda e^{-\lambda x},x\gt 0,\lambda\gt0\)</span>。</p><ul><li>指数分布的无记忆性：<span class="math inline">\(P(X\gt s+t|X\gts)=P(X\gt t),\forall s,t\gt 0\)</span></li></ul><p>数学期望：<span class="math inline">\(\frac 1 {\lambda}\)</span></p><p>方差：<span class="math inline">\(\frac 1 {\lambda^2}\)</span></p><h4 id="正态分布">正态分布</h4><p><span class="math inline">\(X\sim\mathbbN(\mu,\sigma^2)\)</span>，概率密度函数<spanclass="math inline">\(f(x)=\frac{1}{\sqrt{2\pi\sigma}}e^{-\frac{(x-\mu)^2}{2\sigma^2}},-\infin\ltx\lt+\infin,\sigma\gt 0\)</span>。</p><p>数学期望：<span class="math inline">\(\mu\)</span></p><p>方差：<span class="math inline">\(\sigma^2\)</span></p><ul><li>正态分布的对称性</li><li>正态分布的标准化：<span class="math inline">\(Z=\frac{X-\mu}\sigma\)</span>，则<span class="math inline">\(Z\sim\mathbbN(0,1)\)</span>。</li></ul><p>二项分布正态逼近定理：<spanclass="math inline">\(\lim_{n\rightarrow\infin}\mathbb B(n,p)=\mathbbN(\mu,\sigma^2)\)</span></p><p>泊松分布正态逼近定理：<spanclass="math inline">\(\lim_{n\rightarrow\infin}\pi(\lambda)=\mathbbN(\mu,\sigma^2)\)</span></p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多元函数微分学</title>
    <link href="/2022/03/01/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/"/>
    <url>/2022/03/01/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>踏遍青山人未老，风景这边独好。</p><span id="more"></span><h1 id="四-多元函数微分学">四 多元函数微分学</h1><h2 id="多元函数极限与连续">1. 多元函数极限与连续</h2><h3 id="点集与多元函数">1.1 点集与多元函数</h3><ol type="1"><li><p>点集基本知识：<span class="math inline">\(N\)</span>维空间<spanclass="math inline">\(R_n\)</span></p><ul><li>距离：<spanclass="math inline">\(P_1(a_1,……,a_n),P_2(b_1,……,b_n)\)</span>之间的距离为<spanclass="math inline">\(\rho(P_1,P_2)=\Sigma_{i=1}^n\sqrt{(a_i-b_i)^2}\)</span></li><li>邻域：设<span class="math inline">\(P_0\in R_n,\delta\gt0\)</span>，<ul><li><span class="math inline">\(N_\delta(P_0)=U(P_0,\delta)=\{P:P\inR_n,\rho(P,P_0)&lt;\delta\}\)</span>为点<spanclass="math inline">\(P_0\)</span>的<spanclass="math inline">\(\delta\)</span>邻域，简称邻域。</li><li><span class="math inline">\(\dot N_\delta(P_0)=\dotU(P_0,\delta)=\{P:P\in R_n,0\lt\rho(P,P_0)\lt\delta\}\)</span>为点<spanclass="math inline">\(P_0\)</span>的去心<spanclass="math inline">\(\delta\)</span>邻域，简称去心邻域。</li></ul></li></ul><p>设<span class="math inline">\(G\subseteq R_n\)</span>，</p><p>内点、外点、边界点、聚点：</p><ul><li><span class="math inline">\(P_0\in G\)</span>，且存在<spanclass="math inline">\(\delta\gt0\)</span>，使得<spanclass="math inline">\(N_\delta(P_0)⊂G\)</span>，<spanclass="math inline">\(P_0\)</span>是<spanclass="math inline">\(G\)</span>的内点。<ul><li><span class="math inline">\(G\)</span>的内点的集合称为<spanclass="math inline">\(G\)</span>的内部。</li></ul></li><li><span class="math inline">\(P_0\notin G\)</span>，且存在<spanclass="math inline">\(\delta\gt0\)</span>，使得<spanclass="math inline">\(N_\delta(P_0)\cap G=\varnothing\)</span>，<spanclass="math inline">\(P_0\)</span>是<spanclass="math inline">\(G\)</span>的外点。<ul><li><span class="math inline">\(G\)</span>的内点的集合称为<spanclass="math inline">\(G\)</span>的外部。</li></ul></li><li><span class="math inline">\(P_0\in R_n\)</span>，且对任意的<spanclass="math inline">\(\delta\gt0\)</span>，<spanclass="math inline">\(N_\delta(P_0)\)</span>中既有点属于<spanclass="math inline">\(G\)</span>，又有点不属于<spanclass="math inline">\(G\)</span>，<spanclass="math inline">\(P_0\)</span>是<spanclass="math inline">\(G\)</span>的边界点。<ul><li><span class="math inline">\(G\)</span>的全部边界点的集合称为<spanclass="math inline">\(G\)</span>的边界，记为<spanclass="math inline">\(\partial A\)</span>。</li></ul></li><li><span class="math inline">\(P_0\in R_n\)</span>，且对任意的<spanclass="math inline">\(\delta\gt0\)</span>，<spanclass="math inline">\(\dot N_\delta(P_0)\)</span>中总有点属于<spanclass="math inline">\(G\)</span>，则称<spanclass="math inline">\(P_0\)</span>为<spanclass="math inline">\(G\)</span>的聚点。</li></ul><p>开集、闭集、连通集：</p><ul><li>若<span class="math inline">\(G\)</span>的所有点都是<spanclass="math inline">\(G\)</span>的内点，则称<spanclass="math inline">\(G\)</span>为开集。</li><li>若<span class="math inline">\(G\)</span>关于全集<spanclass="math inline">\(R_n\)</span>的补集是开集，则称<spanclass="math inline">\(G\)</span>为闭集。</li><li>如果点集<spanclass="math inline">\(G\)</span>内任意两点都可用曲线连接起来，且该曲线上的点都属于<spanclass="math inline">\(G\)</span>，则称<spanclass="math inline">\(G\)</span>为连通集。</li></ul><p>开区域、闭区域：</p><ul><li>若<span class="math inline">\(G\)</span>是开集且是连通集，则称<spanclass="math inline">\(G\)</span>为开区域。</li><li>若存在非空开区域<span class="math inline">\(A\)</span>，使得<spanclass="math inline">\(G = A\cap\partial A\)</span>，则称<spanclass="math inline">\(G\)</span>为闭区域。</li><li>开区域与闭区域统称区域。</li></ul><p>规定：空集既是开集又是闭集，全空间<spanclass="math inline">\(R_n\)</span>既是开集又是闭集。除此之外，<spanclass="math inline">\(R_n\)</span>的任何非空真子集都不可能既是开集又是闭集。</p><p>有界集：设<span class="math inline">\(G\subseteq R_n,P_0\inR_n\)</span>，若存在<span class="math inline">\(k\inR\)</span>，使得<span class="math inline">\(G\subN_k(P_0)\)</span>，则称<spanclass="math inline">\(G\)</span>为有界集。此时称<spanclass="math inline">\(d(G) = \sup{\rho(P_1,P_2)|\forall P_1,P_2\inG}\)</span>为<span class="math inline">\(G\)</span>的直径，否则，称<spanclass="math inline">\(G\)</span>为无界集。</p></li><li><p>多元函数：设<span class="math inline">\(D\inR_n\)</span>，称映射<span class="math inline">\(f：D\rightarrowR\)</span>为定义在<span class="math inline">\(D\)</span>上的<spanclass="math inline">\(n\)</span>元函数。</p><ul><li><span class="math inline">\(n\)</span>元函数也常常记为<spanclass="math inline">\(y=f(P),P\in D\)</span>，或<spanclass="math inline">\(y=f(x_1,……,x_n),(x_1,……,x_n)\in D\)</span>。</li><li>其中变量<spanclass="math inline">\(x_1,x_2,……,x_n\)</span>称为自变量，<spanclass="math inline">\(y\)</span>称为因变量，<spanclass="math inline">\(D\)</span>称为函数<spanclass="math inline">\(f\)</span>的定义域，记为<spanclass="math inline">\(D(f)\)</span>。</li><li><span class="math inline">\(f(D) = {f(P)|P\inD(f)}\)</span>称为函数<spanclass="math inline">\(f\)</span>的值域。</li></ul><p>对于由解析表达式给出的多元函数，常常并不明确表明定义域，此时多元函数的定义域理解为其自然定义域，即使这个解析表达式有意义时自变量的范围。</p></li></ol><h3 id="多元函数极限">1.2 多元函数极限</h3><ol type="1"><li><p>二重极限：设<span class="math inline">\(D\inR_2\)</span>，函数<span class="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\(D\)</span>上有定义，<spanclass="math inline">\(P_0(x_0,y_0)\)</span>是<spanclass="math inline">\(D\)</span>的聚点。</p><p>若存在常数<spanclass="math inline">\(A\)</span>，使得对于任意给定的正数<spanclass="math inline">\(\varepsilon\)</span>，总存在正数<spanclass="math inline">\(\delta\)</span>，当<spanclass="math inline">\(P(x,y)∈D\)</span>且<spanclass="math inline">\(0&lt;\rho(P,P_0)&lt;\delta\)</span>时，恒有<spanclass="math inline">\(|f(P) - A| = |f(x,y) -A|&lt;\varepsilon\)</span>，则称函数<spanclass="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\(P\rightarrow P_0\)</span>时以<spanclass="math inline">\(A\)</span>为极限。</p><ul><li>可推广一元函数极限的性质：<ul><li>四则运算</li><li>唯一性</li><li>局部保号性</li><li>夹逼准则</li></ul></li><li>二重极限的复杂性在于点<spanclass="math inline">\(P\)</span>在平面上可以多种方式趋近<spanclass="math inline">\(P_0\)</span>。若<spanclass="math inline">\(P\)</span>以不同方式趋近于<spanclass="math inline">\(P_0\)</span>，<spanclass="math inline">\(f(x,y)\)</span>趋向于不同的值，则认为<spanclass="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\(P_0\)</span>处的极限不存在。</li></ul></li><li><p>累次极限：对于二元函数<spanclass="math inline">\(f(x,y)\)</span>。</p><p>先固定变量<span class="math inline">\(y\)</span>，此时<spanclass="math inline">\(f(x,y)\)</span>只是<spanclass="math inline">\(x\)</span>的一元函数，如果对于一切固定的<spanclass="math inline">\(y\)</span>，极限<spanclass="math inline">\(\lim_{x\rightarrowx_0}f(x,y)\)</span>存在，则这个极限是与<spanclass="math inline">\(y\)</span>有关的函数，记为<spanclass="math inline">\(\varphi(y)\)</span>。然后再让<spanclass="math inline">\(y\)</span>趋于<spanclass="math inline">\(y_0\)</span>，若<spanclass="math inline">\(\lim_{y\rightarrowy_0}\varphi(y)\)</span>也存在，设为<spanclass="math inline">\(A\)</span>，则称<spanclass="math inline">\(A\)</span>为函数<spanclass="math inline">\(f(x,y)\)</span>在点<spanclass="math inline">\((x_0,y_0)\)</span>处先对<spanclass="math inline">\(x\)</span>后对<spanclass="math inline">\(y\)</span>的累次极限，记为<spanclass="math inline">\(\lim_{y\rightarrow y_0}\lim_{x\rightarrowx_0}f(x,y)=A\)</span>。</p><ul><li>二元函数的二重极限与累次极限是两个不同的概念。二重极限存在不能得出累次极限存在，累次极限存在也不能得出二重极限存在。</li><li>若二重极限和累次极限都存在，则两者必相等。</li></ul></li></ol><h3 id="多元函数连续性">1.3 多元函数连续性</h3><ol type="1"><li><p>设<span class="math inline">\(G\subseteq R_n\)</span>，函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>上有定义，<spanclass="math inline">\(P_0\)</span>是<spanclass="math inline">\(G\)</span>的聚点且<spanclass="math inline">\(P_0\in G\)</span>。若<spanclass="math inline">\(\lim_{P\rightarrowP_0}f(P)=f(P_0)\)</span>，则称函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(P_0\)</span>处连续。</p><ul><li>如果<spanclass="math inline">\(G\)</span>内的每一点都是聚点，且<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>的每一点都连续，则称<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>上连续。</li><li>如果函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(P_0\)</span>处不连续，则称函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(P_0\)</span>处间断，并称<spanclass="math inline">\(P_0\)</span>是函数<spanclass="math inline">\(f\)</span>的间断点。</li></ul></li><li><p>若<span class="math inline">\(f\)</span>为二元函数<spanclass="math inline">\(z=f(x,y)\)</span>，记<spanclass="math inline">\(\Delta x=x-x_0,\Delta y=y-y_0,\Deltaz=f(x,y)-f(x_0,y_0)\)</span>。称<span class="math inline">\(\Deltaz\)</span>为函数<span class="math inline">\(z=f(x,y)\)</span>在点<spanclass="math inline">\((x_0,y_0)\)</span>处的全增量。</p><ul><li><span class="math inline">\(f(x,y)\)</span>在点<spanclass="math inline">\((x_0,y_0)\)</span>处连续等价于<spanclass="math inline">\(\Delta x\rightarrow0\)</span>，<spanclass="math inline">\(\Delta y\rightarrow 0\)</span>时<spanclass="math inline">\(\Delta z\)</span>的极限为0。</li></ul></li><li><p>有限个多元连续函数的和、差、积、商(分母不为0)仍是连续函数。</p><p>多元连续函数的复合函数仍是连续函数，多元连续函数在其定义域上的每一点都连续。</p></li><li><p>有界闭区域上多元连续函数的性质：设<spanclass="math inline">\(G\in R_n\)</span>为有界闭区域，函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>上连续</p><ul><li>零点定理：若<span class="math inline">\(P_1,P_2\inG\)</span>，且<spanclass="math inline">\(f(P_1)f(P_2)&lt;0\)</span>，则存在<spanclass="math inline">\(P_0\in G,f(P_0)=0\)</span>。</li><li>介值定理：若<span class="math inline">\(P_1,P_2\in G\)</span>，<spanclass="math inline">\(f(P_1) \neq f(P_2)\)</span>，设<spanclass="math inline">\(\mu\)</span>为满足<spanclass="math inline">\(f(P_1)&lt;\mu&lt;f(P_2)\)</span>的任意实数，则存在<spanclass="math inline">\(P_0\in G\)</span>，使得<spanclass="math inline">\(f(P_0)=𝜇\)</span>。</li><li>有界性定理：函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>上有界。</li><li>最值定理：函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>上有最值。</li></ul></li></ol><h2 id="偏导数与全微分">2. 偏导数与全微分</h2><h3 id="偏导数">2.1 偏导数</h3><ol type="1"><li><p>偏导数：设<span class="math inline">\(P(x_0,y_0)\inR_2\)</span>，函数<span class="math inline">\(z=f(x,y)\)</span>在<spanclass="math inline">\(P_0\)</span>的<spanclass="math inline">\(\delta\)</span>邻域内有定义，</p><p>若<span class="math inline">\(\lim_{\Delta x\rightarrow0}\frac{f(x_0+\Delta x,y_0) - f(x_0,y_0)}{\Deltax}\)</span>存在，称其为<spanclass="math inline">\(z=f(x,y)\)</span>在点<spanclass="math inline">\((x_0,y_0)\)</span>处对<spanclass="math inline">\(x\)</span>的偏导数<spanclass="math inline">\(f&#39;_x(x_0,y_0)\)</span>。</p><p>类似可得函数<span class="math inline">\(z=f(x,y)\)</span>在点<spanclass="math inline">\((x_0,y_0)\)</span>处对<spanclass="math inline">\(y\)</span>的偏导数<spanclass="math inline">\(f&#39;_y(x_0,y_0)\)</span>。</p><ul><li>偏导数也可记为<span class="math inline">\(\frac{\partial z}{\partialx}\)</span>等。</li></ul></li><li><p>若二元函数<span class="math inline">\(f(x,y)\)</span>在点<spanclass="math inline">\((x_0,y_0)\)</span>处对<spanclass="math inline">\(x\)</span>及对<spanclass="math inline">\(y\)</span>的两个偏导数都存在，则称<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\((x_0,y_0)\)</span>处可偏导。</p><ul><li>若二元函数<span class="math inline">\(f(x,y)\)</span>在开区域<spanclass="math inline">\(G\)</span>中的每一点均可偏导，则称<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>上可偏导。</li></ul></li><li><p>可偏导和连续的关系：设函数<spanclass="math inline">\(z=f(x,y)\)</span>在<spanclass="math inline">\(P_0(x_0,y_0)\)</span>的某邻域<spanclass="math inline">\(N_\delta(P_0)\)</span>内可偏导，且<spanclass="math inline">\(f’_x(x,y),f’_y(x,y)\)</span>在<spanclass="math inline">\(N_\delta(P_0)\)</span>内有界，则函数<spanclass="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\(P_0\)</span>处连续。</p></li><li><p>高阶偏导数：函数<spanclass="math inline">\(z=f(x,y)\)</span>的偏导数<spanclass="math inline">\(f’_x(x,y),f’_y(x,y)\)</span>如果可以继续对<spanclass="math inline">\(x\)</span>或<spanclass="math inline">\(y\)</span>求偏导数，则可得到四个新的偏导数<spanclass="math inline">\(f&#39;&#39;_{xx},f&#39;&#39;_{xy},f&#39;&#39;_{yx},f&#39;&#39;_{yy}\)</span>，称为二阶偏导数。</p><ul><li>其中<spanclass="math inline">\(f’&#39;_{xy},f’’_{yx}\)</span>称为二阶混合偏导数，二阶以上的偏导数统称为高阶偏导数。</li><li>若二阶混合偏导数<spanclass="math inline">\(f’’_xy(x,y),f’’_yx(x,y)\)</span>在<spanclass="math inline">\((x,y)\)</span>处都连续，则两者相等。<ul><li>二阶混合偏导数在连续的条件下与求导的次序无关。</li></ul></li><li>二阶偏导数也可记为<span class="math inline">\(\frac{\partial^2z}{\partial x^2},\frac{\partial^2 z}{\partial x\partialy}\)</span>等。</li></ul></li></ol><h3 id="全微分">2.2 全微分</h3><ol type="1"><li><p>全微分：设函数<spanclass="math inline">\(z=f(x,y)\)</span>在点<spanclass="math inline">\(P(x,y)\)</span>的某邻域内有定义，若函数在点<spanclass="math inline">\(P\)</span>的全增量可表示为<spanclass="math inline">\(\Delta z=A\Delta x+B\Deltay+o(\rho)\)</span>，其中<spanclass="math inline">\(A,B\)</span>仅与点<spanclass="math inline">\((x,y)\)</span>有关而与增量<spanclass="math inline">\(\Delta x,\Delta y\)</span>无关。</p><p><span class="math inline">\(\rho=\sqrt{(\Delta x)^2+(\Deltay)^2}\)</span>，<spanclass="math inline">\(\rho\rightarrow0_+\)</span>，则称函数<spanclass="math inline">\(f(x,y)\)</span>在点<spanclass="math inline">\((x,y)\)</span>处可微，其线性部分<spanclass="math inline">\(A\Delta x+B\Delta y\)</span>称为函数<spanclass="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\((x,y)\)</span>处的全微分，记为<spanclass="math inline">\(dz=A\Delta x+B\Delta y\)</span>。</p></li><li><p>可微、连续、可偏导之间关系：</p><p>函数<span class="math inline">\(z=f(x,y)\)</span>在<spanclass="math inline">\((x,y)\)</span>处可微，则<spanclass="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\((x,y)\)</span>处连续且可偏导，且<spanclass="math inline">\(dz=\frac{∂z}{∂x}dx+\frac{∂z}{∂y}dy\)</span>。</p><ul><li><p>连续和可偏导是可微的必要条件，但不是充分条件。</p></li><li><p>函数可微的一个充分条件：</p><p><span class="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\((x,y)\)</span>的某邻域可偏导，且<spanclass="math inline">\(f’_x(x,y),f’_y(x,y)\)</span>在<spanclass="math inline">\((x,y)\)</span>连续，则<spanclass="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\((x,y)\)</span>可微。</p></li></ul></li><li><p>连续可微：</p><p><span class="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\((x,y)\)</span>的某邻域可偏导，且<spanclass="math inline">\(f’_x(x,y),f’_y(x,y)\)</span>在<spanclass="math inline">\((x,y)\)</span>连续，则称<spanclass="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\((x,y)\)</span>连续可微。</p><ul><li>若<span class="math inline">\(f(x,y)\)</span>在开区域<spanclass="math inline">\(G\)</span>上每一点都连续可微，则称函数<spanclass="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\(G\)</span>上连续可微。</li></ul></li><li><p>高阶微分：</p><p>函数<spanclass="math inline">\(z=f(x,y)\)</span>的全微分一般仍是<spanclass="math inline">\(x,y\)</span>的二元函数，若二元函数<spanclass="math inline">\(dz\)</span>可微，称<spanclass="math inline">\(z=f(x,y)\)</span>二阶可微，称<spanclass="math inline">\(dz\)</span>的全微分是函数<spanclass="math inline">\(z=f(x,y)\)</span>的二阶微分，记为<spanclass="math inline">\(d^2 z\)</span>。</p><p>若<span class="math inline">\(d^{n-1} z\)</span>可微，则称函数<spanclass="math inline">\(z=f(x,y)\)</span>为n阶可微，称<spanclass="math inline">\(d^{n-1}\)</span>的全微分为函数的<spanclass="math inline">\(n\)</span>阶微分，记为<spanclass="math inline">\(d^n z\)</span>。</p></li></ol><h3 id="微分法则">2.3 微分法则</h3><ol type="1"><li><p>四则运算：</p><ul><li><span class="math inline">\(d(u\pm v)=du\pm dv\)</span></li><li><span class="math inline">\(d(uv)=du·dv\)</span></li><li><span class="math inline">\(d(\frac uv)=\frac{du}{dv}\)</span></li></ul></li><li><p>复合函数：链式法则</p><p>设<span class="math inline">\(u=f(x,y),v=g(x,y)\)</span>在点<spanclass="math inline">\((x,y)\)</span>处可偏导，<spanclass="math inline">\(z=h(u,v)\)</span>在对应的点<spanclass="math inline">\((u,v)\)</span>处可微，则：</p><p><span class="math inline">\(z=h(f(x,y),g(x,y))\)</span>在点<spanclass="math inline">\((x,y)\)</span>处可偏导，且<spanclass="math inline">\(\frac{\partial z}{\partial x}=\frac{\partialz}{\partial u}\frac{\partial u}{\partial x}+\frac{\partial z}{\partialv}\frac{\partial v}{\partial x},\frac{\partial z}{\partialy}=\frac{\partial z}{\partial u}\frac{\partial u}{\partialy}+\frac{\partial z}{\partial v}\frac{\partial v}{\partialy}\)</span>。</p><ul><li><p>一阶全微分的形式不变性：</p><p>设函数<span class="math inline">\(u=f(x,y),v=g(x,y)\)</span>在点<spanclass="math inline">\((x,y)\)</span>处可微，函数<spanclass="math inline">\(z=h(u,v)\)</span>在对应的点<spanclass="math inline">\((u,v)\)</span>处可微，则复合函数<spanclass="math inline">\(z=f(u,v)\)</span>在点<spanclass="math inline">\((x,y)\)</span>处的全微分仍可表示为<spanclass="math inline">\(dz=\frac{\partial z}{\partial u}du+\frac{\partialz}{\partial v}dv\)</span>。</p><p>无论<spanclass="math inline">\(u,v\)</span>是自变量还是中间变量，函数<spanclass="math inline">\(z=f(u,v)\)</span>的一阶全微分的形式是一样的。</p></li></ul></li><li><p>隐函数：</p><ul><li><p>方程确定隐函数：</p><p>给定方程<spanclass="math inline">\(F(x_1,x_2,……,x_n,y)=0\)</span>，其中<spanclass="math inline">\((x_1,……,x_n)\in D\subseteq R,y\in I\subseteqR\)</span>。</p><p>若对于<span class="math inline">\(D\)</span>中的每一点<spanclass="math inline">\(X\)</span>，都有唯一确定的<spanclass="math inline">\(y\)</span>值与之对应，使得方程<spanclass="math inline">\(F(x_1,x_2,……,x_n,y)=0\)</span>恒成立，则称方程确定了一个定义在<spanclass="math inline">\(D\)</span>上的隐函数。</p></li><li><p>方程组确定隐函数组：</p><p><spanclass="math inline">\(\begin{cases}F_1(x_1,...,x_n,y_1,...,y_m)=0\\...\\F_m(x_1,...,x_n,y_1,...,y_m)=0\end{cases},(x_1,……,x_n)\in D\subseteq R_n,(y_1,……,y_n)\in G\subseteqR\)</span>。</p><p>若对于<span class="math inline">\(D\)</span>中的每一点<spanclass="math inline">\(X\)</span>，都有唯一确定的<spanclass="math inline">\(Y(y_1,……,y_n)\)</span>与之对应，满足上述方程组，则称方程组确定了一个定义在<spanclass="math inline">\(D\)</span>上的隐函数组。</p></li></ul><p>隐函数存在定理</p><ul><li><p><span class="math inline">\(F(x,y)=0\)</span>确定隐函数<spanclass="math inline">\(y=f(x)\)</span>，<spanclass="math inline">\(F&#39;_y(x,y)\neq0\)</span>，有<spanclass="math inline">\(\frac{dy}{dx}=-\frac{F&#39;_x(x,y)}{F&#39;_y(x,y)}\)</span></p></li><li><p><span class="math inline">\(F(x,y,z)=0\)</span>确定隐函数<spanclass="math inline">\(z=f(x,y)\)</span>，<spanclass="math inline">\(F&#39;_z(x,y,z)\neq0\)</span>，有<spanclass="math inline">\(\frac{\partial z}{\partialx}=-\frac{F&#39;_x(x,y,z)}{F&#39;_z(x,y,z)},\frac{\partial z}{\partialy}=-\frac{F&#39;_y(x,y,z)}{F&#39;_z(x,y,z)}\)</span></p></li><li><p>设<span class="math inline">\(P_0=(x_0,y_0,u_0,v_0)\inR^4,G=N_\delta(P_0)\)</span>，假设</p><ul><li>函数<span class="math inline">\(F,H\)</span>在<spanclass="math inline">\(G\)</span>上连续可微</li><li><spanclass="math inline">\(F(P_0)=F(x_0,y_0,u_0,v_0)=0,H(P_0)=H(x_0,y_0,u_0,v_0)=0\)</span></li><li>雅可比行列式<spanclass="math inline">\(\frac{D(F,H)}{D(u,v)}|_{P_0}=\left|\begin{matrix}F&#39;_u&amp; F&#39;_v\\H&#39;_u&amp;H&#39;_v \end{matrix}\right|\)</span></li></ul><p>则存在<spanclass="math inline">\(U={(x,y)||x-x_0|&lt;h,|y-y_0|&lt;k}\)</span>和唯一一组函数<spanclass="math inline">\(u=u(x,y),v=v(x,y)\)</span>，使得</p><ul><li><p>对任意<span class="math inline">\((x,y)\inU,F(x,y,u,v)=0,H(x,y,u,v)=0\)</span></p></li><li><p><spanclass="math inline">\(u(x_0,y_0)=u_0,v(x_0,y_0)=v_0\)</span></p></li><li><p>函数<spanclass="math inline">\(u(x,y),v(x,y)\)</span>连续可微，且当<spanclass="math inline">\((x,y)\in U\)</span>时有</p><p><span class="math inline">\(\frac{\partial u}{\partialx}=-\frac{\frac{D(F,H)}{D(x,v)}}{\frac{D(F,H)}{D(u,v)}},\frac{\partialu}{\partialy}=-\frac{\frac{D(F,H)}{D(y,v)}}{\frac{D(F,H)}{D(u,v)}},\frac{\partialv}{\partialx}=-\frac{\frac{D(F,H)}{D(u,x)}}{\frac{D(F,H)}{D(u,v)}},\frac{\partialv}{\partialy}=-\frac{\frac{D(F,H)}{D(u,y)}}{\frac{D(F,H)}{D(u,v)}}\)</span></p></li></ul></li></ul></li></ol><h3 id="极值与最值">2.4 极值与最值</h3><ol type="1"><li><p>二元函数的极值</p><p>设函数在区域<span class="math inline">\(G\)</span>中有定义，<spanclass="math inline">\(P_0\)</span>是<spanclass="math inline">\(G\)</span>的内点。若存在<spanclass="math inline">\(P_0\)</span>的<spanclass="math inline">\(\delta\)</span>去心邻域<spanclass="math inline">\(D\subseteq G\)</span>，使得当<spanclass="math inline">\(P\in D\)</span>时，恒有<spanclass="math inline">\(f(P)\le f(P_0)\)</span> 或<spanclass="math inline">\(f(P)\ge f(P_0)\)</span>，则称<spanclass="math inline">\(f(P_0)\)</span>是函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>上的极大值或极小值，统称为极值。</p><ul><li>称<span class="math inline">\(P_0\)</span>为函数<spanclass="math inline">\(f\)</span>的极大/小值点，统称极值点。</li><li>当上述<span class="math inline">\(\le/\ge\)</span>改为<spanclass="math inline">\(&lt;/&gt;\)</span>，称<spanclass="math inline">\(f(P_0)\)</span>为函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>上的严格极大值/极小值。</li></ul></li><li><p>极值的必要条件：<span class="math inline">\(f\)</span>在<spanclass="math inline">\((x_0,y_0)\)</span>可偏导，<spanclass="math inline">\(f(x_0,y_0)\)</span>是函数<spanclass="math inline">\(f\)</span>的极值，则<spanclass="math inline">\(f’_x(x_0,y_0)=f’_y(x_0,y_0)=0\)</span>。</p><ul><li>驻点：<span class="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\((x_0,y_0)\)</span>可偏导，<spanclass="math inline">\(f’_x(x_0,y_0)=f’_y(x_0,y_0)=0\)</span>，则称<spanclass="math inline">\((x_0,y_0)\)</span>是函数<spanclass="math inline">\(f\)</span>的驻点。</li><li>可微函数只能在驻点取极值，函数在不可偏导点也可取极值，这两类点统称为函数的可疑极值点。</li></ul></li><li><p>极值判别法：</p><ul><li><p>设<spanclass="math inline">\(P_0(x_0,y_0)∈R^2,G=N_\delta(P_0)\)</span>，<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>内连续，在<spanclass="math inline">\(P_0\)</span>的<spanclass="math inline">\(\delta\)</span>去心邻域<spanclass="math inline">\(U\)</span>内连续可微，</p><p>记<spanclass="math inline">\(\mu(x,y)=f&#39;_x(x,y)(x-x_0)+f&#39;_y(x,y)(y-y_0)\)</span>。</p><ul><li><span class="math inline">\(\forall(x,y)\inU,\mu(x,y)\gt0\)</span>，则<spanclass="math inline">\(f(x_0,y_0)\)</span>为极小值。</li><li><span class="math inline">\(\forall(x,y)\inU,\mu(x,y)\lt0\)</span>，则<spanclass="math inline">\(f(x_0,y_0)\)</span>为极大值。</li></ul></li><li><p>设<span class="math inline">\(P_0(x_0,y_0)\inR^2,G=N_\delta(P_0)\)</span>，<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>内二阶连续可微，且<spanclass="math inline">\(f’_x(x_0,y_0)=f’_y(x_0,y_0)=0\)</span>，</p><p>令<spanclass="math inline">\(A=f&#39;&#39;_{xx}(x_0,y_0),B=f&#39;&#39;_{xy}(x_0,y_0),C=f&#39;&#39;_{yy}(x_0,y_0)\)</span></p><ul><li>若<span class="math inline">\(B^2-AC\lt0\)</span>，<ul><li><span class="math inline">\(A\lt0\)</span>，<spanclass="math inline">\(f(x_0,y_0)\)</span>为极大值。</li><li><span class="math inline">\(A\gt0\)</span>，<spanclass="math inline">\(f(x_0,y_0)\)</span>为极小值。</li></ul></li><li>若<span class="math inline">\(B^2-AC\gt0\)</span>，<spanclass="math inline">\(f(x_0,y_0)\)</span>不是极值。</li><li>若<span class="math inline">\(B^2-AC=0\)</span>，<spanclass="math inline">\(f(x_0,y_0)\)</span>不一定是极值。</li></ul></li></ul></li><li><p>二元函数的最值：</p><p>设函数在区域<span class="math inline">\(G\)</span>中有定义，<spanclass="math inline">\(P_0\)</span>是<spanclass="math inline">\(G\)</span>的内点。若当<spanclass="math inline">\(P\in G\)</span>时，恒有<spanclass="math inline">\(f(P)\le f(P_0)\)</span> 或<spanclass="math inline">\(f(P)\ge f(P_0)\)</span>，则称<spanclass="math inline">\(f(P_0)\)</span>是函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(G\)</span>上的最大值或最小值，统称为最值。</p><ul><li>称<span class="math inline">\(P_0\)</span>为函数<spanclass="math inline">\(f\)</span>的最大/小值点，统称最值点。</li><li>函数的最值点只可能在边界或驻点处。</li></ul></li><li><p>条件最值：拉格朗日乘数法</p><p>设函数<spanclass="math inline">\(f(x,y,z)\)</span>连续可微，函数<spanclass="math inline">\(\varphi(x,y,z)\)</span>连续可微，且<spanclass="math inline">\(\varphi&#39;_z\neq0\)</span>，函数<spanclass="math inline">\(f(x,y,z)\)</span>满足约束方程<spanclass="math inline">\(\varphi(x,y,z)=0\)</span>的条件极值在<spanclass="math inline">\(P_0(x_0,y_0,z_0)\)</span>处取得，令<spanclass="math inline">\(F(x,y,z,𝜆)=f(x,y,z)+𝜆\varphi(x,y,z)\)</span>（拉格朗日函数，<spanclass="math inline">\(\lambda\)</span>为拉格朗日乘数），则<spanclass="math inline">\(P_0\)</span>满足下列方程组：</p><p><spanclass="math inline">\(\begin{cases}F_x&#39;=f_x&#39;(x,y,z)+\lambda\varphi_x&#39;(x,y,z)=0\\F_y&#39;=f_y&#39;(x,y,z)+\lambda\varphi_y&#39;(x,y,z)=0\\F_z&#39;=f_z&#39;(x,y,z)+\lambda\varphi_z&#39;(x,y,z)=0\\F_\lambda&#39;=\varphi(x,y,z)=0\end{cases}\)</span></p><ul><li>若再添一条约束方程<spanclass="math inline">\(\psi(x,y,z)=0\)</span>，则拉格朗日函数为<spanclass="math inline">\(F(x,y,z,\lambda,\gamma)=f(x,y,z)+\lambda\varphi(x,y,z)+\gamma\psi(x,y,z)\)</span>。</li></ul></li></ol><h2 id="几何应用">3. 几何应用</h2><ol type="1"><li><p>空间曲线的切线和法平面：</p><p>设有空间曲线<span class="math inline">\(C\)</span>，<spanclass="math inline">\(P_0\)</span>是曲线<spanclass="math inline">\(C\)</span>上一定点，<spanclass="math inline">\(P\)</span>是曲线上一动点，作割线<spanclass="math inline">\(P_0P\)</span>，当<spanclass="math inline">\(P\)</span>沿着曲线<spanclass="math inline">\(C\)</span>无限地接近<spanclass="math inline">\(P_0\)</span>时，若割线<spanclass="math inline">\(P_0P\)</span>的极限位置存在，对应的直线记为<spanclass="math inline">\(L\)</span>，我们称直线<spanclass="math inline">\(L\)</span>为曲线<spanclass="math inline">\(C\)</span>在点<spanclass="math inline">\(P_0\)</span>处的切线。</p><ul><li><p>通过点<span class="math inline">\(P_0\)</span>且与切线<spanclass="math inline">\(L\)</span>垂直的平面，称为曲线<spanclass="math inline">\(C\)</span>在<spanclass="math inline">\(P_0\)</span>的法平面。</p></li><li><p>切线<span class="math inline">\(L\)</span>的方向向量称为曲线<spanclass="math inline">\(C\)</span>在点<spanclass="math inline">\(P_0\)</span>的切向量。</p></li></ul><p>计算：</p><ul><li><p>曲线<span class="math inline">\(C\)</span>方程为<spanclass="math inline">\(x=\varphi(t),y=\psi(t),z=\omega(t),t\in[a,b]\)</span>，<spanclass="math inline">\(x,y,z\)</span>在<spanclass="math inline">\(t=t_0\)</span>均可导，导数不全为0。</p><p>曲线<span class="math inline">\(C\)</span>在点<spanclass="math inline">\(P_0\)</span>处的切线方程为<spanclass="math inline">\(\frac{x-\varphi(t_0)}{\varphi&#39;(t_0)}=\frac{y-\psi(t_0)}{\psi&#39;(t_0)}=\frac{z-\omega(t_0)}{\omega&#39;(t_0)}\)</span>。</p><p>法平面方程为<spanclass="math inline">\(\varphi&#39;(t_0)(x-\varphi(t_0))+\psi&#39;(t_0)(y-\psi(t_0))+\omega&#39;(t_0)(z-\omega(t_0))\)</span>。</p></li><li><p>曲线<span class="math inline">\(C\)</span>的一般式方程为<spanclass="math inline">\(\begin{cases}F(x,y,z)=0\\H(x,y,z)=0\end{cases}\)</span>，<spanclass="math inline">\(F,H\)</span>连续可微，且<spanclass="math inline">\(\frac{D(F,H)}{D(y,z)},\frac{D(F,H)}{D(x,y)},\frac{D(F,H)}{D(x,z)}\)</span>不全为0。</p><p>曲线<span class="math inline">\(C\)</span>在点<spanclass="math inline">\(P_0(x_0,y_0,z_0)\)</span>的切线方程为<spanclass="math inline">\(\frac{x-x_0}{\frac{D(F,H)}{D(y,z)}|_{P_0}}=\frac{y-y_0}{\frac{D(F,H)}{D(z,x)}|_{P_0}}=\frac{z-z_0}{\frac{D(F,H)}{D(x,y)}|_{P_0}}\)</span>。</p><p>法平面方程为<spanclass="math inline">\(\frac{D(F,H)}{D(y,z)}|_{P_0}(x-x_0)+\frac{D(F,H)}{D(z,x)}|_{P_0}(y-y_0)+\frac{D(F,H)}{D(x,y)}|_{P_0}(z-z_0)=0\)</span>。</p></li></ul></li><li><p>空间曲面的切平面和法线：</p><p>设有空间曲面<span class="math inline">\(S\)</span>，<spanclass="math inline">\(P_0\)</span>是曲面<spanclass="math inline">\(S\)</span>上一定点，<spanclass="math inline">\(C\)</span>是曲面<spanclass="math inline">\(S\)</span>上通过点<spanclass="math inline">\(P_0\)</span>的任意一条光滑曲线，如果曲线<spanclass="math inline">\(S\)</span>在点<spanclass="math inline">\(P_0\)</span>的切线总保持在某一平面II上，则称平面II是曲面<spanclass="math inline">\(S\)</span>在点<spanclass="math inline">\(P_0\)</span>的切平面。</p><ul><li><p>通过点<spanclass="math inline">\(P_0\)</span>且与切平面垂直的直线称为曲面<spanclass="math inline">\(S\)</span>在点<spanclass="math inline">\(P_0\)</span>的法线。</p></li><li><p>切平面II的法向量称为曲面<spanclass="math inline">\(S\)</span>在点<spanclass="math inline">\(P_0\)</span>的法向量。</p></li><li><p>每一点都存在切平面和法线的曲面称为光滑曲面。</p></li></ul><p>计算：</p><ul><li><p>设空间曲面<spanclass="math inline">\(S\)</span>的一般式方程为<spanclass="math inline">\(F(x,y,z)=0\)</span>，这里<spanclass="math inline">\(F\)</span>连续可微，且<spanclass="math inline">\(F’_x,F’_y,F’_z\)</span>不全为0。</p><p>曲面<span class="math inline">\(S\)</span>在点<spanclass="math inline">\(P_0\)</span>的切平面方程为<spanclass="math inline">\(F_x&#39;(P_0)(x-x_0)+F_y&#39;(P_0)(y-y_0)+F_z&#39;(P_0)(z-z_0)=0\)</span>。</p><p>法线方程为<spanclass="math inline">\(\frac{x-x_0}{F_x&#39;(P_0)}=\frac{y-y_0}{F_y&#39;(P_0)}=\frac{z-z_0}{F_z&#39;(P_0)}\)</span>。</p></li></ul></li></ol><h2 id="二重积分">4. 二重积分</h2><h3 id="概念和性质">4.1 概念和性质</h3><ol type="1"><li><p>二重积分：</p><p>设函数<spanclass="math inline">\(f(x,y)\)</span>在平面有界闭区域<spanclass="math inline">\(D\)</span>上有定义，将区域<spanclass="math inline">\(D\)</span>任意地分割为<spanclass="math inline">\(n\)</span>个小闭区域<spanclass="math inline">\(D_i\)</span>，其中<spanclass="math inline">\(i=1,2,……,n\)</span>，<spanclass="math inline">\(D_i\)</span>的面积记为<spanclass="math inline">\(\Delta\sigma_i\)</span>，记<spanclass="math inline">\(\lambda=\max\{D_i的直径(1\le i\len)\}\)</span>，在每一个小闭区域<spanclass="math inline">\(D_i\)</span>上任取一点<spanclass="math inline">\((\xi_i,\eta_i)\)</span>，作和式<spanclass="math inline">\(\Sigma_{i=1}^nf(\xi_i,\eta_i)\Delta\sigma_i\)</span>，若<spanclass="math inline">\(\lambda\rightarrow0\)</span>，该式的极限存在，则称<spanclass="math inline">\(f(x,y)\)</span>在区域<spanclass="math inline">\(D\)</span>上黎曼可积，称此极限为<spanclass="math inline">\(f(x,y)\)</span>在区域<spanclass="math inline">\(D\)</span>上的二重积分，记为<spanclass="math inline">\(\iint_Df(x,y)d\sigma\)</span>。</p><ul><li>称<span class="math inline">\(f(x,y)\)</span>为被积函数，<spanclass="math inline">\(D\)</span>为积分区域，<spanclass="math inline">\(d\sigma\)</span>为面积微元。</li></ul></li><li><p>二重积分的可积条件：</p><ul><li>函数<span class="math inline">\(f(x,y)\)</span>在有界闭区域<spanclass="math inline">\(D\)</span>上连续，则函数<spanclass="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\(D\)</span>上可积。</li><li>函数<span class="math inline">\(f(x,y)\)</span>在有界闭区域<spanclass="math inline">\(D\)</span>上有界，<spanclass="math inline">\(f(x,y)\)</span>的间断点分布在<spanclass="math inline">\(D\)</span>内有限条光滑曲线上，则函数<spanclass="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\(D\)</span>上可积。</li></ul></li><li><p>二重积分的性质：<span class="math inline">\(D\subR^2\)</span>为有界闭区域</p><ul><li><p><spanclass="math inline">\(\iint_Dd\sigma=\sigma(D)\)</span>，这里<spanclass="math inline">\(\sigma(D)\)</span>表示<spanclass="math inline">\(D\)</span>的面积。</p></li><li><p>线性性质：<span class="math inline">\(\iint_D(k_1f(x,y)\pmk_2g(x,y))d\sigma=k_1\iint_Df(x,y)d\sigma\pmk_2\iint_Dg(x,y)d\sigma\)</span>。</p></li><li><p>积分区域可加性：<spanclass="math inline">\(D=D_1+D_2\)</span>，则<spanclass="math inline">\(\iint_Df(x,y)d\sigma=\iint_{D_1}f(x,y)d\sigma+\iint_{D_2}f(x,y)d\sigma\)</span>。</p></li><li><p>保向性：<span class="math inline">\(\forall x\inD\)</span>有<span class="math inline">\(f(x,y)\leg(x,y)\)</span>，则<spanclass="math inline">\(\iint_Df(x,y)d\sigma\le\iint_Dg(x,y)d\sigma\)</span>。</p></li><li><p>估值性：<span class="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\(D\)</span>的最大值<spanclass="math inline">\(M\)</span>，最小值<spanclass="math inline">\(m\)</span>，则<spanclass="math inline">\(m\le\frac1{\sigma(D)}\iint_Df(x,y)d\sigma\leM\)</span>。</p></li><li><p>绝对值：<spanclass="math inline">\(|\iint_Df(x,y)d\sigma|\le\iint_D|f(x,y)|d\sigma\)</span></p></li><li><p>中值定理:</p><p>设<span class="math inline">\(D\subseteqR^2\)</span>是有界闭区域，函数<spanclass="math inline">\(f(x,y),g(x,y)\)</span>在<spanclass="math inline">\(D\)</span>上连续，且对任意<spanclass="math inline">\((x,y)\in D,g(x,y)\ge0\)</span>(或<spanclass="math inline">\(g(x,y)\le0\)</span>)，则存在<spanclass="math inline">\((\xi,\eta)\in D\)</span>，使得<spanclass="math inline">\(\iint_Df(x,y)g(x,y)d\sigma=f(\xi,\eta)\iint_Dg(x,y)d\sigma\)</span>。</p></li><li><p>对称性：设<span class="math inline">\(D\)</span>关于<spanclass="math inline">\(x=0\)</span>对称</p><ul><li><p>如果函数<span class="math inline">\(f(x,y)\)</span>关于<spanclass="math inline">\(x\)</span>为奇函数，则<spanclass="math inline">\(\iint_D f(x,y)d\sigma=0\)</span>。</p></li><li><p>如果函数<span class="math inline">\(f(x,y)\)</span>关于<spanclass="math inline">\(x\)</span>为偶函数，则<spanclass="math inline">\(\iint_Df(x,y)d\sigma=2\iint_{D_{x\ge0}}f(x,y)d\sigma\)</span>。</p></li></ul></li><li><p>轮换对称性：区域<span class="math inline">\(D\)</span>关于<spanclass="math inline">\(y=x\)</span>对称，则对换<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(y\)</span>，积分值不变。</p></li></ul></li></ol><h3 id="计算">4.2 计算</h3><ol type="1"><li>累次积分：<ul><li>先对<span class="math inline">\(y\)</span>，后对<spanclass="math inline">\(x\)</span>：<spanclass="math inline">\(\iint_Df(x,y)dxdy=\int_a^bdx\int_{\varphi_1(x)}^{\varphi_2(x)}f(x,y)dy\)</span></li><li>先对<span class="math inline">\(x\)</span>，后对<spanclass="math inline">\(y\)</span>：<spanclass="math inline">\(\iint_Df(x,y)dxdy=\int_c^ddy\int_{\psi_1(y)}^{\psi_2(y)}f(x,y)dx\)</span></li></ul></li><li>换元积分：<spanclass="math inline">\(\iint_Df(x,y)d\sigma=\iint_{D&#39;}f(x(u,v),y(u,v))|J(u,v)|dudv\)</span>。<ul><li>其中雅可比行列式<spanclass="math inline">\(J(u,v)=\frac{D(x,y)}{D(u,v)}=\left|\begin{matrix}x&#39;_u&amp;x&#39;_v\\y&#39;_u&amp;y&#39;_v\end{matrix}\right|\neq0\)</span>。</li><li>常用换元积分：<spanclass="math inline">\(x=\rho\cos\theta,y=\rho\sin\theta,J(\rho,\theta)=\rho\)</span>。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>微积分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_1_基础知识</title>
    <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_1-基础知识">DataScience_1 基础知识</h1><h2 id="dikw模型">1.1 DIKW模型</h2><p>原始观察获得数据，分析数据获得信息，实践应用产生知识，智慧则凭借已有知识预测未来。</p><ol type="1"><li>数据：自然世界抽象为集合元素的表示。</li></ol><p>在实际应用中，采用某种数学元素作为数据的抽象表示<spanclass="math inline">\(d\)</span>，数据集为相应的集合<spanclass="math inline">\(\mathcal{D}\)</span>。</p><ol start="2" type="1"><li>信息：数据赋予某种结构获得信息<spanclass="math inline">\(\mathcal{I}=\mathcal{S}(\mathcalD)\)</span>。</li></ol><p>信息通常能被人类所理解，被用来消除不确定性。</p><p>常见的数学结构包括序结构、代数结构、拓扑结构等等。</p><ol start="3" type="1"><li>知识：信息和规则的二元组<span class="math inline">\(\mathcalK=&lt;\mathcal I,\mathcal R&gt;\)</span>。</li></ol><p>信息和规则结合获得知识，并且能够推理出更多知识。</p><p>知识推理从方式上可分为演绎推理和归纳推理；从单调性上可分为单调与非单调推理；从方法上可分为基于规则、模型、事例推理。</p><ul><li>非单调推理：新知识的加入可能使原先的知识变为假。</li></ul><ol start="4" type="1"><li>智慧：收集、加工、应用、传播知识的能力。</li></ol><h2 id="数据类型">1.2 数据类型</h2><h3 id="表示数据类型">1.2.1 表示数据类型</h3><p>从数据表示的视角，数据可分为结构化与非结构化数据。</p><p>结构化数据指高度组织化，可通过关系数据库输入、检索和操作的数据，往往是定量数据。</p><p>非结构化数据没有预定义的数据模型，通常存储于非关系数据库中，常常是定性数据。</p><p>半结构化数据介于两者之间，使用元数据（标签和语义标记）来识别特定的数据特征并将数据缩放为记录和预设字段。</p><h3 id="计算数据类型">1.2.2 计算数据类型</h3><p>统计数据是采用某种计量尺度对事物进行计量的结果，采用不同计量尺度会得到不同类型的统计数据。从计量的角度来看，统计数据可分为定类、定序、定距、定比数据。</p><p>前两类数据不能用数值表示，称为定性数据，后两类能用数值表示，称为定量数据。</p><ol type="1"><li><p>定类数据：事物的分类结果。</p></li><li><p>定序数据：反映对象顺序，表现为类别，可以进行偏序。</p></li><li><p>定距数据：具有顺序和距离属性，可以进行加减。</p></li></ol><p>定距数据中没有固定的0位。</p><ol start="4" type="1"><li>定比数据：具有顺序、距离、比例属性，可以进行加减乘除，没有负数。</li></ol><p>这四类数据级别从低到高，高级别数据可以用低级类型的数据分析方法来分析，反之则不行。</p><p>定类数据：饼图、柱状图</p><p>定序数据：柱状图</p><p>数字数据：直方图、折线图</p><h2 id="数据汇总">1.3 数据汇总</h2><h3 id="集中趋势度量">1.3.1 集中趋势度量</h3><p>反映数据的平均水平或数据的中心值。</p><p>对于平均的不同理解，往往会导致不同的计算结果。</p><ol type="1"><li>众数：一批数据中出现次数最多的数值。</li></ol><p>众数不受极值的影响，通常用来描述离散型变量，尤其是分类型变量。</p><p>众数通常用于定类变量的统计中，对于定序变量、定距变量和定比变量，通常使用中位数和算术平均数表示集中趋势。</p><ol start="2" type="1"><li>中位数：将数据从小到大排序后，处在数据序列中间的数值。</li></ol><p>n个排序后的数据，若n为奇数，则取第(n + 1) /2个数为中位数，n为偶数，则取第n / 2个和n / 2 +1个数的算术平均为中位数。</p><p>由中位数可扩展出四分位数。记为<spanclass="math inline">\(Q_i\)</span>。进一步可扩展至N分位数。</p><ol start="3" type="1"><li>算术平均数：一组数据的算术平均值，容易受极值的影响。</li></ol><p>求和稳定性（归零性）：每个数据减去算术平均数的结果求和为0。</p><p>算术平均值的偏差平方和极小性：每个数据减去算术平均数的结果的平方最小。</p><p>加权平均数：权重可反映数据的重要程度、频繁度等。</p><p>几何平均数：数据相乘开n次方，通常用于分析数据的平均增长率，通常要求每个数据非负。</p><p>均值不等式：<spanclass="math inline">\(调和平均\leq几何平均\leq算术平均\leq平方平均\)</span>。</p><p>集中趋势度量通常是产品设计的目标，但我们还需要考虑系统能承受的波动，即数据的离散程度。</p><h3 id="离散趋势度量">1.3.2 离散趋势度量</h3><p>全距/极差：样本最大值和最小值的差，当不考虑数据分布且数据中存在极值时适合使用。</p><p>内距/内四分位距：<span class="math inline">\(Q_3-Q_1\)</span>。</p><p>两者均不能提供精确的数据分布信息，不能用来进行精确的统计推算。</p><p>偏差平方和：每个数据与平均数偏差平方的和。</p><p>方差：偏差平方和的平均数</p><p>标准差：方差的平方根</p><p>修正方差：将方差定义式中分母的n改为n-1，具有无偏估计的性质。</p><p>变异系数：样本标准差除以均值。</p><h4 id="矩">矩</h4><p>设一批数据为<spanclass="math inline">\(X_1,X_2,...,X_n\)</span>。</p><p>其k阶原点矩定义为<spanclass="math inline">\(A_k=\frac{1}{n}\Sigma_i^nX_i^k\)</span>，k阶中心矩定义为<spanclass="math inline">\(B_k=\frac{1}{n}\Sigma_i^n(X_i-\overlineX)^k\)</span>。</p><p>中心矩都可用原点矩表示：<spanclass="math inline">\(B_k=\Sigma_{i=0}^kC_k^i(-A_i)^iA_{k-i}\)</span></p><h3 id="形态趋势度量">1.3.3 形态趋势度量</h3><p>偏度：<spanclass="math inline">\(S^3=\frac{B_3}{(B_2)^{1.5}}\)</span></p><p>偏度为0则数据对称，平均值与中位数相等。</p><p>偏度大于0，则称数据为正偏的，平均值大于中位数。</p><p>峰度：<spanclass="math inline">\(S^4=\frac{B_4}{(B_2)^2}\)</span></p><p>标准正态分布的峰度为3，因此大于3的为尖顶峰度，小于3的为平顶峰度。</p><p>峰度在1.8左右，数据分布接近矩形，小于1.8数据分布开始呈U形。</p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象</title>
    <link href="/2022/02/01/C++/C++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/02/01/C++/C++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>路就在你的脚下，只要你想走。</p><span id="more"></span><h1 id="c-面向对象">C++ 面向对象</h1><p>程序是多个对象的总和，对象包含其数据与方法。</p><ul><li>面向对象与基于对象</li></ul><h2 id="封装">封装</h2><p>C++ class</p><h3 id="构造">1. 构造</h3><ul><li><p>构造函数</p></li><li><p>成员初始化表</p></li><li><p>析构函数</p></li><li><p>拷贝构造函数</p></li><li><p>移动构造函数</p></li><li><p>内存：栈和堆</p></li><li><p>new和delete</p></li></ul><h3 id="const">2. const</h3><ul><li>const成员变量</li><li>const成员函数</li><li>mutable<ul><li>为什么要有mutable：const函数对全部成员都无法修改，但是有时候我们会希望它修改部分成员。</li><li>为成员添加mutable关键字，使得它可以被const函数修改。</li></ul></li></ul><h3 id="static">3. static</h3><ul><li>静态成员变量</li><li>静态成员函数</li><li>单例模式</li></ul><h3 id="友元">4. 友元</h3><ul><li>友元函数</li><li>友元类</li><li>友元类成员函数</li></ul><h2 id="继承">继承</h2><p>机制：基于目标代码的复用</p><h3 id="继承-1">1. 继承</h3><p>继承方式：public、private、protected</p><ul><li><p>public继承：继承父类的public为public、继承protected为protected，私有不继承</p></li><li><p>protected继承：继承父类的public、protected为protected</p></li><li><p>private继承：继承父类的public、protected为private</p></li></ul><p>派生类的初始化，构造与析构 -构造函数执行顺序：基类、派生类成员类、派生类 - 析构函数执行次序相反 -缺省执行基类默认构造函数，派生类成员初始化表可指定非默认构造函数</p><h3 id="虚函数">2. 虚函数</h3><ul><li><p>虚函数、final与override</p></li><li><p>纯虚函数和抽象类</p></li><li><p>应用：抽象工厂</p></li><li><p>不要重新定义虚函数继承而来的缺省参数值</p><ul><li>虚函数是动态绑定，而缺省参数是静态绑定。</li><li>如果重新定义缺省参数值，程序会调用基类的虚函数。</li></ul></li></ul><h3 id="多继承">3. 多继承</h3><ul><li>基类声明次序决定了构造/析构函数的调用次序、数据成员的存储安排</li><li>当发生成员名冲突，需要使用<基类名>::<基类成员名></li><li>如果直接基类有公共基类，那么公共基类中的成员在派生类中有多个副本<ul><li>虚基类（在继承公共基类的时候添加virtual关键字）可以使得公共基类在派生类中只有一个实例</li></ul></li></ul><h2 id="多态">多态</h2><p>同一个论域中一个元素可以有多种解释。</p><p>C++ 虚函数、重载、模板</p><p>函数重载 - 名称相同、参数不同 - 静态绑定</p><p>操作符重载：提高可读性和可扩充性 -方式：类成员函数（隐含this）/带有类参数的全局函数（友元） - = () []不能作为全局函数重载</p><ul><li>单目/双目、优先级、结合性</li><li>a++与++a</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span><br>&#123;       int value;<br>    <span class="hljs-keyword">public</span>:<br>        Counter() &#123; value = <span class="hljs-number">0</span>; &#125;<br>        Counter&amp; <span class="hljs-keyword">operator</span> ++() <span class="hljs-comment">// ++a</span><br>        &#123;  value++;<br>           <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>       Counter <span class="hljs-keyword">operator</span> ++(int) <span class="hljs-comment">//a++</span><br>      &#123;    Counter temp=*<span class="hljs-keyword">this</span>;<br>            value++;<br>            <span class="hljs-keyword">return</span> temp;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>特殊操作符重载 -=，默认赋值操作符重载函数为逐个成员赋值，对含有对象成员的类递归进行。 -赋值操作符重载不能继承 - 避免自我赋值 - () - [] - 类型转换：operatordouble() - <code>-&gt;</code></p><ul><li>new和delete重载</li></ul><p><code>void *operator new (size_t size, …)</code></p><p><code>void operator delete(void *p, size_t size)</code></p><p>重载后不再调用内置的new和delete。</p><ul><li>模板函数与模板类</li></ul><h3 id="newdelete与内存管理">new、delete与内存管理</h3><p>new的过程 - 获得一块内存空间 - 调用构造函数 - 返回正确的指针</p><p>delete的过程 - 调用析构函数 - 确定指向分配空间的指针 -将该空间归还系统</p><p>重载：使用链表构造内存池进行管理。</p>]]></content>
    
    
    <categories>
      
      <category>C++学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++基础</title>
    <link href="/2022/01/01/C++/C++%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/01/C++/C++%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>路就在你的脚下，只要你想走。</p><span id="more"></span><h1 id="c-基础">C++ 基础</h1><h2 id="switch">1. switch</h2><p>实现：</p><ul><li>case较少：cmp</li><li>case较多：Jump Table / Tree</li></ul><p>常用设计方法：表驱动switch。</p><h2 id="arraystruct与union">2. array、struct与union</h2><ol type="1"><li>多维数组的类型定义</li><li><code>__attribute__(aligned(8))</code></li></ol><h2 id="指针">3. 指针</h2><p>地址信息。</p><ul><li>读写数据/调用代码</li></ul><ol type="1"><li>指针定义与基本操作<ul><li>常量指针与指针常量</li></ul></li><li>指针与数组</li><li>指针与结构</li><li>指针与函数<ul><li>指针作为参数：提高效率、副作用</li><li>函数指针</li></ul></li><li>多级指针</li><li>引用：函数参数传递、动态变量命名</li></ol><h2 id="函数">4. 函数</h2><ol type="1"><li>执行机制<ol type="1"><li>建立被调用函数的栈空间</li><li>参数传递（值和引用）</li><li>保存调用函数的运行状态</li><li>将控制转交被调用函数</li></ol></li><li>函数原型：先定义、后使用</li><li>重载：名同、参数不同，返回值类型不作为区分依据。</li><li>默认参数：顺序为从右到左</li><li>内联函数：建议编译器将这些函数在调用处直接展开。<ul><li>在生成中间代码后，编译器会检查并确定是否进行内联。</li></ul></li></ol><h2 id="io">5. IO</h2><h3 id="char">char</h3><p><code>cin.get(c)</code>：包含空白符</p><p><code>cin &gt;&gt; c</code>：非空白符</p><p>get 的返回值为 istream 对象，而 istream 对象可以转换为 bool值，因而可以出现在 while 的条件中； &gt;&gt; 实际上会转换成函数operator&gt;&gt; 的调用，函数的返回值也为 istream 对象。</p><h3 id="int">int</h3><p><code>cin &gt;&gt; n</code></p><h3 id="string">string</h3><p><code>cin &gt;&gt; s</code>：以空白符或EOF为结束标志。</p><p><code>getline(cin, s)</code>：以换行符为结束标志。</p><p><code>getline(cin, s, ',')</code>：以 , 为结束标志。</p><p>在行的末尾使用第二种用法，会因为直接遇到换行符结束。这时可以使用<code>cin &gt;&gt; ws</code>先读取该空白符。</p><p><code>stoi</code>、<code>stof</code>可以将<code>string</code>转化为<code>int</code>和<code>float</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C++学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一元函数积分学</title>
    <link href="/2021/11/01/%E5%BE%AE%E7%A7%AF%E5%88%86/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/"/>
    <url>/2021/11/01/%E5%BE%AE%E7%A7%AF%E5%88%86/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>踏遍青山人未老，风景这边独好。</p><span id="more"></span><h1 id="三-一元函数积分学">三 一元函数积分学</h1><h2 id="原函数与不定积分">1. 原函数与不定积分</h2><h3 id="定义">1.1 定义</h3><ol type="1"><li><p>原函数：</p><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\(I\)</span>上有定义，若函数<spanclass="math inline">\(F\)</span>在区间<spanclass="math inline">\(I\)</span>连续且可导，满足条件：<spanclass="math inline">\(\forall x\in I\)</span><spanclass="math inline">\(F’(x) = f(x)\)</span>成立，</p><p>称<span class="math inline">\(F\)</span>是<spanclass="math inline">\(f\)</span>的一个原函数，或者说<spanclass="math inline">\(F\)</span>是微分形式<spanclass="math inline">\(f(x)dx\)</span>的一个原函数。</p><ul><li>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\(I\)</span>上有定义，若函数<spanclass="math inline">\(F\)</span>是<spanclass="math inline">\(f\)</span>的一个原函数，则<spanclass="math inline">\(\forall C\in R,F(x)+C\)</span>也是<spanclass="math inline">\(f\)</span>的原函数。</li></ul></li><li><p>不定积分：</p><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\(I\)</span>上有定义，若函数<spanclass="math inline">\(F\)</span>是<spanclass="math inline">\(f\)</span>的一个原函数，则函数簇<spanclass="math inline">\(F(x)+C(C\in R)\)</span>表示<spanclass="math inline">\(f\)</span>的一切原函数，我们把这一函数簇称为函数<spanclass="math inline">\(f\)</span>的不定积分，记为<spanclass="math inline">\(\int f(x)dx=F(x)+C\)</span>。</p><p>其中，<span class="math inline">\(f(x)\)</span>称为被积函数，<spanclass="math inline">\(f(x)dx\)</span>称为被积表达式，而<spanclass="math inline">\(\int\)</span>是表示不定积分的符号。</p><ul><li>根据定义，有<ul><li><span class="math inline">\((\int f(x)dx)’=f(x)\)</span></li><li><span class="math inline">\(d(\int f(x)dx)=f(x)dx\)</span></li><li><span class="math inline">\(\int F&#39;(x)dx=F(x)+C\)</span></li><li><span class="math inline">\(\int dF(x)=F(x)+C\)</span></li></ul></li><li>不定积分的运算法则：<ul><li><span class="math inline">\(\int(f(x) + g(x))dx = \int f(x)dx +\intg(x)dx\)</span></li><li><span class="math inline">\(\int\lambda f(x)dx = \lambda\intf(x)dx\)</span></li></ul></li></ul></li></ol><h3 id="存在定理">1.2 存在定理</h3><ol type="1"><li>连续函数必有原函数。</li><li>含有第一类间断点和无穷间断点的函数在包含该间断点的区间内必无原函数。</li></ol><h3 id="基本不定积分表">1.3 基本不定积分表</h3><ol type="1"><li><p><span class="math inline">\(\int 0·dx = C\)</span></p><p><span class="math inline">\(\int1·dx = x + C\)</span></p></li><li><p><span class="math inline">\(\int x^\mu dx = \frac1{\mu + 1}·x^{𝜇+ 1} + C,𝜇\ne-1\)</span></p><p><span class="math inline">\(\int\frac1xdx=\ln|x|+C\)</span></p><p><spanclass="math inline">\(\int\frac1{x-a}dx=\ln|x-a|+C\)</span></p></li><li><p><span class="math inline">\(\int e^xdx=e^x+C\)</span></p><p><span class="math inline">\(\int a^xdx=\frac{a^x}{\ln a} +C\)</span></p></li><li><p><span class="math inline">\(\int\cos xdx = \sin x +C\)</span>，<span class="math inline">\(\int \sin xdx = -\cos x +C\)</span></p><p><span class="math inline">\(\int \sec^2x·dx = \tan x + C\)</span>，<span class="math inline">\(\int\csc^2x·dx=-\cot x+C\)</span></p><p><span class="math inline">\(\int\sec\tan xdx=\sec x+C\)</span>，<spanclass="math inline">\(\int\csc\cot xdx=-\csc x+C\)</span></p></li><li><p><span class="math inline">\(\int\tan xdx=-\ln|\cosx|+C\)</span>，<span class="math inline">\(\int\cot xdx = \ln|\sin x| +C\)</span></p><p><span class="math inline">\(\int \sec xdx = \ln|\sec x + \tan x| +C\)</span>，<span class="math inline">\(\int \csc xdx = \ln|\csc x -\cot x| + C\)</span></p></li><li><p><span class="math inline">\(\int\frac1{x^2+1}dx=\arctanx+C\)</span>，<spanclass="math inline">\(\int\frac1{x^2+a^2}dx=\frac1a\arctan\frac xa +C\)</span></p><p><span class="math inline">\(\int\frac1{x^2-1}dx=\frac12\ln|\frac{x -1}{x + 1}|+C\)</span>，<spanclass="math inline">\(\int\frac1{x^2-a^2}dx=\frac1{2a}\ln|\frac{x - a}{x+ a}| + C\)</span></p></li><li><p><span class="math inline">\(\int\frac1{\sqrt{1-x^2}}dx=\arcsin x+ C\)</span>，<spanclass="math inline">\(\int\frac1{\sqrt{a^2-x^2}}dx=\arcsin\frac xa +C\)</span></p></li><li><p><span class="math inline">\(\int\frac1{\sqrt{x^2+a^2}}dx=\ln(x+\sqrt{x^2+a^2})+C\)</span>，<spanclass="math inline">\(\int\frac1{\sqrt{x^2-a^2}}dx=\ln|x+\sqrt{x^2-a^2}|+C\)</span></p></li><li><p><span class="math inline">\(\int \cosh xdx = \sinh x +C\)</span>，<span class="math inline">\(\int \sinh xdx = \cosh x +C\)</span></p></li></ol><h3 id="积分法">1.4 积分法</h3><h4 id="换元积分法">换元积分法</h4><ol type="1"><li><p>一元函数微分表示的不变性：</p><p><span class="math inline">\(dG(u) = g(u)du\)</span>，若把<spanclass="math inline">\(u\)</span>换为可微函数<spanclass="math inline">\(u = u(v)\)</span>，则有<spanclass="math inline">\(dG(u(v)) = g(u(v))du(v)\)</span>。</p><p>由此，从<span class="math inline">\(\int g(u)du = G(u) +C\)</span>可以得到<span class="math inline">\(\int g(u(v))du(v) =G(u(v)) +C\)</span>。</p></li><li><p>第一换元法（凑微分法）：<span class="math inline">\(\intf(x)dx=\int g(u(x))u&#39;(x)dx=\int g(u(x))du(x)=G(u(x))+C\)</span></p><ul><li>用例：<ul><li><span class="math inline">\(\int g(ax+b)dx\)</span></li><li><span class="math inline">\(\int g(x^k)x^{k-1}dx\)</span></li><li><span class="math inline">\(\int g(\ln x)\frac1xdx\)</span></li><li><span class="math inline">\(\int g(e^x)e^xdx\)</span></li><li><span class="math inline">\(\int g(\cos x)\sin xdx,\int g(\sinx)\cos xdx\)</span></li><li><span class="math inline">\(\int \tan xdx,\int \cotxdx\)</span></li></ul></li></ul></li><li><p>第二换元法：<span class="math inline">\(\int f(x)dx=\intf(u(v))du(v)=\int g(v)dv=G(v)+C=G(u^{-1}(x))+C\)</span></p><ul><li>用例：<ul><li><span class="math inline">\(\int\sqrt{x^2 + a^2}dx\)</span></li><li><span class="math inline">\(\int\frac1{\sqrt{x^2\pma^2}}dx\)</span></li><li><span class="math inline">\(\int\frac1{\sqrt{a^2 -x^2}}dx\)</span></li><li><span class="math inline">\(\int\frac1{x^2+a^2}dx\)</span></li></ul></li></ul></li></ol><h4 id="分部积分法">分部积分法</h4><p>因为<span class="math inline">\(d(u(x)v(x)) = u(x)dv(x) +v(x)dv(x)\)</span>，有<span class="math inline">\(\intu(x)dv(x)=u(x)v(x)-\int v(x)du(x)\)</span>。</p><h4 id="有理函数的积分">有理函数的积分</h4><p>初等函数的导数一定是初等函数，但不少初等函数的不定积分并非初等函数，如：</p><p><span class="math inline">\(\int e^{-x^2}dx\)</span>，<spanclass="math inline">\(\int \sin x^2dx\)</span>，<spanclass="math inline">\(\int \cos x^2dx\)</span>，<spanclass="math inline">\(\int \frac{\sin x}xdx\)</span>，<spanclass="math inline">\(\int\frac{\cos x}xdx\)</span>，<spanclass="math inline">\(\int \frac x{\ln x}dx\)</span></p><p>一个不定积分不能用初等函数来表示，并非这个不定积分不存在。</p><p>事实上，任何连续函数<spanclass="math inline">\(f(x)\)</span>都具有原函数。</p><p>有理函数：<span class="math inline">\(f(x) =\frac{P(x)}{Q(x)}=\frac{a_0+a_1x+...+a_nx^n}{b_0+b_1x+...+b_mx^m}\)</span>：</p><p>此处<span class="math inline">\(P(x)\)</span>和<spanclass="math inline">\(Q(x)\)</span>都是实系数的多项式。若<spanclass="math inline">\(n&lt;m\)</span>，称<spanclass="math inline">\(f(x)\)</span>为有理真分式，否则为有理假分式。</p><ul><li>利用多项式的除法，可以把有理假分式表示为多项式和有理真分式的和。</li></ul><p>在实数范围内，一个多项式的不可约因式只可能是一次的或者二次的。设<spanclass="math inline">\(Q(x)\)</span>的不可约因式分解如下：</p><p><spanclass="math inline">\(Q(x)=(x-a_1)^{k_1}···(x-a_r)^{k_r}·(x^2+p_1x+q_1)^{k_1}...(x^2+p_sx+q_s)^{k_s}\)</span></p><p>其中<span class="math inline">\(a_i\)</span>为实数，<spanclass="math inline">\(x^2+p_jx+q_j\)</span>为不可约的实系数二次三项式，且其中每个因式互质，有<spanclass="math inline">\(p_i^2&lt;4q_i\)</span>。</p><p>有理真分式<spanclass="math inline">\(\frac{P(x)}{Q(x)}\)</span>可以唯一地表示为以下形状的简单分式之和：</p><p><span class="math inline">\(\int\frac{dx}{(x-a)^n}\)</span>和<spanclass="math inline">\(\int\frac{(Mx+N)dx}{(x^2+px+q)^n}\)</span></p><p>该分解式称为真分式<spanclass="math inline">\(\frac{P(x)}{Q(x)}\)</span>的简单分式分解或部分分式分解。</p><p>通过部分因式分解，求有理分式的不定积分的问题归结为计算以下两种类型积分：</p><ol type="1"><li><p><spanclass="math inline">\(\int\frac{dx}{(x-a)^n}=\begin{cases}\ln|x-a|+C,n=1\\-\frac{dx}{(n-1)(x-a)^{n-1}}+C,n\ne1\end{cases}\)</span></p></li><li><p><spanclass="math inline">\(\int\frac{(Mx+N)dx}{(x^2+px+q)^n}=\int\frac{\fracM2(2x+p)+(N-\frac M2p)}{(x^2+px+q)^n}=\fracM2\int\frac{d(x^2+px+q)}{(x^2+px+q)^n}+(N-\fracM2p)\int\frac{dx}{(x^2+px+q)^n}\)</span></p><ul><li><p><spanclass="math inline">\(\int\frac{d(x^2+px+q)}{(x^2+px+q)^n}=\begin{cases}\ln(x^2+px+q)+C,n=1\\-\frac{1}{(k-1)(x^2+px+q)^{n-1}}+C,n\ne1\end{cases}\)</span></p></li><li><p><span class="math inline">\(x^2+px+q=(x+\fracp2)^2+q-\frac{p^2}4=t^2+b^2\)</span>，因此此类积分可转化为<spanclass="math inline">\(\int\frac{dt}{(t^2+b^2)^n}\)</span></p><ul><li><spanclass="math inline">\(J_n=\int\frac{dt}{(t^2+b^2)^n}=\begin{cases}\frac1b\arctan\fractb+C,n=1\\\frac1{2(n-1)b^2}[\fract{(t^2+b^2)^{n-1}}+(2n-3)J_{n-1}],n\ne1\end{cases}\)</span></li></ul></li></ul></li></ol><h5 id="可有理化的被积表达式">可有理化的被积表达式</h5><p>某些被积表达式可以通过变元替换而有理化，例如：</p><p>（<span class="math inline">\(R(u,v)\)</span>表示两个变量<spanclass="math inline">\(u,v\)</span>的有理式）</p><ol type="1"><li><p><span class="math inline">\(R(\sin x,\cos x)dx\)</span></p><p>含三角函数的表达式可通过各种三角代换进行有理化，如万能代换。</p></li><li><p><span class="math inline">\(R(x,\sqrt{ax^2+bx+c})dx\)</span></p><p><span class="math inline">\(\sqrt{ax^2+bx+c}\)</span>可化为<spanclass="math inline">\(\sqrt{u^2+-v^2}\)</span>和<spanclass="math inline">\(\sqrt{v^2-u^2}\)</span>，进而进行有理化。</p></li><li><p><spanclass="math inline">\(R(x,\sqrt[n]{\frac{ax+b}{cx+d}})dx\)</span></p><p>若<span class="math inline">\(ad=bc\)</span>，则<spanclass="math inline">\(a/c=b/d=k\)</span>，<spanclass="math inline">\(R(x,\sqrt[n]{\frac{ax+b}{cx+d}})dx=R(x,\sqrt[n]k)dx\)</span></p><p>若<span class="math inline">\(ad\ne bc\)</span>，则可令<spanclass="math inline">\(t=\sqrt[n]\frac{ax+b}{cx+d}\)</span>，则：</p><p><span class="math inline">\(x=\frac{dt^n-b}{a-ct^n}\)</span>，<spanclass="math inline">\(dx=dt·\frac{n(ad-bc)t^{n-1}}{a-ct^n}\)</span></p><p>原式=<spanclass="math inline">\(R(\frac{dt^n-b}{a-ct^n},t)dt·\frac{n(ad-bc)t^{n-1}}{a-ct^n}\)</span></p></li><li><p><span class="math inline">\(x^𝜆(a+bx^𝜇)^vdx\)</span></p><p>设<span class="math inline">\(a,b\in\R\)</span>，<spanclass="math inline">\(𝜆,𝜇,v∈Q\)</span>，且<spanclass="math inline">\(a,b,𝜇,v\ne 0\)</span>，为了防止根号嵌套，可设<spanclass="math inline">\(x^𝜇=t\)</span>，即<spanclass="math inline">\(x=\sqrt[\mu]t\)</span>。</p><p>此时<spanclass="math inline">\(dx=t^{\frac1𝜇-1}\frac{dt}𝜇\)</span>。</p><p>原式=<spanclass="math inline">\(\frac1𝜇t^{\frac{𝜆+1}{𝜇-1}}(a+bt)^vdt\)</span></p><p>如果<span class="math inline">\(\frac{𝜆+1}𝜇\in\Z\)</span>或<spanclass="math inline">\(\frac{𝜆+1}{𝜇+v}\in\Z\)</span>，则可把该式转化为3中情形。</p><p>切比雪夫证明，除了上述情形以外，二项型微分式都不能被积分成有限形式。</p></li></ol><h2 id="定积分">2. 定积分</h2><h3 id="定义和性质">2.1 定义和性质</h3><ol type="1"><li><p>定积分概念的精确化是黎曼所作的贡献，因此我们也把这种积分称作黎曼积分。</p></li><li><p>分割：闭区间<spanclass="math inline">\([a,b]\)</span>的一个分割，是指插入在<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>之间的有限个分点<spanclass="math inline">\(P:a=x_0&lt;…&lt;x_m=b\)</span>。</p><ul><li><p>这些分点把<span class="math inline">\([a,b]\)</span>分成<spanclass="math inline">\(m\)</span>个闭子区间<spanclass="math inline">\([x_0,x_1]…[x_m-1,x_m]\)</span>。</p></li><li><p><spanclass="math inline">\(|P|=\max{(∆x_1,……,∆x_m)}\)</span>称为分割<spanclass="math inline">\(P\)</span>的模。</p></li><li><p>在分割<spanclass="math inline">\(P\)</span>的每一闭子区间上任意选取一点<spanclass="math inline">\(\xi_i∈[x_i-1,x_i]\)</span>，<spanclass="math inline">\(i=1,2,…,m\)</span>，这<spanclass="math inline">\(m\)</span>个点称为相应于分割<spanclass="math inline">\(P\)</span>的一组标识点，约定用单独一个字母<spanclass="math inline">\(\xi\)</span>来表示它们。</p></li><li><p>设函数<span class="math inline">\(f\)</span>在闭区间<spanclass="math inline">\([a,b]\)</span>上有定义，对<spanclass="math inline">\([a,b]\)</span>的任何一个分割<spanclass="math inline">\(P\)</span>和相应于这分割的任何一组标志点<spanclass="math inline">\(\xi\)</span>，作和数<spanclass="math inline">\(\sigma(f,P,\xi)=\Sigma_1^mf(\xi_i)\Deltax_i\)</span>。称这样的和数为函数<spanclass="math inline">\(f\)</span>在闭区间<spanclass="math inline">\([a,b]\)</span>上的积分和或黎曼和。</p></li><li><p>如果闭区间<spanclass="math inline">\([a,b]\)</span>的分割的序列<spanclass="math inline">\(\{P(n)\}\)</span>满足<spanclass="math inline">\(\lim|P|=0\)</span>，则称<spanclass="math inline">\(\{P(n)\}\)</span>是一个无穷细分割序列。</p></li></ul></li><li><p>黎曼积分：设函数<spanclass="math inline">\(f\)</span>在闭区间<spanclass="math inline">\([a,b]\)</span>上有定义，如果存在实数<spanclass="math inline">\(I\)</span>，使得对于任意无穷细分割序列<spanclass="math inline">\(\{P(n)\}\)</span>，不论相应于它的标志点组怎样选择，都有<spanclass="math inline">\(\lim\sigma(f,P,\xi)=I\)</span>，那么我们就说函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，并把<spanclass="math inline">\(I\)</span>称为函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的定积分。记为：<spanclass="math inline">\(\int_a^bf(x)dx=\lim_{|P|\rightarrow0}\sigma(f,P,\xi)=I\)</span>。</p><ul><li>其中<span class="math inline">\(\int\)</span>称为积分号，<spanclass="math inline">\(f(x)dx\)</span>称为被积表达式，<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>称为积分下限和上限。</li></ul></li><li><p>基本性质：</p><ul><li><p><span class="math inline">\(\int_a^bCdx=C(b-a)\)</span></p></li><li><p>线性性质：</p><p><spanclass="math inline">\(\int_a^b(f(x)+g(x))dx=\int_a^bf(x)dx+\int_a^bg(x)dx\)</span></p><p><spanclass="math inline">\(\int_a^b𝜆f(x)dx=𝜆\int_a^bf(x)dx\)</span></p></li><li><p>可加性：</p><p><spanclass="math inline">\(\int_a^cf(x)dx=\int_a^bf(x)dx+\int_b^bf(x)dx\)</span></p></li><li><p>单调性：</p><p>设<span class="math inline">\(a&lt;b\)</span>，函数<spanclass="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积并且满足<spanclass="math inline">\(f(x)\le g(x)\)</span>，则有<spanclass="math inline">\(\int_a^bf(x)dx\le\int_a^bg(x)dx\)</span></p></li><li><p>积分中值定理：</p><p>设<span class="math inline">\(a&lt;b\)</span>，函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>可积(则<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上有界)，若<spanclass="math inline">\(∀x∈[a,b]\)</span>有<spanclass="math inline">\(m\le f(x)\le M\)</span>，则<spanclass="math inline">\(m(b-a)\le\int_a^bf(x)dx\le M(b-a)\)</span>。</p><p>特别的，如果<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>连续，那么存在<spanclass="math inline">\(c∈[a,b]\)</span>，使得<spanclass="math inline">\(\int_a^bf(x)dx=f(c)(b-a)\)</span>。</p></li></ul></li></ol><h3 id="存在定理-1">2.2 存在定理</h3><ol type="1"><li><p>黎曼可积性：可以通过黎曼积分的定义计算积分值。也称为一元函数的常义可积性。</p><ul><li>常义，即区间有限、函数有界。区别于反常积分的区间无限、函数无界。</li></ul></li><li><p>定积分存在定理：即一元函数的常义可积性。</p><ul><li><p>充分条件：</p><ul><li><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，则<spanclass="math inline">\(\int_a^b f(x)dx\)</span>存在</p></li><li><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上单调，则<spanclass="math inline">\(\int_a^b f(x)dx\)</span>存在</p></li><li><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上有界，且只有有限个间断点，则<spanclass="math inline">\(\int_a^b f(x)dx\)</span>存在</p></li></ul></li><li><p>必要条件：有界。</p></li></ul></li></ol><h3 id="变限积分">2.3 变限积分</h3><p><spanclass="math inline">\(F(x)=\int_a^xf(t)dt\)</span>为变上限的积分，同理也有变下限和上下限都变化的积分。</p><ul><li>性质：<ul><li><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(I\)</span>上可积，则<spanclass="math inline">\(F(x)=\int_a^xf(t)dt\)</span>在<spanclass="math inline">\(I\)</span>上连续</li><li><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(I\)</span>上连续，则<spanclass="math inline">\(F(x)=\int_a^xf(t)dt\)</span>在<spanclass="math inline">\(I\)</span>上可导且<spanclass="math inline">\(F&#39;(x)=f(x)\)</span></li><li>若<span class="math inline">\(x=x_0\in I\)</span>是<spanclass="math inline">\(f(x)\)</span>唯一的跳跃间断点，则<spanclass="math inline">\(F(x)=\int_a^xf(t)dt\)</span>在<spanclass="math inline">\(x_0\)</span>处不可导<ul><li><span class="math inline">\(F&#39;_-(x_0)=\lim_{x\rightarrowx_0^-}f(x)\)</span></li><li><span class="math inline">\(F&#39;_+(x_0)=\lim_{x\rightarrowx_0^+}f(x)\)</span></li></ul></li><li>若<span class="math inline">\(x=x_0\in I\)</span>是<spanclass="math inline">\(f(x)\)</span>唯一的可去间断点，则<spanclass="math inline">\(F(x)=\int_a^xf(t)dt\)</span>在<spanclass="math inline">\(x_0\)</span>处可导<ul><li><span class="math inline">\(F&#39;(x_0)=\lim_{x\rightarrowx_0}f(x)\)</span></li></ul></li></ul></li><li>求导公式：设<spanclass="math inline">\(F(x)=\int_{\varphi_1(x)}^{\varphi_2(x)}f(t)dt\)</span>，则<spanclass="math inline">\(F&#39;(x)=f(\varphi_2(x))\varphi_2&#39;(x)-f(\varphi_1(x))\varphi_1&#39;(x)\)</span>。<ul><li>当<span class="math inline">\(f(t)\)</span>中包含<spanclass="math inline">\(x\)</span>，不能直接使用该求导公式。</li></ul></li><li>结论：<ul><li><span class="math inline">\(f(x)\)</span>为可积的奇函数，则<spanclass="math inline">\(\int_a^xf(t)dt\)</span>为偶函数。</li><li><span class="math inline">\(f(x)\)</span>为可积的偶函数，则<spanclass="math inline">\(\int_0^xf(t)dt\)</span>为奇函数。</li></ul></li></ul><h3 id="反常积分">2.4 反常积分</h3><ol type="1"><li>无穷区间的反常积分：<span class="math inline">\(F(x)\)</span>为<spanclass="math inline">\(f(x)\)</span>在相应区间的一个原函数。<ul><li><spanclass="math inline">\(\int_a^{+\infin}f(x)dx=\lim_{x\rightarrow+\infin}F(x)-F(a)\)</span>，极限存在即收敛，否则发散</li><li><spanclass="math inline">\(\int_{-\infin}^bf(x)dx=F(b)-\lim_{x\rightarrow-\infin}F(x)\)</span>，极限存在即收敛，否则发散</li><li><spanclass="math inline">\(\int_{-\infin}^{+\infin}f(x)dx=\lim_{x\rightarrow+\infin}F(x)-\lim_{x\rightarrow-\infin}F(x)\)</span>，两个极限都存在即收敛，否则发散</li></ul></li><li><span class="math inline">\(f(x)\)</span>的瑕点<spanclass="math inline">\(x_0\)</span>：<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的邻域内。</li><li>无界函数的反常积分：<span class="math inline">\(F(x)\)</span>为<spanclass="math inline">\(f(x)\)</span>在相应区间的一个原函数。<ul><li><span class="math inline">\(x=a\)</span>为瑕点，<spanclass="math inline">\(\int_a^bf(x)dx=F(b)-\lim_{x\rightarrowa^+}F(a)\)</span>，极限存在即收敛，否则发散</li><li><span class="math inline">\(x=b\)</span>为瑕点，<spanclass="math inline">\(\int_a^bf(x)dx=\lim_{x\rightarrowb^-}F(b)-F(a)\)</span>，极限存在即收敛，否则发散</li><li><span class="math inline">\(x=c\in(a,b)\)</span>为瑕点，<spanclass="math inline">\(\int_a^bf(x)dx=\int_a^cf(x)dx+\int_c^bf(x)dx\)</span>，两积分都存在则收敛，否则发散</li></ul></li><li>反常积分敛散性判别：比较法。</li><li>重要结论：<ul><li><spanclass="math inline">\(\int_0^1\frac1{x^p}\begin{cases}收敛，0\lt p\lt1\\发散，p\ge1 \end{cases}\)</span></li><li><spanclass="math inline">\(\int_1^{+\infin}\frac1{x^p}\begin{cases}收敛，p\gt1\\发散，p\le1 \end{cases}\)</span></li></ul></li></ol><h3 id="牛顿-莱布尼茨公式">2.5 牛顿-莱布尼茨公式</h3><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>连续，如果存在函数<spanclass="math inline">\(F\)</span>，它在<spanclass="math inline">\([a,b]\)</span>连续且可导，并且满足<spanclass="math inline">\(F’(x)=f(x)\)</span>，那么函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>可积，且<spanclass="math inline">\(\int_a^bf(x)dx=F(b)-F(a)\)</span>。</p><ul><li>基于牛顿-莱布尼茨公式，求定积分可转化为求不定积分。</li></ul><p>连续可微：</p><ul><li><p>如果函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>上每一点可导，并且导函数在<spanclass="math inline">\((a,b)\)</span>连续，那么我们说函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>连续可微。</p></li><li><p>如果函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上每一点可导(在<spanclass="math inline">\(a\)</span>右可导，在<spanclass="math inline">\(b\)</span>左可导)，并且导函数在<spanclass="math inline">\([a,b]\)</span>连续，那么我们说函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>连续可微。</p></li></ul><h4 id="换元法">换元法</h4><p>设函数<span class="math inline">\(𝜑∈C^1[𝛼,𝛽]\)</span>，<spanclass="math inline">\(𝜑(𝛼)=a\)</span>，<spanclass="math inline">\(𝜑(𝛽)=b\)</span>，<spanclass="math inline">\(𝜑((𝛼,𝛽))⊂(a,b)\)</span>，如果<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>连续，那么<spanclass="math inline">\(\int_a^bf(x)dx=\int_\alpha^\betaf(𝜑(t))𝜑’(t)dt\)</span></p><h4 id="分部积分">分部积分</h4><p>设函数<span class="math inline">\(u,v\in C^1[a,b]\)</span>，则<spanclass="math inline">\(\int_a^bu(x)v’(x)dx=u(x)v(x)|_a^b-\int_a^bv(x)u’(x)dx\)</span></p><h4 id="常用结论">常用结论</h4><ol type="1"><li><p><span class="math inline">\(f(x)\)</span>为连续偶函数，则<spanclass="math inline">\(\int_{-a}^af(x)dx=2\int_0^af(x)dx\)</span>。</p></li><li><p><span class="math inline">\(f(x)\)</span>为连续奇函数，则<spanclass="math inline">\(\int_{-a}^af(x)dx=0\)</span>。</p></li><li><p><span class="math inline">\(f(x)\)</span>是周期为<spanclass="math inline">\(T\)</span>的连续函数，则<spanclass="math inline">\(\foralla,\int_a^{a+T}f(x)dx=\int_0^Tf(x)dx\)</span>。</p></li><li><p><span class="math inline">\(f(x)\)</span>为连续函数，则<spanclass="math inline">\(\int_a^bf(x)dx=\int_a^bf(a+b-x)dx\)</span></p></li><li><p>华莱士公式：</p><p><spanclass="math inline">\(\int_0^{\frac\pi2}\sin^nxdx=\int_0^{\frac\pi2}\cos^nxdx=\begin{cases}\frac{(n-1)!!}{n!!},n为大于1的奇数\\\frac{(n-1)!!}{n!!}\frac\pi2,n为正偶数\end{cases}\)</span></p><ul><li>派生：<ul><li><spanclass="math inline">\(\int_0^{\pi}\sin^nxdx=2\int_0^{\frac\pi2}\sin^nxdx\)</span></li><li><spanclass="math inline">\(\int_0^{\pi}\cos^nxdx=\begin{cases}0,n为正奇数\\2\int_0^{\frac\pi2}\sin^nxdx,n为正偶数\end{cases}\)</span></li><li><spanclass="math inline">\(\int_0^{2\pi}\cos^nxdx=\int_0^{2\pi}\sin^nxdx=\begin{cases}0,n为正奇数\\4\int_0^{\frac\pi2}\sin^nxdx,n为正偶数\end{cases}\)</span></li></ul></li></ul></li></ol><h2 id="应用">3. 应用</h2><h4 id="几何计算">几何计算</h4><ol type="1"><li><p>平面图形面积：</p><ul><li>直角坐标系：<spanclass="math inline">\(y=f(x),y=g(x)\)</span>与<spanclass="math inline">\(x=a,x=b\)</span>围成的图形面积：<spanclass="math inline">\(\int_a^b|f(x)-g(x)|dx\)</span></li><li>极坐标系：<spanclass="math inline">\(r=\rho_1(\theta),r=\rho_2(\theta)\)</span>与<spanclass="math inline">\(\theta=\alpha,\theta=\beta\)</span>围成的图形面积：<spanclass="math inline">\(\frac12\int_\alpha^\beta|\rho_1^2(\theta)-\rho_2^2(\theta)|d\theta\)</span></li><li>参数方程：转换为直角坐标系并换元</li></ul></li><li><p>旋转体体积：</p><ul><li><p><span class="math inline">\(y=f(x),x=a,x=b\)</span>及<spanclass="math inline">\(x\)</span>轴围成的图形绕<spanclass="math inline">\(x\)</span>轴旋转一周所得旋转体体积：<spanclass="math inline">\(\int_a^b\pi f(x)^2dx\)</span></p></li><li><p><span class="math inline">\(y=f(x),x=a,x=b\)</span>及<spanclass="math inline">\(x\)</span>轴围成的图形绕<spanclass="math inline">\(y\)</span>轴旋转一周所得旋转体体积：<spanclass="math inline">\(2\pi\int_a^bx|f(x)|dx\)</span></p></li><li><p>平面曲线<span class="math inline">\(y=f(x)\)</span>绕定直线<spanclass="math inline">\(Ax+By+C=0\)</span>旋转一周所得旋转体体积：</p><p><spanclass="math inline">\(\frac\pi{(A^+B^2)^{\frac32}}\int_a^b[Ax+Bf(x)+C]^2|Af&#39;(x)-B|dx\)</span></p></li></ul></li><li><p>函数平均值：<span class="math inline">\(y=f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上的平均值为<spanclass="math inline">\(\frac1{b-a}\int_a^bf(x)dx\)</span></p></li><li><p>曲边梯形的质心：<spanclass="math inline">\(y=f(x),x=a,x=b\)</span>所围曲边梯形质心坐标：</p><p><spanclass="math inline">\(x=\frac{\int_a^bxf(x)dx}{\int_a^bf(x)dx}\)</span>，<spanclass="math inline">\(y=\frac{\frac12\int_a^bf(x)^2dx}{\int_a^bf(x)dx}\)</span></p></li><li><p>平面曲线的弧长</p><ul><li><span class="math inline">\(y=f(x),x\in[a,b]\)</span>：<spanclass="math inline">\(\int_a^b\sqrt{1+f&#39;(x)^2}dx\)</span></li><li><spanclass="math inline">\(x=x(t),y=y(t),t\in[\alpha,\beta]\)</span>：<spanclass="math inline">\(\int_\alpha^\beta\sqrt{x&#39;(t)^2+y&#39;(t)^2}dt\)</span></li><li><spanclass="math inline">\(r=\rho(\theta),\theta\in[\alpha,\beta]\)</span>：<spanclass="math inline">\(\int_\alpha^\beta\sqrt{[\rho(\theta)^2+\rho&#39;(\theta)^2]}dx\)</span></li></ul></li><li><p>旋转曲面的面积：</p><ul><li><span class="math inline">\(y=f(x),x\in[a,b]\)</span>绕<spanclass="math inline">\(x\)</span>轴旋转：<spanclass="math inline">\(2\pi\int_a^b|f(x)|\sqrt{1+f&#39;(x)^2}dx\)</span></li><li><spanclass="math inline">\(x=x(t),y=y(t),t\in[\alpha,\beta]\)</span>绕<spanclass="math inline">\(x\)</span>轴旋转：<spanclass="math inline">\(2\pi\int_\alpha^\beta|y(t)|\sqrt{x&#39;(t)^2+y&#39;(t)^2}dt\)</span></li><li><spanclass="math inline">\(r=\rho(\theta),\theta\in[\alpha,\beta]\)</span>：<spanclass="math inline">\(2\pi\int_\alpha^\beta|\rho(\theta)\sin\theta|\sqrt{[\rho(\theta)^2+\rho&#39;(\theta)^2]}d\theta\)</span></li></ul></li></ol><h4 id="物理计算">物理计算</h4><ol type="1"><li>变力按直线做功：<spanclass="math inline">\(W=\int_a^bF(x)dx\)</span></li><li>抽水做功：水面距离容器口高度<spanclass="math inline">\(x\)</span>，对应水平截面面积<spanclass="math inline">\(A(x)\)</span>，<span class="math inline">\(W=\rhog\int_a^bxA(x)dx\)</span></li><li>静水压力：平板两曲边距水距离为<spanclass="math inline">\(f(x),g(x)\)</span>，<spanclass="math inline">\(P=\rho g\int_a^bx(f(x)-g(x))dx\)</span></li></ol>]]></content>
    
    
    <categories>
      
      <category>微积分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一元函数微分学</title>
    <link href="/2021/10/01/%E5%BE%AE%E7%A7%AF%E5%88%86/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/"/>
    <url>/2021/10/01/%E5%BE%AE%E7%A7%AF%E5%88%86/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>踏遍青山人未老，风景这边独好。</p><span id="more"></span><h1 id="二-一元函数微分学">二 一元函数微分学</h1><h2 id="概念">1. 概念</h2><h3 id="导数">1.1 导数</h3><p>设<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的<spanclass="math inline">\(\delta\)</span>邻域有定义，称<spanclass="math inline">\(\lim_{x\rightarrowx_0}\frac{f(x)-f(x_0)}{x-x_0}\)</span>为<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的导数，记为<spanclass="math inline">\(f&#39;(x)\)</span>。</p><ul><li>导数的几何意义：函数图像的切线。</li></ul><h4 id="单侧导数">单侧导数</h4><p>若<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(U_+(x_0,𝛿)\)</span>有定义，且<spanclass="math inline">\(\lim_{x\rightarrowx_0^+}\frac{f(x)-f(x_0)}{x-x_0}\)</span>存在，则称其为<spanclass="math inline">\(f(x)\)</span>的右导数。</p><p>若<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(U_-(x_0,𝛿)\)</span>有定义，且<spanclass="math inline">\(\lim_{x\rightarrowx_0^-}\frac{f(x)-f(x_0)}{x-x_0}\)</span>存在，则称其为<spanclass="math inline">\(f(x)\)</span>的左导数。</p><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>处左可导又右可导，则<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>处左连续又右连续，则<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>连续。</p><h4 id="导函数">导函数</h4><p>若<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\((a,b)\)</span>上有定义，且<spanclass="math inline">\(\forall x∈(a,b)\)</span>，<spanclass="math inline">\(f(x)\)</span>有导数，则称<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\((a,b)\)</span>上可导，<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\((a,b)\)</span>上的导数也是一个关于<spanclass="math inline">\(x\)</span>的函数，称为<spanclass="math inline">\(f(x)\)</span>的导函数，简称导数。</p><p>若<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上有定义，且在<spanclass="math inline">\((a,b)\)</span>上可导，在<spanclass="math inline">\(a\)</span>有右导数，在<spanclass="math inline">\(b\)</span>有左导数，则称<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上可导。</p><h3 id="微分">1.2 微分</h3><p>可微性：<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>的邻域有定义，若<spanclass="math inline">\(f(x)-f(x_0) = A(x-x_0) +o(x-x_0)\)</span>，则称<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>可微。</p><ul><li><p><spanclass="math inline">\(f(x)-f(x_0)\)</span>称为函数的增量，<spanclass="math inline">\(A(x-x_0)\)</span>称为函数增量的可线性化部分，<spanclass="math inline">\(o(x-x_0)\)</span>为高阶无穷小量</p></li><li><p><span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>可微等价于<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>可导。</p></li></ul><p>函数增量的线性部分，即<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>处导数乘以<spanclass="math inline">\(dx\)</span>，称为<spanclass="math inline">\(f(x)\)</span>的<strong>微分</strong>，记作<spanclass="math inline">\(df\)</span>。<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x\)</span>趋于<spanclass="math inline">\(x_0\)</span>时的导数为<spanclass="math inline">\(\frac{df}{dx}\)</span>，也称为微商。</p><h4 id="一阶微分的形式不变性">一阶微分的形式不变性</h4><p><span class="math inline">\(y = f(u)\)</span>，则<spanclass="math inline">\(dy = f’(u)du\)</span>始终成立。</p><h2 id="求导法则">2. 求导法则</h2><h3 id="四则运算">2.1 四则运算</h3><p>导数：<spanclass="math inline">\(u(x),v(x)\)</span>的导数存在，则</p><p><span class="math inline">\(u(x)+v(x)\)</span>的导数也存在，且为<spanclass="math inline">\(u’(x)+v’(x)\)</span>；</p><p><span class="math inline">\(u(x)\timesv(x)\)</span>的导数也存在，且为<spanclass="math inline">\(u(x)v’(x)+u’(x)v(x)\)</span>；</p><p><span class="math inline">\(\frac{u(x)}{v(x)}\)</span>中<spanclass="math inline">\(v(x)\ne0\)</span>，其导数也存在，且为<spanclass="math inline">\(\frac{u’(x)v(x)-v’(x)u(x)}{v(x)^2}\)</span>。</p><p>微分：<spanclass="math inline">\(u(x),v(x)\)</span>的微分存在，则</p><p><span class="math inline">\(u(x)+v(x)\)</span>的微分也存在，且为<spanclass="math inline">\((u’+v’)dx\)</span>；</p><p><span class="math inline">\(u(x)\timesv(x)\)</span>的微分也存在，且为<spanclass="math inline">\((uv’+u’v)dx\)</span>；</p><p><span class="math inline">\(\frac {u(x)}{v(x)}\)</span>中<spanclass="math inline">\(v(x)\ne0\)</span>，其微分也存在，且为<spanclass="math inline">\(\frac{u’v-v’u}{v^2}dx\)</span>。</p><h3 id="复合函数">2.2 复合函数</h3><p>链式求导法则：<spanclass="math inline">\(u(x),f(u)\)</span>的导数存在，则</p><p><span class="math inline">\(\frac{df}{dx}=f’(u)·u’(x)\)</span>。</p><p>微分：<spanclass="math inline">\(u(x),f(u)\)</span>的微分存在，则</p><p><span class="math inline">\(df = f’·u’·dx\)</span>。</p><p>例：双曲余弦函数：<span class="math inline">\(ch\;x = \frac{e^x +e^{-x}}2\)</span>，双曲正弦函数：<span class="math inline">\(sh\;x=\frac{e^x-e^{-x}}2\)</span>，两者互为导数。</p><h3 id="反函数">2.3 反函数</h3><p>若<span class="math inline">\(y = f(x)\)</span>在<spanclass="math inline">\(I\)</span>上严格单调且连续，且在<spanclass="math inline">\(x_0\)</span>处可导，<spanclass="math inline">\(f’(x)\ne0\)</span>，则其反函数<spanclass="math inline">\(x = 𝜑(y)\)</span>在<span class="math inline">\(y =f(x_0)\)</span>的导数为<spanclass="math inline">\(\frac1{f’(x_0)}\)</span>。</p><h3 id="参数方程">2.4 参数方程</h3><p><span class="math inline">\(x = u(t),y = v(t)\)</span>，则<spanclass="math inline">\(y\)</span>关于<spanclass="math inline">\(x\)</span>的导数为<spanclass="math inline">\(\frac{v’(t)}{u’(t)}\)</span>。</p><h3 id="隐函数">2.5 隐函数</h3><p>关于<spanclass="math inline">\(x,y\)</span>的方程式，如果对于给定<spanclass="math inline">\(x\)</span>有唯一<spanclass="math inline">\(y\)</span>，则<spanclass="math inline">\(y\)</span>是<spanclass="math inline">\(x\)</span>的隐函数。</p><ul><li><p>求导法则：将<span class="math inline">\(y\)</span>视作关于<spanclass="math inline">\(x\)</span>的函数进行求导。</p></li><li><p>应用：对数求导法</p></li></ul><h3 id="高阶导数">2.6 高阶导数</h3><p>若函数<span class="math inline">\(y = f(x)\)</span>的导函数<spanclass="math inline">\(f’\)</span>在区间<spanclass="math inline">\(I\)</span>上有定义且可导，则其在<spanclass="math inline">\(x\)</span>的导数，称为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x\)</span>的二阶导数。</p><p>若<span class="math inline">\(f(x)\)</span>的<spanclass="math inline">\(n-1\)</span>阶导数在区间<spanclass="math inline">\(I\)</span>上有定义且可导，其导函数称为<spanclass="math inline">\(f(x)\)</span>的<spanclass="math inline">\(n\)</span>阶导数，记为<spanclass="math inline">\(f^{(n)}(x)\)</span>。</p><h4 id="莱布尼茨公式">莱布尼茨公式</h4><p>设函数<span class="math inline">\(u,v\)</span>都在<spanclass="math inline">\(x\)</span>处<spanclass="math inline">\(n\)</span>次可导，则其乘积<spanclass="math inline">\(uv\)</span>也在<spanclass="math inline">\(x\)</span>处<spanclass="math inline">\(n\)</span>次可导，且有：</p><p><span class="math inline">\((uv)^{(n)} = \Sigma_{k=0}^nC^k_n·u^{(n-k)}·v^{(k)}\)</span></p><h4 id="高阶微分">高阶微分</h4><p><span class="math inline">\(dy = f’(x)dx\)</span></p><p><span class="math inline">\(d^2y = d(dy) = f’’(x)dx^2\)</span></p><p><span class="math inline">\(d^ny = f^{(n)}(x)dx^n\)</span></p><p><span class="math inline">\(d^n(uv) = (uv)^{(n)}dx^n =\Sigma_{k=1}^nC^k_n ·u^{(n-k)}·v^{(k)}dx^n\)</span></p><p>高阶微分一般不具有形式不变性。</p><h3 id="常见求导公式">2.7 常见求导公式</h3><ol type="1"><li><span class="math inline">\((C)&#39;=0,C\in\R\)</span></li><li><span class="math inline">\((x^\mu)&#39;=\mux^{\mu-1},\mu\in\R\)</span></li><li><span class="math inline">\((a^x)&#39;=a^x\ln a,a\gt0\anda\ne1\)</span></li><li><span class="math inline">\((\log_ax)&#39;=\frac1{x\ln a},a\gt0\anda\ne1\)</span></li><li><span class="math inline">\((\sin x)&#39;=\cos x,(\cos x)&#39;=-\sinx\)</span></li><li><span class="math inline">\((\tanx)&#39;=\sec^2x=\frac1{\cos^2x},(\cotx)&#39;=-\csc^2x=-\frac1{\sin^2x}\)</span></li><li><span class="math inline">\((\sec x)&#39;=\sec x\tan x,(\cscx)&#39;=-\csc x\cot x\)</span></li><li><span class="math inline">\((\arcsinx)&#39;=\frac1{\sqrt{1-x^2}},(\arccosx)&#39;=-\frac1{\sqrt{1-x^2}},(\arctanx)&#39;=\frac1{1+x^2}\)</span></li><li><span class="math inline">\((\sinh x)&#39;=\cosh x,(\coshx)&#39;=\sinh x,(\tanh x)&#39;=\frac1{\cosh^2x}\)</span></li></ol><h2 id="微分中值定理">3. 微分中值定理</h2><p>当<spanclass="math inline">\(∆x\rightarrow0,f(x_0+∆x)=f(x_0)+f’(x_0)·∆x +o(∆x)\)</span>，该式与其等价形式被称为无穷小增量公式。</p><h3 id="极值">3.0 极值</h3><p>内点：设区间<span class="math inline">\(I\)</span>，<spanclass="math inline">\(x_0\in I\)</span>，如果存在<spanclass="math inline">\(\eta&gt;0\)</span>，使得<spanclass="math inline">\(U(x_0,\eta)\in I\)</span>，则称<spanclass="math inline">\(x_0\)</span>为区间<spanclass="math inline">\(I\)</span>的一个内点。</p><p>极大值点：设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\(I\)</span>有定义，存在<spanclass="math inline">\(U(x_0，\delta)\in I\)</span>，任意<spanclass="math inline">\(x\in U(x_0，\delta)\)</span>，都有<spanclass="math inline">\(f(x)\le f(x_0)\)</span>(或<spanclass="math inline">\(f(x)\ge f(x_0)\)</span>)，则称函数<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>取得极大值(或极小值)，称<spanclass="math inline">\(x_0\)</span>为函数<spanclass="math inline">\(f(x)\)</span>的极大值点(或极小值点)。</p><p>此时，如果对于任何<span class="math inline">\(x\in U(x_0，𝛿)\and x\nex_0\)</span>，都有<spanclass="math inline">\(f(x)&lt;f(x_0)\)</span>或<spanclass="math inline">\(f(x)&gt;f(x_0)\)</span>，则称<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>取得严格的极大值或极小值。极大值和极小值统称为极值。</p><h4 id="极值的判别">极值的判别</h4><p>单调性的判别：设<span class="math inline">\(y=f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，<spanclass="math inline">\((a,b)\)</span>内可导。</p><ul><li>如果<span class="math inline">\((a,b)\)</span>内<spanclass="math inline">\(f&#39;(x)\ge0\)</span>，且等号仅在有限个点处成立，则<spanclass="math inline">\(y=f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上严格单调增加。</li><li>如果<span class="math inline">\((a,b)\)</span>内<spanclass="math inline">\(f&#39;(x)\le0\)</span>，且等号仅在有限个点处成立，则<spanclass="math inline">\(y=f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上严格单调减少。</li></ul><p>极值点的必要条件：一阶导数为0或不存在。</p><ul><li>极值的第一充分条件：<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=x_0\)</span>处连续，且在<spanclass="math inline">\(x_0\)</span>的某去心邻域内可导，<spanclass="math inline">\(f&#39;(x_0)=0\)</span>；<ul><li><span class="math inline">\(f&#39;(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的左邻域小于0，右邻域大于0，则<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=x_0\)</span>处取极小值。</li><li><span class="math inline">\(f&#39;(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的左邻域大于0，右邻域小于0，则<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=x_0\)</span>处取极大值。</li></ul></li><li>极值的第二充分条件：<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=x_0\)</span>处二阶可导，且<spanclass="math inline">\(f&#39;(x_0)=0\)</span>，<spanclass="math inline">\(f&#39;&#39;(x_0)\neq0\)</span>。<ul><li><span class="math inline">\(f&#39;&#39;(x_0)\gt0\)</span>，则<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=x_0\)</span>处取极小值。</li><li><span class="math inline">\(f&#39;&#39;(x_0)\lt0\)</span>，则<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=x_0\)</span>处取极大值。</li></ul></li><li>极值的第三充分条件：<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=x_0\)</span>处<spanclass="math inline">\(n\)</span>阶可导，且<spanclass="math inline">\(f^{(m)(x_0)}=0\)</span>，<spanclass="math inline">\(m=1,2,...,n-1\)</span>，<spanclass="math inline">\(f^{(n)}(x_0)\neq0\)</span>，则<ul><li>当<span class="math inline">\(n\)</span>为偶数且<spanclass="math inline">\(f^{(n)}(x_0)\gt0\)</span>，<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=x_0\)</span>处取极小值。</li><li>当<span class="math inline">\(n\)</span>为偶数且<spanclass="math inline">\(f^{(n)}(x_0)\lt0\)</span>，<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=x_0\)</span>处取极大值。</li></ul></li></ul><h3 id="费马定理">3.1 费马定理</h3><p>设<span class="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\(I\)</span>上有定义并在区间I的内点<spanclass="math inline">\(x\)</span>上取得极值，若<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x\)</span>可导，则<spanclass="math inline">\(f’(x)=0\)</span>。</p><ul><li>证明：极大值点左导数大于等于0，右导数小于等于0。</li><li><span class="math inline">\(f’(x)=0\)</span>，称<spanclass="math inline">\(x\)</span>为临界点。<spanclass="math inline">\(f(x)\)</span>的最值只会在边界点和临界点中取得。</li></ul><h3 id="洛尔定理">3.2 洛尔定理</h3><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，在<spanclass="math inline">\((a,b)\)</span>上可导，并且满足<spanclass="math inline">\(f(a)=f(b)\)</span>，则存在<spanclass="math inline">\(c\in(a,b)\)</span>，<spanclass="math inline">\(f’(c)=0\)</span>。</p><ul><li>证明：应用闭区间上连续函数的最值定理和费马定理。</li></ul><h3 id="拉格朗日中值定理">3.3 拉格朗日中值定理</h3><p><span class="math inline">\(f\in C[a,b]\)</span>，且在<spanclass="math inline">\((a,b)\)</span>可导，则存在<spanclass="math inline">\(c∈(a,b)\)</span>，<spanclass="math inline">\(f’(c)=\frac{f(a)-f(b)}{a - b}\)</span>。</p><ul><li><p>证明：构造<spanclass="math inline">\(F(x)=f(x)-\frac{f(a)-f(b)}{a-b}(x-a)\)</span>，应用洛尔定理。</p></li><li><p>拉格朗日中值定理也称为有限增量公式：</p><p><span class="math inline">\(f\in C[a,b]\)</span>，且在<spanclass="math inline">\((a,b)\)</span>可导，则存在<spanclass="math inline">\(c\in(a,b)\)</span>，<spanclass="math inline">\(f(a) - f(b)=f’(c)·(a - b)\)</span>。</p></li></ul><h3 id="柯西中值定理">3.4 柯西中值定理</h3><p><span class="math inline">\(f,g∈C[a,b]\)</span>，且在<spanclass="math inline">\((a,b)\)</span>可导，则存在<spanclass="math inline">\(c\in(a,b)\)</span>，使得<spanclass="math inline">\(\frac{f’(c)}{g’(c)}=\frac{f(a)-g(b)}{g(a)-g(b)}\)</span>。</p><ul><li>证明：构造<spanclass="math inline">\(F(x)=(f(x)-f(a))(g(b)-g(a))-(g(x)-g(a))(f(b)-f(a))\)</span>，应用洛尔定理。</li></ul><h3 id="微分中值定理的应用">3.5 微分中值定理的应用</h3><h4 id="洛必达法则">洛必达法则</h4><ol type="1"><li><span class="math inline">\(x\rightarrow a\)</span>或<spanclass="math inline">\(x\rightarrow\infin\)</span>，函数<spanclass="math inline">\(f(x)\)</span>和<spanclass="math inline">\(F(x)\)</span>趋于0或无穷。</li><li><span class="math inline">\(f&#39;(x)\)</span>和<spanclass="math inline">\(F&#39;(x)\)</span>在<spanclass="math inline">\(a\)</span>的去心邻域，或<spanclass="math inline">\(x\)</span>足够大时存在，且<spanclass="math inline">\(F&#39;(x)\)</span>不为0。</li><li><spanclass="math inline">\(\lim\frac{f&#39;(x)}{F&#39;(x)}\)</span>存在或为无穷大。</li></ol><p>则<span class="math inline">\(\lim_{x\rightarrowa}\frac{f(x)}{F(x)}=\lim_{x\rightarrowa}\frac{f&#39;(x)}{F&#39;(x)}\)</span>，或<spanclass="math inline">\(\lim_{x\rightarrow\infin}\frac{f(x)}{F(x)}=\lim_{x\rightarrow\infin}\frac{f&#39;(x)}{F&#39;(x)}\)</span>。</p><ul><li>注意定义中的使用条件。</li><li>证明：应用柯西中值定理。</li></ul><h4 id="泰勒公式">泰勒公式</h4><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>处<spanclass="math inline">\(n\)</span>次可导，则<spanclass="math inline">\(x\rightarrow x_0\)</span>时，</p><p><span class="math inline">\(f(x) =f(x_0)+\frac{f’(x_0)(x-x_0)}{1!}+……+\frac{f^{(n)}(x)(x -x_0)^n}{n!}+o((x - x_0)^n)\)</span></p><p><span class="math inline">\(o((x -x_0)^n)\)</span>称为皮亚诺余项，该公式称为带皮亚诺余项的泰勒展开式。</p><p><spanclass="math inline">\(x_0=0\)</span>时，又称为带皮亚诺余项的麦克劳林公式。</p><ul><li><p>推导：反复应用拉格朗日中值定理。</p></li><li><p><span class="math inline">\(x\rightarrow0\)</span>时，有</p><ul><li><span class="math inline">\(\sin x=x - \frac{x^3}{3!} +\frac{x^5}{5!}+……+ (-1)^{(n-1)}·\frac{x^{(2n-1)}} {(2n-1)!} +o(x^{2n})\)</span></li><li><span class="math inline">\(\cosx=1-\frac{x^2}{2!}+\frac{x^4}{4!}+...+(-1)^n·\frac{x^{2n}}{(2n)!}+o(x^{2n})\)</span></li><li><span class="math inline">\(\tan x=x+\frac{x^3}3 +o(x^3)\)</span></li><li><spanclass="math inline">\(e^x=1+x+\frac{x^2}{2!}+...+\frac{x^n}{n!}+o(x^n)\)</span></li><li><spanclass="math inline">\(\ln(x+1)=x-\frac{x^2}{2}+\frac{x^3}3+...+(-1)^{(n-1)}·\frac{x^n}n+ o(x^n)\)</span></li><li><span class="math inline">\((1+x)^\alpha=1+\alphax+\frac{\alpha(\alpha-1)}{2!}x^2+...+\frac{\alpha(\alpha-1)...(\alpha-n+1)}{n!}x^n+o(x^n)\)</span></li><li><span class="math inline">\(\arctanx=x-\frac{x^3}3+\frac{x^5}5+...+(-1)^{(n+1)}·\frac{x^{2n+1}}{2n+1}+o(x^{2n+1})\)</span></li></ul></li><li><p><spanclass="math inline">\(f(x)=\Sigma_{k=0}^n\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k+R_n(x)\)</span>，其中<spanclass="math inline">\(R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\)</span>称为拉格朗日余项。</p><p><span class="math inline">\(\xi\)</span>在<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(x_0\)</span>之间。</p></li></ul><h4 id="七种未定式计算">七种未定式计算</h4><p><spanclass="math inline">\(\frac00,\frac\infin\infin,0·\infin,\infin-\infin,\infin^0,0^0,1^\infin\)</span></p><ol type="1"><li>化简：<ul><li>提取因式</li><li>等价无穷小代换</li><li>恒等变形</li></ul></li><li>判断类型</li><li>使用洛必达法则、夹逼准则、泰勒展开进行计算</li></ol><h2 id="导数的应用">4. 导数的应用</h2><h3 id="凹凸性与拐点">4.1 凹凸性与拐点</h3><ol type="1"><li><p>凹凸性：</p><p>设函数<span class="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\(I\)</span>上连续，如果对<spanclass="math inline">\(I\)</span>上任意两点<spanclass="math inline">\(x_1,x_2\)</span>，恒有<spanclass="math inline">\(f(\frac{x_1+x_2}2)\lt\frac{f(x_1)+f(x_2)}2\)</span>，则称函数<spanclass="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\(I\)</span>上是凹的；若<spanclass="math inline">\(f(\frac{x_1+x_2}2)\gt\frac{f(x_1)+f(x_2)}2\)</span>，则称函数<spanclass="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\(I\)</span>上是凸的。</p><ul><li>另一定义：对区间内的任意<spanclass="math inline">\(x,x_0\)</span>，均有<spanclass="math inline">\(f(x_0)+f&#39;(x_0)(x-x_0)\ltf(x)\)</span>，则为凹的。</li><li>凹凸性的判断：二阶导数大于0则为凹函数，二阶导数小于0为凸函数。</li></ul></li><li><p>拐点：凹弧和凸弧的分界点。</p><ul><li>拐点的必要条件：二阶导数为0或不存在。<ul><li>拐点的第一充分条件：<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=x_0\)</span>连续，且在<spanclass="math inline">\(x=x_0\)</span>的某去心邻域内二阶导数存在，且左右邻域中<spanclass="math inline">\(f&#39;&#39;(x)\)</span>的正负不同。</li><li>拐点的第二充分条件：二阶导数为0，三阶导数不为0。</li><li>拐点的第三充分条件：<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=x_0\)</span>处<spanclass="math inline">\(n\)</span>阶可导，且<spanclass="math inline">\(f^{(m)(x_0)}=0\)</span>，<spanclass="math inline">\(m=2,...,n-1\)</span>，<spanclass="math inline">\(f^{(n)}(x_0)\neq0\)</span>，<spanclass="math inline">\(n\)</span>为奇数。</li></ul></li></ul></li><li><p>重要结论：</p><ul><li><p>曲线的可导点不可同时为极值点和拐点，不可导点可以同时为极值的和拐点。</p></li><li><p><span class="math inline">\(f(x)=(x-a)^ng(x)\)</span>，且<spanclass="math inline">\(g(a)\neq0\)</span>，当<spanclass="math inline">\(n\)</span>为偶数，<spanclass="math inline">\(x=a\)</span>为极值点，当<spanclass="math inline">\(n\)</span>为奇数，<spanclass="math inline">\(x=a\)</span>为拐点。</p></li><li><p><spanclass="math inline">\(f(x)=(x-a_1)^{n_1}...(x-a_k)^{n_k}\)</span>，其中<spanclass="math inline">\(n_i\)</span>为正整数，<spanclass="math inline">\(a_i\)</span>为实数且两两不等。</p><p>记<span class="math inline">\(k_1\)</span>为<spanclass="math inline">\(n_i=1\)</span>的个数，<spanclass="math inline">\(k_2\)</span>为<spanclass="math inline">\(n_i\gt1\)</span>且为偶数的个数，<spanclass="math inline">\(k_3\)</span>为<spanclass="math inline">\(n_i\gt1\)</span>且为奇数的个数，</p><p>则<span class="math inline">\(f(x)\)</span>的极值点有<spanclass="math inline">\(k_1+2k_2+k_3-1\)</span>个，拐点有<spanclass="math inline">\(k_1+2k_2+3k_3-2\)</span>个。</p></li></ul></li></ol><h3 id="渐近线">4.2 渐近线</h3><p>定义：</p><ul><li>铅直渐近线：<span class="math inline">\(\lim_{x\rightarrowx_0^+}f(x)=\infin\)</span>或<spanclass="math inline">\(\lim_{x\rightarrowx_0^-}f(x)=\infin\)</span>，则<spanclass="math inline">\(x=x_0\)</span>为一条铅直渐近线。</li><li>水平渐近线：<spanclass="math inline">\(\lim_{x\rightarrow+\infin}f(x)=y_1\)</span>或<spanclass="math inline">\(\lim_{x\rightarrow-\infin}f(x)=y_1\)</span>，则<spanclass="math inline">\(y=y_1\)</span>为一条水平渐近线。</li><li>斜渐近线：<spanclass="math inline">\(\lim_{x\rightarrow+\infin}\frac{f(x)}x=a_1,\lim_{x\rightarrow+\infin}(f(x)-a_1x)=b_1\)</span>，则<spanclass="math inline">\(y=a_1x+b_1\)</span>为一条斜渐近线。<ul><li>或<spanclass="math inline">\(\lim_{x\rightarrow-\infin}\frac{f(x)}x=a_1,\lim_{x\rightarrow-\infin}(f(x)-a_1x)=b_1\)</span>，则<spanclass="math inline">\(y=a_1x+b_1\)</span>为一条斜渐近线。</li></ul></li></ul><h3 id="曲率">4.3 曲率</h3><p>设<span class="math inline">\(y(x)\)</span>二阶可导，则曲线<spanclass="math inline">\(y=y(x)\)</span>在点<spanclass="math inline">\((x,y(x))\)</span>处的曲率公式为<spanclass="math inline">\(k=\frac{|y|&#39;&#39;}{(1+y&#39;^2)^{\frac32}}\)</span>，曲率半径为<spanclass="math inline">\(R=\frac1k\)</span>。</p><h3 id="物理应用">4.4 物理应用</h3><ol type="1"><li>质点运动的位移<span class="math inline">\(s\)</span>关于时间<spanclass="math inline">\(t\)</span>的函数为<spanclass="math inline">\(s=s(t)\)</span>，称它为质点的运动方程。<ul><li>速度为<span class="math inline">\(v(t)=s&#39;(t)\)</span></li><li>加速度为<spanclass="math inline">\(a(t)=s&#39;&#39;(t)\)</span>。</li></ul></li><li>相关变化率：若函数<spanclass="math inline">\(y=f(x)\)</span>由参数方程<spanclass="math inline">\(\begin{cases}x=x(t)\\y=y(t)\end{cases}\)</span>确定且可导，则<spanclass="math inline">\(y&#39;,x’\)</span>由<spanclass="math inline">\(f&#39;\)</span>联系起来，称这种相互关联的变化率为相关变化率。</li></ol>]]></content>
    
    
    <categories>
      
      <category>微积分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>函数极限与连续</title>
    <link href="/2021/09/01/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/"/>
    <url>/2021/09/01/%E5%BE%AE%E7%A7%AF%E5%88%86/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<p>踏遍青山人未老，风景这边独好。</p><span id="more"></span><h1 id="一-函数极限与连续">一 函数极限与连续</h1><h2 id="数列极限">0. 数列极限</h2><h3 id="数列概念与性质">0.1 数列概念与性质</h3><p><span class="math inline">\(\forall n\in \N_+\)</span>，<spanclass="math inline">\(\exists x_n\in \R\)</span>，则<spanclass="math inline">\(x_1,x_2,...,x_n,...\)</span>排列得到的序列称为数列，记作数列<spanclass="math inline">\(\{x_n\}\)</span>。</p><ul><li><p>数列中的每一个数称为数列的项，第<spanclass="math inline">\(n\)</span>项称为数列的通项或一般项。</p></li><li><p>子列：从数列中选取无穷多项，按照原来的顺序组成新的数列称为原数列的子列。</p></li><li><p>等差数列：首项为<spanclass="math inline">\(a_1\)</span>，公差为<spanclass="math inline">\(d\ne0\)</span>，通项公式<spanclass="math inline">\(a_n=a_1+(n-1)d\)</span>，前<spanclass="math inline">\(n\)</span>项和<spanclass="math inline">\(S_n=\frac n2(a_1+a_n)\)</span>。</p></li><li><p>等比数列：首项为<spanclass="math inline">\(a_1\)</span>，公比为<spanclass="math inline">\(q\ne0\)</span>，通项公式<spanclass="math inline">\(a_n=a_1q^{n-1}\)</span>，前<spanclass="math inline">\(n\)</span>项和<spanclass="math inline">\(S_n=\begin{cases} na_1,\quadq=1\\a_1\frac{1-q^n}{1-q} \quad q\ne1 \end{cases}\)</span></p><ul><li><spanclass="math inline">\(1+q+...+q^{n-1}=\frac{1-q^n}{1-q},q\ne1\)</span>。</li></ul></li><li><p>单调性：<span class="math inline">\(\forall n,a_{n+1}&gt;a_n\)</span>，则称数列<spanclass="math inline">\(\{a_n\}\)</span>为单调递增数列。</p></li><li><p>有界性：<span class="math inline">\(\forall n,\exists M\in\R,|a_n|\le M\)</span>，则称数列<spanclass="math inline">\(\{a_n\}\)</span>为有界数列。</p></li><li><p>重要数列：<spanclass="math inline">\(\{(1+\frac1n)^n\}\)</span>：单调递增，且<spanclass="math inline">\(\lim_{n\rightarrow\infin}(1+\frac1n)^n=e\)</span>。</p></li></ul><h3 id="数列极限-1">0.2 数列极限</h3><p>数列<span class="math inline">\(x_n\)</span>，若<spanclass="math inline">\(\exists a\in \R,\forall\varepsilon\gt0,\existsN\in \N_+\)</span>，当<span class="math inline">\(n\gt N\)</span>，<spanclass="math inline">\(|x_n-a|\lt\varepsilon\)</span>，称常数<spanclass="math inline">\(a\)</span>为数列<spanclass="math inline">\(x_n\)</span>的极限，或数列<spanclass="math inline">\(x_n\)</span>收敛于<spanclass="math inline">\(a\)</span>，记为<spanclass="math inline">\(\lim_{n\rightarrow\infin}x_n=a\)</span>。</p><p>如果不存在这样的常数<spanclass="math inline">\(a\)</span>，称数列<spanclass="math inline">\(x_n\)</span>是发散的。</p><h4 id="性质">性质</h4><ol type="1"><li>唯一性：数列<span class="math inline">\(x_n\)</span>，若存在<spanclass="math inline">\(\lim_{n\rightarrow\infin}x_n=a\)</span>，则<spanclass="math inline">\(a\)</span>是唯一的。</li><li>有界性：数列<spanclass="math inline">\(x_n\)</span>的极限存在，那么它有界。</li><li>保号性：<spanclass="math inline">\(\lim_{n\rightarrow\infin}x_n=a\)</span>，则<spanclass="math inline">\(\forall \varepsilon\gt 0,\exists N\in\N_+\)</span>，当<span class="math inline">\(n\gt N\)</span>，<spanclass="math inline">\(x_n\)</span>在<spanclass="math inline">\(a\)</span>的<spanclass="math inline">\(\varepsilon\)</span>邻域内。</li><li>子列的极限：若数列收敛，则其任意子列也收敛于同一极限。</li></ol><h4 id="四则运算">四则运算</h4><ol type="1"><li><p><span class="math inline">\(\lim x_n =a\)</span>，则<spanclass="math inline">\(\lim |x_n| = |a|\)</span></p></li><li><p><span class="math inline">\(\lim x_n =a\)</span>，<spanclass="math inline">\(\lim y_n=b\)</span>，则<spanclass="math inline">\(\lim (x_n\pm y_n) = a\pm b\)</span></p></li><li><p><span class="math inline">\(\lim x_n =a\)</span>，<spanclass="math inline">\(\lim y_n=b\)</span>，则<spanclass="math inline">\(\lim (x_n·y_n) = ab\)</span></p></li><li><p>设<span class="math inline">\(x_n\ne0,n=1,2,...\)</span>，<spanclass="math inline">\(\lim x_n=a\ne0\)</span>，则<spanclass="math inline">\(\lim \frac1{x_n}=\frac1a\)</span>。</p></li></ol><h4 id="函数极限的数列定义">函数极限的数列定义</h4><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(a\)</span>的某个去心邻域上有定义，那么<spanclass="math inline">\(\lim_{x→a}f(x)=A\)</span>等价于：</p><p>每一项均在<spanclass="math inline">\(a\)</span>的去心邻域中的数列<spanclass="math inline">\(\{x_n\}\)</span>，<span class="math inline">\(\limx_n=a\)</span>，<span class="math inline">\(f(x_n)\)</span>在<spanclass="math inline">\(n→+∞\)</span>的极限为<spanclass="math inline">\(A\)</span>。</p><h3 id="数列极限存在准则">0.3 数列极限存在准则</h3><h4 id="夹逼准则">夹逼准则</h4><p>设<spanclass="math inline">\(\{x_n\},\{y_n\},\{z_n\}\)</span>都是实数列，<spanclass="math inline">\(\exists n_0\in \N_+\)</span>，当<spanclass="math inline">\(n\gt n_0\)</span>，有<spanclass="math inline">\(x_n\le y_n\le z_n\)</span>，那么如果<spanclass="math inline">\(\{x_n\}\)</span>与<spanclass="math inline">\(\{z_n\}\)</span>都收敛于<spanclass="math inline">\(a\)</span>，<spanclass="math inline">\(\{y_n\}\)</span>也收敛于<spanclass="math inline">\(a\)</span>。</p><h4 id="单调有界准则">单调有界准则</h4><p>递增序列收敛的充要条件是它有上界。</p><h2 id="函数的概念与性质">1. 函数的概念与性质</h2><h3 id="函数">1.1 函数</h3><p>变量<span class="math inline">\(x,y\)</span>，给定数集<spanclass="math inline">\(D\)</span>，<span class="math inline">\(\forallx\in D\)</span>，按一定法则<span class="math inline">\(f\)</span>，<spanclass="math inline">\(\exists y\)</span>与<spanclass="math inline">\(x\)</span>对应，称<spanclass="math inline">\(y\)</span>为<spanclass="math inline">\(x\)</span>的函数，记作<spanclass="math inline">\(y=f(x)\)</span>。</p><ul><li><span class="math inline">\(x\)</span>为自变量，<spanclass="math inline">\(y\)</span>为因变量，<spanclass="math inline">\(D\)</span>为函数的定义域，<spanclass="math inline">\(\{f(x)|x\in D \}\)</span>为函数的值域。</li></ul><p>函数是两个非空数集上的双射。</p><ul><li>单射：每一个<span class="math inline">\(x\)</span>都有唯一的<spanclass="math inline">\(y\)</span>与之对应</li><li>满射：每个<span class="math inline">\(y\)</span>都至少有一个<spanclass="math inline">\(x\)</span>与之对应</li><li>满足单射和满射即为双射，也称一一对应。</li></ul><h4 id="基本初等函数和初等函数">基本初等函数和初等函数</h4><p>基本初等函数：常函数、幂函数、指数函数、对数函数、三角函数、反三角函数</p><ol type="1"><li><p><span class="math inline">\(y=C,C\in \mathbbR\)</span>。</p></li><li><p><span class="math inline">\(y=x^a,a\in \mathbbR\)</span>。</p></li><li><p><span class="math inline">\(y=a^x,a\in \mathbbR\)</span>。</p></li><li><p><span class="math inline">\(y=\log_ax,a\in \mathbbR\)</span>。</p></li><li><p><span class="math inline">\(y=\sin x,y=\cos x,y=\tan x,y=\cotx\)</span>，</p><p><span class="math inline">\(y=\sec x=\frac1{\cos x},y=\cscx=\frac1{\sin x}\)</span>，</p></li><li><p><span class="math inline">\(y=\arcsin x,y=\arccos x,y=\arctanx\)</span>。</p></li></ol><p>由基本初等函数经过有限次四则运算和有限次复合构成的可用表达式表示的函数为初等函数。</p><ul><li><span class="math inline">\(y=\sin x\)</span>和<spanclass="math inline">\(y=e^x\)</span>为初等函数的生成函数。</li></ul><h4 id="几个特殊函数">几个特殊函数</h4><ol type="1"><li>取整函数：<span class="math inline">\(y=[x]\)</span>，当<spanclass="math inline">\(n\le x\lt n+1\)</span>，<spanclass="math inline">\(y=n\)</span>。</li><li>符号函数：<span class="math inline">\(y =sgn(x)=\begin{cases}-1,x\lt0\\0,x=0\\1,x\gt0 \end{cases}\)</span>。</li><li>狄利克雷函数：<span class="math inline">\(y =D(x)=\begin{cases}0,x为无理数\\1,x为有理数 \end{cases}\)</span>。</li><li>黎曼函数：<span class="math inline">\(y=\begin{cases}\fracqp,x为有理数,\frac qp为x的既约分数表示\\0,x为无理数\end{cases}\)</span>。</li></ol><h4 id="反函数">反函数</h4><p>设函数<span class="math inline">\(f(x)\)</span>的定义域为<spanclass="math inline">\(D\)</span>，值域为<spanclass="math inline">\(R\)</span>，如果对于每一个<spanclass="math inline">\(y\in R\)</span>，存在唯一<spanclass="math inline">\(x\in D\)</span>使得<spanclass="math inline">\(y=f(x)\)</span>，则可以定义函数<spanclass="math inline">\(x=\varphi(y)\)</span>，这个函数称为<spanclass="math inline">\(y=f(x)\)</span>的反函数，一般记作<spanclass="math inline">\(x=f^{-1}(y)\)</span>，它的定义域为<spanclass="math inline">\(R\)</span>，值域为<spanclass="math inline">\(D\)</span>。</p><ul><li>严格单调函数必有反函数。</li><li><span class="math inline">\(y=f^{-1}(x)\)</span>与<spanclass="math inline">\(y=f(x)\)</span>的图像关于<spanclass="math inline">\(y=x\)</span>对称。</li></ul><p>双曲正弦函数：<spanclass="math inline">\(y=\frac{e^x-e^{-x}}2\)</span></p><p>反双曲正弦函数：<spanclass="math inline">\(y=\ln(x+\sqrt{x^2+1})\)</span></p><p>双曲余弦函数：<spanclass="math inline">\(y=\frac{e^x+e^{-x}}2\)</span></p><p>重要结论：</p><ol type="1"><li><span class="math inline">\(x\rightarrow0,\ln(x+\sqrt{x^2+1})\simx\)</span>。</li><li><spanclass="math inline">\([\ln(x+\sqrt{x^2+1})]&#39;=\frac{1}{\sqrt{x^2+1}},\int\frac{1}{\sqrt{x^2+1}}dx=\ln(x+\sqrt{x^2+1})+C\)</span></li><li><spanclass="math inline">\(y=\ln(x+\sqrt{x^2+1})\)</span>是奇函数，<spanclass="math inline">\(\int_{-1}^1\ln(x+\sqrt{x^2+1})dx=0\)</span></li></ol><h4 id="复合函数">复合函数</h4><p><span class="math inline">\(y=f(u)\)</span>的定义域为<spanclass="math inline">\(D_1\)</span>，<spanclass="math inline">\(u=g(x)\)</span>在<spanclass="math inline">\(D\)</span>上有定义，且<spanclass="math inline">\(g(D)\sub D_1\)</span>，由<spanclass="math inline">\(y=f[g(x)],x\in D\)</span>确定的函数称为由<spanclass="math inline">\(u=g(x)\)</span>和<spanclass="math inline">\(y=f(u)\)</span>构成的复合函数，它的定义域为<spanclass="math inline">\(D\)</span>，<spanclass="math inline">\(u\)</span>称为中间变量。</p><h4 id="隐函数">隐函数</h4><p>方程<span class="math inline">\(F(x,y)=0\)</span>，若<spanclass="math inline">\(x\)</span>取某区间的任一值，总有唯一的满足该方程的<spanclass="math inline">\(y\)</span>存在，则称<spanclass="math inline">\(F(x,y)=0\)</span>在上述区间上确定了一个隐函数<spanclass="math inline">\(y=f(x)\)</span>。</p><h4 id="分段函数">分段函数</h4><p>三个重要分段函数：</p><ol type="1"><li><span class="math inline">\(y=|x|,x\in \mathbb R\)</span></li><li><span class="math inline">\(y=sgn x= \begin{cases} 1,\quad x\gt0\\0,\quad x=0\\ -1, \quad x\lt0\end{cases}\)</span>，称为符号函数。</li><li><span class="math inline">\(y=[x]\)</span>，取整函数，<spanclass="math inline">\(y\)</span>为不超过<spanclass="math inline">\(x\)</span>的最大整数。</li></ol><h3 id="函数的性质">1.2 函数的性质</h3><h4 id="有界性">有界性</h4><p>设<span class="math inline">\(f(x)\)</span>的定义域为<spanclass="math inline">\(D\)</span>，区间<span class="math inline">\(I\inD\)</span>，若<span class="math inline">\(\forall x\in I\)</span>，<spanclass="math inline">\(|f(x)|\le M\)</span>，称<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(I\)</span>上有界，否则称<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(I\)</span>上无界。</p><h4 id="单调性">单调性</h4><p>设<span class="math inline">\(f(x)\)</span>的定义域为<spanclass="math inline">\(D\)</span>，区间<span class="math inline">\(I\inD\)</span>，<span class="math inline">\(\forall x_1,x_2\in I,f(x_1)\ltf(x_2)\)</span>，则称<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(I\)</span>上单调递增；<spanclass="math inline">\(f(x_1)\gt f(x_2)\)</span>，则称<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(I\)</span>上单调递减。</p><ul><li>定义法判别单调性：<spanclass="math inline">\((x_1-x_2)(f(x_1)-f(x_2))\gt0\)</span>，单调增。（类推单调减/不增/不减）</li></ul><h4 id="奇偶性">奇偶性</h4><p>偶函数：<spanclass="math inline">\(f(x)=f(-x)\)</span>，图像关于<spanclass="math inline">\(y\)</span>轴对称。</p><p>奇函数：<spanclass="math inline">\(-f(x)=f(-x)\)</span>，图像关于原点对称。</p><ul><li>定义域关于原点对称。</li><li><span class="math inline">\(f(x)+f(-x)\)</span>是偶函数，<spanclass="math inline">\(f(x)-f(-x)\)</span>是奇函数。</li><li>偶[奇]、奇[偶]、偶[偶]都是偶函数，奇[奇]为奇函数。</li></ul><h4 id="周期性">周期性</h4><p>设<span class="math inline">\(f(x)\)</span>的定义域为<spanclass="math inline">\(D\)</span>，若存在正数<spanclass="math inline">\(T\)</span>，<span class="math inline">\(\forallx\in D\)</span>，<span class="math inline">\(x+T\in D\)</span>，<spanclass="math inline">\(f(x)=f(x+T)\)</span>，则称<spanclass="math inline">\(f(x)\)</span>为周期函数，<spanclass="math inline">\(T\)</span>为<spanclass="math inline">\(f(x)\)</span>的周期。</p><ul><li><span class="math inline">\(f(ax+b)\)</span>有周期<spanclass="math inline">\(\frac Ta\)</span>。</li><li><span class="math inline">\(g(x)\)</span>为周期函数，则复合函数<spanclass="math inline">\(f(g(x))\)</span>也是周期函数。</li><li>若<span class="math inline">\(f(x)\)</span>是周期为<spanclass="math inline">\(T\)</span>的可导函数，则<spanclass="math inline">\(f&#39;(x)\)</span>有周期<spanclass="math inline">\(T\)</span>。</li><li>若<span class="math inline">\(f(x)\)</span>是周期为<spanclass="math inline">\(T\)</span>的连续函数，则仅当<spanclass="math inline">\(\int_0^Tf(x)dx=0\)</span>，<spanclass="math inline">\(\int_0^xf(t)dt\)</span>有周期<spanclass="math inline">\(T\)</span>。</li></ul><h2 id="函数的极限">2. 函数的极限</h2><h3 id="函数极限">2.1 函数极限</h3><h4 id="邻域">邻域</h4><ol type="1"><li>正数<span class="math inline">\(\delta\)</span>，<spanclass="math inline">\((x_0-\delta,x_0+\delta)\)</span>称为<spanclass="math inline">\(x_0\)</span>的<spanclass="math inline">\(\delta\)</span>邻域，记作<spanclass="math inline">\(U(x_0,\delta)\)</span></li><li>去心<span class="math inline">\(\delta\)</span>邻域：<spanclass="math inline">\(U\)</span>上加。</li><li>左/右<span class="math inline">\(\delta\)</span>邻域：<spanclass="math inline">\(U^-/U^+\)</span></li></ol><h4 id="函数极限的定义">函数极限的定义</h4><p>设函数<span class="math inline">\(f(x)\)</span>在点<spanclass="math inline">\(x_0\)</span>的某一去心邻域上有定义，<spanclass="math inline">\(\exists A\in \mathbb R,\forall \varepsilon\gt0\)</span>，总存在正数<spanclass="math inline">\(\delta\)</span>，使得当<spanclass="math inline">\(0\lt|x-x_0|\lt\delta\)</span>时，<spanclass="math inline">\(|f(x)-A|\lt\varepsilon\)</span>，则<spanclass="math inline">\(A\)</span>称为<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x\rightarrow x_0\)</span>时的极限，记为<spanclass="math inline">\(\lim_{x\rightarrow x_0}f(x)=A\)</span>，或<spanclass="math inline">\(x\rightarrow x_0\)</span>，<spanclass="math inline">\(f(x)\rightarrow A\)</span>。</p><ul><li><span class="math inline">\(x\rightarrow\infin\)</span>包含<spanclass="math inline">\(x\rightarrow+\infin\)</span>和<spanclass="math inline">\(x\rightarrow-\infin\)</span>。</li><li><span class="math inline">\(x\rightarrow x_0\)</span>包含<spanclass="math inline">\(x\rightarrow x_0^+\)</span>和<spanclass="math inline">\(x\rightarrow x_0^-\)</span>。</li><li>左右极限不同，则该极限不存在。</li></ul><h4 id="两个重要极限">两个重要极限</h4><p><span class="math inline">\(\lim_{x\rightarrow0}\frac{\sinx}x=1,\lim_{x\rightarrow\infin}(1+\frac1x)^x=e\)</span>。</p><h3 id="函数极限的性质">2.2 函数极限的性质</h3><h4 id="唯一性">唯一性</h4><p>如果函数极限存在，那么它唯一。</p><h4 id="局部有界性">局部有界性</h4><p>如果<span class="math inline">\(\lim_{x\rightarrowx_0}f(x)=A\)</span>，则存在正常数<spanclass="math inline">\(M\)</span>和<spanclass="math inline">\(\delta\)</span>，当<spanclass="math inline">\(0\lt|x-x_0|\lt\delta\)</span>，<spanclass="math inline">\(|f(x)|\le M\)</span>。</p><h4 id="局部保号性">局部保号性</h4><p>如果<span class="math inline">\(\lim_{x\rightarrow x_0}f(x)=A(A\ne0)\)</span>，则存在正常数<spanclass="math inline">\(\delta\)</span>，当<spanclass="math inline">\(0\lt|x-x_0|\lt\delta\)</span>，<spanclass="math inline">\(Af(x)\gt 0\)</span>。</p><h4 id="无穷小和无穷大">无穷小和无穷大</h4><p>如果当<span class="math inline">\(x\rightarrowx_0,f(x)\rightarrow0\)</span>，称<spanclass="math inline">\(f(x)\)</span>为<spanclass="math inline">\(x\rightarrow x_0\)</span>时的无穷小。</p><p>如果当<span class="math inline">\(x\rightarrowx_0,|f(x)|\rightarrow\infin\)</span>，称<spanclass="math inline">\(f(x)\)</span>为<spanclass="math inline">\(x\rightarrow x_0\)</span>时的无穷大。</p><ul><li>有限个无穷小的和是无穷小。</li><li>有界函数和无穷小的乘积是无穷小。</li><li>有限个无穷小的乘积是无穷小。</li></ul><p>无穷小比阶：无穷小之间不一定可以比阶。</p><ul><li><p><spanclass="math inline">\(\lim\frac{\alpha(x)}{\beta(x)}=0\)</span>，则<spanclass="math inline">\(\alpha(x)\)</span>为比<spanclass="math inline">\(\beta(x)\)</span>更高阶的无穷小，记为<spanclass="math inline">\(\alpha(x)=o(\beta(x))\)</span>。</p></li><li><p><spanclass="math inline">\(\lim\frac{\alpha(x)}{\beta(x)}=c,c\ne0\)</span>，则<spanclass="math inline">\(\alpha(x)\)</span>为<spanclass="math inline">\(\beta(x)\)</span>的同阶无穷小。</p></li><li><p><spanclass="math inline">\(\lim\frac{\alpha(x)}{\beta(x)}=1\)</span>，则<spanclass="math inline">\(\alpha(x)\)</span>为<spanclass="math inline">\(\beta(x)\)</span>的等价无穷小。</p></li><li><p><spanclass="math inline">\(\lim\frac{\alpha(x)}{\beta(x)^k}=c,c\ne0\)</span>，则<spanclass="math inline">\(\alpha(x)\)</span>为<spanclass="math inline">\(\beta(x)\)</span>的<spanclass="math inline">\(k\)</span>阶无穷小</p></li></ul><p>常用等价无穷小：<spanclass="math inline">\(x\rightarrow0\)</span></p><ol type="1"><li><span class="math inline">\(\sin x\sim x,\tan x\sim x,\arcsin x\simx,\arctan x\sim x\)</span></li><li><span class="math inline">\(\ln(1+x)\sim x\)</span></li><li><span class="math inline">\(a^x-1\sim x\ln a,e^x-1\simx\)</span></li><li><span class="math inline">\(1-\cos x\sim \frac12x^2\)</span></li><li><span class="math inline">\((1+x)^a-1\sim ax\)</span></li><li><span class="math inline">\((1+x)^{\frac1x}-e\sim-\frace2x\)</span></li></ol><p>无穷小计算：正整数m，n。</p><ol type="1"><li><spanclass="math inline">\(o(x^m)+o(x^n)=o(x^l),l=min[m,n]\)</span>：加减法得低阶</li><li><spanclass="math inline">\(o(x^m)·o(x^n)=o(x^{m+n}),x^m·o(x^n)=o(x^{m+n})\)</span>：乘法阶数相加</li><li><span class="math inline">\(ko(x^m)=o(x^m),k\ne0\)</span>且<spanclass="math inline">\(k\)</span>为常数：非零常数相乘不影响阶数</li></ol><h3 id="函数极限的计算">2.3 函数极限的计算</h3><h4 id="极限四则运算">极限四则运算</h4><p>设<span class="math inline">\(\lim f(x)=A,\lim g(x)=B\)</span>：</p><ol type="1"><li><spanclass="math inline">\(\lim[kf(x)+lg(x)]=kA+lB\)</span>，其中<spanclass="math inline">\(k,l\)</span>为常数。</li><li><span class="math inline">\(\lim[f(x)·g(x)]=AB\)</span>。</li><li><span class="math inline">\(\lim\frac{f(x)}{g(x)}=\fracAB,B\ne0\)</span>。</li></ol><h4 id="夹逼准则-1">夹逼准则</h4><p><span class="math inline">\(f(x),g(x),h(x)\)</span>在<spanclass="math inline">\(a\)</span>的某个去心邻域上有定义，满足不等式<spanclass="math inline">\(f(x)\le g(x)\le h(x)\)</span>，并且<spanclass="math inline">\(f(x)\)</span>和<spanclass="math inline">\(h(x)\)</span>在<spanclass="math inline">\(x→a\)</span>的极限为<spanclass="math inline">\(A\)</span>，则<spanclass="math inline">\(g(x)\)</span>在<spanclass="math inline">\(x→a\)</span>的极限为<spanclass="math inline">\(A\)</span>。</p><h2 id="函数的连续性">3. 函数的连续性</h2><h3 id="间断与连续">3.1 间断与连续</h3><p>间断：<spanclass="math inline">\(\exist\varepsilon&gt;0,\forall\delta&gt;0\)</span>，<spanclass="math inline">\(\exist x\)</span>满足<spanclass="math inline">\(|x-x_0|&lt;\delta\)</span>，使得<spanclass="math inline">\(|f(x)-f(x_0)|\ge\varepsilon\)</span>。</p><p>连续：<spanclass="math inline">\(\forall\varepsilon\gt0,\exist\delta\gt0,\forallx\)</span>满足<spanclass="math inline">\(|x-x_0|&lt;\delta\)</span>，有<spanclass="math inline">\(|f(x)-f(x_0)|\lt\varepsilon\)</span>。</p><ul><li>初等函数在其定义域的每一点都连续。</li></ul><h4 id="单侧连续">单侧连续</h4><ol type="1"><li><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>处右极限存在且等于<spanclass="math inline">\(f(x_0)\)</span>，则称其为右连续。</p></li><li><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>处左极限存在且等于<spanclass="math inline">\(f(x_0)\)</span>，则称其为左连续。</p></li><li><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>处连续等价于<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>处左右连续。</p></li></ol><h4 id="间断分类">间断分类</h4><ol type="1"><li>第一类间断：<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的左右极限都存在。<ul><li><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的左极限不等于右极限：跳跃间断点。</li><li><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的左极限等于右极限：可去间断点。</li></ul></li><li>第二类间断：<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的左右极限至少有一个不存在。<ul><li><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的一侧极限为无穷：无穷间断点。</li><li><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的极限振荡不存在：振荡间断点。</li></ul></li></ol><h4 id="连续函数">连续函数</h4><p>若<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\((a,b)\)</span>上有定义，且<spanclass="math inline">\(\forall x_0∈(a,b)\)</span>，<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>连续，则称<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\((a,b)\)</span>上连续。</p><p>若<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上有定义，且在<spanclass="math inline">\((a,b)\)</span>上连续，在<spanclass="math inline">\(a\)</span>右连续，在<spanclass="math inline">\(b\)</span>左连续，则称<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续。</p><ul><li>连续函数的局部有界性、局部保号性</li><li>连续函数四则运算仍为连续函数</li><li>有限个连续函数的和是连续函数。</li></ul><h3 id="闭区间上连续函数的性质">3.2 闭区间上连续函数的性质</h3><h4 id="零点定理">零点定理</h4><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，且<spanclass="math inline">\(f(a)·f(b)&lt;0\)</span>,则至少存在一个<spanclass="math inline">\(\xi\in(a,b)\)</span>,使得<spanclass="math inline">\(f(\xi)=0\)</span>。</p><h4 id="介值定理">介值定理</h4><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续且<spanclass="math inline">\(f(a)\)</span>不等于<spanclass="math inline">\(f(b)\)</span>，<spanclass="math inline">\(\mu\)</span>为满足不等式<spanclass="math inline">\(f(a)&lt;\mu&lt;f(b)\)</span>或<spanclass="math inline">\(f(b)&lt;\mu&lt;f(a)\)</span>的任何实数，则存在<spanclass="math inline">\(\xi\in(a,b)\)</span>，使<spanclass="math inline">\(f(\xi)=\mu\)</span>。</p><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\((a,b)\)</span>连续，且<spanclass="math inline">\(\lim_{x\rightarrow a^+}f(x)=m\)</span>，<spanclass="math inline">\(\lim_{x\rightarrow b^-}f(x)=n\)</span>，<spanclass="math inline">\(\mu\)</span>为满足不等式<spanclass="math inline">\(m&lt;\mu&lt;n\)</span>或<spanclass="math inline">\(n&lt;\mu&lt;m\)</span>的任何实数，则存在<spanclass="math inline">\(\xi\in(a,b)\)</span>，使<spanclass="math inline">\(f(\xi)=\mu\)</span>。</p><h4 id="有界性定理">有界性定理</h4><p><span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，则<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上有界。</p><h4 id="最值定理">最值定理</h4><p>若<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，则<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上有最大最小值。</p>]]></content>
    
    
    <categories>
      
      <category>微积分</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
