<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器学习_03_树学习</title>
    <link href="/2023/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="树学习">树学习</h1><p>20230926</p><p>18:30-21:30</p><p>20231010</p><p>18:30-21:30</p><h2 id="符号学习">符号学习</h2><p>推理的角度：</p><ul><li>演绎推理：<span class="math inline">\(P\rightarrowQ\)</span>，P为真则Q为真</li><li>反绎推理：<span class="math inline">\(P\rightarrowQ\)</span>，Q为真则P为真</li><li>归纳推理：P为真，Q未必为真</li></ul><p>符号（概念）学习是一类归纳推理。</p><h3 id="概念学习">概念学习</h3><p>给定样例集合，以及每个样例是否属于某个概念，自动地推断出该概念的一般定义。</p><h4 id="概念学习任务">概念学习任务</h4><ul><li>实例集合X</li><li>目标概念c：定义在实例集X上的布尔函数<spanclass="math inline">\(c:X\rightarrow\{0,1\}\)</span></li><li>训练样例：正例<spanclass="math inline">\((c(x)=1)\)</span>，反例<spanclass="math inline">\((c(x)=0)\)</span></li><li>假设集H：每个假设h表示X上定义的布尔函数<spanclass="math inline">\(h:X\rightarrow\{0,1\}\)</span></li></ul><p>概念学习：寻找一个假设h，使对于X中的所有x，<spanclass="math inline">\(h(x)=c(x)\)</span></p><p>归纳学习假设：任一假设如果在足够大的训练样例集合中能很好地逼近目标概念函数，它也能在未见实例中很好地逼近目标概念。</p><h4 id="作为搜索的概念学习">作为搜索的概念学习</h4><p>当假设的表示确定后，也就确定了概念学习算法所有假设的空间。</p><p>搜索的目标是为了寻找最好的拟合训练样例的假设。</p><p>搜索的操作：</p><ul><li>用逻辑变量替换常量</li><li>合取表达式去掉部分条件</li><li>对表达式增加析取项</li><li>用属性的超类来替换属性</li></ul><h4 id="假设的一般到特殊序">假设的一般到特殊序</h4><ul><li><p>更泛化</p><p><span class="math inline">\(令h_j和h_k是定义在X上的布尔函数，h_j\ge_gh_k即h_j更泛化于h_k\)</span></p><p><span class="math inline">\(当且仅当(\forall x\inX)[(h_k(x)=1)\rightarrow (h_j(x)=1)]\)</span></p></li><li><p>严格泛化：记为<spanclass="math inline">\(h_j\gt_gh_k\)</span></p></li><li><p>更特化：记为<spanclass="math inline">\(h_j\ge_sh_k\)</span></p></li></ul><h3 id="寻找极大特殊假设find-s">寻找极大特殊假设，Find-S</h3><ol type="1"><li><p>将h初始化为H中最特殊的假设</p></li><li><p>对每个正例x：</p><p>对h的每个属性约束，如果x满足，不处理；</p><p>否则将该约束替换为x满足的另一个最一般的约束</p></li><li><p>输出假设h</p></li></ol><p>对以属性合取式表示的假设空间，输出与正例一致的最特殊的假设。</p><h3id="列表消除算法list-then-eliminate">列表消除算法，List-Then-Eliminate</h3><ol type="1"><li>变型空间Version Space：假设空间H中所有假设的列表</li><li>对每个样例<spanclass="math inline">\(&lt;x,c(x)&gt;\)</span>，从变型空间中移除<spanclass="math inline">\(h(x)\neq c(x)\)</span>的假设h</li><li>输出变型空间中的假设列表</li></ol><p>要列出所有假设，在实际中往往不可能。</p><h2 id="变型空间">变型空间</h2><p>一致：一个假设h与训练样例集合D一致，当且仅当<spanclass="math inline">\(Consistent(h,D)\equiv(\forall&lt;x,c(x)&gt;\inD)\quad h(x)=c(x)\)</span>。</p><p>变型空间（Version Space）：</p><p>关于假设空间H和训练样例集合D的变型空间，是H中与训练样例D一致的所有假设构成的子集。<spanclass="math inline">\(VS_{H,D}\equiv\{h\inH|Consistent(h,D)\}\)</span></p><ul><li><p>极大泛化：H中和D一致的极大一般成员的集合</p><p><span class="math inline">\(G\equiv\{g\inH|Consistent(g,D)\and(\neg\exist g&#39;\in H[(g&#39;\gt_g g)\andConsistent(g&#39;,D)])\}\)</span></p></li><li><p>极大特化：H中和D一致的极大特殊成员的集合</p><p><span class="math inline">\(S\equiv\{s\inH|Consistent(s,D)\and(\neg\exist s&#39;\in H[(s\gt_s s&#39;)\andConsistent(s&#39;,D)])\}\)</span></p></li></ul><h3 id="表示定理">表示定理</h3><p>令X为任意的实例集合，H为X上定义的布尔函数集合。令<spanclass="math inline">\(c:X\rightarrow[0,1]\)</span>为X上定义的任一目标概念，并令D为任意训练样例的集合<spanclass="math inline">\(\{&lt;x,c(x)&gt;\}\)</span>。对所有的X，H，c，D以及良好定义的S和G：<spanclass="math inline">\(VS_{H,D}\equiv\{h\in H|(\exist s\in S)(\exist g\inG)[g\gt_g h\gt_s s]\}\)</span></p><ul><li>其中G为极大泛化集合，S为极大特化集合。</li></ul><h3 id="正例和反例的作用">正例和反例的作用</h3><p>正例用于S泛化，搜索S集合；反例用于G特化，缩小G集合。</p><p>反例对于超泛化具有抑制作用。</p><h3 id="候选消除算法">候选消除算法</h3><p>将G集合初始化为H中最一般的假设：<spanclass="math inline">\(G_0=\{&lt;?,...,?&gt;\}\)</span></p><p>将S集合初始化为H中最特殊的假设：<spanclass="math inline">\(S_0=\{&lt;\empty,...,\empty&gt;\}\)</span></p><p>对每个训练样例d，</p><ul><li><p>如果d是正例：</p><ul><li><p>从G中移去所有与d不一致的假设</p></li><li><p>对S中每一个与d不一致的假设s：</p><ul><li><p>从S中移除s</p></li><li><p>把s的所有极小泛化假设h加入到S中</p><p>h满足与D一致，而且G中某个成员比h更一般</p></li><li><p>从S中移去所有比S中另一假设更一般的假设</p></li></ul></li></ul></li><li><p>如果d是反例：</p><ul><li><p>从S中移去所有和d不一致的假设</p></li><li><p>对G中每一个与d不一致的假设g：</p><ul><li><p>从G中移除g</p></li><li><p>把g的所有极小特化假设h加入到G中</p><p>h满足与D一致，而且S中某个成员比h更特殊</p></li><li><p>从G中移去所有比G中另一假设更特殊的假设</p></li></ul></li></ul></li></ul><h3 id="归纳偏置">归纳偏置</h3><p>归纳推理的根本问题：</p><ul><li>目标概念假设不在假设空间怎么办？</li><li>能设计包含所有假设的空间吗？</li><li>假设空间大小对未见实例的泛化能力有什么影响？</li><li>假设空间大小对所需训练样例数量有什么影响？</li></ul><p>假设空间往往是合取的有偏表示，而真实空间是析取的无偏表示。</p><p>无偏学习的无用性：</p><p>无偏学习需要X中所有实例进行训练，无法进行泛化，变型空间和候选消除算法失效。</p><p>因此，归纳学习必须给定某种形式的预先假定，即归纳偏置。</p><ul><li><p>核心：学习器从训练样例中泛化并推断新实例分类过程中所采用的策略</p></li><li><p>精确定义：</p><ul><li><p>给定任意训练数据<spanclass="math inline">\(D_c=\{x,c(x)\}\)</span>，目标概念c，学习算法L</p></li><li><p>推断新实例性<span class="math inline">\(x_i\)</span></p></li><li><p>归纳推理过程为：</p><p><span class="math inline">\((D_c\and x_i)\rightarrowL(x_i,D_c)\)</span></p><p><span class="math inline">\((B\and D_c\and x_i)\vdashL(x_i,D_c)\)</span></p></li></ul><p>学习器的归纳偏置为附加的前提集合B，通过B，则归纳推理可由演绎推理派生</p></li></ul><h4 id="有偏性">有偏性</h4><ul><li>无归纳偏置</li><li><span class="math inline">\(c\in H\)</span></li><li><span class="math inline">\(c\inH\)</span>且任何实例，除非可由其他先验推出，否则为反例</li></ul><p>有偏性越强，则学习器的归纳能力越强。</p><p>有偏程度不同的三种归纳学习算法：</p><ul><li>机械式学习器</li><li>候选消除算法</li><li>Find-S</li></ul><h2 id="决策树学习">决策树学习</h2><ul><li><p>实例：“属性-值”对表示，应用最广的归纳推理算法之一</p></li><li><p>目标函数具有离散的输出值</p></li><li><p>很好的健壮性（样例可以包含错误，也可以处理缺少属性值的实例）</p></li><li><p>能够学习析取表达式</p></li></ul><p>决策树学习算法：</p><ul><li>ID3、Assistant、C4.5</li><li>搜索一个完整表示的假设空间，表示为多个if-then规则</li></ul><p>归纳偏置：优先选择较小的树</p><h3 id="算法框架">算法框架</h3><p>问题设置：</p><ul><li>可能的实例集X</li><li>未知的目标函数<span class="math inline">\(f:X\rightarrowY\)</span></li><li>假设函数集<span class="math inline">\(H=\{h|h:X\rightarrowY\}\)</span></li></ul><p>输入：未知目标函数f的训练样例<spanclass="math inline">\(\{&lt;x_i,y_i&gt;\}\)</span></p><p>输出：最佳近似f的假设<span class="math inline">\(h\in H\)</span></p><p>算法框架：</p><ol type="1"><li>处理基本情况</li><li>寻找最好的分类属性A</li><li>用A建立一个节点划分样例</li><li>递归处理每一个划分作为其子节点/子树</li></ol><h3 id="假设空间搜索">假设空间搜索</h3><p>搜索的假设空间就是可能的决策树的集合。</p><p>从一个假设空间中搜索一个正确拟合训练样例的假设。</p><p>从简单到复杂的爬山算法遍历假设空间。从空的树开始，然后逐步考虑更加复杂的假设。引导爬山搜索的评估函数是信息增益度量。</p><h3 id="如何选择最佳属性">如何选择最佳属性</h3><p>衡量给定的属性区分训练样例的能力：信息增益</p><p>信息的度量：熵，刻画了样例集合的纯度。</p><ul><li><p>目标属性为布尔值的样例集S的熵：</p><p><spanclass="math inline">\(Entropy(S)=-p_+log_2p_+-p_-log_2p_-\)</span></p><p>其中，<span class="math inline">\(p_+\)</span>为正例的概率，<spanclass="math inline">\(p_-\)</span>为反例的概率。</p></li><li><p>熵的一般定义：</p><p><spanclass="math inline">\(Entropy(S)=\Sigma_{i=1}^c(-p_ilog_2p_i)\)</span></p></li></ul><p>信息增益：使用属性分割样例，导致期望熵降低</p><p><span class="math inline">\(Gain(S,A)=Entropy(S)-\Sigma_{v\inValues(A)}\frac{|S_v|}{S}Entropy(S_v)\)</span></p><ul><li><p>其中<spanclass="math inline">\(Values(A)\)</span>是属性A所有可能值的集合</p></li><li><p><spanclass="math inline">\(S_v\)</span>是S中属性A的值为v的子集，即<spanclass="math inline">\(S_v=\{s\in S|A(s)=v\}\)</span></p></li><li><p>第二项是用A分类S后熵的期望值</p></li></ul><h3 id="用于学习布尔函数的id3算法">用于学习布尔函数的ID3算法</h3><p><span class="math inline">\(ID3(Examples,Attributes)\)</span></p><ol type="1"><li><p>创建树的Root结点</p></li><li><p>如果Examples的目标属性均为正，则返回label=+的单结点树Root</p></li><li><p>如果Examples的目标属性均为反，那么返回label=-的单结点树Root</p></li><li><p>如果Attributes为空，那么返回单结点树Root，label设置为Examples中最普遍的目标属性值</p></li><li><p>否则</p><ul><li><p><span class="math inline">\(A\leftarrowAttributes中分类Examples能力最好的属性\)</span></p></li><li><p><span class="math inline">\(Root的决策属性\leftarrowA\)</span></p></li><li><p><span class="math inline">\(对于A的每个可能值v_i\)</span></p><ul><li><p><spanclass="math inline">\(令Examples_{v_i}为Examples中满足A属性值为v_i的子集\)</span></p></li><li><p><span class="math inline">\(如果Examples_{v_i}为空\)</span></p><ul><li><p><spanclass="math inline">\(在这个分支下加一个叶子结点，\)</span></p><p><spanclass="math inline">\(结点的label设置为Examples中最普遍的目标属性值\)</span></p></li></ul></li><li><p><spanclass="math inline">\(否则，在这个分支下加一个子树ID3(Examples_{v_i},Attributes-\{A\})\)</span></p></li></ul></li></ul></li><li><p>结束，返回树Root</p></li></ol><h4 id="id3算法特点">ID3算法特点</h4><p>假设空间：包含所有的决策树</p><p>遍历过程：仅维持单一的当前假设</p><ul><li>变型空间候选消除算法维持满足训练样例的所有假设</li></ul><p>不进行回溯，局部最优</p><p>基于统计，对错误样例不敏感，不适用于增量处理。</p><p>改进算法：C4.5等。</p><h3 id="决策树学习中的归纳偏置">决策树学习中的归纳偏置</h3><p><span class="math display">\[ 搜索策略决定了归纳偏置\begin{cases}近似：优先选择较短的树\\ 有限选择信息增益高的属性更接近根结点的树\end{cases}\]</span></p><h3 id="奥卡姆剃刀原理">奥卡姆剃刀原理</h3><p>如果对于同一现象有两种不同的假说，应该采取比较简单的那一种。</p><ul><li>不是简单的选择最简化的假设，而是推理所依据的是使可证伪的假设的数目更少。</li></ul><h2 id="其他树算法">其他树算法</h2><h3 id="c4.5算法">C4.5算法</h3><p>属性选择指标：</p><p>信息增益率：信息增益/该属性的熵</p><ul><li>信息增益准则对可取值数目较多的属性有所偏好</li><li>避免对取值数目较少的属性有所偏好，采用以下启发式：<ul><li>先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的</li></ul></li></ul><h3 id="cart算法">CART算法</h3><h4 id="属性选择指标分类">属性选择指标（分类）</h4><p>信息增益和增益率准则均需要计算对数。</p><p>基尼指数：模型的纯度，越小纯度越高。</p><ul><li><p>K个分类：<spanclass="math inline">\(Gini(p)=\Sigma_{k=1}^K(1-p_k)p_k=1-\Sigma_{k=1}^Kp_k^2\)</span></p></li><li><p>数据集D：<spanclass="math inline">\(Gini(D)=1-\Sigma_{k=1}^K(\frac{C_k}{D})^2\)</span></p></li><li><p>属性A对数据集的划分：<spanclass="math inline">\(Gini(D,A)=\frac{|D_1|}{D}Gini(D_1)+\frac{|D_2|}{D}Gini(D_2)\)</span></p></li><li><p>基尼指数和熵是正相关的，均可用来表示一个集合的混乱程度，并作为叶子结点的损失</p></li></ul><h4 id="属性选择指标回归">属性选择指标（回归）</h4><p>采用方差和度量。</p><p>度量目标是对于划分特征A，对应划分点s两边的数据集<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>，求出使<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>各自集合的均方差最小，同时<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>的均方差之和最小。</p><p><span class="math inline">\(min_{A,s}[min_{c_1}\Sigma_{x_i\inD_1(A,s)}(y_i-c_i)^2+min_{c_2}\Sigma_{x_i\inD_2(A,s)}(y_i-c_2)^2]\)</span></p><p>回归树输出不是类别，采用叶子结点的均值或者中位数来预测输出结果。</p><h4 id="连续值处理">连续值处理</h4><p>连续特征离散化：</p><ul><li>C4.5基于信息增益率离散化，CART基于基尼系数离散化</li><li>m个样本的连续特征A有m个，从小到大排列<spanclass="math inline">\(a_1,...,a_m\)</span>，则CART取相邻两样本值的平均数做划分点，一共取m-1个，其中第i个划分点<spanclass="math inline">\(T_i\)</span>表示为：<spanclass="math inline">\(T_i= (a_i+a_{i+1})/2\)</span>。<ol type="1"><li>分别计算以这m-1个点作为二元分类点时的基尼系数。</li><li>选择基尼系数最小的点为该连续特征的二元离散分类点。</li><li>如取到的基尼系数最小的点为<spanclass="math inline">\(a_t\)</span>，则小于<spanclass="math inline">\(a_t\)</span>的值为类别1；大于<spanclass="math inline">\(a_t\)</span>的值为类别2，这样就做到了连续特征的离散化。</li></ol></li></ul><h4 id="离散值处理">离散值处理</h4><p>CART分类树算法：对离散值的处理，采用不停地二分离散特征。</p><ul><li><p>多叉树：在ID3、C4.5，特征A被选中，如果它有3个取值<spanclass="math inline">\(A_1,A_2,A_3\)</span>，则建立三叉子树</p></li><li><p>二叉树：</p><ul><li>CART将特征A分成<span class="math inline">\(\{A_1\}\)</span>和<spanclass="math inline">\(\{A_2,A_3\}\)</span>、<spanclass="math inline">\(\{A_2\}\)</span>和<spanclass="math inline">\(\{A_1,A_3\}\)</span>、<spanclass="math inline">\(\{A_3\}\)</span>和<spanclass="math inline">\(\{A_1,A_2\}\)</span>三种情况，找到基尼系数最小的组合，比如<spanclass="math inline">\(\{A_2\}\)</span>和<spanclass="math inline">\(\{A_1,A_3\}\)</span>，然后建立二叉树节点。</li><li>由于并没有把特征A的取值完全分开，后面还有机会对子节点继续选择特征A划分<spanclass="math inline">\(A_1\)</span>和<spanclass="math inline">\(A_3\)</span>。</li></ul></li></ul><h4 id="剪枝处理">剪枝处理</h4><p>后剪枝：从完全生长的决策树的底端剪去一些子树，使决策树变小，从而增强泛化能力。</p><ul><li>首先从生成算法产生的决策树<spanclass="math inline">\(T_0\)</span>底端开始不断剪枝，直到<spanclass="math inline">\(T_0\)</span>的根节点，形成一个子序列<spanclass="math inline">\(T_0,...,T_n\)</span></li><li>然后通过交叉验证在独立的验证集上对子树序列进行测试，从中选择最优子树。</li></ul><p>最小化子树的损失函数：<spanclass="math inline">\(C_a(T)=C(T)+a|T|\)</span></p><ul><li>T为任意子树，C(T)为对数据的预测误差（如基尼系数），|T|为子树叶结点个数。超参<spanclass="math inline">\(a\ge0\)</span>，权衡训练数据的拟合程度与模型的复杂度。</li><li>a比较大，则最优子树<span class="math inline">\(T_a\)</span>偏小</li><li>a比较小，则最优子树<span class="math inline">\(T_a\)</span>偏大</li><li>a=0，则最优子树等于未剪枝的<spanclass="math inline">\(T_0\)</span></li><li>a趋近于∞，则最优子树为根结点树</li></ul><h2 id="树学习算法优缺点">树学习算法优缺点</h2><h3 id="优点">优点</h3><ul><li><p>简单直观，可解释性强。</p></li><li><p>基本不需要预处理，也不需要提前归一化和处理缺失值。既可以处理离散值也可以处理连续值。不过很多算法只是专注于离散值或者连续值。</p></li><li><p>可以处理多维度输出的分类问题。</p></li><li><p>使用决策树预测的代价为<spanclass="math inline">\(O(log_2m)\)</span>，m为样本数。</p></li><li><p>可以交叉验证的剪枝来选择模型，从而提高泛化能力。</p></li><li><p>对于异常点的容错能力好，健壮性高。</p></li></ul><h3 id="缺点">缺点</h3><ul><li><p>树算法非常容易过拟合，导致泛化能力不强（设置节点最少样本树、限制树深度）</p></li><li><p>样本的一点变动会导致树结构的剧烈改变（集成学习）</p></li><li><p>寻找最优决策树是NP难题，通过启发式方法容易陷入局部最优（集成学习）</p></li><li><p>比较复杂的关系，决策树很难学习（使用其他学习方法）</p></li><li><p>如果某些特征的样本比例过大，生成决策树比较容易偏向于这些特征（调节样本权重）</p></li></ul><h3 id="延伸">延伸</h3><ul><li><p>BAIR博客地址：https://bair.berkeley.edu/blog/2020/04/23/decisions/</p></li><li><p>论文地址：https://arxiv.org/abs/2004.00221</p></li><li><p>开源项目地址：https://github.com/alvinwan/neu</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_02_无监督学习</title>
    <link href="/2023/09/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="无监督学习">无监督学习</h1><p>20230912</p><p>20:10-21:10</p><p>20230917</p><p>18:30-21:10</p><p>聚类算法 Clustering Algorithm</p><p>聚类的“好坏”不存在绝对标准。</p><h2 id="大纲">大纲</h2><ul><li>相关概念</li><li>距离度量</li><li>聚类准则</li><li>聚类方法</li><li>聚类评价</li></ul><h2 id="相关概念">相关概念</h2><p>聚类：数据对象的集合</p><ul><li>在同一个类里，数据对象是相似的</li><li>不同类的数据对象是不相似的</li></ul><p>聚类算法：根据给定的相似性评判标准，将一个数据集合划分为几个聚类。</p><ul><li><p>数学形式化：</p><p>样本集合：<span class="math inline">\(D=\{x_1,x_2,...,x_m\},x_i\inR^d\)</span></p><p>聚类成k个簇：<span class="math inline">\(\{C_l|l=1,2,...,k\}\)</span></p></li><li><p>好的聚类算法：聚类内部高相似，聚类之间低相似。</p></li></ul><p>聚类的依据：将整个数据集中每个样本的特征向量看成是分布在特征空间中的一些点，点与点之间的距离即可作为相似性度量依据。</p><p>聚类方法目的：寻找数据中潜在的自然分组结构、感兴趣的关系。</p><p>聚类方法的有效性和数据分布形式有很大关系。</p><h2 id="距离度量">距离度量</h2><p>目的：度量同类样本间的相似性或不同样本间的差异性</p><h3 id="度量函数和度量空间">度量函数和度量空间</h3><h3 id="常用度量函数">常用度量函数</h3><p>闵可夫斯基距离</p><h2 id="聚类准则">聚类准则</h2><h3 id="类的定义">类的定义</h3><h3 id="试探方法">试探方法</h3><p>凭直观感觉或方法，针对实际问题定义一种距离度量的阈值，然后按最近邻规则制定某些样本属于一个聚类类别。</p><h3 id="聚类准则函数方法">聚类准则函数方法</h3><h2 id="聚类方法">聚类方法</h2><ul><li>基于试探的聚类搜索算法</li><li>系统聚类法</li><li>动态聚类法</li></ul><h3 id="基于试探的聚类搜索算法">基于试探的聚类搜索算法</h3><h4 id="按最近邻规则的简单试探法">按最近邻规则的简单试探法</h4><p>选用不同的阈值和起始点来试探。</p><p>依赖于以下因素：</p><ul><li>第一个聚类中心的位置</li><li>待分类样本的排序次序</li><li>距离阈值T的大小</li><li>样本分布的几何性质</li></ul><h4 id="最大最小距离算法">最大最小距离算法</h4><p>基本思想：以试探类间欧式距离为最大作为预选出聚类中心的条件。</p><ol type="1"><li>任选一个样本作为第一个聚类中心</li><li>选距离其最远的样本为第二个聚类中心</li><li>逐个计算各样本与两个聚类中心间距离，并选取其中较小值</li><li>在所有较小值中选出最大距离，若该最大值达到一定阈值，则选取相应样本点为迪桑聚类中心</li><li>重复3、4步，若无新聚类中心，进入下一步</li><li>不同样本按最近距离分到最近的聚类中心</li><li>最后，在每一类中计算各样本均值以得到更具代表性的聚类中心。</li></ol><h3 id="系统聚类法">系统聚类法</h3><p>基本思想：</p><p>将数据样本按距离准则逐步分类，类别有多到少，直到获得合适的分类要求为止。</p><h4 id="距离准则函数">距离准则函数</h4><ul><li>最短距离（两个集合所有距离最小值）</li><li>最长距离（两个集合所有距离最大值）</li><li>类平均距离（两个集合所有距离平均值）</li></ul><h3 id="动态聚类法">动态聚类法</h3><p>基本思想：</p><p>首先选择若干个样本点作为聚类中心，再按某种聚类准则使样本点向各中心聚集，从而得到初始聚类；然后判断初始分类是否合理，若不合理，则修改聚类，如此反复，直至合理。</p><p>代表算法：K-means算法和ISODATA算法（迭代自组织数据分析算法）</p><h4 id="k-means算法">K-means算法</h4><ol type="1"><li>选择一个聚类数量k</li><li>初始化聚类中心<ul><li>随机选择k个样本点，设置这些样本点为中心</li></ul></li><li>对每个样本点，计算样本点到k个聚类中心的距离，将样本点分距离它最近的聚类中心所属的聚类</li><li>重新计算聚类中心，聚类中心为属于这一聚类的所有样本的均值</li><li>如果没有发生样本所属的聚类改变的情况则退出，否则，返回第三步重复</li></ol><p>K-means算法的结果影响因素：</p><ul><li>所选聚类数目</li><li>聚类中心的初始分布</li><li>样本分布的几何性质</li></ul><p>在实际应用中，需要试探不同的K值和选择不同的聚类中心的起始值。</p><p>如果数据样本可以形成若干个相距较远的孤立区域分布，一般都能得到较好的收敛效果。</p><ul><li>K-means算法比较适合于分类数目已知的情况。</li></ul><h5 id="k-means">K-means++</h5><p>基本思想：K个初始聚类中心相互之间应该分得越开越好</p><ol type="1"><li>从数据集中随机选取一个样本作为初始聚类中心</li><li>首先计算每个样本与当前已有聚类中心之间的最短距离（即与最近的一个聚类中心的距离），用D(x)表示；接着计算每个样本被选为下一个聚类中心的概率<spanclass="math inline">\(\frac{D(x)^2}{\Sigma_{x\inX}D(x)^2}\)</span>，最后，按轮盘法选择下一个聚类中心</li><li>重复第2步选择出共K个聚类中心</li><li>K-means中第3步至第5步</li></ol><h4 id="迭代自组织数据分析算法-isodata">迭代自组织数据分析算法ISODATA</h4><p>基本步骤与思路：</p><ol type="1"><li>选择某些初始值，可选不同的参数，也可在迭代过程中人为修改，以将N个样本按指标分配到各个聚类中心去</li><li>计算各类中诸样本的距离指标函数</li><li>按给定的要求，将前一次获得的聚类集合进行分裂和合并处理，从而获得新的聚类中心</li><li>重新进行迭代运算，计算各项指标，判断聚类结果是否符合要求。经过多次迭代后，若结果收敛，则运算结束。</li></ol><p>具体过程（运行中能够根据各个类别的实际情况进行分裂和合并来调整聚类中心数）：</p><ol type="1"><li>从数据集中随机选取<spanclass="math inline">\(K_0\)</span>个样本作为聚类中心<spanclass="math inline">\(C=\{c_1,...,c_{K_0}\}\)</span></li><li>针对数据集中每个样本<spanclass="math inline">\(x_i\)</span>，计算它到<spanclass="math inline">\(K_0\)</span>个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中</li><li>判断上述每个类中的元素数目是否小于<spanclass="math inline">\(N_{min}\)</span>。如果小于<spanclass="math inline">\(N_{min}\)</span>则需要丢弃该类，令<spanclass="math inline">\(K=K-1\)</span>，并将该类中的样本重新分配给剩下类中距离最小的类</li><li>针对每个类别<spanclass="math inline">\(c_i\)</span>，重新计算它的聚类中心$c_i=_{xc_i}x</li><li>如果当前<spanclass="math inline">\(K\le\frac{K_0}{2}\)</span>，说明当前类别太少，前往分裂</li><li>如果当前<span class="math inline">\(K\ge2K_0\)</span>，说明当前类别太多，前往合并</li><li>如果达到最大迭代次数则终止，否则返回第2步继续执行</li></ol><p>合并</p><ol type="1"><li><p>计算当前所有类别聚类中心两两之间的距离，用矩阵D表示，其中<spanclass="math inline">\(D(i,i)=0\)</span></p></li><li><p>对于<span class="math inline">\(D(i,j)\lt d_{min}(i\neqj)\)</span>的两个类别需要进行合并操作，变成一个新的类，该类的聚类中心位置为<spanclass="math inline">\(m_{new}=\frac{1}{n_i+n_j}(n_im_i+n_jm_j)\)</span></p><p>上述<span class="math inline">\(n_i\)</span>和<spanclass="math inline">\(n_j\)</span>表示这两个类别中样本的个数，新的聚类中心可以看作对这两个类别进行加权求和。如果其中一个类所包含的样本个数较多，所合成的新类就会更加偏向它。</p></li></ol><ul><li><spanclass="math inline">\(d_{min}\)</span>：两个类别对应聚类中心之间所允许最小距<spanclass="math inline">\(d_{min}\)</span>，是否进行合并的阈值</li></ul><p>分裂</p><ol type="1"><li><p>计算每个类别下所有样本在每个维度下的方差</p></li><li><p>针对每个类别的所有方差挑选出最大的方差<spanclass="math inline">\(\sigma_{max}\)</span></p></li><li><p>如果某个类别的<span class="math inline">\(\sigma_{max}\gtSigma\)</span>并且该类别所包含的样本数量<spanclass="math inline">\(n_i\ge2n_{min}\)</span>，则可以进行分裂操作4，否则退出</p></li><li><p>将满足步骤3中的类分裂成两个子类别并令<spanclass="math inline">\(K=K+1\)</span></p><p><spanclass="math inline">\(m_i^{(+)}=m_i+\sigma_{max},m_i^{-}=m_i-\sigma_{max}\)</span></p></li></ol><ul><li>最大方差Sigma</li></ul><h4 id="两个算法的比较">两个算法的比较</h4><ul><li>K-means算法通常适合于类别数目已知的聚类，而ISODATA算法则更加灵活</li><li>从算法角度看，两者相似，聚类中心都是通过样本均值的迭代计算决定</li><li>ISODATA算法加入了一些试探步骤，并且可以结合人机交互的结构，使其能利用中间结果所取得的经验更好地进行分类</li><li>ISODATA原理直观，但需要更多参数，并且某些参数很难确定，因此ISODATA算法实际过程中并没有很受欢迎</li></ul><h2 id="聚类评价">聚类评价</h2><p>几个评价指标：</p><ul><li>聚类中心之间的距离</li><li>聚类域中的样本数目</li><li>聚类域内样本的距离方差</li></ul><p>聚类目前还没有一种通用的准则，往往需要根据实际应用来选择合适的方法。</p><h3 id="常用评价指标标签未知">常用评价指标（标签未知）</h3><h4 id="紧密度compactnesscp">紧密度（Compactness，CP）</h4><p><spanclass="math inline">\(\overline{CP}=\frac{1}{K}\Sigma_{k=1}^K\overline{CP_k}\)</span></p><p>缺点：没有考虑类间聚类效果。</p><h4 id="间隔度separationsp">间隔度（Separation，SP）</h4><p><spanclass="math inline">\(\overline{SP}=\frac{2}{k^2-k}\Sigma_{i=1}^k\Sigma_{j=i+1}^k||w_i-w_j||_2\)</span></p><p><span class="math inline">\(w_i\)</span>表示第i簇的中心，<spanclass="math inline">\(w_j\)</span>表示第j簇的中心，<spanclass="math inline">\(\overline{SP}\)</span>值越大类间越分散。</p><p>缺点：没有考虑类内聚类效果</p><h4 id="davies-bouldin-indexdbi分类适确性指标">Davies-BouldinIndex(DBI)，分类适确性指标</h4><p><span class="math inline">\(DB=\frac{1}{k}\Sigma_{i=1}^kmax_{j\neqi}(\frac{\overline{C_i}+\overline{C_j}}{||w_i-w_j||_2})\)</span></p><p><spanclass="math inline">\(\overline{C_i}\)</span>表示第i簇的紧密度，<spanclass="math inline">\(w_i\)</span>表示第i簇的中心。</p><p>DB越小，表示类内越紧凑，类间越分散，</p><p>缺点：使用欧式距离，对于环状分布聚类评价很差</p><h4 id="dunn-validity-indexdvi邓恩指数">Dunn ValidityIndex(DVI)，邓恩指数</h4><p>缺点：对离散点的聚类评价高，对环状分布评价效果差</p><h3 id="常用评价指标标签已知">常用评价指标（标签已知）</h3><ul><li>Cluster Accuracy，CA，聚类准确率</li><li>Rand Index，RI，兰德指数</li><li>Adjusted Rand Index，ARI，调整兰德指数</li><li>Mutual Information，MI，互信息</li><li>Normalized Mutual Information，NMI，归一化互信息</li></ul><h2 id="前沿进展">前沿进展</h2><p>监督深度学习：</p><ol type="1"><li>收集大量具有差异性的样本</li><li>对数据进行清洗和精细标注</li><li>采用多块显卡长时间训练</li></ol><p>监督深度学习的困境：</p><ul><li>数据体量大</li><li>数据标注时间长</li><li>数据标注代价高</li></ul><p>现实中，获取原始未标注数据较容易，而典型的监督学习技术不能利用这些数据；</p><p>监督信号有时候会使得深度模型有偏。</p><h3 id="自监督学习">自监督学习</h3><p>无监督学习的一种形式，其中数据没有提供（人类标注的）监督信息。</p><ul><li>通常需要定义一个前置任务让网络学习我们关心的事情。</li><li>对于大部分前置任务，我们需要保留一部分数据，让网络学会预测。</li><li>从前置任务学习到的特征会被用到不同的下游任务（通常包含标注）</li></ul><p>自监督预训练：</p><ul><li>无标注数据</li><li>前置任务预训练</li></ul><p>下游任务迁移：</p><ul><li>有标签数据</li><li>训练测试数据集可不同</li><li>多种下游任务测试</li></ul><h4 id="自监督学习分类">自监督学习分类</h4><ul><li>前置任务学习</li><li>对比学习</li><li>非对比学习</li></ul><h4 id="前置任务学习">前置任务学习</h4><ul><li><p>生成式方法——图像着色</p></li><li><p>生成式方法——图像修复</p></li><li><p>判别式方法——图像拼图</p></li></ul><h4 id="对比学习">对比学习</h4><h4 id="非对比学习">非对比学习</h4>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_01_概率与学习-KNN</title>
    <link href="/2023/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%A6%82%E7%8E%87%E4%B8%8E%E5%AD%A6%E4%B9%A0-KNN/"/>
    <url>/2023/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%A6%82%E7%8E%87%E4%B8%8E%E5%AD%A6%E4%B9%A0-KNN/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="概率与学习-knn">概率与学习-KNN</h1><p>20230912</p><p>18:30-20:10</p><h2 id="大纲">大纲</h2><ol type="1"><li>回顾</li><li>k-近邻分类器</li><li>最近邻分类器</li><li>k-近邻回归</li><li>降低近邻计算</li><li>扩展阅读</li></ol><h2 id="回顾">回顾</h2><p>统计学角度：机器学习的目的是得到映射 <spanclass="math display">\[x\rightarrow y\]</span></p><p>对不同类型的数据用手工/自动的方式进行特征工程，得到特征向量。</p><p>分类问题</p><ul><li>训练集：<spanclass="math display">\[D_{train}=\{(x_1,y_1),(x_2,y_2),...,(x_n,y_n)\}\]</span></li><li>训练样本：<span class="math display">\[x_i\in X\in R^d\]</span></li><li>样本标签：<span class="math display">\[y_i\inY=\{1,2,...,C\}\]</span></li><li>测试集：<spanclass="math display">\[D_test=\{\bar{x}_1,\bar{x}_2...\bar{x}_m\}\]</span></li></ul><p>回归问题</p><ul><li>训练集：<spanclass="math display">\[D_{train}=\{(x_1,y_1),(x_2,y_2),...,(x_n,y_n)\}\]</span></li><li>训练样本：<span class="math display">\[x_i\in X\in R^d\]</span></li><li>样本标签：<span class="math display">\[y_i\in R\]</span></li><li>测试集：<spanclass="math display">\[D_test=\{\bar{x}_1,\bar{x}_2...\bar{x}_m\}\]</span></li></ul><p>距离度量</p><ul><li>欧式距离</li><li>余弦相似性</li><li>曼哈顿距离</li><li>切比雪夫距离</li><li>马氏距离</li></ul><h2 id="k-近邻分类器">k-近邻分类器</h2><p>k-Nearest Neighbor Classfier, k-NN</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择k个最近（距离最小/相似度最大）的训练样本</li><li>采用投票法，将近邻中样本数最多的类别标签分配给<spanclass="math inline">\(\bar{x}\)</span></li></ul><p>k的取值的影响</p><ul><li>k一般取奇数值，避免平局</li><li>k取不同的值，分类结果可能不同</li><li>k值较小时，对噪声敏感，整体模型变得复杂，容易过拟合</li><li>k值较大时，对噪声不敏感，整体模型变得简单，容易欠拟合</li></ul><h2 id="最近邻分类器">最近邻分类器</h2><p>1-Nearest Neighbor Classfier, 1-NN</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择最近（距离最小/相似度最大）的训练样本<spanclass="math inline">\(i^*=argmax d(\bar{x},x_i)\)</span></li><li>采用投票法，将<spanclass="math inline">\(x_{i^*}\)</span>的类别标签分配给<spanclass="math inline">\(\bar{x}\)</span></li></ul><p>泛化错误率</p><ul><li>最近邻分类器的泛化错误率（测试样本x，其最近邻为z）<ul><li><span class="math inline">\(P(error)=1-\Sigma_{c\iny}P(c|x)P(c|z)\)</span></li></ul></li><li>贝叶斯最优分类器的结果：<spanclass="math inline">\(2\times(1-P(c^*|x))\)</span></li></ul><p>最近邻分类器虽然简单，但泛化错误率不超过贝叶斯分类器的两倍。</p><h2 id="k-近邻回归">k-近邻回归</h2><p>k-Nearest Neighbor Regression</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择k个最近（距离最小/相似度最大）的训练样本</li><li>将距离值的倒数作为权重，将k个近邻的标签值加权平均，作为<spanclass="math inline">\(\bar{x}\)</span>的预测值</li></ul><p>近邻平滑：核平滑法（kernel smoother）</p><ul><li>二次核</li><li>次方核</li><li>高斯核</li></ul><h2 id="讨论">讨论</h2><ul><li><p>k-NN是典型的“懒惰学习”。</p><p>训练阶段仅仅是把样本保存起来，训练时间开销为零，待收到测试样本后再进行处理。</p></li><li><p>SVM、CNN等是“急切学习”。</p><p>在训练阶段就对样本进行学习处理的方法，这类方法尝试在训练期间构造一个通用的与输入无关的目标函数。</p></li></ul><p>k-近邻分类器的优缺点</p><ul><li>优点<ul><li>精度高</li><li>对异常值不敏感</li><li>无数据输入假定</li></ul></li><li>缺点<ul><li>计算复杂度高</li><li>空间复杂度高</li></ul></li></ul><p>时间复杂度</p><ul><li>假设<spanclass="math inline">\(d(x_i,x_j)\)</span>是欧式距离，时间复杂度为<spanclass="math inline">\(O(d)\)</span></li><li>训练阶段：0</li><li>测试阶段：<span class="math inline">\(O(nd+nlogk)\)</span><ul><li>从n个数中选择k个最小的，时间复杂度为<spanclass="math inline">\(nlogk\)</span></li></ul></li><li>空间复杂度是？</li></ul><h2 id="降低计算">降低计算</h2><ul><li>特征维度2-5：维诺图</li><li>特征维度6-30：KD-Tree</li><li>特征高维：<ul><li>降维算法，如主成分分析（Principle Component Analysis）PCA</li><li>近似最近邻（approximate nearest neighbor, ANN）</li><li>哈希（hashing）</li></ul></li></ul><h3 id="维诺图">维诺图</h3><p>根据一组给定的目标，将一个平面划分成靠近每一个目标的多个区块。</p><ul><li><p>维诺图由一系列维诺单元组成，每个维诺单元是一个凸多面体</p><ul><li><p>假设X是一个点集，包含K个基点<spanclass="math inline">\((P_k)_{k\in K}\)</span>，那么维诺单元<spanclass="math inline">\(R_k\)</span>定义为：</p><p><span class="math inline">\(R_k=\{x\in X|d(x,P_k)\le d(x,P_j),\forallj\neq k\}\)</span></p></li></ul></li><li><p>查询或测试：给定一个查询<span class="math inline">\(q\inR^d\)</span>，找到<span class="math inline">\(P_k\inX\)</span>，使得<span class="math inline">\(q\in R_k\)</span></p></li><li><p>时间复杂度：</p><ul><li>2维数据：<spanclass="math inline">\(O(nlogn)\)</span>用来计算维诺图；</li><li>d维数据：使用二叉空间分割树进行点的定位，但是时间估计困难，难以量化</li></ul></li><li><p>适用范围：1-NN</p></li><li><p>适合特征维度：2～3维，可能4～5维</p></li></ul><h3 id="kd树">KD树</h3><p>KD树是一种对K维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。</p><p>KD树是二叉树，表示对K维空间的一个划分，构造KD树相当于不断用垂直于坐标轴的超平面将K维空间切分，构成一系列K维超矩形区域。KD树的每个结点对应于一个K维超矩形区域。</p><p>构造流程：</p><ol type="1"><li>确定split域。计算每个特征维度的方差，选定方差最大维度为split域。</li><li>确定Node-data域。</li><li>对剩下的数据点进行划分，确定左右子空间。</li><li>递归。在每个子空间继续进行空间划分，直到空间中只包含一个数据点。</li></ol><p>KD树搜索</p><ol type="1"><li>二叉搜索</li><li>回溯分析</li><li>返回最近邻</li></ol><p>时间复杂度</p><ul><li><p>寻找最近邻的时间复杂度为<spanclass="math inline">\(O(logn)\)</span></p></li><li><p>找到中位数的算法时间复杂度为<spanclass="math inline">\(O(n)\)</span></p></li><li><p>KD树搜索时间复杂度为<spanclass="math inline">\(O(nlogn)\)</span></p></li></ul><h3 id="降维">降维</h3><p>核心思想：通过某种数学变换将原始高维属性空间转变为一个低维子空间，来缓解维数灾难问题。</p><ul><li>多维缩放</li><li>主成分分析</li><li>局部线性潜入</li><li>ISOMAP</li></ul><h3 id="近似最近邻">近似最近邻</h3><p>核心思想：搜索可能是最近邻的数据项而不再只限于返回最可能的数据项，在牺牲可接受范围内的精度的情况下提高检索效率。</p><ul><li>不要求一定是距离最短的k个</li><li>如第k个最近邻，其距离为<spanclass="math inline">\(d_k\)</span>，则ANN要求其选取的所有k个样例的距离<spanclass="math inline">\(\hat{d}\le(1+\varepsilon)d_k\)</span></li><li>可以将k-NN搜索速度提高几个数量级</li></ul><p>FLANN：https://github.com/mariusmuja/flann</p><h3 id="哈希">哈希</h3><p>核心思想：利用哈希函数把任意长度的输入映射为固定长度的输出</p><h2 id="扩展阅读">扩展阅读</h2><h3 id="概率化k-nn">概率化k-NN</h3><p>通过定义似然函数来构造概率化的k-NN。</p><p>https://www.cc.gatech.edu/~afb/classes/CS7616-Spring2014/slides/CS7616-13a-PKNN.pdf</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_6_软件系统</title>
    <link href="/2023/09/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/6_%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/09/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/6_%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第六章-嵌入式软件系统">第六章 嵌入式软件系统</h1><h2 id="概述">1. 概述</h2><h3 id="嵌入式软件与桌面软件的对比">嵌入式软件与桌面软件的对比</h3><p>内存：有限</p><p>CPU：往往只是恰好满足要求</p><p>操作系统：Windows、Linux、RTOS、专有操作系统、裸机</p><p>实时行为：可预测、实时性</p><p>开发流程：资源少，交叉开发；代码需要在特定环境下运行</p><p>执行流程：多数嵌入式设备自开启起就会持续运行某个程序至系统关机</p><ul><li>该程序可能存储在ROM，也可能是从非易失性存储器转移到RAM中执行。</li></ul><p>每个嵌入式设备都不同：</p><ul><li>技术层面：不同的CPU架构、内存、外设、应用程序和操作系统。</li><li>商业运作层面的，比如手机开发、生产的商业模式就和核磁共振扫描仪完全不同。</li></ul><p>软件组件：适合嵌入式环境的库；与硬件交互的接口；网络支持；数据存储；GUI</p><h3 id="软硬件权衡">软硬件权衡</h3><p>软件主导硬件，有关硬件的决策会对软件产生影响。</p><p>软硬件可能是不同团队进行开发。</p><ul><li>微处理器的选择：可能影响软件效率</li><li>内存大小和组合</li><li>包含的外设</li></ul><h3 id="调试">调试</h3><p>在线仿真器ICE（In-Circuit Emulator）</p><ul><li><p>模拟CPU的功能，可以完全仿真芯片的行为</p></li><li><p>价格昂贵，难以普及，没有广泛使用</p></li></ul><p>监控调试器</p><ul><li><p>需要通信通道</p></li><li><p>因为占用系统资源的问题，在一些严格的场合下不适合使用</p></li></ul><p>片上调试</p><ul><li><p>例如，JTAG是边界扫描测试的一个标准协议，SWD（Serial WireDebug）仿真器</p></li><li><p>价格便宜，易于实现</p></li><li><p>广泛使用</p></li></ul><h3 id="自检">自检</h3><p>输入/输出电路</p><p>板载开关：用于配置或模式选择</p><p>状态显示：字符或LED（3种状态：开、关、闪烁）</p><h3 id="软件系统层次结构">软件系统层次结构</h3><figure><img src="/image/嵌入式系统概论/软件系统层次结构.png"alt="软件系统层次结构" /><figcaption aria-hidden="true">软件系统层次结构</figcaption></figure><h3 id="可视化程序模型">可视化程序模型</h3><p>将实时应用视为单个/多个执行线程</p><h4 id="单线程程序模型">单线程程序模型</h4><p>优点：</p><ul><li><p>编程和再编程非常快速简单</p></li><li><p>改变系统响应特性的同时，往模型上添加新功能插件也相当容易</p></li></ul><p>缺点：</p><ul><li><p>在于应用领域的限制</p></li><li><p>难以做到安全地再编程</p></li><li><p>很难应用到不同行为或不同环境的运行系统中去</p></li></ul><h4 id="多线程程序模型">多线程程序模型</h4><p>优点：</p><ul><li><p>允许将系统工作划分为几个逻辑阶段，然后编写相互独立的程序来处理各自的工作</p></li><li><p>所有处理过程并行</p></li><li><p>如果有更高吞吐量的需求，工程师可以在任务中引入新的通信和协作模型</p></li></ul><p>缺点：可能引入资源竞争</p><h4 id="建立模型的好处">建立模型的好处</h4><p>辅助测试和完善最终系统。</p><p>模型利用它所知的系统属性来描述整个系统，并能够被用于对系统特性的进一步研究。</p><p>使用程序模型开发软件和硬件，便于将整个实时系统全盘考虑。</p><p>模型使得工程师能够预测程序的运行，从而满足系统的性能需求和功能需求。</p><h4 id="模型之间的差异">模型之间的差异</h4><p>一些模型易于编写，但调试不易；一些模型难于编写，但调试容易。</p><p>一些模型使得程序运行得更快，但需要付出更多内存资源消耗的代价。</p><p>模型准确性与鲁棒性。</p><h2 id="设计模式">2. 设计模式</h2><h3 id="嵌入式软件架构模式">嵌入式软件架构模式</h3><p>分为业务逻辑与实时依赖硬件的逻辑，抽象层将所需操作的高级请求转换为低级命令。<imgsrc="/image/嵌入式系统概论/嵌入式软件架构.png"alt="嵌入式软件架构" /></p><p>对于基于微控制器的系统来说，最常用的架构模式有：</p><ul><li>非结构化单体架构</li><li>分层架构</li><li>事件驱动架构</li><li>微服务架构</li></ul><h4 id="非结构化单体架构">非结构化单体架构</h4><p>应用和与之相连的多个模块，模块之间也可以相互连接</p><ul><li>容易构建，难以维持规模和移植</li><li>与应用层的应用程序紧密耦合</li></ul><h4 id="分层架构">分层架构</h4><p>将应用程序的逻辑划分为若干独立的层，仅通过定义良好的抽象层进行交互。</p><ul><li><p>试图通过将应用程序分解为独立的层来改善非结构化单体架构的高耦合性。</p></li><li><p>最常用。</p></li><li><p>例：应用层、中间件层、操作系统层、驱动层、硬件层</p></li></ul><h4 id="事件驱动架构">事件驱动架构</h4><p>利用中断来立即响应事件。</p><ul><li>事件驱动的体系结构通常使用消息队列、信号量和事件标志来表示系统中发生了事件。</li><li>对于实时嵌入式应用程序和与能耗相关的应用程序非常有意义。</li><li>优点：可扩展、软件模块高内聚、低耦合。</li><li>缺点：无论何时需要做任何事，都有额外的开销和复杂性。</li></ul><h4 id="微服务架构">微服务架构</h4><p>将应用程序构建为为业务领域开发的小型自治服务的集合。</p><ul><li><p>微服务本质上是低耦合的，这使得它易于维护、可测试，可以快速扩展或移植。</p></li><li><p>微服务是围绕系统的业务逻辑组织的。</p><ul><li>业务逻辑：系统行为的业务规则和用例。</li></ul></li><li><p>缺点：</p><ul><li>在架构上，增加设计的复杂性；</li><li>由于具有其他体系结构中可能不需要的通信特性，它们可能会增加额外的开销和内存需求；</li><li>架构的分散性也意味着实时的、确定性的行为可能更具挑战性，实时和响应可能有额外的抖动；</li><li>可能会增加开发时间和预算。</li></ul></li></ul><h4 id="微内核架构microkernel-architecture">微内核架构，MicrokernelArchitecture</h4><p>也称插件化(Plug-in)架构，是一种面向功能拆分的可扩展架构。</p><ul><li>包含核心系统和插件模块。</li><li>具备模块化解耦、弹性部署的能力以及安全稳定的特性，非常符合物联网的发展。</li><li>进程间通信性能相对较低。</li></ul><h3 id="管理外设数据">管理外设数据</h3><p>轮询、中断、直接存储器访问（DMA）</p><h4 id="外设轮询">外设轮询</h4><p>让应用程序定期轮询外设，查看是否有任何数据可供管理和处理。</p><ul><li>优先级：无，按顺序运行</li><li>响应时间：所有任务的总和</li><li>变化的影响：修改任务的执行时间或添加任务会影响所有其他任务</li><li>优点：简单，没有共享数据问题</li><li>缺点：浪费处理周期；在处理外设时可能会有很多抖动和延迟</li></ul><h4 id="有限状态机">有限状态机</h4><p>只执行当前状态，每个状态决定下一个状态（非顺序执行）。</p><ul><li>优先级：每个状态决定下一个状态的优先级</li><li>响应时间：所有任务的总和</li><li>变化的影响：修改任务的执行时间或添加任务会影响所有其他任务</li><li>同样没有共享数据问题</li></ul><h4 id="中断设计模式">中断设计模式</h4><p>中断应用程序的正常流程，以允许中断处理程序运行代码来处理系统中发生的事件。</p><p>当设计ISR时，我们希望中断尽可能快地运行（最小化中断）。</p><ul><li><p>避免内存分配操作，如声明非静态变量、操作堆栈或使用动态内存</p></li><li><p>尽量减少函数调用，以避免时钟周期开销、不可重入函数或阻塞函数的问题</p></li></ul><h5 id="带有中断的轮询">带有中断的轮询</h5><ul><li><p>优先级：中断优先于主循环，中断的优先级</p></li><li><p>反应时间：所有任务的总和或中断执行时间</p></li><li><p>变更的影响：对中断服务例程的影响较小。与主循环的轮询相同。</p></li><li><p>共享数据：必须处理与中断服务例程共享的数据</p></li><li><p>优势：</p><ul><li><p>不需要浪费CPU周期来检查数据是否准备好</p></li><li><p>获取数据的延迟是确定的</p></li><li><p>抖动被最小化</p></li></ul></li><li><p>缺点：</p><ul><li>中断的设置可能比较复杂</li><li>必须小心不要使用频繁触发的中断</li><li>当使用中断来接收数据时，开发人员必须仔细管理他们在ISR中所做的工作。开发人员经常需要使用ISR来处理所需的即时操作，然后将处理和非紧急的工作卸载给应用程序，从而增加了软件设计的复杂性。</li></ul></li></ul><h5id="数据获取存储相关的中断设计模式">数据获取/存储相关的中断设计模式</h5><ul><li>线性数据存储</li><li>双缓冲区</li><li>环形/循环缓冲区</li><li>带有信号量的循环缓冲区</li><li>带有事件标志的循环缓冲区</li><li>消息队列</li></ul><p>线性数据存储：</p><ul><li><p>中断服务程序可以直接访问共享内存位置</p></li><li><p>线性数据存储可能是危险的：</p><ul><li>线性数据存储是经常遇到竞态条件的地方</li><li>用于存储应用程序和ISR之间的数据的共享变量也需要声明为volatile，以防止编译器优化</li></ul></li><li><p>数据存储必须由互斥锁保护，以防止竞态条件</p></li></ul><p>双缓冲区：可以缓解数据存储的一些竞态条件问题。</p><p>环形缓冲区：</p><p>环形缓冲区（Circular Buffer），也被称为循环缓冲区（CyclicBuffer）或者环形队列（RingBuffer），是一种数据结构类型，它在内存中形成一个环形的存储空间。</p><ul><li><p>特点：终点和起点相连形成一个环状结构。</p></li><li><p>在处理流数据和实现数据缓存等场景中具有广泛的应用。</p></li><li><p>在中断中接收到的实时数据可以从外设中移除并存储在循环缓冲区中。因此，中断可以尽可能快地运行，同时允许应用程序代码自行处理循环缓冲区。使用循环缓冲区有助于确保数据不丢失，中断速度快，合理地处理数据。</p></li></ul><p>带有通知的循环缓冲区：</p><ul><li>应用程序需要轮询缓冲区以查看是否有新的可用数据。<ul><li>信号量和事件标志</li></ul></li><li>在大多数实时操作系统中，使用事件标志比使用信号量更有效。</li></ul><p>消息队列：</p><ul><li><p>类似于使用带有信号量的线性缓冲区。</p></li><li><p>通常需要更多的RAM、ROM和处理能力。</p></li></ul><h4 id="dma">DMA</h4><p>无需CPU的交互情况下在RAM和外设之间以及内部传输数据。</p><ul><li><p>RAM到RAM</p></li><li><p>外设到RAM</p></li><li><p>外设到外设</p></li></ul><p>DMA控制器可以显著提高外设和应用程序之间的数据吞吐量。此外，可以利用DMA控制器减轻CPU运行ISR来传输数据的负担，并最大限度地减少浪费的计算周期。</p><h3 id="实时嵌入式软件常用设计模式">实时嵌入式软件常用设计模式</h3><p>单核</p><p>多核</p><p>发布和订阅模型</p><p>RTOS模式</p><p>处理中断和低功耗设计</p><h4 id="多核架构">多核架构</h4><p>同构多核，对称多核处理具有相同处理器架构的两个核。</p><p>异构多核架构，每个处理核心都有不同的底层架构。</p><h4 id="发布和订阅模型">发布和订阅模型</h4><p>在物联网领域广泛使用，ROS也使用。</p><ul><li>在许多情况下，物联网设备将启动电源，连接到云，然后订阅它想要接收的消息主题。该设备甚至还可以发布特定的主题。</li></ul><p>缺点：会导致应用程序占用更大的内存。</p><h4 id="rtos应用程序设计模式">RTOS应用程序设计模式</h4><p>资源同步：对共享资源的访问是否安全</p><ul><li>确保需要访问资源的多个任务或中断协调进行，避免竞争条件和内存损坏。</li><li>可以通过三种方式处理资源同步：中断锁、抢占锁和互斥锁。<ul><li>中断锁：禁用中断以在任务和中断之间提供资源同步</li><li>抢占锁：在临界区期间临时禁用RTOS内核抢占调度程序</li><li>互斥锁：通过创建一个对象来保护临界区，该对象的状态可以被检查，以确定是否可以安全访问共享资源，其唯一目的是为共享资源提供互斥</li><li>中断锁禁用系统中断，可能导致问题；抢占锁不禁用系统中断，但禁止内核抢占；互斥锁两者都不禁用。</li></ul></li></ul><p>活动同步：决定执行是否已达到特定状态</p><ul><li><p>单向同步（任务对任务）：使用二值信号量或事件标志来同步任务。</p></li><li><p>单向同步（中断到任务）：ISR给出信号量或事件标志后，继续执行直到完成为止。</p></li><li><p>双向同步：两个任务在它们之间的两个方向上进行协调。</p></li></ul><h4 id="广播设计模式">广播设计模式</h4><p>允许多个任务阻塞，直到给定信号量、出现事件标志，甚至将消息放入消息队列。</p><p>任务或ISR可以提供由多个任务使用的二值信号量广播。广播可能无法在所有实时操作系统中实现，必须检查RTOS是否支持。</p><ul><li>如果不支持广播，则可以创建由任务或中断给出的多个信号量。从设计的角度来看，使用多个信号量并不优雅，从实现的角度来看也不高效，但有时在软件中就是这样。</li></ul><h4 id="低功耗应用程序设计模式">低功耗应用程序设计模式</h4><p>关于低功耗设计模式，主要模式是尽可能地保持设备关闭。</p><ul><li>事件驱动中，事件之间没有实际工作要做时，应该将微控制器置于适当的低功耗状态，并关闭任何非必要的电子设备</li><li>除非发生唤醒事件，否则系统处于低功耗状态</li><li>实际工作完成后，系统恢复到低功耗状态</li></ul><p>建议：使用内置tickless模式的RTOS，或者扩展系统tick以使微控制器休眠更长时间</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_5_I/O与总线</title>
    <link href="/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/5_IO%E4%B8%8E%E6%80%BB%E7%BA%BF/"/>
    <url>/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/5_IO%E4%B8%8E%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第五章-io与总线">第五章 I/O与总线</h1><h2 id="设备分类">1. 设备分类</h2><h3 id="按从属分类">按从属分类</h3><p>系统设备：操作系统启动时已注册的标准设备</p><ul><li>操作系统中有设备驱动程序和管理程序，例如闪存，触摸面板</li></ul><p>用户设备：操作系统启动时未注册的非标准设备</p><ul><li>设备驱动程序由用户提供，例如SD卡、U盘</li></ul><h3 id="按使用分类">按使用分类</h3><p>专用设备：同一时间只能被一个进程使用。</p><p>共享设备：可被多个进程同时寻址。</p><p>虚拟设备：通过虚拟技术将一台独占设备虚拟成多台逻辑设备供多个用户进程同时使用。</p><h3 id="按特征分类">按特征分类</h3><p>存储设备</p><p>输入/输出设备</p><ul><li>通常由机械部件和电子部件组成，电子部分称为设备控制器或适配器</li></ul><h3 id="按信息传输单元分类">按信息传输单元分类</h3><p>块设备：以块为单位组织和交换数据，是结构化设备，例如硬盘。</p><p>字符设备：以字符为单位组织和交换数据，是非结构化设备，例如串口、打印机。</p><ul><li>基本特征是传输速率低且不可寻址，执行输入/输出操作时经常使用中断。</li></ul><h2 id="输入输出">2. 输入/输出</h2><p>输入/输出接口需要多个寄存器：</p><ul><li>数据寄存器</li><li>控制寄存器</li><li>状态寄存器</li></ul><h3 id="可编程io">可编程I/O</h3><p>通信过程中选择控制寄存器或数据缓冲区的三种方法：</p><ul><li><p>独立I/O端口</p></li><li><p>内存映射I/O</p></li><li><p>混合解决方案，混合模型包括内存映射I/O数据缓冲区和用于控制寄存器的独立I/O端口</p></li></ul><p>Intel x86提供了in、out指令，大多数其他cpu使用内存映射I/O。</p><h4 id="独立io端口">独立I/O端口</h4><p>优点：</p><ul><li>I/O独立编址，不占用内存</li><li>使用I/O指令，程序清晰，很容易看出是I/O操作还是存储器操作</li><li>译码电路比较简单（I/O端口的地址空间较小，所用地址线较少）</li></ul><p>缺点：只能用专门I/O指令，访问端口办法少</p><h4 id="内存映射io">内存映射I/O</h4><p>优点：</p><ul><li><p>在内存映射I/O模式中，设备控制寄存器只是内存中的变量，可以像其他变量一样在C语言中寻址。因此，I/O设备驱动程序可以完全用C语言编写。</p></li><li><p>在这种模式下，不需要特殊的保护机制来阻止用户进程执行I/O操作。</p></li></ul><p>缺点：</p><ul><li><p>目前大多数嵌入式处理器都支持内存缓存。缓存设备控制寄存器会导致灾难。为了防止这种情况，必须为硬件提供选择性禁用缓存的功能，这将增加嵌入式系统中硬件和软件的复杂性。</p></li><li><p>如果只有一个地址空间，所有内存模块和所有I/O设备必须检查所有内存引用，以决定响应哪一个，这将严重影响系统性能。</p></li></ul><h3 id="忙等io">忙等I/O</h3><p>使用指令测试设备忙闲。</p><p>缺点：低效</p><ul><li>CPU在测试设备时不能做其他工作</li><li>很难同时进行输入/输出</li></ul><h3 id="中断io">中断I/O</h3><p>中断允许设备改变CPU中的控制流，调用子例程来处理设备。</p><ul><li>行为：基于子程序调用机制，强制下一条指令为预定义地址的子程序调用</li></ul><h4 id="中断的物理接口">中断的物理接口</h4><ul><li>CPU与设备通过CPU总线连接</li><li>CPU与设备握手</li><li>设备发出中断请求</li><li>CPU在能够处理中断时确认中断</li></ul><h4 id="优先级与向量">优先级与向量</h4><p>优先级：决定哪些中断首先得到CPU</p><ul><li>屏蔽：在挂起的中断完成之前，不会识别低于当前优先级的中断。</li><li>不可屏蔽中断NMI，最高优先级，不会被屏蔽，通常用于断电。</li></ul><p>向量：决定每种类型的中断调用什么代码</p><ul><li>中断向量表</li></ul><h4 id="中断序列">中断序列</h4><ol type="1"><li>CPU确认请求</li><li>设备发送向量</li><li>CPU调用中断处理程序</li><li>软件处理请求</li><li>CPU恢复前台程序状态</li></ol><h4 id="中断开销">中断开销</h4><p>中断处理程序执行时间</p><p>中断机制开销</p><p>寄存器保存/恢复</p><p>流水线相关的开销</p><p>缓存相关的开销</p><h4 id="中断设计">中断设计</h4><p>中断服务处理，Interrupt Service Routines，ISR</p><p>基本原则是保持处理程序简短（时间上）。</p><ul><li>避免循环和冗长复杂的指令。</li><li>尽快重新启用中断，先做硬件关键和不可重入的事情，然后执行中断启用指令。</li><li>预计花费时间和复杂度。</li></ul><p>C语言和汇编语言：</p><ul><li>汇编语言的花费时间易于估计，C语言难以估计</li><li>但是尽量使用C语言</li></ul><h4 id="调试intinta周期">调试INT/INTA周期</h4><ol type="1"><li><p>设备硬件产生中断脉冲</p></li><li><p>中断控制器(如果有的话)以优先级处理多个同时发生的请求，并向处理器发出单个中断</p></li><li><p>CPU响应一个中断确认周期</p></li><li><p>控制器在总线上发出一个中断向量</p></li><li><p>CPU读取向量并计算向量所指向的内存中的地址，然后获取这个值</p></li></ol><h4 id="查找丢失的中断">查找丢失的中断</h4><p>可以使用单个上行/下行计数器构建一个小电路，该计数器对每个中断进行计数，并减少每个中断确认的计数。如果计数器总是显示0或1的值，则一切正常。</p><p>一个经验法则将帮助最小化丢失的中断：在最早的安全点重新启用ISR中的中断。</p><h4 id="避免nmi">避免NMI</h4><p>NMI（不可屏蔽的中断）用于电源故障、系统关闭和即将发生的灾难，定时器或UART中断不是。</p><p>NMI甚至会破坏编码良好的中断处理程序，因为大多数isr在服务硬件的前几行代码中都是不可重入的。NMI也会阻碍堆栈管理工作。</p><p>NMI与大多数工具的混合效果很差。调试任何ISR-NMI或其他方式都是令人恼火的。很少有工具能很好地在ISR内单步执行和设置断点。</p><h4 id="断点问题">断点问题</h4><p>虽然断点确实是很棒的调试辅助工具，但是对于嵌入式代码是具有不确定性的。</p><p>使用实时trace，这是所有仿真器和一些智能逻辑分析仪都具有的功能。</p><h4 id="可重入">可重入</h4><p>例程必须满足以下条件才能重入:</p><ul><li><p>以原子方式使用所有共享变量，除非将每个共享变量分配给函数的特定实例</p></li><li><p>不调用不可重入的函数</p></li><li><p>不以非原子的方式使用硬件</p></li></ul><p>原子指不能被中断的操作。</p><p>消除不可重入代码的办法：</p><ul><li><p>避免共享变量。</p><p>全局变量是没完没了的调试问题和代码失败的根源。使用自动变量或动态分配内存。</p></li><li><p>在不可重入代码期间禁用中断。</p></li><li><p>信号量。</p></li></ul><h4 id="竞态条件">竞态条件</h4><p>设备或系统出现不恰当的执行时序，而得到不正确的结果。</p><p>参考计算机操作系统：进程的同步和互斥问题。</p><h2 id="总线">2. 总线</h2><p>总线是计算机各种功能部件之间传送信息的公共通信干线。</p><ul><li>一组传送线路 + 相关通信协议</li></ul><h3 id="总线协议">总线协议</h3><p>总线协议决定设备如何通信。</p><ul><li>协议由状态机指定，协议中的每个参与者都有一个状态机。</li><li>总线上的设备经历一系列的状态。</li><li>可包含异步逻辑行为。</li></ul><h3 id="系统总线配置">系统总线配置</h3><p>多总线允许并行：一个总线连接慢速设备，另一个独立总线连接高速设备。</p><p>桥连接两个总线。</p><p>常用总线：</p><figure><img src="/image/嵌入式系统概论/常用总线.png" alt="常用总线" /><figcaption aria-hidden="true">常用总线</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_4_存储器架构</title>
    <link href="/2023/09/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/4_%E5%AD%98%E5%82%A8%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/09/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/4_%E5%AD%98%E5%82%A8%E5%99%A8%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第四章-存储器架构">第四章 存储器架构</h1><h2 id="存储系统">1. 存储系统</h2><h3 id="存储系统-1">存储系统</h3><p>对许多应用来说，存储系统对整个系统性能的影响比对数据流水线的影响更大。</p><p>复杂性：在同一个嵌入式系统中，通常需要组合各种存储技术</p><ul><li>至少需要一些非易失性存储和一些易失性存储</li></ul><p>层次结构往往是必须的。</p><p>处理器架构的地址空间被分解成若干子空间来提供不同类型的存储器访问。</p><h3 id="易失性存储器">易失性存储器</h3><p>断电时内容消失的存储器。</p><p>随机存取存储器，RAM</p><ul><li>静态RAM，SRAM：速度快，面积大</li><li>动态RAM，DRAM：保持数据的时间很短，需要定期刷新；比SRAM更不稳定</li></ul><p>大多数嵌入式系统都包括一个SRAM，许多ES也会包括DRAM。</p><ul><li>只利用SRAM不能提供足够大的存储容量</li></ul><p>影响程序执行时间的因素</p><ul><li><p>被访问的存储器地址是映射到SRAM还是DRAM</p></li><li><p>DRAM可能在忙于刷新时被请求访问，因此DRAM刷新周期会引起访问时间的变化</p></li><li><p>访问历史也会影响存取时间</p></li></ul><h3 id="非易失性存储器">非易失性存储器</h3><p>不需要持续供电来保留存储在计算设备中的数据或程序代码。</p><ul><li><p>只读存储器ROM，或掩模ROM（MashROM）：内容在芯片工厂就已经固定</p></li><li><p>电可擦除可编程ROM，EEPROM</p></li><li><p>快闪存储器（Flash）</p></li><li><p>磁盘存储器</p></li></ul><h3 id="固件">固件</h3><p>固件（firmware）一般存储于设备中的电可擦除只读存储器或FLASH芯片中，一般可由用户通过特定的刷新程序进行升级。</p><p>可固化（ROMable）：可被编程到ROM芯片中的机器语言。作为“只读”芯片不能更新，可固化程序必须使用RAM或磁盘来保存变化的数据。</p><ul><li><p>代码将从ROM正确执行：不需要复制到RAM，但是RAM可能更快</p></li><li><p>代码和数据不能混用，除了常量数据</p></li></ul><h3 id="flash">Flash</h3><p>读取快于一般ROM，慢于RAM。</p><p>写入时间大大超过读取时间，且写入次数有限。</p><ul><li><p>SLC：速度快，存储密度低，稳定性好，成本高，约10万次擦写寿命，多用于高端企业级产品</p></li><li><p>MLC：速度一般，成本一般，约3000—10000次擦写寿命，应用于中高端SSD</p></li><li><p>TLC：速度慢，成本最低，约1000次擦写寿命</p></li></ul><p>类型：</p><ul><li><p>NOR：块擦除；擦除和写入时间较长，但能够像RAM那样访问</p></li><li><p>NAND：以块为单位；擦除和写入速度比较快；按页读取</p></li></ul><figure><img src="/image/嵌入式系统概论/Flash.png" alt="Flash" /><figcaption aria-hidden="true">Flash</figcaption></figure><h2 id="存储器层次结构">2. 存储器层次结构</h2><p>精确的分层机构取决于技术参数，也取决于应用领域</p><ul><li><p>处理器寄存器</p></li><li><p>工作存储器（或主存储器、主存）：实现了处理器存储地址所涵盖的存储器。通常，其容量在几MB到几GB之间，并且是易失的</p></li><li><p>缓冲存储器:高速缓存、地址转换高速缓存（TLB）以及暂存存储器（SPM）。</p></li><li><p>flash、磁盘等非易失性存储，也可基于互联网的存储器解决方案（如云）。</p></li></ul><h3 id="cache">Cache</h3><p>高速缓存的架构对应用程序的执行时间具有很大影响。</p><ul><li>潜在地提高了存储系统的能效。</li><li>设计时预测缓存是否命中很困难，这对实时性能的精确预测也是负担。</li><li>多级Cache</li></ul><h3 id="暂存存储器">暂存存储器</h3><p>SPM，也叫紧耦合内存TCM。</p><ul><li>SPM和主存统一编址，每当某个简单的地址解码器给出一个SPM地址范围内的地址时，SPM就被访问。</li><li>SPM通常和处理器集成在一个芯片上。</li><li>功耗低、速度快。</li></ul><h3 id="存储器访问时间难以预测">存储器访问时间难以预测</h3><p>虚拟存储器：使各种存储技术看起来是一个连续的地址空间</p><p>地址转换：把地址空间的逻辑地址转换成一种存储技术上的物理地址</p><ul><li>转换通常是由转换后备缓冲器（Translation LookasideBuffer，TLB）协助完成</li></ul><p>很难预测或理解访问存储器的时间需要多久，因而嵌入式系统设计人员通常比一般程序员需要更深入地理解存储器系统</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_3_微处理器</title>
    <link href="/2023/09/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/3_%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2023/09/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/3_%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第三章-嵌入式微处理器">第三章 嵌入式微处理器</h1><p>Embedded Microprocessor</p><h2 id="嵌入式系统硬件">1. 嵌入式系统硬件</h2><p>包含CPU、总线、存储器、输入/输出设备</p><p>常见微处理器：</p><ul><li>ARM</li><li>MIPS</li><li>PowerPC</li><li>X86</li></ul><h3 id="冯诺伊曼结构">冯诺伊曼结构</h3><ul><li>将程序指令存储器和数据存储器合并在一起的存储器结构</li><li>程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同</li><li>CPU寄存器: 程序计数器(PC)，指令寄存器(IR)，通用寄存器等。</li></ul><h3 id="哈佛结构">哈佛结构</h3><p>明显的特点：</p><ul><li><p>使用两个独立的存储器模块，分别存储指令和数据</p><p>每个存储模块都不允许指令和数据并存</p></li><li><p>使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，这两条总线之间毫无关联</p></li></ul><p>改进的哈佛结构，其结构特点为：</p><ul><li>使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存;</li><li>具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块(程序存储模块和数据存储模块)，公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输</li><li>两条总线由程序存储器和数据存储器分时共用</li></ul><p>大多数数字信号处理器（DSP）使用哈佛架构来处理流数据：</p><ul><li>更大的内存带宽</li><li>更可预测的带宽</li></ul><h3 id="risc和cisc">RISC和CISC</h3><ul><li>复杂指令集计算机，Complex instruction set computer，CISC<ul><li>多种寻址模式</li></ul></li><li>精简指令集计算机，Reduced instruction set computer，RISC<ul><li>流水线指令</li><li>访存指令只有load/store</li></ul></li></ul><h4 id="risc-v">RISC-V</h4><ul><li>简单、完全开源并且免费</li><li>将基准指令和扩展指令分开，可以通过扩展指令做定制化的模块和扩展<ul><li>RISC-V的基准指令集确定后将不会变化，这是RISC-V稳定性的重要保障</li></ul></li></ul><h4 id="设计系统芯片需要考虑">设计系统芯片需要考虑</h4><ul><li>成本</li><li>生态系统</li><li>碎片化风险</li><li>安全性</li><li>设计保证</li></ul><h3 id="编程模型">编程模型</h3><p>在程序中可以用道德寄存器集合。</p><ul><li>有些寄存器不可见</li></ul><h2 id="嵌入式微处理器分类">2. 嵌入式微处理器分类</h2><p>按位数可分为4、8、16等；</p><p>按功能可分为4种：</p><ul><li>嵌入式微处理单元（MPU）：类似CPU</li><li>嵌入式微控制器（MCU）：包含MPU与存储器、I/O接口和基本控制器</li><li>嵌入式DSP处理器：特殊设计系统和算法，用于信号处理</li><li>嵌入式SoC：集成MPU、存储器、外设控制器、通信功能等<ul><li>MCU通常不支持操作系统，裸机运行程序，快速响应实时任务和控制系统</li><li>SoC适合运行操作系统，性能和可靠性强，往往用于更高端的设备</li></ul></li></ul><h3 id="嵌入式微处理单元mpu">嵌入式微处理单元（MPU）</h3><p>嵌入式微处理器就是和通用计算机的处理器对应的CPU。</p><ul><li><p>功能和微处理器基本一样，具有32位以上，性能较高。</p></li><li><p>体积小、功耗少、成本低、可靠性高，有的可提供工业级应用。</p></li></ul><p>流行的嵌入式微处理器：ARM：Cortex-A系列、Power、MIPS</p><figure><img src="/image/嵌入式系统概论/框图.png" alt="框图" /><figcaption aria-hidden="true">框图</figcaption></figure><h3 id="嵌入式微控制器mcu">嵌入式微控制器（MCU）</h3><p>嵌入式微控制器就是将整个计算机系统的主要硬件集成到一块芯片中，芯片内部集成ROM/EPROM，RAM，总线，总线逻辑，定时/计数器，Watchdog，I/O，串行口等各种必要功能和外设。</p><ul><li>特点：<ul><li>一个系列的微控制器具有多种衍生产品</li><li>单片化，体积大大减小，功耗和成本降低，可靠性提高</li><li>是目前嵌入式工业的主流，约占嵌入式系统50%的份额</li></ul></li></ul><p>流行的嵌入式微控制器：</p><ul><li><p>通用系列：8051，Coldfire的MC683xx（32位），Cortex-M0/3/4/7/M33/M35P</p></li><li><p>半通用系列:支持I2C,CAN BUS及众多专用MCU和兼容系列</p></li></ul><h3 id="嵌入式dsp">嵌入式DSP</h3><p>嵌入式DSP是专门用于信号处理方面的处理器，其在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令执行速度。</p><p>应用领域：数字滤波、频谱分析、FFT</p><p>流行的嵌入式DSP：</p><ul><li>德州仪器（TI），c6000 与 c5000</li><li>模拟器件公司（ADI）</li><li>摩托罗拉（Motorola）公司</li></ul><h3 id="嵌入式soc">嵌入式SoC</h3><p>嵌入式SoC是追求产品系统最大包容的集成器件。绝大多数系统构件都在一个系统芯片内部。</p><p>SoC芯片可以有效地降低电子/信息系统产品开发成本，缩短开发周期，提高产品竞争力。</p><p>特点：</p><ul><li>结构简洁</li><li>体积小、功耗小</li><li>可靠性高</li><li>设计生产效率高</li></ul><p>流行的SoC：高通骁龙（Snapdragon）、海思</p><h3 id="现场可编程门阵列fpga">现场可编程门阵列，FPGA</h3><p>具有可编程特性的集成电路。</p><ul><li>赛灵思、阿尔特拉（被英特尔收购）</li></ul><h4 id="dsp和fpga">DSP和FPGA</h4><figure><img src="/image/嵌入式系统概论/DSP与FPGA.png" alt="DSP与FPGA" /><figcaption aria-hidden="true">DSP与FPGA</figcaption></figure><h2 id="嵌入式微处理器的特点">嵌入式微处理器的特点</h2><p>基础是通用微处理器；与通用微处理器的区别：</p><ul><li>体积小、重量轻、可靠性高、功耗低</li><li>成本低：片上存储、引脚与封装、代码密度</li><li>工作温度、抗电磁干扰、可靠性等方面增强</li></ul><h2 id="arm">ARM</h2><h3 id="arm公司">ARM公司</h3><p>成立于1990年11月，从Acorn电脑公司剥离出来。</p><ul><li><p>设计ARM系列的RISC处理器内核。</p></li><li><p>授权ARM核心设计的半导体合作 伙伴制造和销售给他们的客户。</p></li><li><p>同时开发技术以协助ARM架构的设计。</p><ul><li>软件工具、电路板、调试硬件、应用软件、总线架构、外围设备等。</li></ul></li></ul><h3 id="arm处理器的主要应用领域">ARM处理器的主要应用领域</h3><ul><li><p>消费类电子产品：</p><p>ARM技术在目前流行的数字音频播放器、数字机顶盒和游戏机中得到了广泛采用</p></li><li><p>无线通讯领域：</p><p>目前大部分无线通讯设备采用了ARM技术，ARM以其高性价比和低成本，在该领域的地位日益巩固</p></li><li><p>网络应用：</p><p>随着宽带技术的推广，采用ARM技术的ADSL芯片正逐步获得竞争优势，此外，ARM在语音及视频处理上进行了优化，并获得广泛支持，这也对DSP的应用领域提出了挑战</p></li><li><p>工业控制领域：</p><p>基于ARM核的微控制器芯片不但占据了高端微控制器的大部分市场份额，同时也逐渐向低端微控制器应用领域扩展，Cortex-M系列就是ARM公司推出的典型低功耗、高性价比32位工控微控制器，向传统的8位/16位微控制器提出了挑战</p></li><li><p>成像和安全产品：</p><p>现在流行的数码相机和打印机中绝大部分采用ARM技术，手机中的32位SIM智能卡也采用了ARM技术</p></li></ul><h3 id="arm处理器分类">ARM处理器分类</h3><p>结构体系版本（Architecture）</p><ul><li>ARM v4T</li><li>ARM v5TE</li><li>ARM v6</li><li>ARM Cortex（v7 ，v8）</li></ul><p>按应用特征分类</p><ul><li><p>应用处理器，Application Processor</p></li><li><p>实时控制处理器，Real-time Controller</p></li><li><p>微控制器，Micro-controller</p></li><li><p>SecurCore</p></li></ul><h3 id="arm架构">ARM架构</h3><p>典型的RISC：</p><ul><li>丰富的寄存器</li><li>加载/存储体系结构</li><li>简单寻址模式</li><li>统一和固定长度的指令字段</li></ul><p>增强功能：</p><ul><li>每条指令控制ALU和移位器</li><li>自动递增和自动递减寻址模式</li><li>多个加载/存储</li><li>条件执行</li></ul><p>特点：</p><ul><li>高性能</li><li>低代码</li><li>低功耗</li><li>低硅面积</li></ul><h3 id="流水线">流水线</h3><p>提高速度：大多数指令在一个周期内执行。</p><p>版本：</p><ul><li><p>3级（ARM7TDMI及更早版本）</p></li><li><p>5级（ARMS, ARM9TDMI）</p></li><li><p>6级（ARM10TDMI）</p></li></ul><p>流水线清空，导致执行速度变慢。</p><ul><li>分支指令</li></ul><p>分支预测技术</p><ul><li>静态</li><li>动态</li></ul><h3 id="meltdown-spectre">Meltdown &amp; Spectre</h3><p>近20年的Intel，AMD，Qualcomm厂家和其它ARM的处理器受到影响。</p><p>因为此次CPU漏洞特殊性，包括Linux，Windows，OSX等的操作系统平台参与了修复。</p><p>Firefox，Chrome，Edge等浏览器也发布了相关的安全公告和缓解方案。</p><h2 id="选择微处理器">选择微处理器</h2><h3 id="准则">准则</h3><ul><li>高效、经济<ul><li>速度、尺寸、功耗、易于升级、单位成本</li></ul></li><li>软件开发工具可用性<ul><li>汇编器、C编译器、仿真器</li></ul></li><li>广泛的可用性和可靠的微控制器来源</li></ul><h3 id="步骤">步骤</h3><ol type="1"><li>列出所需的硬件接口</li><li>检查软件架构</li><li>选择体系结构</li><li>确定内存要求</li><li>搜索微控制器</li><li>检查零件可用性</li><li>选择开发工具包</li><li>研究编译器和工具</li><li>开始尝试</li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_2_设计方法</title>
    <link href="/2023/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/2_%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2023/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/2_%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第二章-嵌入式系统设计方法">第二章 嵌入式系统设计方法</h1><h2 id="嵌入式系统设计面临的挑战">1. 嵌入式系统设计面临的挑战</h2><ul><li>硬件需求</li><li>多项功能在时间上的协调一致性、时限要求</li><li>系统功耗</li><li>系统可升级性</li><li>系统可靠性</li></ul><h3 id="设计者要求">设计者要求</h3><ul><li>懂得系统架构</li><li>了解硬件细节</li><li>软件设计满足<ul><li>实时要求</li><li>低功耗</li><li>代码量小</li></ul></li><li>了解领域知识</li></ul><h3 id="设计目标">设计目标</h3><ul><li>成本</li><li>性能</li><li>功耗</li><li>尺寸</li><li>可伸缩性和可重用性</li><li>容错</li><li>……</li></ul><h2 id="嵌入式系统的设计过程">2. 嵌入式系统的设计过程</h2><ul><li><p>问题：功能、性能要求、价格、开发周期等约束</p></li><li><p>设计：选择、折衷、分析比较、计算、评价</p></li></ul><h3 id="简化的设计流">简化的设计流</h3><figure><img src="/image/嵌入式系统概论/简化的设计流.png" alt="简化的设计流" /><figcaption aria-hidden="true">简化的设计流</figcaption></figure><h3id="嵌入式系统的设计过程的基本流程">嵌入式系统的设计过程的基本流程</h3><figure><img src="/image/嵌入式系统概论/基本流程.png" alt="基本流程" /><figcaption aria-hidden="true">基本流程</figcaption></figure><h3 id="v模型的设计流">V模型的设计流</h3><figure><img src="/image/嵌入式系统概论/V模型.png" alt="V模型" /><figcaption aria-hidden="true">V模型</figcaption></figure><h2 id="嵌入式系统设计方法学">3. 嵌入式系统设计方法学</h2><h3 id="体系结构设计">体系结构设计</h3><ul><li>满足规格说明的主要组件<ul><li>硬件：中央处理器、外围设备等</li><li>软件：必要的程序及其运行</li></ul></li><li>功能性和非功能性需求</li></ul><h4 id="硬件和软件组件设计">硬件和软件组件设计</h4><ul><li>开始编码前，必须花时间构建系统</li><li>有些组件是现成的，可以根据现有设计进行修改，还有一些必须从头开始设计</li></ul><h4 id="软硬件的划分">软硬件的划分</h4><p>嵌入式系统的设计涉及硬件与软件部件，设计中必须决定什么功能由硬件实现，什么功能由软件实现。</p><ul><li>硬件和软件具有双重性，这是划分决策的前提</li><li>软硬件变动对系统决策有影响</li><li>划分选择需考虑多种因素</li></ul><h5 id="通常由软件实现的部分">通常由软件实现的部分</h5><ul><li>操作系统功能<ul><li>任务调度</li><li>资源管理</li><li>设备驱动</li></ul></li><li>协议栈<ul><li>TCP/IP</li></ul></li><li>应用软件框架</li><li>除了基本系统、物理接口、基本逻辑电路，许多由硬件实现的功能都可以由软件实现</li></ul><h5 id="双重性部分">双重性部分</h5><ul><li>算法<ul><li>加密/解密</li><li>编码/解码</li><li>压缩/解压</li><li>等等</li></ul></li><li>数学运算<ul><li>浮点运算、FFT、等等</li></ul></li></ul><h4 id="软硬件技术对系统结构影响">软硬件技术对系统结构影响</h4><ul><li>硬软件设计的趋势——融合、渗透<ul><li>硬件设计的软件化：VHDL、Verilog、HANDEL-C</li><li>软件实现的硬件化：各种算法的ASIC</li></ul></li><li>对系统设计的影响——协同设计<ul><li>增加灵活性</li><li>增加了风险</li></ul></li></ul><h3 id="嵌入式系统设计方法的演变">嵌入式系统设计方法的演变</h3><ol type="1"><li>以PCB、CAD和在线仿真器为主要工具</li><li>EDA和EOS为开发平台</li><li>以IP内核库为设计基础，用软硬件协同设计技术的系统级设计方法</li></ol><h4 id="传统嵌入式系统设计过程">传统嵌入式系统设计过程</h4><ul><li>系统在一开始就被划分为软件和硬件两大部分</li><li>软件和硬件独立进行开发设计</li><li>硬件优先</li></ul><p>问题：</p><ul><li>软硬件间交互受很大限制<ul><li>凭经验划分软硬件</li><li>软硬件之间的相互性能影响很难评估</li></ul></li><li>系统集成相对滞后，NRE较大</li></ul><p>导致：</p><ul><li>设计质量差</li><li>设计修改难</li><li>研制周期不能有效保障</li></ul><h4 id="软硬件协同设计hwsw-co-design">软硬件协同设计HW/SW Co-design</h4><p>协同设计是指通过并行设计利用硬件和软件的协同作用来实现系统级目标。</p><p>协同设计试图通过提供分析方法来增加嵌入式系统设计的可预测性，这些分析方法告诉设计师一个系统是否满足其性能、功率和尺寸目标，并提供综合方法让设计师快速评估许多潜在的设计方法。</p><ul><li>它从90年代早期的一个新兴的学科变成了如今的主流技术。</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_1_引言</title>
    <link href="/2023/09/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/1_%E5%BC%95%E8%A8%80/"/>
    <url>/2023/09/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/1_%E5%BC%95%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第一章-引言">第一章 引言</h1><h3 id="几个术语">几个术语</h3><ul><li><p>泛在计算：任何时间、任何地点的计算</p></li><li><p>不可见计算机：计算机被集成到物件中</p></li><li><p>普适计算：计算设备对日常生活的渗透</p></li><li><p>环境智能：生活环境中的计算机技术</p></li></ul><h2 id="嵌入式系统的定义">1. 嵌入式系统的定义</h2><h3 id="嵌入式系统">嵌入式系统</h3><p>以应用为中心，以计算机技术为基础，软硬件可裁减，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统。</p><ul><li><p>嵌入式系统（Emedded System）实际上是嵌入式计算机系统。</p></li><li><p>嵌入式系统就是一个具有特定功能或用途的隐藏在设备中的计算机软硬件集合体。</p></li><li><p>嵌入式系统三要素</p><ul><li>嵌入性：嵌入到对象体系中，有对象环境要求</li><li>专用性：软硬件按对象要求设计、裁减</li><li>计算机：实现对象的智能化功能</li></ul></li></ul><h3 id="信息物理系统">信息物理系统</h3><p>Cyber-Physical System（CPS），是计算进程和物理进程的集成。</p><ul><li><p>强调嵌入式系统和物理学的深度融合</p></li><li><p>深度融合了各类信息技术：传感器、嵌入式计算、云计算、网络通信</p><p>使各种信息化能力高度协同和自治</p></li><li><p>信息化能力：</p><p>3C：计算-Computer、通信-Communication、控制-Control</p></li></ul><h3 id="无线感知网络">无线感知网络</h3><p>Wireless sensornetwork/WSN，是由许多在空间中分布的自动装置组成的一种无线通信计算机网络，这些装置使用传感器协作地监控不同位置的物理或环境状况。</p><h3 id="物联网">物联网</h3><p>Internet ofThings（IoT），通过射频识别（RFID），红外感应器，全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物品与互联网相连接，进行信息交换和通信，以实现智能化识别、定位、跟踪、监控和管理的一种网络概念。</p><ul><li>面向生产的物联网技术开发被称为“工业4.0”。</li></ul><h3 id="发展历程">发展历程</h3><p>1960-1970：出现和兴起</p><p>1971-1989：走向繁荣，软硬件日益完善</p><p>1990-现在：走向纵深</p><h2 id="嵌入式系统的组成">2. 嵌入式系统的组成</h2><p>嵌入式系统一般由嵌入式硬件和软件组成：应用软件+中间件+运行内核+驱动+系统硬件</p><ul><li>硬件以微处理器为核心，集成存储器和系统专用的输入/输出设备</li><li>软件包括初始化代码及驱动、嵌入式操作系统和应用程序等</li></ul><h2 id="嵌入式系统的特点">3. 嵌入式系统的特点</h2><p>形式多样、面向特定应用</p><p>得到多种类型的处理器和处理器体系结构的支持</p><p>通常及其关注成本</p><p>实时性、可靠性</p><p>一般使用适应多种处理器、可剪裁、轻量型、实时可靠、可固化的嵌入式操作系统</p><p>需要专门工具和特殊方法进行开发</p><h2 id="嵌入式系统的分类">4. 嵌入式系统的分类</h2><p>处理器位数：8位、16位、32位、64位</p><p>应用：移动互联网、工业控制、可穿戴设备等</p><p>速度：</p><ul><li>强实时系统：响应时间毫秒或微秒级</li><li>一般实时系统：几秒级</li><li>弱实时系统：数十秒或更长</li></ul><p>确定性：</p><ul><li>硬实时系统：对系统响应时间有严格要求</li><li>软实时系统：系统响应时间不满足，不会导致系统出现致命错误或崩溃</li></ul><p>软件复杂程度：循环轮询、有限状态机、前后台、单/多处理器多任务系统</p><h2 id="嵌入式系统的发展趋势">5. 嵌入式系统的发展趋势</h2><p>嵌入式人工智能</p><p>嵌入式安全性</p><p>高计算需求和复杂性</p><p>软硬件协同设计</p><p>更高集成度</p><p>云计算</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑_0_集合基础</title>
    <link href="/2023/08/01/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91_0_%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/08/01/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91_0_%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>飞流直下三千尺，疑是银河落九天。</p><span id="more"></span><h1 id="第零章-集合基础">第零章 集合基础</h1><h2 id="集合论符号">集合论符号</h2><ul><li>“$$”用于表示一个证明的结束。</li><li>“如果···那么···”，即“蕴含”，缩写为“<spanclass="math inline">\(···\Longrightarrow···\)</span>”；“逆蕴含”则为"<spanclass="math inline">\(···\Longleftarrow···\)</span>"。</li><li>“当且仅当”缩写为“<spanclass="math inline">\(iff\)</span>”或符号“<spanclass="math inline">\(\Longleftrightarrow\)</span>”</li><li>“因为”缩写为“<spanclass="math inline">\(\because\)</span>”，因此缩写为“<spanclass="math inline">\(\therefore\)</span>”</li><li>“<span class="math inline">\(x\neq y\)</span>”是“<spanclass="math inline">\(x=y\)</span>”的否定，“<spanclass="math inline">\(x\notin y\)</span>”是“<spanclass="math inline">\(x\in y\)</span>”的否定，类似符号可推广</li></ul><p>集合是指一些对象的全体，这些对象称为集合的元素或成员。</p><ul><li><p><span class="math inline">\(t\in A\)</span>表示t是A的元素，<spanclass="math inline">\(x=y\)</span>表示x和y是同一个元素</p></li><li><p>如果A和B是两个集合，且对于任意元素t都有</p><p><span class="math inline">\(t\in A\quad iff\quad t\in B\)</span></p><p>那么<span class="math inline">\(A=B\)</span>。</p></li></ul><p>集合论的基本思想：集合是由其元素所确定的。</p><p>对于集合A，<spanclass="math inline">\(A;t\)</span>表示一个新的集合，其元素包括A的元素和元素t（可能是新的），即：</p><p><span class="math inline">\(A;t=A\cup \{t\}\)</span></p><p>集合的表示方法：</p><ul><li>列举法，也称为外延表示方法。</li><li>内涵表示方法，即这个集合由具有某些性质P的对象构成</li></ul><p>如果集合A的所有元素都是集合B的元素，我们称A是B的子集，记作<spanclass="math inline">\(A\subseteq B\)</span>。</p><ul><li>任何集合都是其自身的子集，空集是每个集合的子集</li></ul><h2 id="集合">集合</h2><p>对象是人们感觉和思维中确定的某些事物。我们总是使用对象的名来谈论它。</p><ul><li>对象的名称也可以作为对象，这时候我们通常加引号用以区别</li></ul><h3 id="集合的定义">集合的定义</h3><p>康托尔的集合定义：具有某种性质的、确定的、互异的对象所组成的整体。</p><ul><li>确定性：对于任意集合A和任意元素a，a是否是A的元素是客观确定的</li><li>互异性：一个集合中任意两个对象是不相等的</li></ul><p>罗素悖论集合论：不能用更简单的数学概念来给集合下一个确定的定义</p><ul><li>集合的概念是不能定义的</li><li>康托尔的集合定义只是对集合的一个描述</li></ul><p>罗素悖论：<span class="math inline">\(A=\{A:A\notinA\}\)</span>，可以推导出<span class="math inline">\(A\inA\)</span>当且仅当<span class="math inline">\(A\notin A\)</span>。</p><p>这说明弗雷格根据康托尔的表述引入的概括原则（对任意确定的性质P，所有基于性质P的对象组成的群体就是集合）是有问题的。</p><h3 id="公理化">公理化</h3><h4 id="外延公理-extensionality">外延公理 Extensionality</h4><p>如果X和Y有相同元素，则<spanclass="math inline">\(X=Y\)</span>。即</p><p><span class="math inline">\(A=B\quad iff\quad \forall x(x\in A\quadiff\quad x\in B)\)</span></p><h4 id="空集公理">空集公理</h4><p>存在一个集合，它不含任何元素，除此之外的其他集合都称为非空的。</p><p>空集是每个集合的子集。</p><h4 id="分离公理-separation">分离公理 Separation</h4><p>如果<spanclass="math inline">\(\varphi\)</span>是一性质，则对于任意集合A和参数p，存在一个集合<spanclass="math inline">\(B=\{u\in X:\varphi (u,p)\}\)</span>，它包含所有具有这个性质的A中的元素u。</p><ul><li>由外延公理，分离公理中的集合B是唯一确定的。</li></ul><p>Paring无序对公理：对任意a，b，存在一个集合<spanclass="math inline">\(\{a,b\}\)</span>，恰好含有元素a，b。</p><h3 id="关系">关系</h3><h4 id="幂集交集并集">幂集、交集、并集</h4><ul><li><p>集合A的幂集<span class="math inline">\(\RhoA\)</span>的元素是A的所有子集，即：</p><p><span class="math inline">\(\Rho A=\{x|x\subseteq A\}\)</span></p></li><li><p>集合A与B的并集<span class="math inline">\(A\cupB\)</span>是属于A或属于B的元素的集合</p></li><li><p>集合A与B的交集是所有A与B共有的元素的集合</p><ul><li>A与B不相交，当且仅当二者的交集为空集</li></ul></li></ul><p>对于非空集合A，其元素也是集合，有</p><ul><li><span class="math inline">\(\bigcupA=\{x|x属于A的某个元素\}\)</span></li><li><span class="math inline">\(\bigcapA=\{x|x属于A的每个元素\}\)</span></li></ul><h4 id="有序对">有序对</h4><h5 id="有序对的定义">有序对的定义</h5><p>元素x和y的有序对<spanclass="math inline">\(&lt;x,y&gt;\)</span>定义如下：</p><p><span class="math inline">\(&lt;x,y&gt;=&lt;u,v&gt;\quad iff\quadx=u且y=v\)</span></p><p>所有具有上述性质的定义都可以作为有序对的定义。</p><p>其中，一个标准的定义是<spanclass="math inline">\(&lt;x,y&gt;=\{\{x\},\{x,y\} \}\)</span></p><p>有序三元组可以定义为<spanclass="math inline">\(&lt;x,y,z&gt;=&lt;&lt;x,y&gt;,z&gt;\)</span></p><p>更一般地，对于<spanclass="math inline">\(n&gt;1\)</span>可以如下递归地定义n元组：</p><p><spanclass="math inline">\(&lt;x_1,x_2,...,x_{n+1}&gt;=&lt;&lt;x_1,x_2,...,x_n&gt;,x_{n+1}&gt;\)</span></p><p>为方便起见，对于<spanclass="math inline">\(n=1\)</span>，我们定义<spanclass="math inline">\(&lt;x&gt;=x\)</span>；这样上式对于<spanclass="math inline">\(n=1\)</span>也是成立的。</p><h5 id="有限序列">有限序列</h5><p>称S是A中元素的有限序列（有限串）当且仅当对某个正整数n，<spanclass="math inline">\(S=&lt;x_1,...,x_n&gt;\)</span>，其中每个<spanclass="math inline">\(x_i\in A\)</span>。</p><p>S的子段指一个有限序列<spanclass="math inline">\(&lt;x_k,x_{k+1},...,x_{m-1},x_m&gt;,1\leq k\leqm\leq n\)</span></p><ul><li>这个子段是初始段当且仅当<spanclass="math inline">\(k=1\)</span></li><li>这个子段是真子段当且仅当该子段与S不同</li></ul><p>如果<spanclass="math inline">\(&lt;x_1,...,x_n&gt;=&lt;y_1,...,y_n&gt;\)</span>，易证<spanclass="math inline">\(x_i=y_i,1\leq i\leq n\)</span></p><p>如果<spanclass="math inline">\(&lt;x_1,...,x_m&gt;=&lt;y_1,...y_n&gt;\)</span>，未必有<spanclass="math inline">\(m=n\)</span>，因为每个有序三元组也是一个有序对。</p><ul><li>只有当某个<span class="math inline">\(x_i\)</span>本身是<spanclass="math inline">\(y_i\)</span>的一个有限序列，或某个<spanclass="math inline">\(y_i\)</span>本身是<spanclass="math inline">\(x_i\)</span>的一个有限序列时，m和n才不相等。</li></ul><p>引理：如果<spanclass="math inline">\(&lt;x_1,...,x_m&gt;=&lt;y_1,...,y_m,...,y_{m+k}&gt;\)</span>，那么<spanclass="math inline">\(x_1=&lt;y_1,...,y_{k+1}&gt;\)</span></p><h5 id="笛卡尔积">笛卡尔积</h5><p>笛卡尔积<span class="math inline">\(A\times B\)</span>是所有序对<spanclass="math inline">\(&lt;x,y&gt;\)</span>的集合，其中<spanclass="math inline">\(x\in A,y\in B\)</span>，即<spanclass="math inline">\(A\times B=\{&lt;x,y&gt;|x\in A,y\in B\}\)</span></p><p><spanclass="math inline">\(A^n\)</span>表示A中元素构成的所有的n元组组成的集合，比如<spanclass="math inline">\(A^3=(A\times A)\times A\)</span></p><h4 id="关系-1">关系</h4><p>关系是有序对的集合。</p><ul><li>关系R的定义域记为dom R，是所有满足<spanclass="math inline">\(&lt;x,y&gt;\in R\)</span>的元素x的集合</li><li>关系R的值域记作ran R，是所有满足<spanclass="math inline">\(&lt;x,y&gt;\in R\)</span>的元素y的集合</li><li>dom R和ran R并称为R的域，记作fld R</li></ul><p>A上的n元关系是<span class="math inline">\(A_n\)</span>的子集，若<spanclass="math inline">\(n&gt;1\)</span>，它就是一个关系；<spanclass="math inline">\(n=1\)</span>，A上的一元关系只是A的一个子集。</p><ul><li><p>A上的一个特殊的二元关系是恒等关系<spanclass="math inline">\(\{&lt;x,x&gt;|x\in A \}\)</span></p></li><li><p>对于A上的二元关系R和A的一个子集B，R对B的限制指交集<spanclass="math inline">\(R\cap B^n\)</span></p></li></ul><p>对于关系R，定义：</p><ul><li><p>R在A上是自反的，当且仅当对A中每个x都有<spanclass="math inline">\(&lt;x,x&gt;\in R\)</span></p></li><li><p>R是对称的，当且仅当如果<span class="math inline">\(&lt;x,y&gt;\inR\)</span>，则<span class="math inline">\(&lt;y,x&gt;\inR\)</span></p></li><li><p>R是传递的，当且仅当如果<span class="math inline">\(&lt;x,y&gt;\inR,&lt;y,z&gt;\in R\)</span>，则<spanclass="math inline">\(&lt;x,z&gt;\in R\)</span></p></li></ul><p>R在A上满足三分律，当且仅当对A中任意的x和y，如下三种可能有且仅有一种成立：</p><ul><li><span class="math inline">\(&lt;x,y&gt;\in R\)</span></li><li><span class="math inline">\(x=y\)</span></li><li><span class="math inline">\(&lt;y,z&gt;\in R\)</span></li></ul><p>关系R是A上的一个等价关系当且仅当R是A上自反、对称和传递的一个二元关系；</p><p>关系R是A上的一个序关系当且仅当R是传递的且在A上满足三分律。</p><ul><li><p>对于A上的等价关系R盒<span class="math inline">\(x\inA\)</span>，定义x的等价类为<spanclass="math inline">\(\{y|&lt;x,y&gt;\in R\}\)</span></p><p>等价类划分了A，每个等价类都是A的子集，A的每个元素恰好只属于一个等价类。</p></li></ul><p>关系R的逆关系记为<spanclass="math inline">\(R^{-1}\)</span>，定义为<spanclass="math inline">\(R^{-1}=\{&lt;x,y&gt;|&lt;y,x&gt;\inR\}\)</span></p><h4 id="函数">函数</h4><p>一个具有单值性质的关系F，对于定义域domF中的每一个x，都有唯一的y满足<span class="math inline">\(&lt;x,y&gt;\inF\)</span>。通常，这个唯一的y称F在x上的值F(x)。</p><p>我们称F将定义域A映射到值域B，F是一个函数。</p><ul><li><p>F是一个一一映射当且仅当对于B中的每个y，存在唯一的x使得<spanclass="math inline">\(&lt;x,y&gt;\in F\)</span></p></li><li><p>如果<span class="math inline">\(&lt;x,y&gt;\)</span>在定义域domF中，则记<spanclass="math inline">\(F(x,y)=F(&lt;x,y&gt;)\)</span></p></li><li><p>这个记法可以推广到n元</p></li></ul><p>A上的n元运算是一个将<spanclass="math inline">\(A^n\)</span>映射到A中的函数。</p><h4 id="偏序关系">偏序关系</h4><p>序的一般理论：</p><p>设A为一个集合，R是A上的二元关系，称R为A上的偏序关系，如果满足如下条件：</p><ul><li><p>R具有自反性</p></li><li><p>R具有反对称性，且对任意<span class="math inline">\(x,y\inR\)</span>，如果<span class="math inline">\(xRy\)</span>且<spanclass="math inline">\(yRx\)</span>，则<spanclass="math inline">\(x=y\)</span></p></li><li><p>R具有传递性</p></li></ul><p>设A为一个集合，R是A上的二元关系，称R为A上的严格偏序关系，如果满足如下条件：</p><ul><li><p>R具有禁自反性，即任意x属于A都有非<spanclass="math inline">\(R(x,x)\)</span></p></li><li><p>R具有禁对称性，且对任意<span class="math inline">\(x,y\inA\)</span>，如果<span class="math inline">\(R(x,y)\)</span>，则非<spanclass="math inline">\(R(y,x)\)</span></p></li><li><p>R具有传递性</p></li></ul><p>自然数集N上面的小于关系就是严格的偏序关系。</p><p>极小元的定义：</p><p>如果<spanclass="math inline">\((A,\leq)\)</span>是偏序集，B包含于A，b属于B，称b为B的关于<spanclass="math inline">\(\leq\)</span>关系的极小元，如果不存在x属于B，使得<spanclass="math inline">\(x\neq b\)</span>且<spanclass="math inline">\(x\leq b\)</span>。</p><h4 id="良序关系">良序关系</h4><p>线序的定义：</p><p>如果<spanclass="math inline">\((A,\leq)\)</span>是偏序集，A中任意两个元素x，y都在偏序关系<spanclass="math inline">\(\leq\)</span>下可以比较，即要么<spanclass="math inline">\(x\leq y\)</span>，要么<spanclass="math inline">\(y\leq x\)</span>，则称<spanclass="math inline">\(\leq\)</span>关系是线序关系或全序关系。相应地称<spanclass="math inline">\((A,\leq)\)</span>为线序集或全序集。</p><p>如果<span class="math inline">\(\leq\)</span>为A上的线序，则称<spanclass="math inline">\(&lt;\)</span>为A上的严格线序。</p><p>良序的定义：</p><p>设<spanclass="math inline">\((A,\le)\)</span>是线序集，如果A的任意非空子集都有<spanclass="math inline">\(\le-\)</span>极小元，则称<spanclass="math inline">\((A,\le)\)</span>为良序集，且称<spanclass="math inline">\(\le\)</span>为A上的良序，或称A被<spanclass="math inline">\(\le\)</span>良序。</p><p>如果<spanclass="math inline">\(\le\)</span>是R上的良序，有时也称<spanclass="math inline">\(&lt;\)</span>是A上的良序。</p><ul><li>有穷的线序集都是良序集。</li><li>在定义中如果只要求偏序而不是线序，就称为良基偏序。</li></ul><h5 id="良序问题">良序问题</h5><p>是否对任意的集合A，都存在A上的良序关系？</p><p>良序原则：任意的集合都可以被良序</p><ul><li>良序原则和Zorn引理等价</li></ul><h4 id="乘积公理">乘积公理</h4><p>对任意集族<span class="math inline">\((X_i)_{i\inI}\)</span>，如果I为非空集合，且对任意<span class="math inline">\(i\inI\)</span>，集合<span class="math inline">\(X_i\)</span>非空，则<spanclass="math inline">\(\prod_{i\in I}X_i\)</span>非空。</p><h4 id="选择公理">选择公理</h4><p>对任意非空集合X，如果X中的元素均为非空集合，则存在映射f使得<spanclass="math inline">\(dom(f)=X\)</span>，且<spanclass="math inline">\(\forall x\in X\)</span>都有<spanclass="math inline">\(f(x)\in x\)</span>（称f为X上的选择函数）。</p><h4 id="可数">可数</h4><p>集合A是可数的，当且仅当存在某个函数将A一对一映射到自然数N中。</p><ul><li>设A是一个可数集，则所有由A的元素构成的有限序列的集合也可数</li></ul><h3 id="有穷与无穷集合">有穷与无穷集合</h3><h4 id="自然数的定义">自然数的定义</h4><p>集合的后继：</p><p>设A为任意的集合，我们称集合<span class="math inline">\(A\cup\{A\}\)</span>为A的后继集合，简称A的后继，记作<spanclass="math inline">\(A^+\)</span>，而A为<spanclass="math inline">\(A^+\)</span>的前趋。</p><p>自然数的定义：</p><ol type="1"><li><span class="math inline">\(0=\empty\)</span></li><li><span class="math inline">\(1=0^+=\{0\}\)</span></li><li><span class="math inline">\(2=1^+=\{0,1\}\)</span></li><li>假设我们已经定义了<spanclass="math inline">\(n=\{0,1,...,n-1\}\)</span>，则定义<spanclass="math inline">\(n+1=n^+=n\cup\{n\}=\{0,1,...,n-1,n\}\)</span></li><li>每个自然数都是从0开始经过有穷步后继运算的结果</li></ol><h4 id="无穷公理">无穷公理</h4><p>所有自然数组成的集合的整体是集合，记为<spanclass="math inline">\(\omega\)</span>。</p><h4 id="佐恩引理或极大原则">佐恩引理或极大原则</h4><p>设A是一个集合，且满足对于任意的链<spanclass="math inline">\(C\subseteq A\)</span>，有集合<spanclass="math inline">\(\bigcupC\)</span>在A中，那么A中存在极大元m，即m不是A中其他任意元素的子集。</p><ul><li>我们说一组集合C是一个链，当且仅当对于C中任意元素x和y，要么<spanclass="math inline">\(x\subseteq y\)</span>要么<spanclass="math inline">\(y\subseteq x\)</span></li></ul><h4 id="数学归纳法">数学归纳法</h4><p>集合形式的数学归纳法：</p><p>设S为一个集合，如果S满足如下两个条件：</p><ul><li><span class="math inline">\(0\in S\)</span></li><li>对任何自然数n，如果<span class="math inline">\(n\inS\)</span>，则<span class="math inline">\(n+1\in S\)</span></li></ul><p>则<span class="math inline">\(\omega \subseteqS\)</span>，即每个自然数对属于S。</p><h5 id="正则公理">正则公理</h5><p>每个非空集合A中总存在元素x使得<span class="math inline">\(x\capA=\empty\)</span>（此时称x为A的<span class="math inline">\(\in-\)</span>极小元）。</p><p>正则公理的蕴含：</p><ul><li><p>不存在集合<span class="math inline">\(x\in x\)</span></p></li><li><p>不存在集合x,y使得<span class="math inline">\(x\iny\)</span>且<span class="math inline">\(y\inx\)</span>。一般地，不存在集合<spanclass="math inline">\(x_1,...,x_n\)</span>使得<spanclass="math inline">\(x_1\in x_2,...,x_{n-1}\in x_n,x_n\inx_1\)</span>。</p><p>不存在集合<span class="math inline">\(\{x_n|n\in \omega使得每个n\in\omega 都有x_{n+1}\in x_n\}\)</span></p></li></ul><p>集合形式的数学归纳法证明：暂略，20230912，P30</p><p>性质形式的数学归纳原理：</p><p>设R是性质，如果有</p><ol type="1"><li>R(0)成立，且</li><li>对任意自然数n，若R(n)成立，R(n+1)也成立</li></ol><p>则对任意自然数n都有R(n)成立。</p><h5 id="传递集合">传递集合</h5><p>设A是一个集合，如果A的任意元素都是A的子集，则称A是传递集合。</p><ul><li><p>A为传递集合，则<span class="math inline">\(\forall x\in A,y\inx,y\in A\)</span>。</p></li><li><p>每个自然数都是传递集合</p></li><li><p><spanclass="math inline">\(\omega\)</span>是传递集合，即对任意自然数n都有n是<spanclass="math inline">\(\omega\)</span>的传递集合</p></li><li><p>引理：<span class="math inline">\(\forall n,m\in N,如果n\subseteqm,有n=m或者n\in m\)</span></p></li></ul><p>$<span class="math inline">\(-三歧性：\)</span>x,yA有xy或x=y或yx$</p><ul><li><span class="math inline">\(\omega\)</span>具有三歧性</li></ul><p>任意自然数n、m，定义</p><ul><li><span class="math inline">\(m&lt;n当且仅当m\in n\)</span></li><li><span class="math inline">\(m\le n当且仅当m&lt;n或m=n\)</span></li></ul><h4 id="有穷集合和无穷集合">有穷集合和无穷集合</h4><h5 id="等势集合">等势集合</h5><p>设A、B为两个集合，如果存在A到B上的双射，则称A与B等势，或称A与B对等，记为<spanclass="math inline">\(A～B\)</span></p><ul><li>直观上，A与B等势，则A和B有同样多的元素。</li></ul><p>等势关系是等价关系，即</p><ul><li><span class="math inline">\(\forall A,A～A\)</span></li><li><span class="math inline">\(\forallA,B,如果A～B,则B～A\)</span></li><li><span class="math inline">\(\forallA,B,C,如果A～B,B～C,则A～C\)</span></li></ul><h5 id="康托尔伯恩斯坦定理">康托尔伯恩斯坦定理</h5><p>设A、B为两个集合，假设<span class="math inline">\(A\preceq B,B\preceqA\)</span>，则<span class="math inline">\(A～B\)</span></p><h5 id="有穷集合">有穷集合</h5><p>和某个自然数等势的集合为有穷集合，否则为无穷集合。</p><ul><li><p>每个自然数都是有穷集合</p></li><li><p>引理：假设A是有穷集合，x不属于A，则<spanclass="math inline">\(A\cup \{x\}\)</span>是有穷集合</p></li><li><p>引理：集合A是有穷集合，当且仅当存在自然数n，使得<spanclass="math inline">\(A\preceq n\)</span></p></li><li><p>对任意的自然数n，n的每个真子集都不与n等势</p><ul><li>抽屉原理：集合A为有穷集合，当且仅当它不与它的任何真子集等势</li></ul></li></ul><h5 id="可数集合">可数集合</h5><p>若集合<span class="math inline">\(A\preceq\omega\)</span>，即存在A到<spanclass="math inline">\(\omega\)</span>的单射，则称A可数</p><ul><li>若<spanclass="math inline">\(A～\omega\)</span>，则称A为可数的无穷集合</li><li>定理：可数多个可数集合的并集可数</li></ul><h5 id="无穷集合">无穷集合</h5><p>每一个无穷集合都有无数无穷子集。</p><ul><li>如果A是无穷集合，则<span class="math inline">\(\omega\preceqA\)</span></li><li>A是无穷集合当且仅当它与自身的一个真子集等势</li><li>引理：假设A是非空集合且<span class="math inline">\(\bigcupA=A\)</span>，则A是无穷集合</li></ul><h5 id="不可数集合">不可数集合</h5><p>不是可数集合的无穷集合为不可数元集合。</p><ul><li><p>康托尔定理：<span class="math inline">\(\forall A,A\prec\Rho(A)\)</span></p></li><li><p>区间(0,1)不可数</p></li><li><p>连通性假设：<span class="math inline">\(\forall A,\omega\preceqA且A\preceq R，则要么A～\omega，要么A～R。\)</span></p><p><span class="math inline">\(换言之，不存在集合A使得\omega\preceqA且A\preceq R。\)</span></p></li></ul><h5 id="序数">序数</h5><p>每一个良序集合都与一个自然数序同构。</p><ul><li>设<spanclass="math inline">\((A,\le_A)\)</span>为一个良序集，A有穷，则存在一个自然数n，使得<spanclass="math inline">\((A,\le_A)\)</span>与<spanclass="math inline">\((n,\le)\)</span>序同构</li></ul><p>具有三歧性的传递集合叫做序数</p><ul><li>0是序数</li><li>每个自然数都是序数</li><li><span class="math inline">\(\omega\)</span>是序数</li></ul><p>引理：如果<span class="math inline">\(\alpha\)</span>是序数，<spanclass="math inline">\(\alpha^+\)</span>也是序数；序数的每个元素也是序数。</p><p>对于自然数n，归纳定义<spanclass="math inline">\(\omega+n\)</span>：</p><ol type="1"><li><span class="math inline">\(\omega+0=\omega\)</span></li><li><span class="math inline">\(\omega+(n+1)=(\omega+n)^+\)</span></li></ol><p>对任意自然数有<spanclass="math inline">\(\omega+n\)</span>为序数。</p><p>定理：对任意两个序数<spanclass="math inline">\(\alpha、\beta\)</span>都有<spanclass="math inline">\(\alpha\in\beta\)</span>，或者<spanclass="math inline">\(\alpha=\beta\)</span>，或者<spanclass="math inline">\(\beta\in\alpha\)</span>。</p><ul><li>证明：0912 P42</li></ul><p>用<span class="math inline">\(O_n\)</span>表示所有序数的类。</p><ul><li><p><span class="math inline">\(O_n\)</span>不是集合，否则<spanclass="math inline">\(O_n是序数，O_N\subseteqO_n\)</span>，与正则公理矛盾。</p></li><li><p>任何序数在属于关系上是良序集，我们用&lt;表示序数的属于关系</p></li></ul><p>定理：假设S中每个元素都是序数，那么<spanclass="math inline">\(\bigcup S\)</span>也是序数。</p><ul><li><span class="math inline">\(\omega\)</span>是序数</li><li>设<spanclass="math inline">\(S_0=\{\omega,\omega+1,...,\omega+n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega+\omega\)</span>或<spanclass="math inline">\(\omega·2\)</span><ul><li>类似地，可以定义<spanclass="math inline">\(\omega·3,...,\omega·n,...\)</span></li></ul></li><li>设<spanclass="math inline">\(S_1=\{\omega,\omega·2,...,\omega·n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega·\omega\)</span>或<spanclass="math inline">\(\omega^2\)</span><ul><li>类似地，可以定义<spanclass="math inline">\(\omega^3,...,\omega^n,...\)</span></li></ul></li><li>设<spanclass="math inline">\(S_2=\{\omega,\omega^2,...,\omega^n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega^\omega\)</span></li></ul><p>上述<span class="math inline">\(\omega^n\)</span>和<spanclass="math inline">\(\omega^\omega\)</span>为序数算数，不是笛卡尔积。</p><p>替换公理：设<spanclass="math inline">\(P(x,y)\)</span>为类关系，A是一个集合，如果<spanclass="math inline">\(\forall x\in A\)</span>，有唯一<spanclass="math inline">\(y_x\)</span>，使得<spanclass="math inline">\(P(x,y_x)\)</span>成立，则<spanclass="math inline">\(\{y_x|x\in A\}\)</span>是集合。</p><h5 id="超穷归纳法">超穷归纳法</h5><p>设<span class="math inline">\(\alpha\)</span>为序数</p><ul><li>如果存在序数<span class="math inline">\(\beta\)</span>使得<spanclass="math inline">\(\alpha=\beta^+\)</span>，则称<spanclass="math inline">\(\alpha\)</span>为后继序数</li><li>不是后继序数的非零序数称为极限序数</li></ul><p>设<span class="math inline">\(\alpha\neq 0\)</span>为序数，则</p><ul><li><spanclass="math inline">\(\alpha\)</span>为极限序数当且仅当对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都有<spanclass="math inline">\(\beta^+\lt\alpha\)</span></li><li><span class="math inline">\(\alpha\)</span>是极限序数当且仅当<spanclass="math inline">\(\alpha\)</span>中无最大元，即对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都存在<spanclass="math inline">\(\gamma\lt\alpha\)</span>，使得<spanclass="math inline">\(\beta\lt\gamma\)</span></li></ul><p>超穷归纳法原理：</p><p>设<span class="math inline">\(R(x)\)</span>为一个性质</p><ol type="1"><li><p>假设<span class="math inline">\(R(0)\)</span>成立</p></li><li><p>对任意的序数<spanclass="math inline">\(\alpha\)</span>，如果<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\alpha+1)\)</span>也成立</p></li><li><p>对于任意的极限序数<spanclass="math inline">\(\lambda\)</span>，如果对每一<spanclass="math inline">\(\alpha\lt\lambda\)</span>都有<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\lambda)\)</span>成立</p><p>那么对于任意的序数<spanclass="math inline">\(\alpha\)</span>都有<spanclass="math inline">\(R(\alpha)\)</span>成立</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数理逻辑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>毛概-期末复习</title>
    <link href="/2023/06/15/%E5%A4%8D%E4%B9%A0/%E6%AF%9B%E6%A6%82%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/15/%E5%A4%8D%E4%B9%A0/%E6%AF%9B%E6%A6%82%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1id="毛泽东思想和中国特色社会主义理论体系概论-期末复习">毛泽东思想和中国特色社会主义理论体系概论期末复习</h1><span id="more"></span><p>任课教师：武海宝</p><h3 id="科学社会主义">科学社会主义</h3><ul><li>科学社会主义确认金融资本是现代社会各种病症的根源。</li><li>共产主义不是对财产的否定，而是对社会财产的私人垄断的否定。</li></ul><p>伦理社会主义：</p><p>伦理社会主义是在自然经济时代发展起来的，它强调人与人之间的和谐，与宗教、大同理想、家族文化等各种形态相结合，以一种改良的身份去批评资本主义，但它无法改变资本主义的基本逻辑</p><h2 id="新民主主义革命">新民主主义革命</h2><h3 id="中国社会主义革命道路探索">中国社会主义革命道路探索</h3><h4 id="中国的两步走">中国的两步走</h4><p>中国革命必须分为两个步骤。第一步，改变这个殖民地、半殖民地、半封建的社会形态，使之变成一个独立的民主主义的社会，第二部，使这个革命向前发展，建立一个社会主义的社会。——毛泽东《新民主主义论》</p><h4 id="三湾改编">三湾改编</h4><p>1927年9月至10月，毛泽东在江西省永新县三湾村领导了三湾改编。</p><p>毛泽东创造性地确立了支部建在连上、官兵平等等一系列治军方略。三湾改编是中国共产党建设新型人民军队最早的一次成功探索和实践。</p><p>意义：</p><ul><li>从政治上和组织上保证了党对军队的绝对领导，是我党建设新型人民军队最早的一次成功探索和实践，标志着毛泽东建设人民军队思想的开始形成</li><li>初步解决了如何把以农民和旧军人为主要成分的革命军队建设成为一支无产阶级新型人民军队的问题，奠定了政治强军的基础</li><li>实现民主主义，对团结广大士兵群众、瓦解敌军起到巨大作用</li></ul><h4 id="新民主主义革命的基本纲领">新民主主义革命的基本纲领</h4><ul><li>没收封建地主阶级的土地归农民所有；没收官僚资本主义的垄断资本归国家所有；保护民族工商业</li><li>建立无产阶级领导下的一切反帝反封建的人民联合专政的民主共和国，这就是新民主主义的共和国</li><li>实行人民大众的反帝反封建的文化，即民族的、科学的、大众的文化</li></ul><h4 id="新旧民主主义革命的异同">新旧民主主义革命的异同</h4><ul><li>相同点：<ul><li>社会性质：都发生在半殖民地半封建社会</li><li>革命任务：都是反对外国资本主义侵略和本国封建统治</li><li>革命性质：都属于资产阶级民主革命的范畴</li></ul></li><li>不同点：<ul><li>领导力量：旧民主主义革命的领导是资产阶级，新民主主义革命的领导是无产阶级</li><li>指导思想：旧民主主义革命是资产阶级的平等、自由思想和民族观念，新民主主义革命是马克思主义</li><li>革命前途：旧民主主义革命是建立资产阶级民主共和国，新民主主义革命在完成民主革命任务后，还要进入社会主义社会</li><li>革命发展和群众发动的深度、广度：旧民主主义革命的纲领不彻底，群众发动不充分，土地问题不能彻底解决；新民主主义革命提出了彻底的革命纲领，广泛发动群众，解决了民主革命的中心问题，即土地问题</li><li>结果不同：旧民主主义革命有胜利的一面，但最终果实被窃取，革命任务没有完成，社会性质没有改变，在这一意义讲是最终遭到了失败；新民主主义革命的胜利成为了社会主义的必要准备，社会主义是新民主主义革命的必然结果</li><li>旧民主主义革命属于世界资产阶级革命的一部分，新民主主义革命属于无产阶级世界革命的一部分</li></ul></li></ul><h3 id="新民主主义社会">新民主主义社会</h3><ul><li>政治上，新民主主义的国家实行工人阶级领导的、工农联盟为基础的、团结各民主阶级和国内各民族的人民民主专政。</li><li>经济上：</li></ul><table><thead><tr class="header"><th>成分</th><th>来源</th><th>性质</th><th>地位</th></tr></thead><tbody><tr class="odd"><td>国营经济</td><td>没收官僚资本</td><td>社会主义</td><td>领导地位</td></tr><tr class="even"><td>合作社经济</td><td>个体向社会主义集体经济过渡</td><td>半社会主义</td><td></td></tr><tr class="odd"><td>个体经济</td><td>个体农业、手工业</td><td>个体经济</td><td>绝对优势</td></tr><tr class="even"><td>私人资本主义经济</td><td>民族资本主义</td><td>资本主义</td><td></td></tr><tr class="odd"><td>国家资本主义经济</td><td>私人资本主义经济向社会主义国营经济过渡</td><td>半社会主义</td><td></td></tr></tbody></table><p>新民主主义社会，是指在新民主主义革命胜利的基础上，建立起来的既不是资产阶级共和国也不是无产阶级共和国的的各个革命阶级联合专政的共和国，是落后国家进行革命的特有社会形态。</p><ul><li>性质：过渡性社会形态，隶属于社会主义体系</li><li>特点：既有社会主义因素，也有资本主义因素</li><li>从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期</li><li>过渡时期的时间，中央领导估计大约需要10年、15年或者更久</li></ul><h4 id="过渡时期总路线">过渡时期总路线</h4><p>从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造。</p><h4id="中国社会主义改造道路三大改造">中国社会主义改造道路：三大改造</h4><ul><li>农业合作化，将小农经济改造为农业集体主义经济</li><li>手工业社会主义改造，通过合作化道路，把个体手工业转变为社会主义劳动群众集体所有制经济</li><li>资本主义工商业社会主义改造，通过国家资本主义的形式，采取和平赎买的政策，将民族资本主义经济改造成社会主义公有制企业，而且将所有制改造与人的改造相结合，努力使剥削者成为自食其力的劳动者</li></ul><p>社会主义改造时期，把实现国家的工业化作为党在过渡时期总路线的主体，受苏联的影响，一度过多强调重工业和基础设施的发展，促使党思考如何走中国工业化道路的问题。</p><h4 id="中国工业化道路的目标和方针">中国工业化道路的目标和方针</h4><ul><li>总方针：以农业为基础，以工业为主导，以农、轻、重为序发展国民经济</li><li>农业为重工业提供积累资金和原料，同时提供市场</li><li>目标：逐步建立独立的比较完整的基础工业体系和国防工业体系</li></ul><h3 id="中国无产阶级的主要优点">中国无产阶级的主要优点</h3><ol type="1"><li>革命性强。深受帝国主义、封建主义、资本主义的三重压迫，具有强烈的反抗意识</li><li>和广大农民有着天然联系，容易和农民结成亲密的联盟</li><li>集中在沿海、沿江大中城市，便于组织</li></ol><p>新民主主义革命的动力：农民</p><h2 id="改革开放">改革开放</h2><h3 id="家庭联产承包责任制和土地流转">家庭联产承包责任制和土地流转</h3><p>家庭联产承包责任制和统分结合的双层经营体制：</p><p>所有权、承包权和经营权三权分置，经营权流转的格局。农业用地在土地承包期限内，可以通过转包、转让、入股、合作、租赁、互换等方式出让经营权。</p><h3id="中国社会主义农业改革和发展的两个飞跃">中国社会主义农业改革和发展的两个飞跃</h3><p>两个飞跃是邓小平晚年关于我国农业改革和发展的重要思考</p><ol type="1"><li>废除人民公社，实行家庭联产承保责任制</li><li>适应科学生产、生产社会化的需要，再度发展集体经济</li></ol><h3id="中国特色社会主义市场经济制度的体制优势">中国特色社会主义市场经济制度的体制优势</h3><ul><li>从落后国家率先取得胜利的社会主义，还不能一下子排除掉资本。中国从新民主主义社会到改革开放，基本探索出一个相对稳定的制度形式，也就是公有制主导下的市场经济</li><li>以公有制为主体的社会主义市场经济制度既能充分利用市场、充分利用一般职能资本的积极作用来推动社会发展，又能避免金融资本的剥削性、寄生性、投机性积累及其所导致的一系列问题，创造了一条不同于西方的现代化道路</li></ul><h2 id="社会主义">社会主义</h2><h3 id="社会主义的本质">社会主义的本质</h3><ul><li>解放和发展生产力——基本经济制度的内在属性</li><li>消灭剥削，消除两极分化——基本经济制度的内在张力</li><li>最终达到共同富裕</li></ul><h3 id="三个代表">三个代表</h3><p>三个代表是建党理论。</p><p>中国共产党始终代表</p><ul><li>中国先进生产力的发展要求</li><li>中国先进文化的前进方向</li><li>中国最广大人民的根本利益</li></ul><h3 id="科学发展观">科学发展观</h3><ul><li>第一要义是发展</li><li>核心是以人为本</li><li>基本要求是全面协调可持续发展</li><li>根本方法是统筹兼顾</li></ul><h3 id="十个坚持">十个坚持</h3><ul><li>坚持党的领导</li><li>坚持人民至上</li><li>坚持理论创新</li><li>坚持独立自主</li><li>坚持中国道路</li><li>坚持胸怀天下</li><li>坚持开拓创新</li><li>坚持敢于斗争</li><li>坚持统一战线</li><li>坚持自我革命</li></ul><h2 id="使命型政党">使命型政党</h2><h3 id="理论渊源">理论渊源</h3><p>⻢克思：过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的，为绝大多数人谋利益的独立的运动。在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。</p><h3 id="人民利益的统一性完整性">人民利益的统一性、完整性</h3><ul><li>区别公意和众意：<ul><li>卢梭在《社会契约论》中说：“公意和众意之间经常有着很大的差别。公意总是着眼于公共利益，而众意则着眼于私利，它只是个体意志的总和。”</li></ul></li></ul><h3 id="中国共产党是使命型政党">中国共产党是使命型政党</h3><ul><li>把国家从金融资本、金融寡头的工具变成社会利益的集中代表，这是社会主义国家的国体概念。作为社会联合所有制的代理人来执行职能的国家，这是一种和新自由主义消极国家不一样的积极国家，这种积极国家又要依赖一个先锋队、依赖一个使命型政党。</li><li>这种政党不同于⻄方那样一种选举型政党。选举型政党容易分裂人⺠的意志，而人⺠意志的分裂有利于金融寡头对经济、政治的支配。</li><li>共产党作为先锋队的组织，作为人⺠意志的集中表现，作为一个没有自己特殊私利的政党，共产党的合法性依据先进的纲领、依据人⺠⺠主、依据自我革命。社会主义政权的一系列的组织形式不同于⻄方三权分立的政治制度。</li></ul><h4id="使命型政党和西方选举型政党的区别">使命型政党和西方选举型政党的区别</h4><ul><li>基于全心全意为人民服务的马克思主义政党；建立在人性恶和权力恶的双重不信任文化基础上的政党</li><li>作为整体的部分而服务于本体的政党；割裂于整体而利用本体牟利的政党</li></ul><h2 id="我国的政治制度">我国的政治制度</h2><h4 id="人民民主专政国体">人民民主专政——国体</h4><p>中国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家。</p><p>人民民主专政是中国的国家根本性质</p><p>只有人民民主专政才能终结国外列强操控的军阀割据。</p><p>军阀割据的社会根源：</p><ul><li>中国社会的半封建性，中国具有分散性的封建地主经济的必然产物</li><li>中国社会的半殖民性，帝国主义分而治之的侵略政策必然导致军阀割据</li></ul><h4 id="人民代表大会制度政体">人民代表大会制度——政体</h4><ul><li>人民通过人民代表大会有效行使国家权力</li><li>全国人民代表大会是最高国家权力机关，地方人民代表大会是地方国家权力机关</li><li>各级国家行政机关、监察机关、审判机关、检察机关都由人民代表大会产生，对人大负责，受人大监督。人民代表大会有立法权、监督权、决定权、任免权</li><li>人大代表来自人民，横向上，来自各地区、各民族、各方面、各阶层；纵向上，全国、省、市、县、乡五级都有人民代表大会，具有广泛代表性</li></ul><h4id="中国共产党领导的多党合作和政治协商制度">中国共产党领导的多党合作和政治协商制度</h4><p>中国共产党是执政党，八个民主党派是接受中国共产党领导、同中国共产党亲密合作的参政党。</p><ul><li>在中国，没有反对党，也没有在野党。中国既不是一党专政，也不是多党竞争、轮流执政，而是“共产党领导、多党派合作，共产党执政、多党派参政”。</li></ul><h4 id="民主实践选举民主">民主实践：选举民主</h4><ul><li><p>人⺠通过选举、投票行使权利，选出代表自己意愿的人来掌握并行使权力，是中国⺠主的一种主要形式，是人⺠实现当家作主的主要体现。</p></li><li><p>中国的选举是广泛的，有国家机构选举、村(居)委会选举、企事业单位职工代表大会选举等，涵盖了国家政治生活和社会生活的各个方面。</p></li><li><p>中国的选举是平等的，人⺠的选举权和被选举权得到充分保障，一人一票、票票等值</p></li><li><p>中国的选举是真实的，不受金钱操控，选⺠按照自己的意愿选出自己信任的人。</p></li><li><p>国家机构选举：从全国人大到乡级人大，五级人⺠代表大会代表均由⺠主选举产生，每届任期5年。选⺠直接选举产生县乡两级人大代表，县级以上人大代表由下一级人大选举产生。各级国家机关领导人员均由同级人大选举产生或者决定任命。</p></li><li><p>基层选举：村(居)⺠委员会选举和企事业单位职工代表大会选举。村(居)⺠依法定期选举产生村(居)⺠委员会成员。在企事业单位中，职工代表大会是职工当家作主、行使⺠主管理权力的机构。</p></li></ul><h4 id="民主实践协商民主">民主实践：协商民主</h4><ul><li><p>人⺠在通过选举、投票行使权利的同时，在重大决策前和决策过程中进行充分协商，尽可能就共同性问题取得一致意⻅。协商⺠主是中国⺠主独特的、独有的、独到的⺠主形式。</p></li><li><p>协商⺠主形式:提案、会议、座谈、论证、听证、评估、咨询、网络、⺠意调查等多种途径和方式，在决策之前和决策实施之中开展广泛协商。</p></li></ul><p>缺乏协商民主：英国脱欧</p><p>票决至上：一人一票是民主的一种形式，但绝非其唯一和全部</p><h4 id="政党和民主">政党和民主</h4><ul><li>中国共产党的领导，是中国发展全过程人⺠⺠主的根本保证。</li><li>把中国14亿多人⺠的意愿表达好、实现好，必须有坚强有力的统一领导。</li><li>中国共产党始终坚持以人⺠为中心、坚持人⺠主体地位，真正为人⺠执政、靠人⺠执政；充分发挥总揽全局、协调各方的领导核心作用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>复习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-目标代码生成</title>
    <link href="/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
    <url>/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>子不语</p><span id="more"></span><h1 id="目标代码生成">目标代码生成</h1><h2 id="risc-v">RISC-V</h2><h3 id="寄存器">寄存器</h3><ul><li><p>zero：存放常数0，不允许修改</p></li><li><p>ra：存放返回地址</p></li><li><p>t0~t6：保存临时变量</p></li><li><p>pc：保存下一条指令的地址</p></li></ul><h3 id="指令">指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">t0</span>, <span class="hljs-number">20</span><span class="hljs-comment"># li: load immediate</span><br>li <span class="hljs-built_in">t1</span>, <span class="hljs-number">22</span><br><span class="hljs-keyword">add </span><span class="hljs-built_in">t2</span>, <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">t1</span><br></code></pre></td></tr></table></figure><p>li指令是一条伪指令，最终会翻译为addi t0, zero, 20的形式</p><ul><li>负数则为addi t0, zero, -20</li><li>没有subi指令</li></ul><h3 id="系统调用">系统调用</h3><ol type="1"><li>把服务号写入a7寄存器</li><li>把参数写入a0、a1、a2、a3、fa0、...</li><li><code>ecall</code></li><li>从结果寄存器中获得返回值</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">1</span><span class="hljs-comment"># service 1 is print integer</span><br><span class="hljs-keyword">add </span><span class="hljs-built_in">a0</span>, <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">zero</span><span class="hljs-comment"># load desired int into a0</span><br>ecall<br></code></pre></td></tr></table></figure><h3 id="代码段">代码段</h3><ul><li><p>.开始的指令是写给汇编器的指令</p></li><li><p>.data存储全局变量</p><ul><li><code>g: .word 0</code></li><li><code>msg: .string "sss"</code>以\0结尾的string</li><li><code>msg: .ascii "sds"</code>的string不以\0结尾</li></ul></li><li><p>.text存储运行代码</p><ul><li><code>la t0, g      # la: load address</code></li><li><code>lw t0, 0(t0) # lw: load word</code></li><li><code>sw t6, 0(t0) #sw: store word</code></li></ul></li></ul><p>默认在程序开始添加.text</p><ul><li>打印字符串：</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">4</span><br>la <span class="hljs-built_in">a0</span>, msg<br>ecall<br></code></pre></td></tr></table></figure><ul><li>mv</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">1</span><br>mv <span class="hljs-built_in">a0</span>, <span class="hljs-built_in">t6</span> <span class="hljs-comment">#add a0, t6, zero</span><br>ecall<br></code></pre></td></tr></table></figure><ul><li>数组：偏移地址</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br><span class="hljs-symbol">numbers:</span> <span class="hljs-meta">.word</span> -<span class="hljs-number">30</span>, <span class="hljs-number">30</span>, -<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span><br><br><span class="hljs-meta">.text</span><br>la <span class="hljs-built_in">t0</span>, numbers<br><span class="hljs-keyword">lw </span><span class="hljs-built_in">t1</span>, <span class="hljs-number">12</span>(<span class="hljs-built_in">t0</span>)<span class="hljs-comment"># 偏移12个字节，到20</span><br><span class="hljs-keyword">addi </span><span class="hljs-built_in">t1</span>, <span class="hljs-built_in">t1</span>, <span class="hljs-number">90</span><br><span class="hljs-keyword">sw </span><span class="hljs-built_in">t1</span>, <span class="hljs-number">12</span>(<span class="hljs-built_in">t0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-语法分析</title>
    <link href="/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>子不语</p><span id="more"></span><h1 id="语法分析">语法分析</h1><p>文法：一组描述良构程序语法结构的精确的规则</p><ul><li>文法给出了一个程序设计语言的精确易懂的语法规约</li><li>对于某些类型的文法，我们可以自动地构造出高效的语法分析器，它能够确定一个源程序的语法结构。同时，语法分析器的构造过程可以揭示出语法的二义性，还能发现一些容易在语法的初始设计阶段被忽略的问题</li><li>一个正确设计的文法给出了一个语言的结构，该结构有助于把源程序翻译成正确的目标代码，也有助于检测错误</li><li>一个文法支持逐步加入可以完成新任务的新语言构造从而迭代地演化和开发语言。如果对语言的实现遵循语言的文法结构，那么在实现中加入这些新构造的工作就变得更容易</li></ul><h2 id="一引论">一、引论</h2><h3 id="语法分析器的作用">语法分析器的作用</h3><p>语法分析器从词法分析器获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成，能够以易于理解的方式报告语法错误，并且能够从常见的错误中恢复并继续处理程序的其余部分。</p><ul><li><p>对于良构的程序，语法分析器构造出一棵语法分析树，并把它传递给编译器的其他部分进一步处理。</p></li><li><p>处理文法的语法分析器大体上可分为三种类型：</p><ul><li>通用的：效率较低不能用于编译器产品</li><li>自顶向下的：从语法分析树的顶部开始向底部构造语法分析树</li><li>自底向上的：从叶结点开始逐步向根结点构造<ul><li>语法分析器的输入总是按从左到右的方式被扫描，每次扫描一个符号</li></ul></li></ul></li></ul><h3 id="语法错误的处理">语法错误的处理</h3><p>错误的不同层次：</p><ul><li>词法错误</li><li>语法错误</li><li>语义错误</li><li>逻辑错误</li></ul><p>可行前缀特性：</p><p>一旦发现输入的某个前缀不能够通过添加一些符号而形成这个语言的串，就可以立即检测到语法错误。</p><p>错误恢复的一般策略：恐慌模式和短语层次恢复</p><ul><li>恐慌模式恢复<ul><li>一旦发现错误就不断丢弃输入中的符号，知道找到同步词法单元集合中的某个元素<ul><li>同步词法单元通常是界限符，如分号和右大括号</li><li>跳过大量输入，但简单且能保证不会进入无限循环</li></ul></li></ul></li><li>短语层次的恢复<ul><li>将余下输入的某个前缀替换为另一个串，使之可以继续分析<ul><li>必须小心选择替换方法以免无限循环</li></ul></li></ul></li><li>错误产生式<ul><li>预测常见错误，在文法中加入错误产生式</li></ul></li><li>全局纠正<ul><li>通过最小的改动序列将错误输入串转换为语法正确的串<ul><li>开销大，仅具理论价值</li></ul></li></ul></li></ul><h2 id="二上下文无关文法">二、上下文无关文法</h2><h3 id="上下文无关文法的定义">上下文无关文法的定义</h3><p>上下文无关文法（Context-free grammar，CFG）</p><p>一个上下文无关文法由终结符号，非终结符号，一个开始符号和一组产生式组成。</p><ul><li><p>终结符号是组成串的基本符号</p></li><li><p>非终结符号是表示串的集合的语法变量</p></li><li><p>一个文法中，某个非终结符号被指定为开始符号</p></li><li><p>一个文法的产生式描述了将终结符号和非终结符号组合成串的方法，其组成元素：</p><ul><li>一个被称为产生式头或左部的非终结符号，这个产生式定义了这个头所代表的串集合的一部分</li><li>符号<spanclass="math inline">\(\rightarrow\)</span>。有时也使用::=来替代箭头</li><li>一个由零个或多个终结符号与非终结符号组成的产生式体或右部</li></ul></li></ul><p>语义：上下文无关文法G定义了一个语义L(G)</p><p>约定：</p><ul><li>常用开始符号S</li><li>常用表达式、项和因子的非终结符号E、T、F</li><li>一般第一个产生式的头为开始符号</li></ul><h3 id="推导">推导</h3><p>将某个产生式的左边替换成它的右边。</p><ul><li><p>每一步推导需要选择替换哪个非终结符号，以及使用哪个产生式</p></li><li><p>一次推导：<spanclass="math inline">\(\Longrightarrow\)</span></p></li><li><p>一次或多次推导：<spanclass="math inline">\(\Longrightarrow^+\)</span></p></li><li><p>零次或多次推导：<spanclass="math inline">\(\Longrightarrow^*\)</span></p></li></ul><p>如果<span class="math inline">\(S\Longrightarrow^*\alpha\)</span>，其中S为文法G的开始符号，称<spanclass="math inline">\(\alpha\)</span>为G的一个句型。</p><ul><li>文法G的一个句子是不包含非终结符号的句型</li><li>文法生成的语言是它的所有句子的集合，称为上下文无关语言</li><li>两个生成相同语言的文法是等价的</li></ul><p>最左推导：总是选择每个句型的最左非终结符号</p><p>最右推导：总是选择每个句型的最右边的非终结符号</p><p>正则表达式的表达能力严格弱于上下文无关文法。</p><p>正则表达式转上下文无关文法：</p><ol type="1"><li>转NFA或DFA</li><li>自动机每个状态转为上下文无关文法的一个非终结符号</li><li>逐步转换</li></ol><h4 id="二义性">二义性</h4><p>如果一个文法可以为某个句子生成多棵语法分析树，那么它就是二义性的。</p><p>消除二义性</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">stmt</span>: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span><br>| <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span> <span class="hljs-keyword">else</span> <span class="hljs-type">stmt</span><br>| other<br></code></pre></td></tr></table></figure><p>修改规则：每个else和最近的尚未匹配的then匹配</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">stmt</span>: matched_stmt<br>| open_stmt<br>matched_stmt: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> thrn matched_stmt <span class="hljs-keyword">else</span> matched_stmt<br>| other<br>open_stmt: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span><br> | <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then matched_stmt <span class="hljs-keyword">else</span> open_stmt<br></code></pre></td></tr></table></figure><h4 id="左递归">左递归</h4><p>如果一个文法中有一个非终结符号使得对某个串<spanclass="math inline">\(\alpha\)</span>存在一个推导<spanclass="math inline">\(A\Longrightarrow^+A\alpha\)</span>，那么这个文法就是左递归的。</p><ul><li>自顶向下语法分析不能处理左递归文法</li></ul><p>消除直接左递归：</p><ol type="1"><li>将A的全部产生式分组：<span class="math inline">\(A\rightarrowA\alpha_1|A\alpha_2|...|A\alpha_m|\beta_1|\beta_2|...|\beta_n\)</span>，其中<spanclass="math inline">\(\beta_i\)</span>都不以A开始</li><li>将A的产生式替换为<ul><li><span class="math inline">\(A\rightarrow\beta_1A^{&#39;}|\beta_2A^{&#39;}|...|\beta_nA^{&#39;}\)</span></li><li><span class="math inline">\(A^{&#39;}\rightarrow\alpha_1A^{&#39;}|\alpha_2A^{&#39;}|...|\alpha_nA^{&#39;}|\epsilon\)</span></li></ul></li></ol><p>消除间接左递归：先化为直接左递归，再使用上述方法</p><ul><li>该方法下的文法不能存在环和<spanclass="math inline">\(\epsilon\)</span>产生式</li></ul><h4 id="提取左公因子">提取左公因子</h4><p>对于每个非终结符号A，找出它的两个或多个选项之间的最长公共前缀<spanclass="math inline">\(\alpha\)</span>，若<spanclass="math inline">\(\alpha \neq\epsilon\)</span>，即存在一个非平凡的公共前缀，将所有<spanclass="math inline">\(A\rightarrow\alpha\beta_1|\alpha\beta_2|...|\alpha\beta_n|\gamma\)</span>替换为</p><ul><li><span class="math inline">\(A\rightarrow \alphaA^{&#39;}|\gamma\)</span></li><li><span class="math inline">\(A^{&#39;}\rightarrow\beta_1|\beta_2|...|\beta_n\)</span></li></ul><p>其中<span class="math inline">\(\gamma\)</span>为A所有不以<spanclass="math inline">\(\alpha\)</span>开始的产生式体。</p><ul><li>不断应用上述转换，直到每个非终结符号的任意两个产生式体没有公共前缀为止</li></ul><h3 id="自顶向下的语法分析">自顶向下的语法分析</h3><p>为输入串构造语法分析树，从语法分析树的根结点开始，按照先根次序创建这棵语法分析树的各个结点。可以被看作寻找输入串的最左推导的过程。</p><ul><li>根结点是文法的起始符号S</li><li>每个中间结点表示对某个非终结符应用某个产生式进行推导</li><li>叶结点为词法单元流，仅包括终结符号和特殊的文件结束符$（EOF）</li></ul><p>对于有些文法，可以构造出向前看k个输入符号的预测分析器，这类文法称为LL(k)文法。</p><h4 id="递归下降">递归下降</h4><p>为每一个非终结符写一个递归函数，内部按需调用其他非终结符对应的递归函数进行下降。</p><h4 id="预测分析表">预测分析表</h4><p>指明每个非终结符在面对不同的词法单元或文件结束符时，该选择哪个产生式或报错。</p><p>首行为各个终结符和$，首列为各个非终结符。</p><h5 id="first和follow集合">FIRST和FOLLOW集合</h5><p><span class="math inline">\(First(\alpha)\)</span>是可以从<spanclass="math inline">\(\alpha\)</span>推导得到的句型的<strong>首终结符号</strong>的集合。</p><p><span class="math inline">\(First(\alpha)=\{t\inT\cup\{\epsilon\}|\alpha\Longrightarrow^*t\beta\or\alpha\Longrightarrow^*\epsilon \}\)</span></p><p>如果非终结符A的所有产生式对应的FIRST集合不相交，那么只需查看当前词法单元即可确定选择的产生式。</p><ul><li>单个符号X的<span class="math inline">\(First(X)\)</span>的计算<ul><li>先判断是否是终结符，若是，则<spanclass="math inline">\(First(X)\)</span>即其自身</li><li>否则，判断X的每一条产生式，且需要判断X可否推导出空串</li></ul></li><li>符号串<span class="math inline">\(\alpha\)</span>的<spanclass="math inline">\(First(\alpha)\)</span>的计算，<spanclass="math inline">\(\alpha=X\beta\)</span><ul><li>若<span class="math inline">\(\epsilon\notin L(X)\)</span>，即<spanclass="math inline">\(First(X)\)</span></li><li>若<span class="math inline">\(\epsilon\in L(X)\)</span>，为<spanclass="math inline">\((First(X)\setminus\{\epsilon\})\cupFirst(\beta)\)</span></li><li>如果<span class="math inline">\(\epsilon\in\alpha\)</span>，将<spanclass="math inline">\(\epsilon\)</span>加入<spanclass="math inline">\(First(\alpha)\)</span></li></ul></li></ul><p><spanclass="math inline">\(Follow(A)\)</span>是可能在某些句型中<strong>紧跟在A右边的终结符</strong>的集合。</p><p>对于任意的产生式左部非终结符<span class="math inline">\(A\inN\)</span>：</p><p><span class="math inline">\(Follow(A)=\{t\in T\cup\{\$\}|\exists.S\Longrightarrow^*s=^\triangle At\gamma\}\)</span></p><p>考虑产生式<span class="math inline">\(A\rightarrow\alpha\)</span>，如果从<spanclass="math inline">\(\alpha\)</span>可以推导出空串，则只有当当前词法单元属于<spanclass="math inline">\(Follow(A)\)</span>，才可以选择该产生式。</p><ul><li>非终结符X的<span class="math inline">\(Follow(X)\)</span>的计算<ul><li>若X是开始符号，则<span class="math inline">\(\$\)</span>也在<spanclass="math inline">\(Follow(X)\)</span>中<ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cup\{\$\}\)</span></li></ul></li><li>若X是某产生式右部最后一个符号，即<spanclass="math inline">\(A\rightarrow \alpha X\)</span><ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cupFollow(A)\)</span></li></ul></li><li>若X是某产生式右部中间的一个符号，即<spanclass="math inline">\(A\rightarrow \alpha X\beta\)</span><ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cup(First(\beta)\setminus\{\epsilon\})\)</span></li><li>若<span class="math inline">\(\epsilon\inFirst(\beta)\)</span>，<span class="math inline">\(Follow(X)\leftarrowFollow(X)\cup Follow(A)\)</span></li></ul></li></ul></li></ul><p>根据First和Follow集合计算确定给定文法G的预测分析表：</p><p>对应每条产生式<spanclass="math inline">\(A\rightarrow\alpha\)</span>与终结符t，如果</p><ul><li><span class="math inline">\(t\in First(\alpha)\)</span></li><li><span class="math inline">\(\epsilon\in First(\alpha)\and t\inFollow(A)\)</span></li></ul><p>则在表格[A,t]中填入<spanclass="math inline">\(A\rightarrow\alpha\)</span></p><h4 id="ll1文法">LL(1)文法</h4><ul><li><p>从左向右读入词法单元</p></li><li><p>在推导的每一步，LL(1)总是选择最左边的非终结符进行展开</p></li><li><p>如果文法G的预测分析表是无冲突的，则G是LL(1)文法。</p><ul><li>对于当前选择的非终结符，仅根据输入中当前的词法单元即可确定需要哪条产生式</li></ul></li></ul><p>非递归的预测分析算法：使用栈保存终结符和非终结符</p><h3 id="adaptive-ll算法">Adaptive LL(*)算法</h3><p>Adaptive LL(*)算法，简称ALLStar算法。</p><h4 id="优先级上升算法">优先级上升算法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;)&#x27;</span><br>| INT<br>| ID<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>: (<br><span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-built_in">expr</span>[0] <span class="hljs-string">&#x27;)&#x27;</span><br>| INT<br>| ID<br>)<br>(&#123;5 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-built_in">expr</span>[6]<br>| &#123;4 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[5]<br>)*<br>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;!&#x27;</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| ID<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>:(ID<br>| <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span>[4]<br>)<br>(&#123;3 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;!&#x27;</span><br>| &#123;2 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>)*<br>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: &lt;assoc = right&gt; <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| INT<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>:( INT )<br>(&#123;3 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>|&#123;2 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>)*<br>;<br></code></pre></td></tr></table></figure><p>总结：</p><p>按原产生式排序优先级；</p><p>左结合运算符右操作符优先级上升，右结合运算符右操作符优先级不变。</p><h4 id="antlr4的错误报告与恢复">ANTLR4的错误报告与恢复</h4><p>共四类词法、语法错误</p><ul><li>词法错误：LexerNoViableAltException</li><li>语法错误<ul><li>NoViableAltException：非终结符的可选分支均不可行</li><li>InputMismatchException：可选分支不匹配</li><li>FailedPerdicateException</li></ul></li></ul><h3 id="自底向上的语法分析">自底向上的语法分析</h3><p>自底向上的、不断归约的、基于句柄识别自动机的、适用于LR文法的LR语法分析器。</p><h4 id="自底向上构建语法分析树">自底向上构建语法分析树</h4><ul><li>根结点是文法起始符号S</li><li>叶结点是词法单元流，仅包含终结符号与特殊文件结束符$</li><li>每个中间非终结符结点表示使用它的某条产生式进行归约</li></ul><h4 id="lr语法分析器">LR语法分析器</h4><ul><li>从左向右扫描输入</li><li>构建反向最右推导</li></ul><p>LR语法分析器的状态：</p><p>在任意时刻，语法分析树的上边缘和剩余的输入构成当前句型。</p><ul><li>LR语法分析器使用栈存储语法分析树的上边缘，它包含了语法分析器目前所知的所有信息。</li></ul><p>栈上操作：</p><ul><li>移入输入符号</li><li>按产生式归约</li></ul><h4 id="lr分析表">LR分析表</h4><p>在当前状态（编号）下，面对当前文法符号时，该采取什么动作</p><ul><li><p>第一列为状态，用数字编号</p></li><li><p>其后的一组列为ACTION列，其首行为文法符号，余行指明动作</p></li><li><p>再之后的一组列为GOTO列，其首行为归约的文法符号，余行指明转换到的状态</p></li><li><p><spanclass="math inline">\(s_n\)</span>：移入输入符号，并进入状态n</p></li><li><p><spanclass="math inline">\(r_k\)</span>：使用k号产生式进行归约</p></li><li><p><span class="math inline">\(g_n\)</span>：转换到状态n</p></li><li><p><span class="math inline">\(acc\)</span>：成功接受，结束</p></li><li><p>空白：错误</p></li></ul><p>示例（SLR(1)分析表）：</p><figure><img src="/image/编译原理/LR分析表.png" alt="LR分析表" /><figcaption aria-hidden="true">LR分析表</figcaption></figure><p>栈中存储语法分析器的状态（编号），编码了语法分析树的上边缘。</p><p>如何构造LR分析表？</p><h5 id="句柄">句柄</h5><p>在输入串的反向最右推导中，如果下一步是逆用产生式<spanclass="math inline">\(A\rightarrow \alpha\)</span>，则称<spanclass="math inline">\(\alpha\)</span>为当前句型的句柄。</p><ul><li>LR语法分析器的关键就是高效寻找每个归约步骤所使用的句柄。</li></ul><p>存在一种LR语法分析方法，保证句柄总是出现在栈顶。</p><h5 id="lr0句柄识别有穷自动机">LR(0)句柄识别有穷自动机</h5><p>LR(0)项：文法G的一个LR(0)项是G的某个产生式加上一个位于体部的点。</p><ul><li>项指明了语法分析器已经观察到了某个产生式的某个前缀</li><li>例：<span class="math inline">\(A\rightarrow XYZ\)</span>的项<ul><li><span class="math inline">\(A\rightarrow ·XYZ\)</span></li><li><span class="math inline">\(A\rightarrow X·YZ\)</span></li><li><span class="math inline">\(A\rightarrow XY·Z\)</span></li><li><span class="math inline">\(A\rightarrow XYZ·\)</span></li></ul></li><li>项集：若干项构成的集合，可以表示句柄识别自动机的一个状态</li><li>项集族：若干项集的集合，可以表示句柄识别自动机的状态集</li></ul><p>增广文法：文法G的增广文法G‘为在G中加入产生式<spanclass="math inline">\(S&#39;\rightarrow S\)</span>的文法。</p><p>状态的划分：“点”的位置</p><ul><li><p>点指明了栈顶，左边是栈中内容，右边是期望看到的文法符号。</p></li><li><p>以<span class="math inline">\(E&#39;\rightarrow·E\)</span>为初始状态，推导点右边的内容。</p></li><li><p>逐步推导接受文法符号后的内容。</p></li></ul><p>示例：</p><figure><img src="/image/编译原理/LR0句柄识别自动机.png"alt="LR0句柄识别自动机" /><figcaption aria-hidden="true">LR0句柄识别自动机</figcaption></figure><p><span class="math inline">\(J=GOTO(I,X)=CLOSURE({[A\rightarrow\alphaX·\beta]|[A\rightarrow\alpha·X\beta]\in I})\)</span></p><p>接受状态：<span class="math inline">\(F=\{I\in C|\exist[A\rightarrow\alpha·]\in I \}\)</span></p><p>GOTO函数拆分成ACTION表（针对终结符）和GOTO表（针对非终结符）。</p><p>上图转化为的表：</p><figure><img src="/image/编译原理/LR0分析表.png" alt="LR0分析表" /><figcaption aria-hidden="true">LR0分析表</figcaption></figure><p>LR(0)分析表构造规则</p><ul><li><p><span class="math inline">\(GOTO(I_i,a)=I_j\and a\inT\Longrightarrow ACTION[i,a]\leftarrow sj\)</span></p></li><li><p><span class="math inline">\(GOTO(I_i,A)=I_j\and A\inN\Longrightarrow GOTO[i,A]\leftarrow gj\)</span></p></li><li><p><span class="math inline">\([k: A\rightarrow\alpha·]\in I_i\andA\neq S&#39;\Longrightarrow\forall t\inT\cup\{\$\}.ACTION[i,t]=rk\)</span></p></li><li><p><span class="math inline">\([S&#39;\rightarrow S·]\inI_i\Longrightarrow ACTION[i,\$]\leftarrow acc\)</span></p></li></ul><p>改进第三规则即为SLR(1)分析表：</p><p><span class="math inline">\([k: A\rightarrow\alpha·]\in I_i\and A\neqS&#39;\Longrightarrow\forall t\in Follow(A).ACTION[i,t]=rk\)</span></p><p>LR(0)文法</p><p>如果文法G的LR(0)分析表是无冲突的，则G是LR(0)文法。</p><ul><li>LR(0)分析表每一行选用的归约产生式是相同的。</li></ul><p>SLR(1)文法</p><p>如果文法G的SLR(1)分析表无冲突，则G是SLR(1)文法。</p><p>两类可能的冲突：移入/归约冲突、归约/归约冲突</p><h2 id="三属性文法">三、属性文法</h2><p>属性文法：为上下文无关文法赋予语义</p><p>在语义分析过程中实现属性文法，语义动作嵌入的位置决定了何时执行该动作。</p><p>基本思想：一个动作在它左边的所有文法符号都处理过之后立即执行</p><h3 id="语法制导定义">语法制导定义</h3><p>Syntax-Directed Definition，SDD</p><p>一个上下文无关文法和属性及规则的结合。</p><ul><li>每个文法符号都可以关联多个属性</li><li>每个产生式都可以关联一组规则</li></ul><p>SDD唯一确定了语法分析树上每个非终结符节点的属性；</p><p>SDD没有规定以什么方式、什么顺序计算这些属性值。</p><h4 id="综合属性">综合属性</h4><p>结点N的综合属性只能通过N的子结点或N本身的属性进行定义。</p><h4 id="s属性定义">S属性定义：</h4><p>如果一个SDD的每个属性都是综合属性，则它是S属性定义。</p><p>依赖图用于确定一棵给定的语法分析树中各个属性实例之间的依赖关系。</p><p>S 属性定义的依赖图刻画了属性实例之间自底向上的信息流动。</p><h4 id="继承属性">继承属性</h4><p>结点N上的继承属性只能通过N的父结点、N本身和N的兄弟结点上的属性来定义。</p><p>继承属性<spanclass="math inline">\(T^{&#39;}.inh\)</span>用于在表达式中从左到右传递中间计算结果</p><table><thead><tr class="header"><th>产生式</th><th>语法规则</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(T\rightarrow FT^{&#39;}\)</span></td><td><span class="math inline">\(T^{&#39;}.inh=F.val\)</span>；<spanclass="math inline">\(T.val=T^{&#39;}.syn\)</span>；</td></tr><tr class="even"><td><span class="math inline">\(T^{&#39;}\rightarrow*FT_1^{&#39;}\)</span></td><td><span class="math inline">\(T^{&#39;}_1.inh=T^{&#39;}.inh\timesF.val\)</span>；<spanclass="math inline">\(T^{&#39;}.syn=T^{&#39;}_1.syn\)</span>；</td></tr><tr class="odd"><td><span class="math inline">\(T^{&#39;}\rightarrow\epsilon\)</span></td><td><spanclass="math inline">\(T^{&#39;}.syn=T^{&#39;}.inh\)</span>；</td></tr><tr class="even"><td><span class="math inline">\(F\rightarrow digit\)</span></td><td><span class="math inline">\(F.val=digit.lexval\)</span>；</td></tr></tbody></table><p>综合属性<spanclass="math inline">\(T^{&#39;}.syn\)</span>则用以计算最终结果。</p><h4 id="l属性定义">L属性定义</h4><p>如果一个SDD的每个属性要么是综合属性，要么是继承属性，则它是L属性定义。</p><ul><li><p>继承属性规则需满足限制：</p><p>对于<span class="math inline">\(A\rightarrowX_1X_2...X_n\)</span>及其对应规则定义的<spanclass="math inline">\(X_i.a\)</span>，这个规则只能使用</p><ul><li>和产生式头A关联的继承属性</li><li>位于<spanclass="math inline">\(X_i\)</span>左边的文法符号的相关的综合属性或继承属性</li><li>和这个<spanclass="math inline">\(X_i\)</span>的实例本身相关的继承属性或综合属性，但是在这个<spanclass="math inline">\(X_i\)</span>的全部属性组成的依赖图中不存在环</li></ul></li></ul><p>数组类型文法：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">T:</span> BC<br><span class="hljs-symbol">B:</span> INT<br><span class="hljs-symbol">C:</span> <span class="hljs-string">&#x27;[&#x27;</span> INT <span class="hljs-string">&#x27;]&#x27;</span> C<br></code></pre></td></tr></table></figure><p>有符号二进制数文法</p><table><thead><tr class="header"><th>产生式</th><th>属性规则</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(Number\rightarrow SignList\)</span></td><td><spanclass="math inline">\(List.pos=0;\)</span>$if(Sign.neg){Number.val=-List.val;}<span class="math display">\[else\{Number.val=List.val;\}$ || $Sign\rightarrow +$           |$Sign.neg=false;$                                            || $Sign\rightarrow -$           |$Sign.neg=true;$                                             || $List\rightarrow Bit$         | $Bit.pos =List.pos;\]</span>List.val=Bit.val;$</td></tr><tr class="even"><td><span class="math inline">\(List\rightarrow List_1Bit\)</span></td><td><span class="math inline">\(List_1.pos=List.pos+1;\)</span><spanclass="math inline">\(Bit.pos=List.pos;\)</span><spanclass="math inline">\(List.val=List_1.val+Bit.val;\)</span></td></tr><tr class="odd"><td><span class="math inline">\(Bit\rightarrow 0\)</span></td><td><span class="math inline">\(Bit.val=0;\)</span></td></tr><tr class="even"><td><span class="math inline">\(Bit\rightarrow 1\)</span></td><td><span class="math inline">\(Bit.val=1;\)</span></td></tr></tbody></table><h4 id="后缀表示">后缀表示</h4><p>递归定义：</p><ul><li>如果E是一个常量或变量，则E的后缀表示是E本身</li><li>如果E是形如<span class="math inline">\(E_1 opE_2\)</span>的表达式，则E的后缀表示是<spanclass="math inline">\(E_1&#39;E_2&#39;op\)</span>，这里的<spanclass="math inline">\(E_1&#39;\)</span>和<spanclass="math inline">\(E_2&#39;\)</span>是<spanclass="math inline">\(E_1\)</span>和<spanclass="math inline">\(E_2\)</span>的后缀表达式</li><li>如果E是形如<spanclass="math inline">\((E_1)\)</span>的表达式，则E的后缀表示是<spanclass="math inline">\(E_1\)</span>的后缀表示</li></ul><h3 id="语法制导的翻译方案">语法制导的翻译方案</h3><p>Syntax-Directed translation，SDT</p><p>在其产生式体中嵌入语义动作的上下文无关文法。</p><ul><li>用大括号包括规则，写在产生式之后。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-词法分析</title>
    <link href="/2023/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2023/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>子不语</p><span id="more"></span><h1 id="词法分析">词法分析</h1><h2 id="一词法分析器的作用">一、词法分析器的作用</h2><h3 id="词法分析器的主要任务">词法分析器的主要任务</h3><p>读入源程序的输入字符，将它们组成词素，生成并输出一个词法单元序列，每个词法单元对应于一个词素。</p><p>词法分析器负责读取源程序，因此还会完成一些识别词素之外的任务，例如：</p><ul><li>过滤源程序中的注释与空白</li><li>将编译器生成的错误信息与源程序位置关联</li><li>宏预处理</li></ul><p>此后，进入词法分析阶段。</p><p>词法分析与语法分析分离的原因：</p><ol type="1"><li>简化编译器设计：简化词法分析和语法分析中的一些任务</li><li>提高编译器效率：使用专用于词法分析的一些技术</li><li>增强编译器可移植性：输入设备的特殊性可限制于词法分析中</li></ol><h3 id="术语">术语</h3><ul><li>词素：源程序中的一个字符序列，和某个词法单元的模式匹配，被词法分析器识别为该词法单元的一个实例</li><li>词法单元：一个词法单元名和一个可选的属性值</li><li>模式：一个词法单元的词素可能具有的形式</li></ul><p>词法单元的一般类别：</p><ol type="1"><li>关键字，其模式为其本身</li><li>运算符</li><li>表示符</li><li>常量词法单元</li><li>标点符号</li></ol><h3 id="词法错误">词法错误</h3><p>当出现所有词法单元的模式都无法和剩余输入的某个前缀相匹配的情况，词法分析器就不能继续处理输入。</p><p>“恐慌模式”恢复：从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的语法单元为止。</p><p>其他恢复动作：</p><ul><li>从剩余的输入中删除一个字符</li><li>向剩余的输入中插入一个遗漏的字符</li><li>用一个字符来替换另一个字符</li><li>交换两个相邻的字符</li></ul><h2 id="二输入缓冲">二、输入缓冲</h2><p>在编译一个大型源程序时需要处理大量的字符，利用两个交替读入的缓冲区可以减少处理字符的开销。</p><p>每个缓冲区都有N个字符，通常N为一个磁盘块的大小。可以使用系统读取命令一次将N个字符读入到缓冲区中，若读入的剩余字符不足N个，则会有一个特殊字符(如eof)标记源文件的结束，该字符不同于任何可能出现在源程序中的字符。</p><p>程序为输入维护了两个指针：</p><ul><li>lexemeBegin指针：指向当前词素的开始处</li><li>forward指针：一直向前扫描，直到发现某个模式被匹配为止</li></ul><p>确定一个词素后，词法分析器将这个词素记录下来，然后用lexemeBegin指向词素后第一个字符。</p><h3 id="哨兵标记">哨兵标记</h3><p>每次前移forward时，都须检查是否到了缓冲区的末尾，若是，则须加载另一个缓冲区。</p><p>我们扩展每一个缓冲区，在它们的末尾加上一个哨兵字符来完成对缓冲区末端的测试，这个哨兵字符的一个选择就是eof。</p><h2 id="三词法单元的规约">三、词法单元的规约</h2><h3 id="串和语言">串和语言</h3><ul><li><p>字母表：一个有限的符号集合。</p></li><li><p>串：某个字母表中符号的一个有穷序列。</p><ul><li>串s的长度，通常记作|s|。空串是长度为0的串，用𝜖表示。</li></ul></li><li><p>语言：某个给定字母表上一个任意的可数的串集合。</p></li></ul><p>串的一些术语：</p><ol type="1"><li>串的前缀是从其尾部删除0个或多个符号后得到的串，包括其本身和𝜖</li><li>串的后缀是从其首部删除0个或多个符号后得到的串，包括其本身和𝜖</li><li>串的子串是删除某个前缀和某个后缀后得到的串</li><li>串的真前缀、真后缀、真子串不等于其本身</li><li>串的子序列是从其中删除0个或多个符号后得到的串</li></ol><h4 id="串的连接">串的连接</h4><p>如果x和y是串，那么x和y的连接(记作xy)是把y附加到x后形成的串。</p><p>可以把连接看成两个串的乘积，定义串的指数运算：</p><p>串的0次方为𝜖，n次方为n个该串的连接。</p><h4 id="语言上的运算">语言上的运算</h4><p>并、连接、闭包</p><ul><li><p>L和M的并：<span class="math inline">\(L\cup M = \{s|s\in L\ors\in M\}\)</span></p></li><li><p>L和M的连接：<span class="math inline">\(LM= \{st|s\in L\and t\inM\}\)</span></p></li><li><p>L的Kleene闭包：将L连接0次或多次后得到的串集，记为<spanclass="math inline">\(L^*\)</span></p></li><li><p>L的正闭包：将L连接1次或多次后得到的串集，记为<spanclass="math inline">\(L^+\)</span></p></li></ul><h3 id="正则表达式的递归定义">正则表达式的递归定义</h3><p>归纳基础：</p><ol type="1"><li>𝜖是一个正则表达式，<span class="math inline">\(L(\epsilon ) =\{\epsilon\}\)</span>，即该语言只包含空串</li><li>如果a是字母表上的一个符号，那么a是一个正则表达式，并且<spanclass="math inline">\(L(a) =\{a\}\)</span>，即该语言只包含一个符号串a</li></ol><p>归纳步骤：由小的正则表达式构造大的正则表达式的步骤有四个部分。假定r和s都是正则表达式，分别表示语言L(r)和L(s)，那么：</p><ol type="1"><li><spanclass="math inline">\((r)\)</span>是一个正则表达式，表示语言<spanclass="math inline">\(L(r)\)</span></li><li><spanclass="math inline">\((r)(s)\)</span>是一个正则表达式，表示语言<spanclass="math inline">\(L(r)L(s)\)</span></li><li><spanclass="math inline">\((r)^*\)</span>是一个正则表达式，表示语言<spanclass="math inline">\((L(r))^*\)</span></li><li><spanclass="math inline">\((r)|(s)\)</span>是一个正则表达式，表示语言<spanclass="math inline">\(L(r)\cup L(s)\)</span></li></ol><p>采取如下约定来舍去不需要的括号：</p><ol type="1"><li>一元运算符*具有最高的优先级，并且左结合</li><li>连接具有次高的优先级，并且左结合</li><li>|的优先级最低，并且左结合</li></ol><p>正则集合：可以用一个正则表达式定义的语言。</p><p>称两个表示相同语言的正则表达式等价。</p><p>以下为一些正则表达式的代数定律</p><ol type="1"><li><span class="math inline">\(r|s=s|r\)</span>，即|运算具有交换性</li><li><spanclass="math inline">\(r|(s|t)=(r|s)|t\)</span>，|运算具有结合性</li><li><span class="math inline">\(r(st)=(rs)t\)</span>，连接可结合</li><li><span class="math inline">\(r(s|t)=rs|rt\)</span>，<spanclass="math inline">\((s|t)r=st|sr\)</span>连接对|可分配</li><li><span class="math inline">\(\epsilon\)</span>是连接的单位元</li><li>闭包中一定包含<span class="math inline">\(\epsilon\)</span></li><li><span class="math inline">\(r^*=r^{**}\)</span>，*具有幂等性</li></ol><p>正则定义：为某些正则表达式命名，使用这些名称来表示正则表达式。</p><p>正则表达式的扩展：</p><ol type="1"><li>单目后缀运算符+用以表示一个正则表达式及其语言的正闭包</li><li>单目后缀运算符?表示“0或1个出现”，?具有和+与*相同的优先级、结合性</li><li>字符类：用<spanclass="math inline">\([a_1a_2...a_n]\)</span>缩写<spanclass="math inline">\(a_1|a_2|...|a_n\)</span>，如果<spanclass="math inline">\([a_1a_2...a_n]\)</span>形成一个逻辑上连续的序列，可以表示成<spanclass="math inline">\([a_1-a_n]\)</span></li></ol><p>至此，我们可以使用正则表达式来表示一个模式。</p><h3 id="java正则表达式">Java正则表达式</h3><h4 id="单个字符">单个字符</h4><table><thead><tr class="header"><th>正则表达式</th><th>规则</th></tr></thead><tbody><tr class="odd"><td>A</td><td>指定字符</td></tr><tr class="even"><td>48c</td><td>指定Unicode字符</td></tr><tr class="odd"><td>.</td><td>任意字符</td></tr><tr class="even"><td> 数字0～9</td><td></td></tr><tr class="odd"><td></td><td>大小写字母、数字和下划线</td></tr><tr class="even"><td></td><td>空格、Tab键</td></tr><tr class="odd"><td></td><td>非数字</td></tr><tr class="even"><td></td><td>非</td></tr><tr class="odd"><td></td><td>非</td></tr></tbody></table><h4 id="多个字符">多个字符</h4><table><thead><tr class="header"><th>正则表达式</th><th>规则</th></tr></thead><tbody><tr class="odd"><td>A*</td><td>任意个数字符</td></tr><tr class="even"><td>A+</td><td>至少一个字符</td></tr><tr class="odd"><td>A？</td><td>0或1个字符</td></tr><tr class="even"><td>A{n}</td><td>指定个数字符</td></tr><tr class="odd"><td>A{2,3}</td><td>指定范围个数字符</td></tr><tr class="even"><td>A{n,}</td><td>至少n个字符</td></tr><tr class="odd"><td>A{,n}</td><td>最多n个字符</td></tr></tbody></table><h4 id="复杂匹配规则">复杂匹配规则</h4><table><thead><tr class="header"><th>正则表达式</th><th>规则</th><th>可以匹配</th></tr></thead><tbody><tr class="odd"><td>^</td><td>开头</td><td>字符串开头</td></tr><tr class="even"><td>$</td><td>结尾</td><td>字符串结束</td></tr><tr class="odd"><td>[ABC]</td><td>[...]内任意字符</td><td><code>A</code>,<code>B</code>,<code>C</code></td></tr><tr class="even"><td>[A-F0-9xy]</td><td>指定范围的字符</td><td><code>A</code>,...,<code>F</code>,<code>0</code>,...,<code>9</code>,<code>x</code>,<code>y</code></td></tr><tr class="odd"><td>[^A-F]</td><td>指定范围外的字符</td><td>非<code>A</code>~<code>F</code></td></tr><tr class="even"><td>AB|CD|EF</td><td>AB或者CD或者EF</td><td><code>AB</code>,<code>CD</code>,<code>EF</code></td></tr></tbody></table><h2 id="四词法单元的识别">四、词法单元的识别</h2><p>检查输入字符串，并在其前缀中找出一个和某个模式匹配的词素。</p><h3 id="状态转换图">状态转换图</h3><p>将模式转换成具有特定风格的流图，称为状态转换图。</p><ol type="1"><li>其中包含一组结点或圆圈，即状态，每个状态代表一个可能在词法分析器扫描输入串的过程中匹配到的情况。</li><li>状态图中的边从图的一个状态指向另一个状态，每条边的标号包含了一个或多个符号。</li></ol><p>规则：</p><ol type="1"><li>接受状态或最终状态指已经找到一个词素的状态，用双层的圈表示。</li><li>若需要在接受状态回退数个位置，就在该接受状态附近加上相应数目的*。</li><li>初始状态由一条没有出发结点的标号为start的边指定，是没有读入任何输入前状态转换图的位置。</li></ol><h3 id="保留字和标识符的处理">保留字和标识符的处理</h3><ol type="1"><li>初始化时即将各保留字填入符号表中</li><li>为每个关键字建立单独的状态转换图</li></ol><h2 id="五有穷状态机">五、有穷状态机</h2><ul><li>不确定的有穷状态机 (Nondeterministic Finite Automata，NFA)<ul><li>对边上的标号没有限制，一个符号标记离开同一状态的多条边，并且空串也可作为标号</li></ul></li><li>确定的有穷状态机 (Deterministic Finite Automata，DFA)<ul><li>对于每个状态及输入自动机的每个符号，有且只有一条离开该状态，以该符号为标号边</li></ul></li></ul><h3 id="不确定有穷状态机">不确定有穷状态机</h3><p>组成部分：</p><ol type="1"><li>一个有穷的状态集合S</li><li>一个输入符号集合<spanclass="math inline">\(\Sigma\)</span>，即输入字母表，假设空串的<spanclass="math inline">\(\epsilon\)</span>不是字母表中的元素</li><li>一个转换函数，为每个状态和<span class="math inline">\(\Sigma \cup\{\epsilon\}\)</span>中每个符号给出相应后继状态的集合</li><li>S中的一个状态<spanclass="math inline">\(s_0\)</span>被指定为开始状态</li><li>S的一个子集F被指定为接受状态的集合</li></ol><h4 id="转换图">转换图</h4><p>不管是不确定有穷状态机还是确定有穷状态机，都可以表示为一张转换图，图中的结点是状态，带有标号的边表示自动机的转换函数。从状态s到状态t存在一条标号为a的边当且仅当状态t是状态s在输入a之后的后继状态之一。</p><p>和状态转换图的区别：</p><ul><li>同一个符号可以标记从同一状态出发到达多个目标状态的多条边</li><li>一条边的标号不仅可以是输入字母表中的符号，也可以是空符号串<spanclass="math inline">\(\epsilon\)</span></li></ul><h4 id="转换表">转换表</h4><p>从次行起的各行对应各状态，首行的各列对应于输入符号和$$。</p><ul><li>对应于一个给定状态和给定输入的条目是将NFA的转换函数应用于这些参数后得到的值</li><li>如果转换函数没有给出对应于某个状态-输入对的信息，就将<spanclass="math inline">\(\varnothing\)</span>放入对应表项中</li></ul><p>转换表易于确定给定状态与输入符号对应的转换，但当输入字母表较大且多数状态在多数输入字符上无转换时需占用大量空间。</p><h4 id="自动机接受输入字符串">自动机接受输入字符串</h4><p>一个不确定有穷状态机接受输入字符串，当且仅当对应的转换图中存在一条从开始状态到某个接受状态的路径上的标号(忽略空串)组成该字符串。</p><p>由一个不确定有穷状态机定义的语言为从开始状态到接受状态的所有路径上标号串的集合。可以用<spanclass="math inline">\(L(A)\)</span>表示自动机A接受的语言。</p><h3 id="确定有穷状态机">确定有穷状态机</h3><p>组成部分：</p><ol type="1"><li>一个有穷的状态集合S</li><li>一个输入符号集合<spanclass="math inline">\(\Sigma\)</span>，即输入字母表，假设空串的<spanclass="math inline">\(\epsilon\)</span>不是字母表中的元素</li><li>一个转换函数，为每个状态和<spanclass="math inline">\(\Sigma\)</span>中每个符号给出相应后继状态的集合</li><li>S中的一个状态<spanclass="math inline">\(s_0\)</span>被指定为开始状态</li><li>S的一个子集F被指定为接受状态的集合</li></ol><p>不确定有穷状态机的特例</p><ul><li>没有输入<span class="math inline">\(\epsilon\)</span>的转换动作</li><li>对每个状态s和每个输入符号a，有且仅有一条为标号a的边离开s</li></ul><p>不确定有穷状态机抽象地表示了用来识别某个语言中的串的算法，而相应的确定有穷状态机则是一个简单具体的识别串的算法。</p><ul><li><p>在构造词法分析器时，真正实现或模拟的是确定有穷状态机。</p></li><li><p>每个正则表达式和每个确定有穷状态机都可以被转变成为一个接受相同语言的确定有穷状态机。</p></li></ul><h2 id="六从正则表达式到自动机">六、从正则表达式到自动机</h2><p>正则表达式——&gt;不确定有穷状态机——&gt;确定有穷状态机——&gt;词法分析器</p><p>第一步：Thompson构造法</p><p>第二步：子集构造法</p><h3 id="thompson构造法">Thompson构造法</h3><p>基本思想：按结构归纳</p><p>记r的不确定有穷状态机为N(r)。</p><p>根据正则表达式的递归定义进行构造：</p><ul><li>𝜖是一个正则表达式<ul><li>初始状态接受<spanclass="math inline">\(\epsilon\)</span>到达结束状态</li></ul></li><li>字母表上的一个符号a是一个正则表达式<ul><li>初始状态接受a到达结束状态</li></ul></li><li><span class="math inline">\((r)\)</span>是一个正则表达式<ul><li>等同于r的不确定有穷状态机</li></ul></li><li><span class="math inline">\((r)(s)\)</span>是一个正则表达式<ul><li>将r的结束状态和s的初始状态合并</li></ul></li><li><span class="math inline">\((r)^*\)</span>是一个正则表达式<ul><li>r的结束状态接受<spanclass="math inline">\(\epsilon\)</span>到达开始状态或系统结束状态</li><li>系统初始状态接受<spanclass="math inline">\(\epsilon\)</span>到r的初始状态或系统结束状态</li></ul></li><li><span class="math inline">\((r)|(s)\)</span>是一个正则表达式<ul><li>系统初始状态接受<spanclass="math inline">\(\epsilon\)</span>到达r和s的初始状态，r和s的结束状态接受<spanclass="math inline">\(\epsilon\)</span>到达系统结束状态</li></ul></li></ul><p>复杂度：<span class="math inline">\(O(n)\)</span></p><h4 id="nr的性质">N(r)的性质</h4><ul><li>开始状态和接受状态唯一</li><li>开始状态没有入边，接受状态没有出边</li><li>N(r)的状态数<span class="math inline">\(|S|\leq 2\times|r|\)</span>，其中|r|为r中运算符和运算分量的总和</li><li>每个状态最多有两个<spanclass="math inline">\(\epsilon\)</span>入边与两个<spanclass="math inline">\(\epsilon\)</span>出边（<spanclass="math inline">\(r|s\)</span>的情况下）</li><li>$a$，每个状态最多有一个a入边和一个a出边</li></ul><h3 id="子集构造算法">子集构造算法</h3><p>r的确定有穷状态机记为D(r)。</p><p>让构造得到的DFA每个状态对应于NFA的一个状态集合。</p><ol type="1"><li>使用NFA开始状态的<spanclass="math inline">\(\epsilon\)</span>闭包确定DFA的开始状态</li><li>根据NFA开始状态的<spanclass="math inline">\(\epsilon\)</span>闭包的转换确定DFA开始状态的转换</li><li>逐步进行DFA的模拟</li></ol><p>复杂度：<spanclass="math inline">\(O(2^n)\)</span>，极限情况下有<spanclass="math inline">\(\Omega (2^n)\)</span></p><p>闭包与不动点</p><p>集合T的函数f闭包为对T进行任意次或0次f的结果的集合。</p><p>若存在f(x)=x，则x称为f的不动点。</p><h3 id="dfa最小化算法">DFA最小化算法</h3><p>基本思想：等价的状态可以合并</p><p>状态等价的定义：</p><p>状态s和t等价，即两者接受相同的字符时，会到达相同的状态。记为s～t。</p><ul><li>但是无法判断初始等价的状态，无法进行递归合并。</li><li>于是使用不等价进行划分。</li></ul><p><span class="math inline">\(s不等价于t\Longleftrightarrow \existsa\in \Sigma. (s\rightarrow^a s&#39;) \and (t \rightarrow^at&#39;)\and(s&#39;不等价于t&#39;)\)</span></p><p>步骤：</p><ol type="1"><li>接受状态和非接受状态必然不等价，以此为初始条件进行等价状态的递归划分。</li><li>合并等价的状态。</li></ol><p>使用该算法前，需要确保该自动机确实是DFA，检查是否需要补充死状态。</p><h3 id="从dfa到词法分析器">从DFA到词法分析器</h3><ul><li><p>最前优先匹配：匹配匹配到的最优先的接受状态</p></li><li><p>最长优先匹配：匹配最长的字符串</p></li></ul><p>模拟DFA步骤</p><ol type="1"><li>模拟运行DFA，直到无法继续为止（输入结束或状态无转移）</li><li>若当前状态为接受状态，则识别成功</li><li>否则回溯至最近一次经过的接受状态，识别成功</li><li>若回溯到初始状态，则报错，删除当前字符，运行第1步</li></ol><h3 id="从dfa到正则表达式">从DFA到正则表达式</h3><p>暂略</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第六章_并发程序设计</title>
    <link href="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第六章-并发程序设计">第六章 并发程序设计</h1><h2 id="并发进程">6.1 并发进程</h2><h3 id="顺序程序设计">6.1.1 顺序程序设计</h3><p>进程在处理器上的顺序执行是严格按序的，一个操作结束后，才能开始后续操作。</p><p>顺序程序设计：把一个程序设计成顺序执行的程序模块。</p><ul><li>顺序不仅在一个程序模块内部，也在多个程序模块之间。</li></ul><p>顺序程序设计的特点：</p><ul><li>程序执行的顺序性</li><li>程序环境的封闭性</li><li>执行结果的确定性</li><li>计算过程的可再现性</li></ul><h3 id="进程的并发性">6.1.2 进程的并发性</h3><p>进程的并发性（Concurrency）是指一组进程的执行在时间上是重叠的。</p><ul><li>宏观上，并发性反映一个时间段中几个进程都在同一处理器上，处于运行还未运行结束状态</li><li>微观上，任一时刻仅有一个进程在处理器上运行</li></ul><h4 id="并发程序设计">并发程序设计</h4><p>使一个程序分成若干个可同时执行的程序模块的方法称为并发程序设计（concurrentprogramming），每个程序模块和它执行时所处理的数据就组成一个进程。</p><p>并发进程的分类：无关的、交互的</p><ul><li>无关的并发进程：一个进程的执行与其他并发进程的进展无关<ul><li>并发进程的无关性是进程的执行与时间无关的一个充分条件，又称为Bernstein条件</li></ul></li><li>交互的并发进程：一个进程的执行可能影响其他并发进程的结果</li></ul><h4 id="bernstein条件">Bernstein条件</h4><ul><li><p>程序<spanclass="math inline">\(p_i\)</span>在执行期间引用的变量集，记为<spanclass="math inline">\(R(p_i)=\{a_{i1},a_{i2},...,a_{in}\}\)</span>，</p></li><li><p>程序<spanclass="math inline">\(p_i\)</span>在执行期间改变的变量集，记为<spanclass="math inline">\(W(p_i)=\{b_{i1},b_{i2},...,b_{im}\}\)</span></p></li><li><p>若两个进程的程序<span class="math inline">\(p_1\)</span>和<spanclass="math inline">\(p_2\)</span>能满足Beinstein条件，即满足</p><p><span class="math inline">\((R(p_1)\cap W(p_2))\cup (R(p_2)\capW(p_1))\cup (W(p_1)\cap W(p_2))=\varnothing\)</span>，</p><p>则这两个并发进程的执行与时间无关</p></li></ul><p>与时间有关的错误：对于一组交互的并发进程，执行的相对速度无法相互控制，各种与时间有关的错误就有可能出现。</p><ul><li>与时间有关错误的表现形式：结果不唯一、永远等待</li></ul><h3 id="进程的交互竞争和协作">6.1.3 进程的交互：竞争和协作</h3><p>进程之间存在两种基本关系：竞争关系和协作关系</p><ul><li>竞争关系：一个进程的执行可能影响到同其竞争资源的其他进程，如果两个进程要访问同一资源，那么一个进程通过操作系统分配得到该资源，另一个将不得不等待</li><li>协作关系：某些进程为了完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的信号之前应阻塞自己，直到其他合作进程发来协调信号后方被唤醒并继续执行。</li></ul><h4 id="资源竞争的两个控制问题">资源竞争的两个控制问题</h4><ul><li>死锁：一组进程如果都获得了部分的资源，还想要得到其他进程所占有的资源，最终所有的进程都将陷入死锁</li><li>饥饿：一个进程由于其他进程总是优先于它而被无限期拖延</li><li>操作系统需要保证诸进程能互斥地访问临界资源，既要解决饥饿问题，又要解决死锁问题</li></ul><h4 id="进程的互斥与同步">进程的互斥与同步</h4><p>进程的互斥（mutual exclusion）是解决进程间竞争关系的手段。</p><ul><li>若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源</li></ul><p>进程的同步（Synchronization）是解决进程间协作关系的手段。</p><ul><li>两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的信号，当一个进程没有得到来自于另一个进程的信号则需等待。</li></ul><p>进程的互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，是对进程使用资源次序上的一种协调。</p><h2 id="临界区管理">6.2 临界区管理</h2><h3 id="互斥与临界区">6.2.1 互斥与临界区</h3><ul><li><p>并发进程中与共享变量有关的程序段称为临界区（criticalsection）</p><p>共享变量代表的资源称为临界资源</p></li><li><p>与同一变量有关的临界区分散在各进程的程序段中，而各进程的执行速度不可预见</p></li><li><p>如果保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问互斥，就不会造成与时间有关的错误。</p></li></ul><h4id="临界区调度原则dijkstra1965">临界区调度原则（Dijkstra，1965）</h4><ul><li>一次至多一个进程能够进入临界区内执行</li><li>如果已有进程在临界区，其他试图进入的进程应等待</li><li>进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入</li></ul><h3 id="临界区管理-1">6.2.2 临界区管理</h3><p>临界区管理的简单方法（忙式等待/反复测试）：</p><ul><li>Peterson算法</li><li>关中断</li><li>对换指令</li><li>测试并建立指令</li></ul><p>存在的问题：</p><ul><li>对不能进入临界区的进程，采用忙式等待测试法，浪费CPU时间</li><li>将测试能否加入临界区的责任推给各个竞争的进程会削弱系统的可靠性，加重编程负担</li></ul><p>通用的解决方案：信号量与PV操作</p><h4 id="peterson算法">Peterson算法</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">bool</span> inside[<span class="hljs-number">2</span>];<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">enum</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125; turn;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">P0</span><span class="hljs-params">()</span></span>&#123;<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>turn = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(inside[<span class="hljs-number">1</span>]&amp;&amp;turn==<span class="hljs-number">1</span>);<br>&#123;临界区&#125;;<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P1</span><span class="hljs-params">()</span></span>&#123;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(inside[<span class="hljs-number">0</span>]&amp;&amp;turn==<span class="hljs-number">0</span>)<br>&#123;临界区&#125;;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 1:1交替</span><br><span class="hljs-keyword">enum</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125; turn;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">P0</span><span class="hljs-params">()</span></span>&#123;<br>turn = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(turn==<span class="hljs-number">1</span>);<br>&#123;临界区&#125;;<br>turn = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P1</span><span class="hljs-params">()</span></span>&#123;<br>turn = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(turn==<span class="hljs-number">0</span>);<br>&#123;临界区&#125;;<br>turn = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关中断">关中断</h4><ul><li>实现互斥的最简单方法</li></ul><h4 id="测试并建立指令">测试并建立指令</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//TS指令实现进程互斥</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TS</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(x)&#123;<br>    x = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> s = <span class="hljs-literal">true</span>;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">Pi</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">TS</span>(s)); <span class="hljs-comment">//上锁</span><br>  &#123;临界区&#125;;<br>  s = <span class="hljs-literal">true</span>;      <span class="hljs-comment">//开锁</span><br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h4 id="对换指令">对换指令</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//对换指令实现进程互斥</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SWAP</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> &amp;a, <span class="hljs-built_in">bool</span> &amp;b</span>)</span>&#123;<br><span class="hljs-built_in">bool</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-built_in">bool</span> <span class="hljs-keyword">lock</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">Process <span class="hljs-title">Pi</span>()</span>&#123;<br><span class="hljs-built_in">bool</span> key = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">do</span>&#123;<br>SWAP(key, <span class="hljs-keyword">lock</span>);<br>&#125;<span class="hljs-keyword">while</span>(key);<span class="hljs-comment">//上锁</span><br>&#123;临界区&#125;;<br>SWAP&#123;key, <span class="hljs-keyword">lock</span>&#125;;<span class="hljs-comment">//开锁</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号量与pv操作">6.3 信号量与PV操作</h2><h3id="信号量与pv操作的数据结构与原语操作">信号量与PV操作的数据结构与原语操作</h3><p>设s为一个记录型数据结构，一个分量为整型量value，另一个为信号量队列queue，P和V操作原语的定义：</p><ul><li>P(s)：将信号量s减去1，若结果小于0，则调用P(s)的进程被设置成等待信号量s的状态</li><li>V(s)：将信号量s加1，若结果不大于0，则释放一个等待信号量s的进程，其转为就绪态</li></ul><p>对于信号量，只允许使用P和V原语操作访问，不能直接对信号量的整型值和队列作操作</p><p>原语：CPU处于内核态，在关中断环境下执行的一段指令序列</p><ul><li>原子性：不被中断，确保安全且完整执行这段指令序列</li></ul><h4 id="几个经典问题">几个经典问题</h4><h5 id="哲学家就餐问题互斥">哲学家就餐问题（互斥）</h5><p>有五个哲学家围坐在一圆桌旁，桌中央有一盘通心面，每人面前有一只空盘子，每两人之间放一把叉子。每个哲学家思考、饥饿、然后吃通心面。为了吃面，每个哲学家必须获得两把叉子，且每人只能直接从自己左边或右边去取叉子。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">semaphore fork<span class="hljs-literal">[<span class="hljs-number">5</span>]</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>fork<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=<span class="hljs-number">1</span>;<br>semaphore room=<span class="hljs-number">4</span>; <span class="hljs-comment">//增加一个侍者，设想有两个房间1号房间是会议室，2号房间是餐厅</span><br>cobegin<br>process philosopher<span class="hljs-constructor">_i()</span>&#123; <span class="hljs-comment">//i=0,1,2,3,4</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>think<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">room</span>)</span>; <span class="hljs-comment">//控制最多允许4位哲学家进入2号房间餐厅取叉子</span><br><span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>; <span class="hljs-comment">//偶数哲学家先右手</span><br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span> % <span class="hljs-number">5</span> ]); <span class="hljs-comment">//后左手</span><br>eat<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>;<br>V (fork<span class="hljs-literal">[(<span class="hljs-identifier">i</span>+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span> % <span class="hljs-number">5</span> ]); <span class="hljs-comment">//奇数哲学家，先左手</span><br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>; <span class="hljs-comment">//后右手</span><br>eat<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span>%<span class="hljs-number">5</span>]);<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>;<br>&#125;<br><span class="hljs-constructor">V(<span class="hljs-params">room</span>)</span>;<br>&#125;<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h5 id="生产者与消费者问题同步">生产者与消费者问题（同步）</h5><p>有n个生产者和m个消费者，连接在一个有k个单位缓冲 区的有界缓冲上。</p><p>其中，生产者进程<spanclass="math inline">\(Producer_i\)</span>和消费者进程<spanclass="math inline">\(Consumer_j\)</span>都是并发进程，只要缓冲区未满，生产者<spanclass="math inline">\(Producer_i\)</span>生产的产品就可投入缓冲区；只要缓冲区不空，消费者进程<spanclass="math inline">\(Consumer_j\)</span>就可从缓冲区取走并消耗产品。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">产品 Buffer<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>semaphore put = k, get = <span class="hljs-number">0</span>;<span class="hljs-comment">//可以put或get的缓冲区数</span><br><span class="hljs-built_in">int</span> putPos = getPos = <span class="hljs-number">0</span>;<span class="hljs-comment">//put或get的位置</span><br>semaphore p = g = <span class="hljs-number">1</span>;<span class="hljs-comment">//互斥使用put或get的位置</span><br><br>process <span class="hljs-constructor">Producer_i()</span>&#123;<br>&#123;生产产品&#125;;<br><span class="hljs-constructor">P(<span class="hljs-params">put</span>)</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">p</span>)</span>;<br>Buffer<span class="hljs-literal">[<span class="hljs-identifier">putPos</span>]</span> = 产品;<br>putPos = (putPos + <span class="hljs-number">1</span>) % k;<br><span class="hljs-constructor">V(<span class="hljs-params">p</span>)</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">get</span>)</span>;<br>&#125;<br><br>process <span class="hljs-constructor">Consumer_i()</span>&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">get</span>)</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">g</span>)</span>;<br>产品 = Buffer<span class="hljs-literal">[<span class="hljs-identifier">getPos</span>]</span>;<br>getPos = (getPos + <span class="hljs-number">1</span>) % k;<br><span class="hljs-constructor">V(<span class="hljs-params">g</span>)</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">put</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管程">6.4 管程</h2><h3 id="管程和条件变量">6.4.1 管程和条件变量</h3><p>管程的引入：</p><ul><li>把分散在各进程中的临界区集中管理</li><li>防止进程的违法同步操作</li><li>便于用高级语言来编写程序</li></ul><h4 id="管程的定义">管程的定义</h4><p>由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。</p><p>管程的属性：共享性、安全性、互斥性</p><h4 id="管程的形式">管程的形式</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">type 管程名<span class="hljs-operator">=</span>monitor &#123;<br>局部变量说明<span class="hljs-comment">;</span><br>  条件变量说明<span class="hljs-comment">;</span><br>  初始化语句<span class="hljs-comment">;</span><br>define 管程内定义的，管程外可调用的过程或函数名列表<span class="hljs-comment">;</span><br>use 管程外定义的，管程内将调用的过程或函数名列表<span class="hljs-comment">;</span><br>过程名/函数名(形式参数表) &#123;<br>&lt;过程/函数体&gt;<span class="hljs-comment">;</span><br>&#125;<br>...<br>过程名/函数名(形式参数表) &#123;<br>&lt;过程/函数体&gt;<span class="hljs-comment">;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管程的条件变量">管程的条件变量</h4><p>只有在管程中才能被访问，它对管程内所有过程是全局的，只能通过两个原语操作来控制</p><ul><li><p>wait()：阻塞调用进程并释放管程，直到另一个进程在该条件变量上执行signal()</p></li><li><p>signal()：释放由于对条件变量执行wait()而被阻塞的其他进程，若无，信号不被保存</p></li><li><p>使用signal释放等待进程时，可能出现两个进程同时停留在管程内</p><ul><li><p>执行signal的进程等待，直到被释放进程退出管程或等待另一个条件变量</p></li><li><p>被释放进程等待，直到执行signal的进程退出管程或等待另一个条件</p></li><li><p>Hoare采用前一种方法。</p></li></ul></li></ul><h3 id="管程的实现">6.4.2 管程的实现</h3><h4 id="hoare管程">Hoare管程</h4><p>Hoare使用P和V操作原语来实现对管程中过程的互斥调用，以及实现对共享资源互斥使用的管理。</p><ul><li>wait和signal操作可被设计成可以中断的进程</li></ul><h4 id="hoare管程数据结构">Hoare管程数据结构</h4><ol type="1"><li>mutex</li></ol><ul><li>对于每个管程，使用用于管程中过程互斥调用的信号量mutex（初值为1）</li><li>进程调用管程中的任何过程时，应执行P(mutex)，进程退出管程时，需要判断是否有进程在next信号量等待，如果有（即next_count&gt;0），则通过V(next)唤醒一个发出signal的进程，否则应执行V(mutex)开放管程，以便让其他调用者进入</li><li>为了使进程在等待资源期间，其他进程能进入管程，在wait操作中也必须执行V(mutex)</li></ul><ol start="2" type="1"><li>next和next-count</li></ol><ul><li><p>对每个管程，引入信号量next（初值为0），发出signal操作的进程应该用P(next)阻塞自己，直到被释放进程退出管程或产生其他等待条件</p></li><li><p>next-count（初值为0），记录next上等待的进程个数</p></li></ul><ol start="3" type="1"><li>x-sem和x-count</li></ol><ul><li>x-sem（初值为0），申请资源无法满足时，执行P(x-sem)阻塞。由于释放资源时，需知道是否有其他进程在等待资源，用计数器x-count（初值为0）记录等待资源的进程数</li><li>执行signal操作时，应让等待资源的诸进程中的某个进程立即恢复运行，而不让其他进程抢先进入管程，这使用V(x-sem)实现</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">typedef <span class="hljs-keyword">struct</span> Monitor&#123;<br>semaphore mutex;<br>semaphore next;<br><span class="hljs-built_in">int</span> next_count;<br>&#125;<br>mutex = <span class="hljs-number">1</span>;<br>next = <span class="hljs-number">0</span>;<br>next_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//enter()和leave()操作</span><br>void enter(Monitor &amp;m)&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<br>&#125;<br>void leave<span class="hljs-literal">()</span>&#123;Monitor &amp;m&#125;&#123;<br><span class="hljs-keyword">if</span>(m.next_count&gt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">//wait()</span><br>void wait(semaphore &amp;x_sem, <span class="hljs-built_in">int</span> x_count, Monitor &amp;m)&#123;<br>x_count++;<span class="hljs-comment">//等待资源进程个数加1</span><br><span class="hljs-keyword">if</span>(m.next_count&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//判断是否有发出过signal的进程</span><br><span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<span class="hljs-comment">//释放</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<span class="hljs-comment">//开放管程</span><br><span class="hljs-constructor">P(<span class="hljs-params">x_sem</span>)</span>;<span class="hljs-comment">//等待资源进程阻塞自己</span><br>x_count--;<span class="hljs-comment">//等待资源进程个数减1</span><br>&#125;<br><br><span class="hljs-comment">//signal()</span><br>void signal(semaphore &amp;x_sem, <span class="hljs-built_in">int</span> x_count, Monitor &amp;m)&#123;<br><span class="hljs-keyword">if</span>(x_count&gt;<span class="hljs-number">0</span>)&#123;<br>m.next_count++;<span class="hljs-comment">//发出signal进程数加1</span><br><span class="hljs-constructor">V(<span class="hljs-params">x_sem</span>)</span>;<span class="hljs-comment">//释放一个等待资源的进程</span><br><span class="hljs-constructor">P(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<span class="hljs-comment">//发出signal的进程阻塞自己</span><br>m.next_count--;<span class="hljs-comment">//发出signal的进程个数减1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管程求解进程的同步和互斥问题">6.4.3管程求解进程的同步和互斥问题</h3><p>互斥问题：读者写者问题、哲学家就餐问题</p><p>同步问题：生产者与消费者问题、苹果桔子问题</p><h4 id="哲学家就餐问题">哲学家就餐问题</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs perl">type philosophers=monitor<br>enum &#123;thinking,hungry,eating&#125; <span class="hljs-keyword">state</span>[<span class="hljs-number">5</span>];<br>semaphore self[<span class="hljs-number">5</span>]; <span class="hljs-keyword">int</span> self_count[<span class="hljs-number">5</span>]; Monitor M;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++) <span class="hljs-keyword">state</span>[i] = thinking;<br>define pickup, putdown;<br><span class="hljs-keyword">use</span> enter, leave, <span class="hljs-keyword">wait</span>, signal;<br><br>void pickup(<span class="hljs-keyword">int</span> i)&#123;<br>enter(M);<br><span class="hljs-keyword">state</span>[i] = hungry;<br>test(i);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">state</span>[i] != eating)<br><span class="hljs-keyword">wait</span>(self[i], self_count[i], M);<br>leave(M);<br>&#125;<br><br>void putdown(<span class="hljs-keyword">int</span> i)&#123; <span class="hljs-regexp">//i</span>=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,..,<span class="hljs-number">4</span><br>enter(M);<br>  <span class="hljs-keyword">state</span>[i] = thinking;<br>    test((i-<span class="hljs-number">1</span>)%5);<br>    test((i+<span class="hljs-number">1</span>)%5);<br>leave(M);<br>&#125;<br><br>void test(<span class="hljs-keyword">int</span> k)&#123; <span class="hljs-regexp">//</span>k=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,...,<span class="hljs-number">4</span> <br><span class="hljs-keyword">if</span>((<span class="hljs-keyword">state</span>[(k-<span class="hljs-number">1</span>)%5] != eating) &amp;&amp; (<span class="hljs-keyword">state</span>[k] == hungry) <br>&amp;&amp;(<span class="hljs-keyword">state</span>[(k+<span class="hljs-number">1</span>)%5] != eating)) <br><span class="hljs-keyword">state</span>[k]=eating;<br>signal(self[k], self_count[k], IM);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生产者与消费者问题">生产者与消费者问题</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> <span class="hljs-built_in">product</span>=monitor<br>item Buffer[k];//缓冲区<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">in</span>, <span class="hljs-keyword">out</span>;//存取位置<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>;<br>semaphore full, empty;<br><span class="hljs-built_in">int</span> full_count, empty_count;<br>Monitor m;<br>define append, take;<br><span class="hljs-keyword">use</span> enter, leave, <span class="hljs-keyword">wait</span>, signal;<br><br>void append(item x)&#123;<br>enter(m);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">count</span> == k) <span class="hljs-keyword">wait</span>(full, full_count, m);<br>Buffer[<span class="hljs-keyword">in</span>] = x;<br><span class="hljs-keyword">in</span> = (<span class="hljs-keyword">in</span> + <span class="hljs-number">1</span>) % k;<br><span class="hljs-built_in">count</span>++;<br>signal(empty, empty_count, m);<br>leave(m);<br>&#125;<br><br>void take(item x)&#123;<br>enter(m);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">count</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">wait</span>(empty, empty_count, m);<br>x = Buffer[<span class="hljs-keyword">out</span>];<br><span class="hljs-keyword">out</span> = (<span class="hljs-keyword">out</span> + <span class="hljs-number">1</span>) % k;<br><span class="hljs-built_in">count</span>--;<br>signal(full, full_count, m);<br>leave(m);<br>&#125;<br><br>cobegin<br>process producer_i()&#123;<br><span class="hljs-built_in">product</span>.append(x);<br>&#125;<br>process consumer_i()&#123;<br><span class="hljs-built_in">product</span>.take(x);<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h2 id="进程通信">6.5 进程通信</h2><h3 id="进程通信-1">6.5.1 进程通信</h3><p>当进程互相交互时，必须满足两个基本要求：同步和通信</p><ul><li>为实施互斥，进程间需要同步</li><li>为了协作，进程间需要交换信息</li></ul><p>消息传递提供了最典型的消息传递原语：send和receive</p><h4 id="进程直接通信">进程直接通信</h4><ul><li>对称直接寻址，发送进程和接收进程必须命名对方以便通信，原语定义如下：<ul><li><code>send(P, message)</code>发送消息到进程P</li><li><code>receive(Q, message)</code>接收来自进程Q的消息</li></ul></li><li>非对称直接寻址，只要发送者命名接收者，而接收者不需命名发送者<ul><li><code>send(P, message)</code>发送消息到进程P</li><li><code>receive(id, message)</code>接收来自任何进程的消息，id置为与其通信的进程名称</li></ul></li></ul><p>进程P向Q发送消息：</p><pre><code class=" mermaid">graph LR进程P--&gt;内核--&gt;进程Q</code></pre><p>消息格式：消息头与消息体（即消息内容），</p><ul><li>消息头包括：消息类型、目标ID、源ID、消息长度、控制信息</li></ul><h4 id="进程间接通信">进程间接通信</h4><ul><li><p>消息不是直接从发送者发送到接收者，而是发送到由临时保存这些信息的队列组成的一个共享数据结构，这些队列通常称为信箱。</p></li><li><p>一个进程给合适的信箱发送消息，另一进程从信箱中获得消息。</p></li><li><p>间接通信的通信原语定义：</p><ul><li><p><code>send(A, message)</code>把消息传送到信箱A</p></li><li><p><code>receive(A, message)</code>从信箱A接收消息</p></li></ul></li></ul><p>信箱可以分成信箱头和信箱体两部分，信箱头指出信箱容量、信件格式、存放信件位置的指针等；信箱体用来存放信件。信箱体分成若干个可容纳一封信的区。</p><ul><li>send：若指定信箱未满，将信件送入信箱中指针指示的位置，并释放该信箱中信件的等待者，否则，发送信件者被置为等待信箱状态</li><li>receive：如果指定信箱中有信，则取出一封信件，并释放等待信箱的等待者，否则，接收信件者被置成等待信箱中信件的状态</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> box = record<br><span class="hljs-built_in">int</span> size;<span class="hljs-comment">//信箱大小</span><br><span class="hljs-built_in">int</span> count;<span class="hljs-comment">//现有信件数</span><br>message<span class="hljs-literal">[<span class="hljs-identifier">n</span>]</span> letter;<br>semaphore s1, s2;<span class="hljs-comment">//等信箱和等信件信号量</span><br><br>procedure send(box B, message M)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>size) <span class="hljs-constructor">W(B.<span class="hljs-params">s1</span>)</span>;<span class="hljs-comment">//R和W时让进程入队和出队的两个过程</span><br><span class="hljs-built_in">int</span> i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count + <span class="hljs-number">1</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = M;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count = i;<br><span class="hljs-constructor">R(B.<span class="hljs-params">s2</span>)</span>;<br>&#125;<br><br>procedure receive(box B, message M)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) <span class="hljs-constructor">W(B.<span class="hljs-params">s2</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count - <span class="hljs-number">1</span>;<br>x = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count;i++)&#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span> + <span class="hljs-number">1</span>]</span>;<br>&#125;<br>&#125;<br><span class="hljs-constructor">R(B.<span class="hljs-params">s1</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消息传递的若干问题">消息传递的若干问题</h4><ul><li>信箱容量问题</li><li>多进程与信箱相连的信箱接收问题</li><li>信箱的所有权问题<ul><li>信箱为操作系统所有，是指操作系统统一设置信箱，归系统所有，供相互通信的进程共享，例：消息缓冲机制</li></ul></li><li>信件的格式问题和其他有关问题</li><li>通信进程的同步问题</li></ul><h4 id="消息缓冲通信">消息缓冲通信</h4><h5 id="基本思想">基本思想</h5><p>由操作系统统一管理一组用于通信的消息缓冲存储区，每个消息缓冲存储区可以存放一个消息。</p><p>当一个进程需要发送消息：</p><ol type="1"><li>先在自己的消息发送区内生成待发送的消息，包括接收进程名、消息长度、消息正文等。</li><li>向系统申请一个消息缓冲区，把消息从发送区复制到消息缓冲区中。复制过程中，系统会将接收进程名换为发送进程名，以便接收者识别。</li><li>该消息缓冲区被挂在接收消息的进程的消息队列上，供接收者在需要时从消息队列中摘下并复制到消息接收区使用，同时释放消息缓冲区。</li></ol><p>消息缓冲通信涉及的数据结构：</p><ul><li>sender：发送消息的进程名或标识符</li><li>size：发送的消息长度</li><li>text：发送的消息正文</li><li>next-ptr：指向下一个消息缓冲区的指针</li></ul><p>在进程的PCB中涉及通信的数据结构：</p><ul><li>mptr：消息队列首指针</li><li>mutex：消息队列互斥信号量，初始为1</li><li>sm：表示接收进程信号队列上消息的个数，初值为0，是控制收发进程同步的信号量</li></ul><h5 id="发送和接收原语的实现">发送和接收原语的实现</h5><ul><li>发送原语Send：<ul><li>申请一个消息缓冲区，把发送区内容复制到这个缓冲区中</li><li>找到接收进程的PCB，执行P(mutex)</li><li>把缓冲区挂在接收进程消息队列尾部</li><li>执行V(sm)</li><li>执行V(mutex)</li></ul></li><li>接收原语Receive：<ul><li>执行P(sm)查看是否有信件</li><li>执行P(mutex)，取消息</li><li>执行V(mutex)</li><li>把消息缓冲区内容复制到接收区，释放消息缓冲区</li></ul></li></ul><h4 id="管道和套接字">管道和套接字</h4><p>基于信箱的消息传递方式的一种变体，与传统的信箱方式等价，但没有设定消息的边界。</p><ul><li>即，若一个进程发送10条100字节的消息，另一个进程接收1000个字节，接收者将获得10条消息。</li></ul><h3 id="高级进程通信机制">6.5.2 高级进程通信机制</h3><h4 id="基于流的进程通信">基于流的进程通信</h4><ul><li><p>多个进程使用一个共享的消息缓冲区（可称为管道、多路转接器、套接字）。</p></li><li><p>一些进程向消息缓冲区中写入字符流</p></li><li><p>一些进程从消息缓冲区中读出字符流</p></li><li><p>信息以任意长度的字符流交换。</p></li></ul><h4 id="基于rpc的高级通信规约">基于RPC的高级通信规约</h4><p>采用客户/服务器计算模式，服务器进程提供一系列过程/服务，供客户进程调用；客户进程通过调用服务器进程提供的过程/服务获得服务。</p><ul><li>考虑到客户计算机和服务器计算机的硬件异构性，外部数据表示XDR被引入来转换每台计算机的特殊数据格式为标准数据格式。</li></ul><h5 id="rpc执行步骤">RPC执行步骤</h5><ol type="1"><li>客户进程以普通方式调用客户存根</li><li>客户存根组织RPC消息并执行Send，激活内核程序</li><li>内核把消息通过网络发送到远地内核</li><li>远地内核把消息送到服务器存根</li><li>服务器存根取出消息中参数后调用服务器过程</li><li>服务器过程执行完后把结果返回至服务器存根</li><li>服务器存根进程将它打包并激活内核程序</li><li>服务器内核把消息通过网络发送至客户机内核</li><li>客户内核把消息交给客户存根</li><li>客户存根从消息中取出结果并返回给客户进程</li><li>客户进程获得控制权并得到了过程调用的结果</li></ol><figure><img src="/image/计算机操作系统/远程过程调用RPC.png"alt="远程过程调用RPC" /><figcaption aria-hidden="true">远程过程调用RPC</figcaption></figure><h2 id="死锁">6.6 死锁</h2><h3 id="死锁的产生">6.6.1 死锁的产生</h3><h4 id="死锁产生的可能原因">死锁产生的可能原因</h4><ul><li>进程推进顺序不当</li><li>PV操作使用不当</li><li>资源分配不当</li><li>对临时性资源使用不加限制</li></ul><h4 id="死锁的定义">死锁的定义</h4><p>一个进程集合中的每一个进程都在等待只能由该集合中的其他进程才能引发的事件。</p><h4 id="系统形成死锁的四个必要条件">系统形成死锁的四个必要条件</h4><ul><li>互斥条件：系统中存在进程应互斥使用的临界资源</li><li>占有和等待条件：进程请求资源不得到满足而等待时，不释放已占有的资源</li><li>不剥夺条件：已被占有的资源只能被属主释放，不允许被其他进程剥夺</li><li>循环等待条件：存在循环等待链，每个进程都在链中等待下一个进程所持有的资源</li></ul><h3 id="死锁的防止">6.6.2 死锁的防止</h3><ul><li>破坏互斥条件：使资源可同时访问而不是互斥使用</li><li>破坏占有和等待条件：静态分配</li><li>破坏不剥夺条件：剥夺式调度</li><li>上述方法均导致资源利用率和吞吐率低</li></ul><h4 id="层次分配策略">层次分配策略</h4><p>破坏占有和等待条件、循环等待条件。</p><ul><li>资源被分为多个层次</li><li>当进程得到某一层的一个资源后，它只能再申请较高层次的资源</li><li>当进程要释放某层的一个资源时，必须先释放占有的较高层次的资源</li><li>当进程得到某一层的一个资源，并想申请该层的另一个资源，必须先释放该层中的已占资源</li></ul><p>变种：按序分配，资源排序，不得申请序数比占有资源序数小的资源。</p><h3 id="死锁的避免">6.6.3 死锁的避免</h3><h4 id="银行家算法">银行家算法</h4><ul><li>银行家拥有一笔周转资金</li><li>客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能归还贷款</li><li>银行家应谨慎地贷款，防止出现坏账<ul><li>操作系统——银行家</li><li>资源——周转资金</li><li>进程——客户</li></ul></li></ul><p>银行家算法的数据结构：</p><p>一个系统有n个进程和m种不同的资源，定义包含以下向量和矩阵的数据结构：</p><ul><li>系统每类资源总数：该m个元素的向量为系统中每类资源的数量<ul><li><span class="math inline">\(Resource=(R_1,R_2,...,R_m)\)</span></li></ul></li><li>每类资源未分配数量：该m个元素的向量为系统中每类资源尚可供分配数量<ul><li><spanclass="math inline">\(Available=(V_1,V_2,...,V_m)\)</span></li></ul></li><li>最大需求矩阵：每个进程对每类资源最大需求量，<spanclass="math inline">\(C_{ij}\)</span>表示进程<spanclass="math inline">\(P_i\)</span>需<spanclass="math inline">\(R_j\)</span>类资源最大数<ul><li><span class="math inline">\(Claim=\begin{pmatrix}C_{11} &amp; C_{12}&amp; ... &amp; C_{1m} \\ C_{21} &amp; C_{22} &amp; ... &amp; C_{2m} \\... \\ C_{n1} &amp; C_{n2} &amp; ... &amp; C_{nm}\end{pmatrix}\)</span></li></ul></li><li>分配矩阵：进程当前分得资源数，<spanclass="math inline">\(A_{ij}\)</span>表示进程<spanclass="math inline">\(P_{i}\)</span>已分得<spanclass="math inline">\(R_j\)</span>类资源个数<ul><li><span class="math inline">\(Allocation=\begin{pmatrix}A_{11} &amp;A_{12} &amp; ... &amp; A_{1m} \\ A_{21} &amp; A_{22} &amp; ... &amp;A_{2m} \\ ... \\ A_{n1} &amp; A_{n2} &amp; ... &amp; A_{nm}\end{pmatrix}\)</span></li></ul></li></ul><p>确定成立的关系式：</p><ul><li><span class="math inline">\(R_i=V_i+\sum A_{ki}\)</span>，对<spanclass="math inline">\(i=1,...,m,k=i,...,n\)</span><ul><li>表示所有资源要么已被分配，要么尚可分配</li></ul></li><li><span class="math inline">\(C_{ki} \leq R_i\)</span>，对<spanclass="math inline">\(i=1,...,m,k=1,...,n\)</span><ul><li>表示进程申请资源数不能超过系统拥有的资源总数</li></ul></li><li><span class="math inline">\(A_{ki} \leq C_{ki}\)</span>，对<spanclass="math inline">\(i=1,...,m,k=1,...n\)</span><ul><li>表示进程申请任何类资源数不能超过声明的最大资源需求数</li></ul></li></ul><p>一种死锁的避免策略：</p><p>系统中若要启动一个新进程工作，其对资源<spanclass="math inline">\(R_i\)</span>的需求仅当满足以下不等式：</p><p><span class="math inline">\(R_i \geq C_{(n+1)i} + \sumC_{ki}\)</span>，对<spanclass="math inline">\(i=1,...,m,k=1,...n\)</span></p><p>即应满足当前系统中所有进程对资源<spanclass="math inline">\(R_i\)</span>的最大资源需求数加上启动的新进程的最大资源需求数不超过系统拥有的最大数。</p><h5 id="系统安全性">系统安全性</h5><p>系统在时刻<spanclass="math inline">\(T_0\)</span>是安全的，仅当存在一个进程序列<spanclass="math inline">\(P_1,...,P_n\)</span>，对进程<spanclass="math inline">\(P_k\)</span>满足公式：</p><p><span class="math inline">\(C_{ki} - A_{ki} \leq V_i+\sumA_{ji}\)</span>，对i=1,...,m,k=1,...n$</p><h5 id="银行家算法基本思想">银行家算法基本思想</h5><ol type="1"><li>系统中的所有进程进入进程集合。</li><li>在安全状态下系统收到进程的资源请求后，先把资源试探性分配给它。</li><li>系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较，在进程集合中找到剩余资源能满足最大需求量的进程，从而保证这个进程运行完毕并归还全部资源。</li><li>把这个进程从集合中去掉, 系统的剩余资源更多了。反复执行上述步骤。<ul><li>进程退出系统，资源回收</li></ul></li><li>最后，检查进程集合，若为空表明本次申请可行，系统处于安全状态,可实施本次分配；否则，有进程执行不完，系统处于不安全状态，本次资源分配暂不实施，让申请进程等待。</li></ol><h3 id="死锁的检测和解除">6.6.4 死锁的检测和解除</h3><p>系统定时进行死锁的检测，如检测到，则解除它。</p><h4 id="进程-资源分配图">进程-资源分配图</h4><ul><li><p>约定<span class="math inline">\(P_i\rightarrowR_j\)</span>为请求边，表示进程<spanclass="math inline">\(P_i\)</span>申请资源类<spanclass="math inline">\(R_j\)</span>中的一个资源得不到满足而处于等待<spanclass="math inline">\(R_j\)</span>类资源的状态，该有向边从进程开始指到方框的边缘，表示进程<spanclass="math inline">\(P_i\)</span>申请<spanclass="math inline">\(R_j\)</span>中的一个资源。</p></li><li><p>约定<span class="math inline">\(R_j \rightarrowP_i\)</span>为分配边，表示<spanclass="math inline">\(R_j\)</span>类中的一个资源已被进程<spanclass="math inline">\(P_i\)</span>占用。由于已把一个具体的资源分配给了进程<spanclass="math inline">\(P_i\)</span>，故该有向边从方框内的某个黑圆点出发指向进程。</p></li></ul><p>死锁资源分配图示例：</p><figure><img src="/image/计算机操作系统/死锁资源分配图示例.png"alt="死锁资源分配图示例" /><figcaption aria-hidden="true">死锁资源分配图示例</figcaption></figure><ul><li>如果进程-资源分配图中无环路，则此时系统中没有发生死锁</li><li>如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充要条件，环路中的进程便为死锁进程</li><li>如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则，环路是系统发生死锁的必要条件而不是充分条件</li></ul><p>如果能在进程-资源分配图中消去此进程的所有请求边和分配边，成为孤立结点，经一系列简化，使所有进程成为孤立结点，则该图是可完全简化的</p><ul><li>系统为死锁状态的充分条件是，此进程-资源分配图是不可完全简化的</li></ul><h4 id="死锁的安全性测试算法">死锁的安全性测试算法</h4><p>类似于死锁避免算法，不同在于前者考虑了检查每个进程还需要的所有资源能否满足要求，后者则要根据进程的当前申请资源量来判断系统是否进入不安全状态。</p><p>一种检测方法：</p><ol type="1"><li>currentAvailable=available</li><li>若allocation[k,*]!=0，令finish[k]=false，否则finish[k]=true</li><li>寻找一个k，满足条件(finish[k]==false)&amp;&amp;(request[k,*]&lt;=currentavail[*])，找不到则跳到5</li><li>currentAvailable[*]=currentAvailable[*]+allocation[k,*]，finish[k]=true，跳至3</li><li>如果存在k(1≤k≤n)，finish[k]=false，则系统处于死锁状态，并且finish[k]=false的P_k为处于死锁的进程。</li></ol><h4 id="死锁的解除">死锁的解除</h4><ul><li><p>结束所有进程的执行，重新启动操作系统。</p><ul><li>以前工作全部作废，损失很大。</li></ul></li><li><p>撤销陷于死锁的所有进程，解除死锁继续运行。</p></li><li><p>逐个撤销陷于死锁的进程，回收其资源重新分派，直至死锁解除。</p></li><li><p>剥夺陷于死锁的进程占用的资源，但并不撤销它，直至死锁解除。</p><ul><li>可仿照撤销陷于死锁进程的条件来选择剥夺资源的进程</li></ul></li><li><p>根据系统保存的检查点，让所有进程回退，直到足以解除死锁</p><ul><li>要求系统建立保存检查点、 回退及重启机制。</li></ul></li><li><p>当检测到死锁时，可能存在某些未卷入死锁的进程，随着这些进程执行到结束，有可能释放足够的资源来解除死锁。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第五章_文件管理</title>
    <link href="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第五章-文件管理">第五章 文件管理</h1><h2 id="文件系统概述">5.1 文件系统概述</h2><h3 id="文件的概念">5.1.1 文件的概念</h3><p>具有符号名的，在逻辑上具有完整意义的一组相关信息项的序列</p><p>文件名是由字母、数字和其他符号组成的一个字符串，其格式和长度因系统而异</p><h4 id="文件的命名">文件的命名</h4><ul><li>一般包括文件名和扩展名<ul><li>前者用于识别文件，后者用于标识文件特性，两者用小数点隔开</li></ul></li><li>每个操作系统都有约定的扩展名，Windows系统中有：<ul><li>.com表示可执行的二进制代码文件</li><li>.exe表示可执行的浮动二进制代码文件</li><li>.lib表示库程序文件</li><li>.bat表示批命令文件</li><li>.obj表示编译或汇编生成的目标文件</li></ul></li></ul><h4 id="文件的分类">文件的分类</h4><ul><li>按用途：系统文件、库文件、用户文件</li><li>按保护级别：只读文件、读写文件、不保护文件</li><li>按信息时限：临时文件、永久文件、档案文件</li><li>按设备类型：磁盘文件、磁带文件、光盘文件、软盘文件</li><li>还可以按文件的逻辑结构或物理结构分类</li></ul><h4 id="引入文件的优点">引入文件的优点</h4><ul><li>用户使用方便</li><li>文件安全可靠</li><li>文件可备份</li><li>文件可共享</li></ul><h3 id="文件系统及其功能">5.1.2 文件系统及其功能</h3><h4 id="文件系统的概念">文件系统的概念</h4><p>操作系统中负责存取和管理信息的模块，用统一方式管理用户和系统信息的存储、检索、更新、共享和保护，为用户提供一整套方便有效的文件使用和操作方法。</p><ul><li>文件系统中的文件和用户概念中的逻辑结构以及存储器中的存储结构密切相关，因此，同一个文件需要从逻辑文件和物理文件两个侧面观察。</li></ul><h4 id="文件系统的功能">文件系统的功能</h4><p>文件系统面向用户的功能：</p><ul><li>文件的按名存取</li><li>文件的共享和保护</li><li>文件的操作和使用</li></ul><p>为了实现这些功能，操作系统必须考虑：</p><ul><li>文件目录的建立和维护</li><li>存储空间的分配和回收</li><li>数据的保密和保护</li><li>监督用户存取和修改文件的权限</li><li>实现在不同存储介质上信息的表示方式、编址方式、存储次序，以及信息检索等问题</li></ul><h4 id="文件系统的组成">文件系统的组成</h4><pre><code class=" mermaid">graph文件系统---文件的组织---组织方法---逻辑结构:\n流式文件\n记录式文件组织方法---物理结构:\n顺序文件\n连接文件\n直接文件\n索引文件文件系统---文件的存取---存取方法:\n顺序存取\n索引存取\n文件系统---文件的控制---控制系统:\n逻辑控制系统\n物理控制系统文件系统---文件的使用---文件操作:\n打开\n关闭\n读\n写\n控制</code></pre><h2 id="文件的组织">5.2 文件的组织</h2><h3 id="文件的存储">5.2.1 文件的存储</h3><h4 id="卷和块">卷和块</h4><p>文件存储介质有磁带、光盘和磁盘。</p><ul><li>卷是存储介质的物理单位，对应于一盘磁带、一块软盘、一片光盘、一个硬盘分区</li><li>块是存储介质上连续信息所组成的一个区域，也称为物理记录<ul><li>块是主存储器和辅助存储器进行信息交换的物理单位，每次总是交换一块或整数块信息</li><li>决定块的大小要考虑用户使用方式、数据传输效率和存储设备类型等因素</li><li>不同类型的存储介质，块的长短常常不同；对同一类型的存储介质，块的大小一般相同，但也可以不同</li><li>外围设备由于机械动作或识别不同块的要求，两个相邻块之间必须留有间隙，间隙是块之间不记录用户代码信息的区域</li></ul></li></ul><h4 id="顺序存取存储设备的信息安排">顺序存取存储设备的信息安排</h4><p>顺序存储设备是严格依赖信息的物理位置次序进行定位和读写的存储设备。</p><ul><li>磁带是最常用的一种顺序存取存储设备，它具有存储容量大、稳定可靠、卷可装卸和易于保存等优点，广泛用于存档<ul><li>磁带的突出特点是块长的变化范围较大，块可以很小，也可以很大，原则上没有限制</li></ul></li><li>光盘也是一种顺序存取存储设备</li></ul><h4 id="直接存取存储设备的信息安排">直接存取存储设备的信息安排</h4><p>磁盘是一种直接存取存储设备，又称为随机存取存储设备。 -移臂与旋转两维组织，存取速度高 -每个物理地址有确定的位置和唯一的地址，存取任何一个物理块所需的时间几乎不依赖于此信息的位置</p><h3 id="文件的逻辑结构">5.2.2 文件的逻辑结构</h3><p>逻辑文件，又称为文件的逻辑结构。</p><ul><li>独立于物理环境的，用户概念中的抽象信息组织方式</li><li>用户能观察到并加以处理的数据集合</li></ul><p>文件的逻辑结构分为两种：流式文件和记录式文件。</p><h4 id="流式文件">流式文件</h4><p>文件内的数据不再组成记录，只是由一串依次的字节组成的信息流序列。</p><ul><li>这种文件常常按长度来读取所需信息，也可以用插入的特殊字符作为分界。</li></ul><h4 id="记录式文件">记录式文件</h4><p>一种有结构的文件，是若干逻辑记录信息所组成的记录流文件。</p><ul><li>逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位</li></ul><p>记录式文件与数据库</p><ul><li>数据库管理系统也支持逻辑记录</li><li>有别于记录式文件的是，数据库中的记录之间可以通过数据冗余构成某种联系</li><li>数据库管理系统支持基于联系的数据查询，文件系统则不行</li></ul><h4 id="记录的成组与分解">记录的成组与分解</h4><p>一个物理记录只存放一个逻辑记录可能造成极大的浪费。</p><p>若干个逻辑记录合并成一组，写入一个块，称为记录的成组。</p><ul><li>每块中的逻辑记录数称为块因子</li></ul><p>对于流式文件，一个物理记录可以存放很多个连续字节</p><h5 id="成组与分解操作">成组与分解操作</h5><ol type="1"><li>系统设置独立于用户数据区的输入/输出缓冲区</li><li>记录的成组操作在输出缓冲区内进行，凑满一块后才将缓冲区内的信息写到存储介质上</li><li>当存储介质上的一个物理记录读进输入缓冲区后，把逻辑记录从块中分离出来的操作称为记录的分解操作</li></ol><p>成组与分解的特征：</p><ul><li>优点：记录成组与分解节省存储空间，减少输入/输出操作次数，提高系统效率</li><li>提前读与推迟写<ul><li>提前读：用户读请求，导致包含该逻辑记录的物理块读如输入缓冲区，这一操作可能读入了多个逻辑记录</li><li>推迟写：用户写请求，首先是写入输出缓冲区，只有当该缓冲区中的逻辑记录满后才会引起实际输出</li></ul></li></ul><h3 id="文件的物理结构">5.2.3 文件的物理结构</h3><p>文件的物理结构和组织是指文件在物理存储空间中的存放方法和组织关系，又称为物理文件。</p><ul><li>文件的存储结构涉及块的划分、记录的排列、索引的组织、信息的搜索等问题</li><li>直接影响文件系统性能</li></ul><h4 id="顺序文件">顺序文件</h4><p>将一个文件中逻辑上连续的信息存放到存储介质的依次相邻的块中形成顺序结构，这类文件称为顺序文件，也称连续文件。</p><ul><li><p>例：磁带文件、光盘文件</p></li><li><p>优点：顺序存取记录时速度较快</p><ul><li>常用于批处理文件和系统文件</li><li>采用磁带存放顺序文件，总可以保持快速存取存储的优点</li></ul></li><li><p>缺点：建立文件前需要能预先确定文件长度以便分配存储空间；修改、插入和增加文件记录有困难</p></li></ul><h4 id="连接文件">连接文件</h4><p>连接文件又称串联文件，使用连接字来表示文件中各个物理块之间的先后次序。</p><ul><li><p>第一块文件信息的物理地址由文件目录给出，每一块的连接字指出了文件的下一个物理块位置，连接字内容为0时，表示文件至本块结束。</p></li><li><p>输入井、输出井都是连接文件</p></li><li><p>优点：易于对文件记录做增、删、改，易于动态增长记录；不必预先确知文件长度；存储空间利用率高</p></li><li><p>缺点：存放指针需要额外的存储空间，由于存取需通过缓冲区，待获得连接字后，才能找到下一物理块的地址，因而仅适用于顺序存取</p></li></ul><h4 id="直接文件">直接文件</h4><p>直接文件又称散列文件，通过计算记录的关键字建立与其物理存储地址之间的对应关系，这种变换通常采用散列。</p><ul><li>计算寻址结构可能出现冲突，解决办法有拉链法、循环探查法、二次散列法、溢出区法等</li></ul><h4 id="索引文件">索引文件</h4><p>索引文件为每个文件建立了一张索引表，其中每个表目包含一个记录的键（逻辑记录号）及其存储地址。</p><ul><li>索引表的地址可由文件目录指出，查阅索引表先找到相应记录键，然后获得数据存储地址</li></ul><p>访问方式：</p><ul><li>索引文件在文件存储器上分为索引区和数据区</li><li>访问索引文件的两步操作：查找索引表，获得记录的物理地址</li><li>需要两次访问辅助存储器，若文件索引表已预先掉入主存储器，可减少一次内外存信息交换</li></ul><p>索引结构时连接结构的一种扩展，克服了连接文件只能作顺序存取的缺点，但增加了索引表的空间开销和查找时间。</p><p>索引表的组织：一级索引、二级索引、多级索引</p><h2 id="文件目录">5.3 文件目录</h2><h3 id="文件目录结构">5.3.1 文件目录结构</h3><p>文件目录是实现文件的按名存取的关键数据结构。</p><ul><li>文件系统的基本功能之一就是负责文件目录的建立、维护和检索，要求编排的目录便于查找、防止冲突</li><li>文件目录需要永久保存，因此也组织成文件存放在磁盘上</li></ul><h4 id="一级目录结构">一级目录结构</h4><p>在操作系统中构造一张线性表，与每个文件的相关属性占一个目录项，构成一级目录结构</p><ul><li>由于用户与文件众多，容易重名，不利于记忆</li></ul><h4 id="二级目录结构">二级目录结构</h4><ul><li>第一级为主文件目录，用于管理所有用户文件目录，目录项登记系统接受的用户名和该用户文件目录的地址</li><li>第二级为用户文件目录，为该用户的每个文件保存一个登记栏，内容与一级目录的目录项相同</li><li>每个用户只允许查看自己的文件目录</li></ul><p>二级目录结构的特点：</p><ul><li>可以检查访问文件者的存取权限，实现对文件的保密和保护</li><li>对同一个用户而言，依然存在文件多、易重名的问题</li></ul><h4 id="树形目录结构">树形目录结构</h4><p>每一级目录可以登记下一级目录，也可以登记文件，形成层次文件目录结构，一般采用树形目录结构，根是根目录，非叶节点为子目录，叶节点为文件</p><ul><li>较好地反映现实世界中具有层次关系的数据集合，较准确地反映系统内部文件的组织结构</li><li>不位于同一末端子目录的不同文件可以重名</li><li>易于规定不同层次货子树中文件的不同存取权限，便于文件的保护、保密和共享</li></ul><p>树形目录结构的文件定位</p><ul><li>一个文件的全名包括从根目录到文件为止的所有子目录路径</li><li>各子目录名间用文件分隔符分开</li><li>一个硬盘分区组织成一棵子树<ul><li>每棵子树对应一个逻辑盘符（Windows）</li><li>众多子树嫁接成一棵大树（UNIX）</li></ul></li></ul><h3 id="文件目录的管理">5.3.2 文件目录的管理</h3><h4 id="文件查找">文件查找</h4><p>系统跟去用户提供的文件路径（绝对/相对）搜索各级文件目录，找到文件。</p><ul><li>现代操作系统都有改变工作目录的命令。</li></ul><h4 id="目录项查找">目录项查找</h4><p>搜索具体目录项时，可以采用顺序查找法或二分查找、杂凑法等方式查找。</p><ul><li>目录项按一定顺序编排时可用二分查找</li><li>杂凑法，把每个文件名经过变换函数变换成唯一的目录表表项。</li></ul><h4 id="活动文件表">活动文件表</h4><ul><li><p>树形目录结构存在的问题：一个文件经过许多目录节点时，使用不方便，系统在沿路径查找目录时，要多次访问文件存储器，使访问速度大大减慢。</p></li><li><p>若将所有文件的目录都复制到主存，访问速度加快但主存开销大。</p></li><li><p>一种办法是，把常用的和正在使用的文件目录复制进主存</p></li></ul><p>系统为每个用户进程建立一张活动文件表，用户使用一个文件前，先通过打开操作，把该文件有关目录信息复制到指定主存区域，有关信息填入活动文件表，以建立用户进程和该文件索引的联系。</p><p>不再使用该文件时，使用关闭操作，切断用户进程和这个文件的联系，同时若该目录已被修改过，更新辅存中对应的文件目录。</p><h2 id="文件的共享保护和保密">5.4 文件的共享、保护和保密</h2><p>文件是计算机系统的重要资源，文件系统需要具有保障文件安全的手段，提供文件保密的措施，有效实现文件共享。</p><ul><li>文件共享是指不同用户共同使用某些文件</li><li>文件保护是指防止文件被破坏</li><li>文件保密是指防止文件及其内容被其他用户窃取</li></ul><h3 id="文件的共享">5.4.1 文件的共享</h3><p>文件共享是计算机用户完成共同任务所必需的。</p><ul><li>好处：减少用户大量重复性劳动；免除系统复制文件的工作；节省文件占用的存储空间；减少程序设计输入/输出文件的次数</li></ul><p>文件共享的并发控制：</p><ul><li>在允许文件共享的系统中，操作系统应提供手段实现对共享文件的同步控制</li><li>多个进程可能同时存取一个文件如果它们同时进行读操作，操作系统应对文件进行公用控制</li><li>如果有进程进行写操作，操作系统须提供同步控制机制以保证文件数据完整性</li></ul><p>文件的保密：</p><ul><li>文件保密是指文件及其内容不能被未经文件主授权的其他用户窃取</li><li>保密措施：<ul><li>隐蔽文件目录</li><li>设置口令</li><li>使用密码</li></ul></li></ul><h3 id="文件的保护">5.4.2 文件的保护</h3><p>文件保护是指防止文件被破坏。操作系统须提供文件保护机制，实现文件完整性。</p><p>常见的文件保护方法：文件副本；文件存取矩阵；文件属性</p><h4 id="文件副本">文件副本</h4><p>文件系统必须要有防止硬软件故障，保存信息完整性的能力，文件副本是主要实现机制。</p><ul><li>动态多副本技术</li><li>转储、备份和恢复</li></ul><h5 id="动态多副本">动态多副本</h5><p>在多个介质上维持同一内容的文件，在更新内容时同时进行。</p><p>增加了设备费用和系统负载，一般适用于容量较小且较为重要的文件，当文件发生故障时只需切换到备用设备即可。</p><p>一般适用于不需更新的系统文件及专用文件，</p><h5 id="文件转储">文件转储</h5><p>定时将文件复制转储到其他介质上，当某介质上出现故障时，复原转储文件。</p><p>转储的两种方式：</p><ul><li>一，一定时间间隔或一个单位处理结束时，系统自动复写更新过的文件和数据</li><li>二，每天或每周把文件信息全部复写，需要时再通过装入转储文件来恢复系统</li></ul><h4 id="文件的存取控制矩阵">文件的存取控制矩阵</h4><p>系统为每个用户设置访问每个文件对象的存取属性，则全部用户对全部文件的存取属性就组成一个二维矩阵，称为存取控制矩阵。</p><ul><li>由于操作系统具有很多用户和众多文件，存取控制矩阵是一个稀疏矩阵，可以将其简化为一张存取控制表<ul><li>每行包括：用户、文件、存取属性</li><li>仅登记那些对文件拥有存取属性的部分</li></ul></li></ul><p>基于存取控制矩阵/表的文件保护：</p><ul><li>存取属性：可以有访问、读、写、执行、创建、删除、授权等</li><li>系统通过查阅矩阵/表核对用户对文件的存取权限</li><li>文件主通过命令进行授权甚至授权权的转授</li><li>系统管理用户等同于文件主权限，获得对系统文件的授访问权权限</li></ul><h4 id="文件属性">文件属性</h4><p>存取控制表的一种简化方法是用户分类，再针对每类用户规定文件属性。</p><ul><li>用户分类：属主、合作者、其他</li><li>文件属性：读、写、执行</li><li>文件属性可以放在文件目录项中，管理大为简化</li><li>用户使用文件时，通过核对文件属性，实现保护</li></ul><h2 id="文件的使用">5.5 文件的使用</h2><h3 id="文件存取方法">5.5.1 文件存取方法</h3><p>文件存取方法是操作系统为用户程序提供的使用文件的技术和手段，在某种程度上依赖于文件的物理结构。</p><h4 id="顺序存取">顺序存取</h4><p>按记录顺序进行读写操作的存取方法。</p><ul><li>读操作根据读指针读出当前记录，同时推进读指针，指向下一次要读出的记录</li><li>写操作则设置写指针，把一个记录写到文件末端，同时推进写指针</li><li>允许对读指针进行前进或后退整数个记录的操作</li></ul><h4 id="直接存取">直接存取</h4><p>快速地以任意次序直接读写某个记录。</p><h4 id="索引存取">索引存取</h4><p>基于索引文件的索引存取方法。</p><ul><li>信息块的地址可以通过查找记录键换算出</li><li>也可以采用顺序存取或直接存取的方法</li><li>实际都采用多级索引加速记录查找</li></ul><h3 id="文件的使用-1">5.5.2 文件的使用</h3><p>用户通过两类接口与文件系统联系。</p><ul><li>一类是与文件有关的操作命令</li><li>另一类是提供给用户程序的文件类系统调用，如下</li></ul><h4 id="建立文件">建立文件</h4><p>参数：文件名、设备类、文件属性及存取控制信息</p><p>流程：在相应设备上建立一个文件目录项，分配第一个物理块，在活动文件表中申请一个项，登记有关目录信息，返回一个文件句柄。</p><h4 id="撤销文件">撤销文件</h4><p>参数：文件名、设备类</p><p>流程：若文件未关闭，先关闭文件；若为共享文件，进行联访处理；在目录文件中删除对应目录项，释放文件占用的文件存储空间</p><h4 id="打开文件">打开文件</h4><p>参数：文件名、设备类、打开方式</p><p>流程：在主存活动文件表中申请一个项，返回一个文件句柄；跟踪文件名查找目录文件，把目录信息复制到活动文件表相应栏，按存取控制说明检查访问的合法性；对共享文件进行相应的额外处理</p><h4 id="关闭文件">关闭文件</h4><p>参数：文件句柄</p><p>流程：将活动文件表中该文件的当前使用用户数减一，若此值为0，则收回此活动文件表，完成推迟写；若活动文件表目内容已被改过，则应先将表目内容写回文件存储器上相应表目中，使文件目录保存最新状态。</p><h4 id="读写文件">读写文件</h4><p>参数：文件句柄、用户数据区地址、读写的记录或字节数</p><p>按文件句柄从活动文件表中找到该目录的目录项信息；根据目录项指出的该文件逻辑和物理组织方式，把相关逻辑记录转换成物理块</p><h4 id="定位文件">定位文件</h4><p>调整所打开文件的读写指针位置</p><p>参数：文件句柄，定位指针</p><h2 id="文件系统的实现">5.6 文件系统的实现</h2><h3 id="辅存空间管理">1. 辅存空间管理</h3><h4 id="辅存空间的分配方式">辅存空间的分配方式</h4><ul><li>连续分配：存放在辅存空间连续存储区中（连续的存储块号）<ul><li>优点是顺序访问速度快，管理简单</li><li>为了获得足够大的连续存储区，需要定时进行碎片整理</li></ul></li><li>非连续分配：动态分配给若干扇区或簇，不要求连续<ul><li>辅存空间管理效率高，便于文件动态增长和收缩</li></ul></li></ul><h4 id="空闲块的管理">空闲块的管理</h4><h5 id="位示图">位示图</h5><p>使用若干字节构成一张表，表中每一字位对应一个物理块，字位的顺序和块的相对次序一致，字位为1表示相应块已占用，字位为0表示该块空闲。</p><p>优点：可以把位示图全部或大部分保存在主存中，配合位操作指令实现高速物理块分配与去配。</p><h5 id="空闲块成组连接法">空闲块成组连接法</h5><h3 id="文件系统的实现层次">2. 文件系统的实现层次</h3><ul><li>用户接口：接受用户发来的系统调用，进行语法检查，进入逻辑文件控制子系统</li><li>逻辑文件控制子系统：根据文件路径名，搜索文件目录，建立活动文件表，根据文件结构和存取方法，把逻辑记录转换成相对物理块号和块内相对地址</li><li>文件保护子系统：识别调用者身份，验证存取权限，判定本次文件操作的合法性</li><li>物理文件控制子系统：实现缓冲区管理，根据物理结构，将对应相对物理块号转换为实际物理块号，负责文件存储空间的分配，生存输入/输出控制系统调用形式</li><li>输入/输出控制子系统：执行具体的物理块输入/输出操作</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第四章_设备管理</title>
    <link href="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第四章-设备管理">第四章 设备管理</h1><h2 id="设备管理基础">4.1 设备管理基础</h2><h3 id="设备管理概述">4.1.1 设备管理概述</h3><h4 id="输入输出设备及其分类">1. 输入/输出设备及其分类</h4><ul><li><p>输入/输出设备，又称外围设备、外设，用于计算机系统与外部世界的信息交换或存储。</p></li><li><p>输入/输出操作：内存和外设间的信息传送操作</p><ul><li>影响计算机系统的通用性和可扩展性</li><li>影响计算机系统综合处理能力及性价比</li></ul></li></ul><p>输入/输出设备分类：</p><ul><li>信息传输视角：分为输入设备、输出设备和输入输出设备</li><li>交互功能视角：分为人机交互设备、存储设备和机机通信设备</li><li>设备管理视角：分为字符设备、块设备和网络设备</li></ul><h4 id="设备管理的目标">2. 设备管理的目标</h4><p>解决设备和CPU速度的不匹配，使主机和设备充分并行工作，提高设备使用效率。</p><p>屏蔽设备的物理细节和操作过程，配置驱动程序，提供同一界面。</p><ul><li>抽象为裸设备</li><li>抽象为设备文件</li></ul><h4 id="设备管理的功能">3. 设备管理的功能</h4><ul><li>设备中断管理</li><li>缓冲区管理</li><li>设备的分配与去配</li><li>设备驱动调度</li><li>虚拟设备的实现</li></ul><h4 id="设备管理的实现层次">4. 设备管理的实现层次</h4><ul><li>输入/输出硬件<ul><li>输入/输出设备及其接口线路</li><li>控制部件</li><li>通道</li></ul></li><li>输入/输出软件<ul><li>系统输入/输出软件</li><li>用户空间输入/输出软件</li></ul></li></ul><h3 id="输入输出控制方式">4.1.2 输入/输出控制方式</h3><h4 id="设备控制器">1. 设备控制器</h4><p>为达到模块化和通用性的设计目标，通常分开设置设备的机械部件和电子部件。</p><p>电子部件成为设备控制器，又称为设备适配器、输入/输出控制器(模块/接口等)。</p><p>系统与控制器交互，而非与设备交互，设备控制器具体控制设备进行输入/输出。</p><h5 id="设备控制器的功能">设备控制器的功能</h5><p>设备控制器是CPU与设备之间的接口。</p><ul><li>接受和识别CPU或通道发来的命令</li><li>实现数据交换</li><li>发现和记录设备及其自身的状态信息，供CPU处理时使用</li><li>当连接多台设备时，识别设备地址</li></ul><h4 id="三种基本输入输出控制方式">2. 三种基本输入/输出控制方式</h4><h5 id="轮询方式">轮询方式</h5><ul><li>处理器向控制器发送输入/输出命令，轮询输入/输出结果</li><li>若设备未就绪，则重复测试过程，直至设备就绪</li><li>执行内存数据交换</li><li>等待输入/输出操作完成后，处理器才可以继续其他操作</li></ul><h5 id="中断方式">中断方式</h5><ul><li>处理器向控制器发出具体输入/输出命令，然后继续执行后续指令<ul><li>若进程支持异步输入/输出，后续指令仍然可以是该进程中指令</li><li>否则该进程在这个中断上挂起，处理器执行其他工作</li></ul></li><li>控制器检查设备状态，就绪后发出中断</li><li>CPU响应中断，进行中断处理，执行内存数据交换</li></ul><h5 id="dmadirect-memory-access直接存储器访问方式">DMA（Direct MemoryAccess，直接存储器访问）方式</h5><p>DMA模块：替代处理器来控制主存和设备控制器间的数据交换</p><ul><li>处理器向DMA模块发出输入/输出命令</li><li>处理器继续执行其他工作，DMA模块负责传送全部数据</li><li>数据传送结束后，DMA中断处理器</li></ul><h5 id="dma方式中的周期窃取">DMA方式中的周期窃取</h5><p>DMA和CPU同时通过总线访问内存，CPU会把总线的占有权让给DMA一个或几个主存周期。</p><p>周期窃取对CPU与主存的数据交换影响不大</p><ul><li>数据传送过程是不连续、不规则的</li><li>CPU大部分情况下与Cache进行数据交换，直接访问内存较少</li></ul><p>总结：</p><ul><li>轮询：CPU等待设备就绪，参与内存数据交换</li><li>中断：CPU不等待设备就绪，响应中断后参与内存数据交换</li><li>DMA：CPU不等待设备就绪，不参与主存数据交换</li></ul><h4 id="输入输出通道及其工作方式">3. 输入/输出通道及其工作方式</h4><h5 id="输入输出通道">输入/输出通道</h5><p>又称为通道控制器、输入/输出处理器，用于完成逻辑上独立的输入/输出任务。</p><p>采用四级连接：处理器、通道、控制器、设备</p><ul><li>通道可控制多台同类或不同类设备</li></ul><p>处理器不再执行输入/输出指令，而是在主存中组织通道程序，由输入/输出通道执行。</p><h5 id="输入输出通道的工作流程">输入/输出通道的工作流程</h5><ol type="1"><li>CPU遇到输入/输出任务，组织通道程序，置通道程序地址字CAW，启动指定通道</li><li>通道从CAW获得通道程序，控制输入/输出设备进行操作，CPU执行其他任务</li><li>输入/输出操作完成后，输入/输出通道发出中断，CPU处理中断，并从通道程序状态字CSW获得通道执行情况，处理输入/输出操作</li></ol><ul><li>CPU与通道高度并行工作</li></ul><h3 id="总线与输入输出">4.1.3 总线与输入/输出</h3><h4 id="总线对输入输出的影响">1. 总线对输入/输出的影响</h4><ul><li>输入/输出和CPU速度不匹配、各设备输入/输出速度不匹配</li><li>总线使主机和设备充分并行，提高系统效率</li></ul><h4 id="几种经典总线模型">2. 几种经典总线模型</h4><h5 id="单总线结构模型">单总线结构模型</h5><p>将CPU、主存和输入/输出模块连接到同一总线</p><ul><li><p>优点：结构简单、易于扩充</p></li><li><p>缺点：设备多时总线压力大，传输时间延长，慢速外设占用带宽多</p></li></ul><h5 id="三级总线模型">三级总线模型</h5><p>主存和Cache通过主存总线连接，主存总线和扩展总线上的输入/输出设备通过扩展总线接口缓冲</p><ul><li>优点：主存和输入/输出之间的数据传送、处理器的内存活动分离，可以支持更多输入/输出设备</li><li>缺点：不适用于输入/输出设备数据速率相差太大的情形</li></ul><h5id="南桥输入输出控制器与北桥主存控制器">南桥（输入/输出控制器）与北桥（主存控制器）</h5><p>通过存储总线、PCI总线、E(ISA)总线分别连接主存、高速输入/输出设备和低速输入/输出设备。</p><p>优点：可以支持不同数据速率的输入输出设备。</p><pre><code class=" mermaid">graph LRCPU--处理器总线---北桥--存储总线---Cache北桥--桥间接口---南桥南桥---PCI总线---E总线</code></pre><h5 id="一种基于通道的服务器总线模型">一种基于通道的服务器总线模型</h5><p>支持CPU、主存和多个输入/输出通道之间的数据传送</p><p>支持输入/输出通道和输入/输出控制器，以及输入/输出控制器和设备之间的数据传送。</p><ul><li>CPU通过主存控制器连接主存</li><li>CPU、主存和主存控制器均连接在一条与各个输入/输出通道连接的总线上</li><li>各个输入/输出通道分别与负责的输入/输出控制器连接</li><li>各个输入/输出控制器分别与负责的设备连接</li></ul><h2 id="设备管理软件">4.2 设备管理软件</h2><h3 id="输入输出软件的实现层次">4.2.1 输入/输出软件的实现层次</h3><h4 id="输入输出软件的设计">1. 输入/输出软件的设计</h4><p>设计目标：</p><ul><li>高效率：改善设备效率，尤其是磁盘输入/输出操作的效率</li><li>通用性：用统一标准来管理所有设备</li></ul><p>设计思路：</p><ul><li>把软件组织成层次结构，底层软件用来屏蔽硬件细节，高层软件向用户提供简洁、友善、统一的界面</li></ul><p>设计需要考虑的问题：</p><ul><li>设备无关性：访问设备的程序与具体设备无关</li><li>出错处理：低层软件能处理的错误不让高层软件感知</li><li>同步/异步传输：支持阻塞和中断驱动两种工作方式</li><li>缓冲技术：建立内存数据缓冲区，提高吞吐量</li></ul><h4 id="输入输出软件的实现层次-1">2. 输入/输出软件的实现层次</h4><p>从低到高有：</p><ol type="1"><li>输入/输出硬件：执行输入/输出操作</li><li>输入/输出中断处理程序：处理输入/输出中断，报告输入/输出错误，唤醒输入/输出设备驱动程序</li><li>输入/输出设备驱动程序：设备寄存器初始化，启动输入/输出操作，检查输入/输出状态</li><li>独立于设备的输入/输出软件：设备的命名、保护、阻塞、缓冲、分配、跟踪</li><li>用户空间的输入/输出软件：输入/输出系统调研、输入/输出格式化、SPOOLing</li></ol><h3 id="输入输出软件的实现">4.2.2 输入/输出软件的实现</h3><h4 id="输入输出中断处理程序">1. 输入/输出中断处理程序</h4><p>输入/输出中断处理程序位于操作系统底层，与硬件设备密切相关，与系统其余部分尽可能少地发生联系。</p><ul><li>进程请求输入/输出操作时，通常被阻塞</li><li>数据传输结束后产生输入/输出中断</li><li>CPU响应请求并转入中断处理程序</li></ul><h5 id="输入输出中断处理程序的功能">输入/输出中断处理程序的功能</h5><p>检查设备状态寄存器，判断中断原因，根据输入/输出操作完成情况进行相应处理</p><ul><li>如果数据传输有误，向上层软件报告设备出错信息，实施重新执行</li><li>如果正常结束，唤醒等待传输的进程，使其转换为就绪态</li><li>如果有等待传输的输入/输出命令，通知相应软件开启下一个输入/输出请求</li></ul><h4 id="设备驱动程序">2. 设备驱动程序</h4><ul><li>包括与设备密切相关的所有代码</li><li>从独立于设备的软件中接受输入/输出请求</li><li>把用户提交的逻辑输入/输出请求转化为物理输入/输出操作的启动和执行</li><li>监督设备是否正确执行，访问数据缓冲区，进行必要的纠错处理</li></ul><h5 id="设备驱动程序的功能">设备驱动程序的功能</h5><ul><li>设备初始化：在设备传输数据时，预置设备、控制器以及通道状态</li><li>执行设备驱动例程：负责启动设备，进行数据传输；对于通道，负责组织通道程序，启动通道工作</li><li>执行与设备相关的具体中断处理，负责处理设备、控制器及通道所发出的各种具体中断</li></ul><h5 id="设备驱动程序的层次">设备驱动程序的层次</h5><p>每个设备驱动程序原则上只处理一种设备，或者一类紧密相关的设备。</p><p>设备驱动程序的分层实现：</p><ul><li>高层/处理类设备，底层/处理具体设备</li><li>系统建立栈，接到输入/输出请求时先调用栈顶的驱动程序，然后继续向下调用底层驱动程序，直至所有物理操作被处理</li><li>这一方式使设备驱动的实现结构清晰，易于移植，但会增加一部分系统开销</li></ul><h4 id="独立于设备的输入输出软件">3. 独立于设备的输入/输出软件</h4><p>执行适用于所有设备的常用输入/输出功能，并向用户层软件提供一致性接口，包括：</p><ul><li>设备命名：通过路径名寻址设备</li><li>设备保护：用户是否有权访问设备</li><li>提供与设备无关的数据单位：字符、块</li><li>缓冲技术：调整CPU与输入/输出速度不匹配</li><li>分配和状态跟踪：分配设备</li><li>错误处理与报告：驱动无法处理的错误</li></ul><h4 id="用户空间的输入输出软件">4. 用户空间的输入/输出软件</h4><ul><li>库函数：操作系统内核外，使用库函数实现的输入/输出软件，运行时与应用程序链接</li><li>虚拟设备：用一类设备模拟另一类设备的仿真输入/输出软件</li></ul><h3 id="输入输出缓冲">4.2.3 输入/输出缓冲</h3><h4 id="输入输出缓冲-1">1. 输入/输出缓冲</h4><h5 id="设置输入输出缓冲的目的">设置输入/输出缓冲的目的</h5><ul><li>解决CPU与设备之间速度不匹配的矛盾</li><li>协调逻辑记录大小和物理记录大小不一致的问题</li><li>提高CPU和设备的并行性</li><li>减少输入/输出操作对CPU的中断次数</li><li>放宽对CPU中断响应时间的要求</li></ul><h5 id="输入输出缓冲区">输入/输出缓冲区</h5><p>在内存中开辟的存储区，专门用于临时存放输入/输出操作的数据</p><p>操作过程：</p><ul><li>写操作：将数据送至缓冲区，直到写满或需要写出，待适当时候系统将缓冲区内容写到设备上</li><li>读操作：系统将设备上的物理记录读至缓冲区，根据要求将当前所需要的数据从缓冲区中读出并传送给进程</li></ul><h4 id="几种缓冲技术">2. 几种缓冲技术</h4><h5 id="单缓冲技术">单缓冲技术</h5><p>操作系统在主存系统区中开设一个缓冲区。</p><ul><li>输入：先把数据读至缓冲区，再把缓冲区数据送至用户区，应用程序处理数据，如此往复，系统继续读入后续数据</li><li>输出，把数据从用户区传送至缓冲区，再将数据输出至设备，应用程序继续请求输出</li></ul><h5 id="双缓冲技术">双缓冲技术</h5><p>操作系统在主存系统区开设两个缓冲区。</p><ul><li>输入：先把数据输入缓冲区1，再从缓冲区1把数据传到用户区，供应用程序处理（同时设备可将数据传送到缓冲区2）</li><li>输出：先将数据从用户区传送到缓冲区1，再将数据传送到设备（同时应用程序可将数据传送到缓冲区2）</li></ul><h5 id="循环缓冲技术">循环缓冲技术</h5><p>操作系统分配一组缓冲区，每个缓冲区有指向下一个缓冲区的链接指针，构成循环</p><ul><li>调节设备和进程速度不匹配的问题</li></ul><h2 id="独占型外围设备的分配">4.3 独占型外围设备的分配</h2><h3 id="设备独立性">4.3.1 设备独立性</h3><ul><li><p>用户通常不指定物理设备，而是指定逻辑设备，使得用户进程和物理设备分离，再通过其他途径建立逻辑设备和物理设备间的映射。</p></li><li><p>设备管理中需要将逻辑设备名转换为物理设备名，为此系统需要提供逻辑设备名和物理设备名的对应表以供转换使用</p></li></ul><h4 id="设备独立性的优点">设备独立性的优点</h4><ul><li>应用程序与具体物理设备无关，系统增减或变更设备时不需要修改原程序</li><li>易于应对各种输入/输出设备故障，提高系统的可靠性</li><li>增加设备分配的灵活性，有利于更加有效地利用设备资源，实现多道程序设计</li></ul><h3 id="独占型外围设备的分配-1">4.3.2 独占型外围设备的分配</h3><h4 id="设备分配方式">设备分配方式</h4><p>独占型外围设备：一次只能由一个进程独占使用</p><p>分配方式：</p><ul><li>静态分配：进程运行前申请<ul><li>实现简单，能防止系统发生死锁，但会降低设备利用率</li></ul></li><li>动态分配：进程随用随申请<ul><li>提高设备利用率</li></ul></li></ul><h4 id="设备分配的数据结构">设备分配的数据结构</h4><p>设备类表</p><ul><li>每类设备对应于设备类表中的一栏</li><li>包括设备类、总台数、空闲台数、设备表起始地址等</li><li>支持设备独立性</li></ul><p>设备表</p><ul><li>每类设备有各自的设备表，用来登记这类设备的每台物理设备</li><li>包括：物理设备名，逻辑设备名，占有设备的进程，分配标志，好/坏标志等</li></ul><h2 id="共享型外围设备的驱动">4.4 共享型外围设备的驱动</h2><h3 id="磁盘的物理结构">4.4.1 磁盘的物理结构</h3><h4 id="磁盘结构">1. 磁盘结构</h4><ul><li>磁盘一般由多个盘片组成</li><li>每个盘片一般由两个盘面</li><li>盘面包括多个同心圆结构的磁道，不同盘面上位于相同位置的磁道构成柱面</li><li>每个磁道分为固定多个扇区，相邻扇区组合成簇</li><li>物理块的地址：<ul><li>柱面号，磁道号，扇区号</li><li>0面0道1扇区（此处面指磁头而不是柱面）</li></ul></li></ul><h4 id="磁盘读写数据的方式">2. 磁盘读写数据的方式</h4><p>读写数据时，磁头必须定位到指定磁道上的指定扇区的开始处，过程为：</p><ol type="1"><li>寻道：控制移动臂到达指定柱面</li><li>旋转：等待要读写的扇区旋转到磁头下</li><li>选择磁头号，进行数据传送</li></ol><h4 id="磁盘存取时间">3. 磁盘存取时间</h4><p>磁盘完成数据读写所需要的时间，是寻道时间、旋转延迟、传送时间的总和。</p><p><spanclass="math inline">\(T_a=T_s+\frac{1}{2r}+\frac{b}{rN}\)</span></p><p>其中，<span class="math inline">\(T_a\)</span>为存取时间，<spanclass="math inline">\(T_s\)</span>为寻道时间，<spanclass="math inline">\(r\)</span>为磁盘旋转速度（转/秒），<spanclass="math inline">\(b\)</span>为要传送的字节数，<spanclass="math inline">\(N\)</span>为一个磁道中的字节数。</p><h3 id="磁盘的驱动调度">4.4.2 磁盘的驱动调度</h3><p>磁盘可能同时接收到若干输入/输出请求，如果随机响应，性能会很差。</p><p>驱动调度：操作系统的磁盘调度策略，按照最佳次序执行处理访问磁盘的多个输入/输出请求，以减少磁盘访问的总处理时间。</p><p>驱动调度策略有移臂调度和旋转调度。</p><h4 id="移臂调度及其算法">移臂调度及其算法</h4><ul><li><p>目的：使移动臂的移动时间最短以减少寻道总时间</p></li><li><p>算法：</p><ul><li>先来先服务：移臂距离大，性能差</li><li>最短查找时间优先<ul><li>先执行查找时间最短的请求，寻道性能较好</li><li>存在“饥饿”现象</li></ul></li><li>单向扫描：移动臂向一个方向扫描，归途不提供服务</li><li>双向扫描：移动臂向一个方向移动，到达最后一个柱面再向反方向移动</li><li>电梯调度：改进双向扫描，当前移动方向没有访问请求时就改变方向</li></ul></li></ul><h4 id="旋转调度及其策略">旋转调度及其策略</h4><p>目的：使旋转延迟的总时间最少</p><p>循环排序：</p><ul><li><p>通过优化输入/输出请求排序，在最少旋转圈数内完成位于同一柱面的访问请求</p></li><li><p>旋转位置测定硬件和多磁头同时读写技术有利于提高旋转调度的效率</p></li></ul><p>优化分布：</p><ul><li>通过信息在存储空间的排列方式来减少旋转延迟</li><li>交替排序：由于磁盘匀速旋转，可能处理当前扇区数据时，下个扇区已经跳过。因此，可对扇区间隔编号，交叉因子为n:1表示相邻编号间间隔n-1个扇区</li><li>相邻扇区集中成簇读写</li><li>按柱面集中存储数据，可以减少数据读写时的移臂操作</li></ul><h2 id="虚拟设备">4.5 虚拟设备</h2><h3 id="spooling系统">4.5.1 SPOOLing系统</h3><h4 id="虚拟设备-1">1. 虚拟设备</h4><p>使用一类物理设备模拟另一类物理设备的技术。</p><p>示例：</p><ul><li>内存模拟磁盘</li><li>块设备模拟字符设备</li><li>输入输出重定向</li></ul><h4 id="spooling系统-1">2. SPOOLing系统</h4><p>SPOOLing（Simultaneous Peripheral OperationsOn-Line，外部设备联机并行操作），是关于慢速字符设备如何与计算机主机交换信息的一种技术，通常称为“假脱机技术”。</p><p>一个经典的SPOOLing系统：</p><ul><li>用高速的磁盘设备来模拟慢速的字符设备，缩短进程在内存中的驻留时间</li><li>慢速输出设备先输出到输出井</li><li>进程运行过程中只从输入井读入数据，只向输出井输出数据，使得全部输入/输出都基于磁盘</li><li>加快进程周转时间，提高系统吞吐量</li></ul><p>该系统的软件组成：</p><ul><li>预输入系统：预先把数据从输入设备传送到磁盘输入井</li><li>缓输出设备：把数据从磁盘输出并传送到输出设备</li><li>井管理程序：控制进程和井之间的数据交换（输入/输出重定向）</li></ul><p>打印SPOOLing系统：打印机守护进程和SPOOLing打印目录</p><ul><li>守护进程是唯一有特权使用打印机设备的进程</li><li>打印文件前，用户进程先产生完整的待输出文件，存放在打印目录下</li><li>打印机空闲时，启动守护进程，打印待输出文件</li></ul><h3 id="批处理系统的作业管理">4.5.2 批处理系统的作业管理</h3><ul><li>作业说明语言：用于作业控制的语言</li><li>作业说明书：刻画具体作业的控制方式</li><li>作业状态：输入状态（预输入）、后备状态（空闲）、运行状态（运行）、完成状态（缓输出）</li><li>作业调度：从后备状态作业中选择部分进入运行状态</li><li>作业调度算法：优先数、短作业、响应比、设备搭配等</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第三章_存储管理</title>
    <link href="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第三章-存储管理">第三章 存储管理</h1><h2 id="存储管理基础">3.1 存储管理基础</h2><h3 id="基本内容">3.1.1 基本内容</h3><p>逻辑地址(相对地址)，用户编程所使用的地址空间，从0开始编号，两种形式：</p><ol type="1"><li>一维，即地址</li><li>二维，段号：段内地址</li></ol><p>物理地址(绝对地址)，处理器执行指令时按照物理地址进行。</p><h4 id="段式程序设计">段式程序设计</h4><p>将一个程序设计成多个段(代码段、数据段、堆栈段，等等)。</p><p>用户可以应用段覆盖技术(程序设计技术)扩展内存空间使用量。</p><h4 id="主存储器的复用">主存储器的复用</h4><p>多道程序设计需要复用主存</p><ul><li>按照分区复用</li></ul><p>主存划分为多个固定/可变尺寸的分区，一个程序/程序段占用一个分区</p><ul><li>按照页架复用</li></ul><p>主存划分为多个固定大小的页架，一个程序/程序段占用多个页架</p><h4 id="存储管理的基本模式">存储管理的基本模式</h4><ol type="1"><li>单连续存储管理：一维逻辑地址空间的程序占用一个主存固定/可变分区</li><li>段式存储管理：段式二维逻辑地址空间的程序占用多个主存可变分区</li><li>页式存储管理：一维逻辑地址空间的程序占用多个主存页架区</li><li>段页式存储管理：段式二维逻辑地址空间的程序占用多个主存页架区</li></ol><figure><img src="/image/计算机操作系统/存储管理基本模式.png"alt="存储管理基本模式" /><figcaption aria-hidden="true">存储管理基本模式</figcaption></figure><h3 id="存储管理功能">3.1.2 存储管理功能</h3><p>地址转换：又称重定位，将逻辑地址转换为绝对地址</p><p>静态重定位：程序装入内存时进行重定位，早期小型OS使用，由装入程序执行</p><p>动态重定位：CPU执行程序时进行重定位，效率依赖硬件地址转换机构</p><h4 id="主存储器空间的分配和去配">主存储器空间的分配和去配</h4><ul><li><p>分配：进程装入主存时，存储管理软件进行具体的主存分配操作，并设置表格记录主存空间的分配情况</p></li><li><p>去配：当某个进程撤离或主动归还主存资源时，存储管理软件收回其占用的全部或部分存储空间，调整主存分配表信息</p></li></ul><h4 id="主存储器空间的共享">主存储器空间的共享</h4><ul><li>多个进程共享主存储器资源：多道程序设计技术使若干个程序同时进入主存储器，各自占用一定数量的存储空间，共同使用一个主存储器</li><li>多个进程共享主存储器的某些区域：若干个协作进程有共同的主存程序或者主存数据块</li></ul><h4 id="存储保护">存储保护</h4><p>为避免主存中多个进程相互干扰，须对主存中程序和数据进行保护：</p><ul><li>私有主存区信息：可读写</li><li>公共区共享信息：根据授权</li><li>非本进程信息：不可读写</li></ul><p>需软硬件协同完成：CPU检查是否允许访问，不允许则产生地址保护异常。</p><h4 id="主存空间的扩充">主存空间的扩充</h4><p>存储扩充：把磁盘作为主存扩充，只把部分进程或进程的部分内容装入内存</p><ol type="1"><li>对换技术：把部分不运行的进程调出</li><li>虚拟技术：只调入进程的部分内容</li></ol><p>需软硬件协同完成：</p><ol type="1"><li>对换进程决定对换，硬件机构调入</li><li>CPU处理到不在主存的地址，发出虚拟地址异常，OS将其调入再执行指令</li></ol><h3 id="虚拟存储器">3.1.3 虚拟存储器</h3><p>主存容量限制了用户编程与多道程序设计的道数—&gt;部分调入进程内容。</p><h4 id="虚拟存储器的基本思想">虚拟存储器的基本思想</h4><ol type="1"><li>存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，之后根据执行行为随用随调</li><li>若主存空间不足，存储管理根据执行将主存中暂时不用的信息调出到辅存</li></ol><h4 id="实现思路">实现思路</h4><p>建立和自动管理两个地址空间</p><ol type="1"><li>主存：实际地址空间，承载进程执行</li><li>辅存：虚拟地址空间，容纳进程装入</li></ol><p>对于用户，计算机系统具有一个容量大得多的主存空间，即虚拟存储器</p><p>虚拟存储器是一种地址空间扩展技术，通常意义上对用户编程是透明的，除非用户需要进行高性能程序设计。</p><h3 id="存储管理的硬件支撑">3.1.4 存储管理的硬件支撑</h3><h4 id="存储器的组织层次">存储器的组织层次</h4><figure><img src="/image/计算机操作系统/存储器组织层次.png"alt="存储器组织层次" /><figcaption aria-hidden="true">存储器组织层次</figcaption></figure><p>存储管理是操作系统管理主存储器的软件部分。</p><p>为了更好的处理性能，部分主存程序与数据被调入Cache；</p><p>为了获得更大虚拟地址空间，存储管理需要管理更大的虚拟存储器。</p><h4 id="高速缓冲存储器cache">高速缓冲存储器(Cache)</h4><p>介于CPU和主存间的高速小容量存储器。</p><p>构成：高速存储器、联想存储器、地址转换部件、替换部件等。</p><ol type="1"><li>联想存储器：根据内容进行寻址的存储器</li><li>地址转换部件：通过联想存储器建立目录表以实现快速地址转换，命中时直接访问Cache，未命中时从内存读取放入Cache</li><li>替换部件：缓存已满时按一定策略进行数据块替换，并修改地址转换部件</li></ol><p>组织：由于中央处理器芯片面积和成本，Cache很小</p><p>根据成本控制，划分为L1、L2、L3三级。</p><ol type="1"><li>L1Cache：分为数据缓存和指令缓存，内置，成本最高，对CPU性能影响最大，通常在32-256KB</li><li>L2 Cache：分内置和外置两种，后者性能低。通常在512KB-8MB</li><li>L3 Cache：多为外置，在游戏和服务器领域有效。</li></ol><p>对很多应用而言，改善总线比设置L3更加有利于提升系统性能</p><h4 id="存储管理与硬件支撑">存储管理与硬件支撑</h4><ol type="1"><li>程序执行与数据访问的局部性原理—&gt;使用Cache可大幅提升程序执行效率</li><li>动态重定位、存储保护等，无硬件支撑在效率上无意义</li><li>无虚拟地址中断，虚拟存储器无法实现</li><li>无页面替换等硬件支撑机制，虚拟存储器在效率上无意义</li></ol><p>存储保护的硬件支撑：限长寄存器与逻辑地址比较判断是否越界</p><p>地址转换的硬件支撑：基址寄存器与逻辑地址运算得物理地址</p><h2 id="单连续分区存储管理">3.2 单连续分区存储管理</h2><p>每个进程占用一个物理上完全连续的存储空间。</p><p>分为：单用户连续分区存储管理、固定分区存储管理、可变分区存储管理</p><h3 id="单用户连续分区存储管理">3.2.1 单用户连续分区存储管理</h3><ol type="1"><li>主存区域划分为系统区和用户区</li><li>设置一个栅栏寄存器界分两个区域，硬件用其在执行时进行存储保护</li><li>一般使用静态重定位进行地址转换</li></ol><p>硬件实现代价低，适用于单用户单任务操作系统，如DOS。</p><h4 id="静态重定位">静态重定位</h4><p>装入作业时，把该作业中程序的指令地址和数据地址全部转换为绝对地址。</p><h3 id="固定分区存储管理">3.2.2 固定分区存储管理</h3><p>硬件实现代价低，早期操作系统采用</p><p>基本思想：支持多个数量、大小固定的分区</p><p>使用主存分配表(分区号，起始地址，长度，占用标志)，执行主存分配/去配。</p><p>固定分区会产生内存内零头，即内存分区中空闲的部分。</p><h3 id="三可变分区存储管理">三、可变分区存储管理</h3><p>创建进程时，根据进程所需主存查看主存中是否有足够空闲空间，有则分配，无则等待。由于分区大小为实际分配，其个数是随机变化的。</p><h4 id="主存分配表">主存分配表</h4><p>分为已分配区表和未分配区表，采用链表。</p><h4 id="内存分配">内存分配</h4><ul><li>最先适应分配算法</li><li>邻近适应分配算法</li><li>最优适应分配算法</li><li>最坏适应分配算法</li></ul><p>可变分区会随着进程的内存分配产生不可用的小内存分区，称为内存外零头。</p><p>任何算法难免产生外零头，最优适配算法最容易产生外零头。</p><h4 id="移动技术程序浮动技术">移动技术（程序浮动技术）</h4><p>移动分区以解决内存外零头，需要动态重定位支撑</p><h2 id="页式存储管理">3.3 页式存储管理</h2><h3 id="页式存储管理的基本原理">3.3.1 页式存储管理的基本原理</h3><ol type="1"><li>分页存储器将主存划分为多个大小相等的页架</li><li>逻辑地址被页架分成页</li><li>不同的页可以放在不同页架中，不需要连续</li><li>页表用于维系进程的主存完整性</li></ol><h4 id="地址">地址</h4><ol type="1"><li>逻辑地址由页号和单元号组成</li><li>物理地址由页架号和单元号组成</li><li>地址转换可以通过查页表完成</li></ol><h4 id="内存分配去配">内存分配/去配</h4><ol type="1"><li>可用位示图记录主存分配情况</li><li>建立进程页表维护主存逻辑完整性</li></ol><p>位示图：使用0和1表示磁盘中块的使用情况。</p><h4 id="页的共享">页的共享</h4><ol type="1"><li>数据共享：不同进程可以使用不同页号共享数据页</li><li>程序共享：不同进程必须使用相同页号共享代码页</li></ol><p>原因：共享代码页中的JMP <页内地址>使用不同页号是做不到的。</p><h3 id="页式存储管理的地址转换">3.3.2 页式存储管理的地址转换</h3><h4 id="页式存储管理的代价">页式存储管理的代价</h4><p>页表放在主存，每次地址转换需访问两次主存</p><ol type="1"><li>按页号读出页表中相应页架号</li><li>按计算出来的绝对地址进行读写</li></ol><p>这降低了存取速度—&gt;使用Cache存放部分页表，即快表。</p><h4 id="快表">快表</h4><p>存放在高速缓冲存储器中的页表部分</p><p>快表的表项：页号和页架号</p><p>这种高速存储器是联想存储器，即按照内容寻址，而非按照地址寻址。</p><p>基于快表的地址转换流程：</p><ol type="1"><li>按逻辑地址中的页号查快表</li><li>若在快表中，则由页架号和单元号生成绝对地址</li><li>不在快表中，再查主存页表形成绝对地址，同时登记该页到快表中</li><li>快表填满后，按一定策略淘汰一个旧登记项，登记新页</li></ol><h4 id="多道程序环境下的进程表">多道程序环境下的进程表</h4><p>进程表中登记了每个进程的页表，进程占有处理器运行时，其页表起始地址和长度送入页表控制寄存器。</p><p>多道程序环境下的地址转换：</p><figure><img src="/image/计算机操作系统/多道程序环境下的地址转换.png"alt="多道程序环境下的地址转换" /><figcaption aria-hidden="true">多道程序环境下的地址转换</figcaption></figure><h3 id="页式虚拟存储管理">3.3.3 页式虚拟存储管理</h3><p>基本思想：</p><p>把进程全部页面装入虚拟存储器，执行时先把部分页面装入实际内存，然后根据执行行为动态调入不在主存的页，并进行必要的页面调出。</p><ul><li>这是现代操作系统主流存储管理技术。</li></ul><p>首次只把进程第一页信息装入主存，称为请求页式存储管理。</p><h4 id="页式虚拟存储管理的页表">页式虚拟存储管理的页表</h4><p>扩充页表项，指出：</p><ul><li><p>每页的虚拟地址、实际地址</p></li><li><p>主存驻留标志、写回标志、保护标志、引用标志、可移动标志，等等</p></li></ul><p>实现</p><ul><li>中央处理器处理地址<ul><li>若页驻留，则获得块号形成绝对地址</li><li>若页不在内存，则中央处理器发出缺页中断</li></ul></li><li>操作系统处理缺页中断<ul><li>若有空闲页架，则根据辅存地址调入页，更新页表和快表等</li><li>若无空闲页架，则决定淘汰页，调出已修改页，调入页，更新页表与快表</li></ul></li></ul><figure><img src="/image/计算机操作系统/页式虚拟存储管理.png"alt="页式虚拟存储管理" /><figcaption aria-hidden="true">页式虚拟存储管理</figcaption></figure><figure><img src="/image/计算机操作系统/页式虚拟存储管理2.png"alt="页式虚拟存储管理2" /><figcaption aria-hidden="true">页式虚拟存储管理2</figcaption></figure><h3 id="页式存储管理的页面调度">3.3.4 页式存储管理的页面调度</h3><p>当主存空间已满又需要装入新页时，页式虚拟存储管理必须按一定的算法把已在主存的一些页调出去。选择淘汰页的工作即为页面调度。</p><p>若页面调度算法设计不当，会导致页面被反复淘汰、调入，这称为页面抖动。</p><h4 id="缺页中断率">缺页中断率</h4><p>衡量存储管理性能和用户编程水平的重要依据</p><p>假定进程P共n页，系统分配页架数m个，P运行中成功访问次数S，不成功访问次数F，总访问次数A=S+F，缺页中断率为：f=F/A。</p><p>影响缺页中断率的因素：</p><ul><li>分配给进程的页架数：可用页架数越多，缺页中断率越低</li><li>页面大小：页面尺寸越大，缺页中断率越低</li><li>用户编程方法：大数据条件下，对缺页中断率影响也很大</li></ul><h4 id="页面调度算法">页面调度算法</h4><ul><li><p>OPT页面调度算法</p><ul><li><p>由Belady提出，又称Belady算法。</p></li><li><p>只可模拟，不可实现。</p></li></ul><p>当要调入新页面时，先淘汰以后不再访问的页，后选择距现在最长时间后再访问的页。</p></li><li><p>先进先出算法(FIFO)：总是淘汰最先调入主存的页</p></li><li><p>最近最少用算法(LRU)：淘汰最近一段时间较久未被访问的页</p><ul><li>严格实现的代价大：维持特殊队列</li></ul></li><li><p>最不常用算法(LFU)：淘汰最近一段时间内访问次数较少的页</p></li><li><p>时钟调度算法：用循环队列构造页面队列，队列指针指向可能要淘汰的页</p></li></ul><p>LFU模拟OPT比LRU更接近。</p><p>时钟调度算法使用页引用标志位，工作流程：</p><ol type="1"><li><p>页面调入主存时，引用标志位被置为1</p></li><li><p>访问主存页面时，引用标志位被置为1</p></li><li><p>淘汰页面时，从指针当前指向的页面开始扫描循环队列</p><ul><li>将所遇到的引用标志位是1的页面的引用标志位清0，跳过</li><li>将所遇到的引用标志位是0的页面淘汰，指针推进</li></ul></li></ol><h3 id="反置页表">3.3.5 反置页表</h3><h4 id="反置页表的提出">反置页表的提出</h4><ul><li><p>页表及相关硬件机制在地址转换、存储保护、地址虚拟中发挥了关键作用</p><ul><li>为页式存储管理设置专门硬件机构</li></ul></li><li><p>内存管理单元（MMU）：中央处理器管理虚拟/物理存储器的控制线路，把虚拟地址映射成物理地址，提供存储保护，必要时确定淘汰页面</p></li><li><p>反置页表（IPT）：MMU的数据结构</p></li></ul><h4 id="反置页表的基本设计思想">反置页表的基本设计思想</h4><ol type="1"><li>对内存中每个页架建立一个页表，按照块号排序</li><li>用以完成内存页架到访问进程页号的对应，即物理到逻辑地址的转换</li></ol><h4 id="反置页表的页表项">反置页表的页表项</h4><ol type="1"><li>页号：虚拟地址页号</li><li>进程标识符：使用该页的进程号</li><li>标志位：有效、引用、修改、保护和锁定等标志信息</li><li>链指针：哈希链</li></ol><h4 id="基于反置页表的地址转换过程">基于反置页表的地址转换过程</h4><ol type="1"><li>MMU通过哈希表把进程标识和虚页号转换成一个哈希值，指向反置页表的一个表目</li><li>MMU遍历哈希链找到所需进程的虚页号，该项的索引就是页架号，通过拼接移位即可生成物理地址</li><li>若遍历反置页表未能找到匹配页表项，则产生缺页中断</li><li>选择淘汰页面也由MMU完成</li></ol><h2 id="段式存储管理">3.4 段式存储管理</h2><h3 id="段式程序设计-1">3.4.1 段式程序设计</h3><p>每个程序可由若干段组成，每一段都可以从0开始编址，段内的地址是连续的。</p><ul><li>分段存储器的逻辑地址由两部分组成<ul><li>段号：单元号</li></ul></li></ul><h4 id="基本思想">基本思想</h4><ul><li>段式存储管理基于可变分区存储管理实现，一个进程要占用多个分区。</li><li>硬件需要增加一组用户可见的段地址寄存器（代码段、数据段、堆栈段、附加段），供地址转换使用</li><li>存储管理需要增加设置一个段表，每个段占用一个段表项，包括：<ul><li>段始址、段限长、存储保护、可移动、可扩充等标志位</li></ul></li></ul><h4 id="地址转换流程">地址转换流程</h4><ol type="1"><li>从段表控制寄存器中得到当前段表</li><li>按逻辑地址中段号查段表</li><li>得到段始址和段限长</li><li>比较逻辑地址中的单元号和段限长<ul><li>若单元号&gt;段限长则发生越界中断</li><li>否则，绝对地址=段始址+单元号</li></ul></li></ol><h4 id="段的共享">段的共享</h4><ul><li>通过不同进程段表中的项指向同一个段基址来实现</li><li>对共享段的信息必须进行保护，如规定只能读不能写。不满足条件则产生保护中断</li></ul><h3 id="段式虚拟存储管理">3.4.2 段式虚拟存储管理</h3><h4 id="基本思想-1">基本思想</h4><p>把进程的所有分段都存放在辅存中，进程运行时先把当前需要的一段或几段装入主存，在执行过程中访问到不在主存的段时再把它们动态装入。</p><ul><li>段式虚拟存储管理中段的调入和调出由操作系统自动实现，对用户透明</li><li>与段覆盖技术不同，它是用户控制的主存扩充技术，操作系统不感知</li></ul><h4 id="段表扩充">段表扩充</h4><ul><li>特征位<ul><li>00：不在主存</li><li>01：在主存</li><li>11：共享段</li></ul></li><li>存取权限<ul><li>00：可执行</li><li>01：可读</li><li>11：可写</li></ul></li><li>扩充位<ul><li>0：固定长</li><li>1：可扩充</li></ul></li><li>标志位<ul><li>00：未修改</li><li>01：已修改</li></ul></li></ul><h4 id="地址转换流程-1">地址转换流程</h4><figure><img src="/image/计算机操作系统/段式虚拟存储管理的地址转换.png"alt="段式虚拟存储管理的地址转换" /><figcaption aria-hidden="true">段式虚拟存储管理的地址转换</figcaption></figure><h3 id="段页式存储管理">3.4.3 段页式存储管理</h3><h4 id="基本思想-2">基本思想</h4><p>段式存储管理可以基于页式存储管理实现，每一段不必占据连续的存储空间，可以存放在不连续的主存页架中。</p><ul><li>可以扩充出段页式虚拟存储管理：装入部分段，或者装入段中部分页面</li></ul><p>段表项为标志、页表始址和页表长，页表项为标志和块号。</p><h4 id="段页式存储管理的地址转换">段页式存储管理的地址转换</h4><figure><img src="/image/计算机操作系统/段页式存储管理的地址转换.png"alt="段页式存储管理的地址转换" /><figcaption aria-hidden="true">段页式存储管理的地址转换</figcaption></figure><h4 id="段页式虚拟存储管理的地址转换">段页式虚拟存储管理的地址转换</h4><figure><img src="/image/计算机操作系统/段页式虚拟存储管理的地址转换.png"alt="段页式虚拟存储管理的地址转换" /><figcaption aria-hidden="true">段页式虚拟存储管理的地址转换</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第二章_处理器管理文件</title>
    <link href="/2023/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6/"/>
    <url>/2023/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第二章-处理器管理文件">第二章 处理器管理文件</h1><h2 id="处理器">2.1 处理器</h2><h3 id="处理器与寄存器">2.1.1 处理器与寄存器</h3><h4 id="处理器部件的简单示意">处理器部件的简单示意</h4><figure><img src="/image/计算机操作系统/处理器部件简单示意.png"alt="处理器部件简单示意" /><figcaption aria-hidden="true">处理器部件简单示意</figcaption></figure><h4 id="用户程序可见寄存器">用户程序可见寄存器</h4><ul><li><p>可以让程序员减少访问主存储器次数，提高指令执行的效率</p></li><li><p>所有程序可使用，包括应用程序和系统程序</p></li></ul><ol type="1"><li>数据寄存器，又称通用寄存器</li><li>地址寄存器：索引、栈指针、段地址等寄存器</li></ol><h4 id="控制与状态寄存器">控制与状态寄存器</h4><p>用于控制处理器的操作，主要被具有特权的操作系统程序使用</p><ol type="1"><li>程序计数器：存储将取指令的地址</li><li>指令寄存器：存储最近使用的指令</li><li>条件码：中央处理器为指令操作结果设置的位，标志正/负/零、溢出等结果</li><li>标志位：中断位、中断允许位、中断屏蔽位、处理器模式位、内存保护位等</li></ol><h4 id="程序状态字psw">程序状态字（PSW）</h4><p>记录当前程序运行的动态信息。</p><p>通常包含：</p><ul><li>程序计数器、指令寄存器、条件码</li><li>中断字、中断允许/禁止、中断屏蔽、处理器模式、内存保护、调试控制</li></ul><p>程序状态字也是计算机系统的寄存器。</p><ul><li>通常设置一组控制与状态寄存器，也可以专设一个程序状态字寄存器</li></ul><h3 id="指令与处理器模式">2.1.2 指令与处理器模式</h3><h4 id="机器指令">机器指令</h4><p>计算机系统执行的基本命令，中央处理器执行的基本单位</p><ul><li><p>指令由一个或多个字节组成，包括操作码、操作数地址、状态字以及特征码。</p></li><li><p>指令完成各种算术逻辑运算、数据传输、控制流跳转。</p></li></ul><p>指令执行过程</p><ol type="1"><li>取指：根据程序计数器从存储器或高速缓冲存储器中取指令到指令寄存器</li><li>译码：解译指令寄存器中的指令</li><li>执行：连接中央处理器，执行运算</li></ol><h4 id="特权指令与处理器模式">特权指令与处理器模式</h4><p>与计算机核心资源相关的特殊指令会被保护，只能被操作系统程序使用。</p><p>特权指令：只能被操作系统内核使用的指令。</p><p>处理器模式：管理特权指令</p><p>设置0、1、2、3等运行模式，执行规定的指令子集。</p><p>0：操作系统内核</p><p>1：系统调用</p><p>2：共享库程序</p><p>3：用户程序</p><p>0模式可执行全部指令，3模式只能执行非特权指令。</p><p>一般而言，现代操作系统只使用0和3两种模式，即内核模式与用户模式。</p><p>处理器模式切换：中断、异常或系统异常等事件导致用户程序向OS内核切换。</p><h2 id="中断">2.2 中断</h2><h3 id="中断的概念">2.2.1 中断的概念</h3><p>在程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转而执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程，称为中断。</p><ul><li>操作系统是中断驱动的，换言之，中断是激活操作系统的唯一方式。</li></ul><p>由硬件产生的中断称为硬中断，可分为外中断和内中断</p><ol type="1"><li>外中断，也称中断（狭义）、异步中断，是来自处理器外的中断，如设备中断</li><li>内中断，也称异常，是来自处理器内部的中断，通常是程序执行过程中发生的与当前指令关联的不正常的事件，如访管、硬件故障、程序性异常</li></ol><p>外中断会根据中断优先级处理，内中断一旦出现则立即由异常处理程序处理。</p><h3 id="中断的响应和处理">2.2.2 中断的响应和处理</h3><p>在指令执行周期最后增加一个检查中断的微操作以响应中断。</p><p>中断系统是响应和处理中断的系统，包括硬件(响应)和软件(处理)子系统两部分</p><p>中断装置是计算机系统中发现并响应中断/异常的硬件装置。</p><ul><li><p>外中断；中断控制器发现和响应</p></li><li><p>异常：由指令的控制逻辑和实现线路发现和响应，Trap机制</p></li></ul><h4 id="中断控制器">中断控制器</h4><p>CPU的一个控制部件，包括中断控制逻辑线路、中断寄存器</p><ol type="1"><li>外部设备向其发出中断请求，在中断寄存器中设置已发生的中断</li><li>指令处理结束前，检查中断寄存器，若有不被屏蔽的中断产生，则改变处理器内操作顺序，引出操作系统中的中断处理程序</li></ol><h4 id="中断响应的一般过程">中断响应的一般过程</h4><ol type="1"><li>发现中断源：发现中断寄存器中中断，根据优先级决定是否响应</li><li>保护现场：将当前程序的PSW/PC保存至核心栈</li><li>处理中断</li><li>恢复现场</li></ol><h4 id="不同中断源的处理原则">不同中断源的处理原则</h4><ol type="1"><li>硬件故障中断：由处理器、内存储器、总线等硬件故障引起。</li></ol><p>保护现场，停止设备，停止中央处理器，报告操作员，等待人工干预。</p><ol start="2" type="1"><li>程序性中断：处理器执行机器指令引起。</li></ol><p>算术异常—简单处理，报告用户；也可由用户编写中断续元程序处理。</p><p>非法指令、用户态使用特权指令、地址越界、非法存取等指令异常：终止进程。</p><p>虚拟地址异常：调整内存后重新执行指令。</p><ol start="3" type="1"><li>访管/自愿性中断：由系统调用引起。</li></ol><p>保护现场，跳转具体处理程序。</p><ol start="4" type="1"><li>输入/输出中断：外围设备报告输入/输出状态。<ul><li>输入/输出完成：调整进程状态，释放等待进程</li><li>出错：等待人工干预</li></ul></li><li>外部中断：外围设备发出的信号引起。<ul><li>时钟中断、间隔时钟中断：记时和时间片处理</li><li>设备报到与结束中断：调整设备表</li><li>键盘/鼠标信号中断：根据信号相应反应</li><li>关机/重启中断：写回文件，停止设备和中央处理器</li></ul></li></ol><h3 id="多中断的响应和处理">2.2.3 多中断的响应和处理</h3><p>中断优先级：中断装置预设的对不同中断的响应顺序</p><p>中断屏蔽：高级中断事件屏蔽低级中断源（中断屏蔽位）</p><p>中断嵌套：高级中断嵌套在低级中断中，嵌套层数不宜太多。</p><h2 id="进程">2.3 进程</h2><h3 id="进程-1">2.3.1 进程</h3><p>进程是操作系统进行资源分配和调度的基本单位。</p><p>进程的概念：具有一定独立功能的程序关于某个数据集合的一次运行活动。</p><p>包括五个实体部分：</p><ol type="1"><li>操作系统管理运行程序的数据结构P</li><li>程序的内存代码C</li><li>程序的内存数据D</li><li>程序的通用寄存器信息R</li><li>操作系统控制程序执行的程序状态字PSW</li></ol><h4 id="三态模型">三态模型</h4><ul><li>就绪态：进程具有运行条件等待处理器运行</li><li>等待态：进程由于等待资源、输入输出、信号等而不具备运行条件</li><li>运行态：进程占有处理器运行</li></ul><ol type="1"><li>就绪态—&gt;运行态：处理器空闲时选择、优先进程抢占</li><li>运行态—&gt;等待态：等待资源、输入输出、信号</li><li>等待态—&gt;就绪态：资源满足、输入输出结束、信号完成</li><li>运行态—&gt;就绪态：运行时间片到、优先进程抢占</li></ol><p>此外，也有短暂的新建态和结束态，但并不属于三态模型的循环中。</p><h4 id="进程挂起">进程挂起</h4><ol type="1"><li>操作系统无法预期进程的数目和资源需求，系统运行过程中可能资源不足</li><li>运行资源不足将导致低性能与死锁</li><li>解决办法：剥夺某些进程的内存及其他资源，调入操作系统管理对换区，不参加进程调度，等合适时机调入内存、恢复资源、参与运行<ul><li>等待态占有已申请的资源，而挂起态不具有任何资源。</li></ul></li></ol><p>进程挂起和恢复的过程：</p><ol type="1"><li>一般使等待态进程进入挂起等待态，也可使就绪态进程进入挂起就绪态</li><li>运行态进程可以挂起自己进入挂起就绪态</li><li>等待事件结束后，挂起等待态进入挂起就绪态</li><li>一般恢复挂起就绪态进程为就绪态进程，也可恢复挂起等待态为等待态</li></ol><h3 id="进程的数据描述">2.3.2 进程的数据描述</h3><h4 id="进程映像">进程映像</h4><p>某时刻进程的内容及其状态集合，包括</p><ol type="1"><li>进程控制块 (Process Control Block，PCB)</li><li>进程程序块：被进程执行的程序，规定进程运行所应完成的功能</li><li>进程数据块：进程的私有地址空间，存放各种私有数据，用户栈也在数据块中，用于在函数调用时存放栈帧、局部变量和返回地址等</li><li>进程核心栈：进程在内核态工作时使用，用于保存中断现场，以及函数调用参数、局部变量和返回地址等</li></ol><h4 id="进程上下文">进程上下文</h4><p>进程物理实体和支持进程运行的环境，由三部分组成</p><ol type="1"><li>用户级上下文：程序块、数据块、共享内存区、用户栈</li><li>寄存器上下文：处理器状态寄存器、程序计数器、栈指针、通用寄存器</li><li>系统级上下文：进程控制块、内存管理信息、核心栈等操作系统管理进程所需信息</li></ol><p>当系统调度新进程占有处理器，新老进程随之发生上下文切换。</p><h4 id="进程控制块">进程控制块</h4><p>进程创建时建立进程控制块，进程销毁时回收进程控制块，与进程一一对应。</p><p>操作系统根据进程控制块对进程进行控制和管理。</p><p>进程控制块是操作系统记录和刻画进程状态及环境信息的数据结构，包含：</p><ol type="1"><li><p>标识信息：唯一地标识一个进程</p></li><li><p>现场信息：通用、控制寄存器内容、核心与用户栈指针、程序状态字等</p></li><li><p>控制信息：用于管理和调度进程</p></li><li><p>进程调度相关信息：进程状态、等待事件及原因、优先级、队列指针等</p></li><li><p>进程组成信息：代码、数据地址，进程映像在外存的地址</p></li><li><p>进程队列指引元：进程队列指针、父子进程指针</p></li><li><p>进程通信相关信息：消息队列、信号量、锁</p></li><li><p>进程处理器使用信息：占用的处理器、时间片、处理器使用时间</p></li><li><p>进程特权信息：内存访问权限、处理器特权</p></li><li><p>进程资源清单：正占有的资源、已使用的资源</p></li></ol><h3 id="进程管理">2.3.3 进程管理</h3><p>关键进程管理软件包括：</p><ol type="1"><li>系统调用/中断/异常处理</li><li>队列管理</li><li>进程控制</li><li>进程调度</li><li>进程通信</li><li>终端登录与作业控制、性能监控、审计程序等外围程序</li></ol><h4 id="进程队列">进程队列</h4><p>将处于同一状态的所有进程的PCB链接在一起的数据结构。</p><p>不同状态的进程可以排列成运行、就绪或等待队列，组织方式有：</p><ol type="1"><li>链接方式</li></ol><p>通过PCB的链接指针将同一状态进程的PCB链接，可采用单/双链表</p><ol start="2" type="1"><li>索引方式</li></ol><p>建立索引表，存放PCB地址或在PCB表中的编号</p><p>队列管理模块是操作系统实现进程管理的核心模块，进程与资源调度围绕进程队列展开。</p><h4 id="进程管理原语">进程管理原语</h4><p>操作系统通过原语来完成进程管理。常见的进程管理原语有：</p><ol type="1"><li>进程创建：在进程列表添加新进程，申请PCB并完成初始化</li><li>进程撤销：从队列中移除，归还资源，回收PCB，移除进程表项</li><li>进程阻塞：保存现场信息，修改PCB，移入等待队列，调度其他进程执行</li><li>进程唤醒：修改PCB，从等待队列移入就绪队列</li><li>进程挂起：修改状态，出入相关队列，收回资源</li><li>进程激活：修改状态，出入相关队列，分配内存</li><li>其他，如修改进程特权</li></ol><h4 id="处理器状态模式切换">处理器状态（模式）切换</h4><p>处理器状态从用户态到内核态，或从内核态到用户态。</p><p>当发生中断或系统调用，处理器状态从用户态切换到内核态。切换过程：</p><ol type="1"><li>保存被中断进程的处理器现场信息</li><li>处理器从用户态转换到内核态</li><li>处理中断或进行系统调用</li></ol><p>此时进程仍在自己的上下文中执行，仅处理器状态发生变化。</p><h4 id="进程切换">进程切换</h4><p>收回运行中进程占用的处理器，让待运行进程执行</p><p>实质上，进程切换就是进程上下文的切换：</p><ol type="1"><li>保存被中断进程的上下文</li><li>进程调度（队列管理）</li><li>恢复待运行进程的上下文</li></ol><p>进程切换的发生时机：一定发生在中断处理过程，也就是在内核态中。</p><p>P：可再入程序是能够被多个程序同时调用的程序，它是纯代码的。</p><h2 id="线程">2.4 线程</h2><h3 id="多线程环境">2.4.1 多线程环境</h3><h4id="单线程结构在并发程序设计上的问题">单线程结构在并发程序设计上的问题</h4><ul><li>进程切换、通信开销大</li><li>进程并发粒度受限，并行计算效率低</li></ul><p>解决办法：进程分配资源，线程调度执行。</p><h4 id="多线程">多线程</h4><p>在多线程环境中，进程是操作系统中进行资源分配与保护的独立单位，具有：</p><ul><li><p>容纳进程映像的虚拟地址空间</p></li><li><p>对进程、文件和设备的存取保护机制</p></li></ul><p>线程是进程的一条执行路径，是调度的基本单位。</p><p>同一个进程中所有线程共享进程获得的主存空间和资源，具有：</p><ul><li>线程唯一标识符和其状态</li><li>受保护的线程上下文</li><li>独立的程序计数器</li><li>执行堆栈</li><li>容纳局部变量的静态存储器</li></ul><p>线程的状态：运行(Active)、就绪(Runnable)和睡眠(Sleeping)</p><p>线程状态变化的相关操作：孵化、封锁、活化、剥夺、指派、结束</p><p>线程的调度：</p><p>操作系统感知线程环境：</p><ul><li><p>处理器调度线程</p></li><li><p>进程只有挂起状态</p></li></ul><p>操作系统不感知线程环境：</p><ul><li><p>处理器调度进程</p></li><li><p>用户空间中的用户调度程序调度线程</p></li></ul><h4 id="并发多线程程序设计的优点">并发多线程程序设计的优点</h4><ol type="1"><li>快速线程切换</li><li>减少系统管理开销</li><li>线程通信易于实现</li><li>并行程度提高</li><li>节省内存空间</li></ol><h3 id="多线程的实现">2.4.2 多线程的实现</h3><h4 id="内核级线程kltkernel-level-thread">内核级线程（KLT，Kernel-levelThread）</h4><ol type="1"><li>线程管理的所有工作交由操作系统内核</li><li>操作系统提供了使用KLT的程序设计接口</li><li>操作系统直接调度KLT</li></ol><p>内核级线程的特点：</p><ol type="1"><li>进程的一个线程阻塞，内核能调度同一进程的其他线程运行</li><li>多处理器环境中，内核能同时调度同一进程的多个线程并行执行</li><li>内核自身也可用多线程技术实现，提高操作系统执行速度和效率</li><li>应用程序线程在用户态而线程调度在内核态，因而线程切换需要模式切换，系统开销大</li></ol><h4 id="用户级线程ultuser-level-thread">用户级线程（ULT，User-levelThread）</h4><ol type="1"><li>用户空间运行的线程库提供多线程应用程序的开发和运行环境</li><li>任何应用程序需通过线程库进行程序设计，与线程库连接后运行</li><li>线程管理的所有工作由应用程序完成，内核不知道线程的存在</li></ol><p>用户级线程的特点</p><ol type="1"><li>线程切换不需要模式切换，系统开销小</li><li>允许进程按特定需要选择调度算法</li><li>能运行在任何操作系统上</li><li>不能利用多处理器，操作系统调度进程，只有一个ULT能执行</li><li>一个ULT的阻塞将引起整个进程的阻塞</li></ol><h4 id="jacketing技术">Jacketing技术</h4><p>将阻塞式操作系统改造为非阻塞的。</p><p>当线程陷入系统调用，执行Jacketing程序，检查资源使用，决定是否进行进程切换或线程切换。</p><h4 id="混合式线程">混合式线程</h4><p>在用户空间进行线程创建、调度与同步，单应用多个ULT可映射成一些KLT。</p><p>混合式线程的特点：</p><ol type="1"><li>组合用户级线程/内核级线程设施</li><li>程序员可针对特定应用和机器调节内核级线程数目以达更好效果</li><li>结合了纯粹用户级、内核级线程优点，减少其缺点</li></ol><figure><img src="/image/计算机操作系统/混合式线程调用.png"alt="混合式线程调用" /><figcaption aria-hidden="true">混合式线程调用</figcaption></figure><h2 id="处理器调度">2.5 处理器调度</h2><h3 id="处理器调度的层次">2.5.1 处理器调度的层次</h3><ul><li><p>高级调度，又称长程调度，作业调度，决定能否加入执行的进程池中</p><p>分时操作系统中，高级调度决定：</p><ul><li>是否接受终端用户连接</li><li>命令是否被系统接纳并构成进程</li><li>新建的进程是否加入就绪进程队列</li></ul><p>批处理操作系统中，高级调度又称为作业调度，按某种原则从后备作业队列中选取作业进入主存，并为作业做好运行前的准备和完成后的完善。</p></li><li><p>中级调度，又称平衡负载调度，决定主存中的可用进程集合</p><ul><li>提高内存利用率和作业吞吐量。</li><li>决定哪些进程被允许驻留在主存中参与竞争处理器及其他资源，起到短期调整系统负荷的作用。（将一些进程挂起）</li></ul></li><li><p>低级调度，又称短程调度，进程调度，决定哪个进程占用处理器执行</p><ul><li>按某种原则将处理器分配给就绪态进程或内核级线程。</li></ul></li></ul><p>进程调度程序，又称分派程序，是操作系统中实现处理器调度的程序。</p><figure><img src="/image/计算机操作系统/处理器调度.png" alt="处理器调度" /><figcaption aria-hidden="true">处理器调度</figcaption></figure><h3 id="处理器调度算法">2.5.2 处理器调度算法</h3><h4 id="选择处理器调度算法的原则">选择处理器调度算法的原则</h4><ol type="1"><li>资源利用率</li><li>响应时间：尽快处理实时任务</li><li>周转时间：提交给系统开始到执行完成获得结果为止的时间</li><li>吞吐量：单位时间处理的进程数</li><li>公平性：每个用户每个进程获得合理的资源份额</li></ol><h4 id="优先数调度算法">优先数调度算法</h4><p>根据分配给进程的优先数决定运行进程，分为抢占式和非抢占式</p><p>优先数的确定准则：</p><ul><li>任务的紧迫程度</li><li>交互性</li><li>使用外设的频度</li><li>进入系统时间长短</li></ul><p>一些优先数选择：</p><ul><li>计算时间短优先</li><li>剩余时间短优先</li><li>响应比（等待时间/进入时间）高优先</li><li>先来先服务FCFS：先进队先选择 (多用于高级调度)</li></ul><h4 id="时间片轮转调度算法">时间片轮转调度算法</h4><ul><li>根据各个进程进入就绪队列的顺序轮流占有CPU一个时间片</li></ul><p>时间片的确定：适中，过长则为FCFS，过短则开销大</p><p>分为单时间片、多时间片和动态时间片</p><h4 id="分级调度算法">分级调度算法</h4><ul><li>又称多队列策略，反馈循环队列</li></ul><p>基本思想：</p><ol type="1"><li>建立多个不同优先级的就绪进程队列</li><li>多个就绪进程队列间按照优先数调度</li><li>高优先级就绪进程分配的时间片短</li><li>单个就绪进程队列中进程的优先数和时间片相同</li></ol><h4 id="随机调度算法">随机调度算法</h4>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第一章_概述</title>
    <link href="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第一章-计算机操作系统概述">第一章 计算机操作系统概述</h1><h2 id="计算机系统">1.1 计算机系统</h2><h3 id="计算机系统概述">1.1.1 计算机系统概述</h3><p>电子数字计算机：能够自行按照已设定的程序进行数据处理的电子设备。</p><h4 id="计算机发展历史">计算机发展历史</h4><ul><li><p>1945～：电子真空管、机器语言，应用于科学计算</p></li><li><p>1956～：晶体管、批处理控制、Fortran/COBOL，扩展到数据处理</p></li><li><p>1959～：集成电路、多道程序、操作系统/数据库/高级语言</p></li><li><p>1976～：大规模集成电路，向快速化、小型化、系统化、网络化、智能化发展</p></li><li><p>1980～：微机出现</p></li><li><p>1990～：图形化人机交互</p></li><li><p>2003～：移动计算</p></li></ul><h4 id="计算机系统组成">计算机系统组成</h4><p>包括硬件子系统和软件子系统</p><ul><li><p>硬件：借助电、磁、光、机械等原理构成的各种物理部件的有机组合</p></li><li><p>软件：各种程序和文件，包括系统软件、支撑软件和应用软件</p><ul><li>关键系统软件：操作系统和语言处理程序</li></ul></li></ul><h4 id="计算机系统视图">计算机系统视图</h4><ul><li><p>用户视图：应用、语言处理、操作系统、计算机硬件</p></li><li><p>应用程序员视图：语言处理、操作系统、计算机硬件</p></li><li><p>语言处理程序设计者视图：操作系统、计算机硬件</p></li><li><p>操作系统设计者视图：计算机硬件</p></li></ul><h3 id="计算机硬件系统">1.1.2 计算机硬件系统</h3><h4 id="一计算机硬件系统的组成">一、计算机硬件系统的组成</h4><ol type="1"><li>中央处理器：运算单元、控制单元</li><li>主存储器</li><li>外围设备：输入/输出设备、存储设备、网络通信设备</li><li>总线</li></ol><h4 id="二冯氏计算机存储程序计算机">二、冯氏计算机：存储程序计算机</h4><p>冯·诺伊曼等人在1946年总结提出，称为冯·诺伊曼计算机模型</p><ol type="1"><li>以运算单元为中心，控制流由指令流产生</li><li>采用存储程序原理，面向主存组织数据流</li><li>主存是按地址访问、线性编址的空间</li><li>指令由操作码和地址码组成</li><li>数据以二进制编码</li></ol><h4 id="三总线">三、总线</h4><p>总线是计算机各种功能部件之间传送信息的公共通信干线，是CPU、内存、输入输出设备传递信息的公用通道。</p><p>计算机各个部件通过总线相连接，外围设备通过相应的接口电路与总线相连接，形成了计算机硬件系统。</p><p>总线的组成：一组控制线、一组数据线、一组地址线</p><p>总线的类型：</p><ol type="1"><li>内部总线：用于CPU芯片内部连接各元件</li><li>系统总线：用于连接CPU、存储器和各种输入/输出模块等主要部件</li><li>通信总线：用于计算机系统间通信</li></ol><p>片上系统 (SoC: System on a Chip)</p><p>在单个芯片上集成一个完整的系统(包括中央处理器、存储器以及外围电路等)，对所有或部分必要的电子电路进行包分组的技术。</p><p>SoC是与其他技术(如绝缘硅，提高增强时钟频率，降低功耗)并行发展的。</p><h4 id="四中央处理器">四、中央处理器</h4><p>中央处理器是计算机的运算核心和控制单元，主要包括：</p><ol type="1"><li>运算逻辑部件：一个或多个运算器</li><li>寄存器部件：包括通用寄存器、控制与状态寄存器、高速缓冲存储器</li><li>控制部件：实现各部件之间联系的数据、控制与状态内部总线；指令译码、控制指令执行、实现数据传输等功能的部件</li></ol><figure><img src="/image/计算机操作系统/中央处理器.png" alt="中央处理器" /><figcaption aria-hidden="true">中央处理器</figcaption></figure><p>存储器组织层次：越往下，容量越大、速度越慢、价格越低</p><p>L0：寄存器</p><p>L1：L1 Cache</p><p>L2：L2 Cache</p><p>L3：L3 Cache</p><p>L4：主存</p><p>L5：本地固态硬盘</p><p>L6：本地硬盘</p><p>外围设备：输入/输出设备、存储设备、通信设备</p><p>输入/输出控制方式：</p><ol type="1"><li>轮询：CPU忙式控制输入/输出，执行内存数据交换</li><li>中断：CPU启动输入/输出设备，设备中断CPU</li><li>DMA方式：CPU启动DMA，DMA独立进行输入/输出和内存数据交换，DMA中断CPU</li></ol><h3 id="计算机软件系统">1.1.3 计算机软件系统</h3><h4 id="一计算机软件系统的组成">一、计算机软件系统的组成</h4><ol type="1"><li>系统软件</li></ol><p>操作系统、实用程序、语言处理程序、数据库管理系统</p><ol start="2" type="1"><li>支撑软件</li></ol><p>接口软件、工具软件、环境数据库，也可认为是系统软件的一部分</p><ol start="3" type="1"><li>应用软件</li></ol><p>用户按其需要自行编写的专用程序</p><h4 id="二程序员的计算机系统视图">二、程序员的计算机系统视图</h4><ol type="1"><li>机器语言：计算机硬件系统</li><li>机器指令：操作系统和实用程序</li><li>数据库语言：数据库管理系统</li><li>高级语言：支撑软件</li><li>更高：支撑软件</li></ol><p>软件开发的不同层次</p><ol type="1"><li>计算机硬件系统：机器语言</li><li>操作系统资源管理：机器语言+广义指令</li><li>操作系统文件系统：机器语言+系统调用</li><li>数据库管理系统：数据库语言</li><li>语言处理程序：面向问题的语言</li></ol><h4 id="三计算机程序的执行过程">三、计算机程序的执行过程</h4><figure><img src="/image/计算机操作系统/计算机程序执行过程.png"alt="计算机程序执行过程" /><figcaption aria-hidden="true">计算机程序执行过程</figcaption></figure><h2 id="计算机操作技术">1.2 计算机操作技术</h2><h3 id="计算机操作技术的发展">1.2.1 计算机操作技术的发展</h3><h4 id="操作平台与操作系统">1. 操作平台与操作系统：</h4><p>任何一台机器都有其操作平台与操作系统，操作平台的精细化和系统化，产生了操作系统。</p><h4 id="计算机人工操作">2. 计算机人工操作</h4><p>计算机手工操作的问题：手工操作速度和电子计算速度不匹配</p><p>装入程序的引进：</p><ol type="1"><li>引入卡片和打孔纸带描述程序指令和数据</li><li>装入程序：自动化执行程序装入，必要时进行地址切换，存放在ROM中</li></ol><p>外存储设备变迁：过去的磁带与软盘，使用逐渐减少的光盘</p><p>计算机控制</p><p>汇编语言：先将汇编语言程序编译为可执行程序，再由计算机执行</p><p>高级语言：高级语言程序编译为目标代码，后编译成可执行程序，再执行</p><h4 id="简单批处理系统的操作方式">3. 简单批处理系统的操作方式</h4><p>简单批处理系统的操作控制：</p><p>引入作业控制语言，用户编写作业说明书，描述对一次计算机作业的控制。</p><p>操作员控制计算机成批输入作业，成批执行作业。</p><p>这一方式缩短了手工操作时间，提高了计算机系统的使用效率。</p><p>进展：</p><ol type="1"><li>出现了初步的资源管理程序，屏蔽了硬件处理细节</li><li>输入/输出中断出现，实现CPU与输入/输出设备并行</li><li>磁带出现，磁盘文件系统形成，但输入/输出效率还是不支持多道程序</li></ol><h4 id="操作系统与自动化操作方式">4. 操作系统与自动化操作方式</h4><p>操作系统与自动化操作控制：</p><ol type="1"><li>电子计算速度与机械输入/输出速度的矛盾</li><li>程序执行过程中输入作业，重叠时间</li></ol><p>需要多道程序同时执行，程序切换需要高速外存储设备</p><ol start="3" type="1"><li>磁盘设备出现，于是有了计算机操作系统，实现自动化控制</li></ol><h3 id="计算机操作系统">1.2.2 计算机操作系统</h3><h4 id="操作系统基本概念">1. 操作系统基本概念</h4><p>操作系统是计算机系统最基础的系统软件，管理软硬件资源、控制程序执行、改善人机界面，合理组织计算机工作流程，为用户使用计算机提供良好运行环境。</p><h4 id="操作系统组成">2. 操作系统组成</h4><ol type="1"><li>进程调度子系统</li><li>进程通信子系统</li><li>内存管理子系统</li><li>设备管理子系统</li><li>文件管理子系统</li><li>网络通信子系统</li><li>作业控制子系统</li></ol><h4 id="操作系统分类">3. 操作系统分类</h4><p>从操作方式看：</p><ol type="1"><li>多道批处理操作系统，脱机控制方式</li><li>分时操作系统，交互式操作系统</li><li>实时操作系统</li></ol><p>按应用领域分类：</p><p>服务器操作系统、并行操作系统、网络操作系统、分布式操作系统、个人机操作系统、手机操作系统、嵌入式操作系统、传感器操作系统</p><p>普适计算 Pervasive/Ubiquitous Computing</p><p>物联网 Things of Internet, CPS</p><p>移动计算 Mobile Computing (移动互联网)</p><p>嵌入式的操作系统: μC/OS-II, VxWorks, LiteOS, 翼辉SylixOS......</p><p>移动终端的操作系统： Android, iOS, 鸿蒙OS......</p><p>PC的OS: 微软的桌面系统</p><p>服务器的OS: CentOS, Ubuntu等Linux各类发行版, EulerOS, ...</p><h2 id="操作系统的不同视角">1.3 操作系统的不同视角</h2><h3 id="资源管理的视角">1.3.1 资源管理的视角</h3><h4 id="计算机系统的资源">计算机系统的资源</h4><ul><li>硬件资源：处理器、内存、外设</li><li>信息资源：数据、程序</li></ul><h4 id="软硬件资源管理">软硬件资源管理</h4><ul><li>处理器资源：占有处理器运行的程序</li><li>内存资源：程序、数据在内存中的分布</li><li>设备资源：分配、去配和使用资源</li><li>信息资源管理：访问文件信息</li><li>信号量资源：管理进程间通信</li></ul><h4 id="屏蔽资源使用的底层细节">屏蔽资源使用的底层细节</h4><p>驱动程序：最底层的、直接控制和监视各类硬件资源的地方</p><ul><li>隐藏底层硬件的具体细节，为其他部分提供抽象、具体的接口</li></ul><h4 id="资源的共享独占与并发">资源的共享：独占与并发</h4><p>资源的分配：</p><ul><li>静态分配：进程运行前一次拿到所有全部独占资源</li><li>动态分配：使用资源前临时申请</li></ul><p>可能产生竞争资源的死锁。</p><p>资源抢占方式：被抢占资源的进程需要回滚执行</p><h3 id="控制程序执行的视角">1.3.2 控制程序执行的视角</h3><p>由于中央处理器速度和输入/输出速度不匹配的矛盾，只有让多道程序同时进入内存争抢中央处理器运行，才可以使中央处理器与外围设备充分并行，提高计算机系统使用效率。</p><h4 id="多道程序设计">多道程序设计</h4><p>让多个程序同时进入计算机主存储器进行计算。</p><p>特点：</p><ol type="1"><li>中央处理器与外部设备充分并行</li><li>外部设备间充分并行</li><li>发挥中央处理器使用效率</li><li>提高单位时间算题量</li><li>单道程序的运算时间会增加</li></ol><p>多道程序系统的实现：</p><ol type="1"><li>为进入内存执行的程序建立管理实体：进程</li><li>操作系统管理和控制进程程序的执行</li><li>操作系统协调管理各类资源在进程间使用</li></ol><ul><li>处理器的管理与调度</li><li>主存储器的管理与调度</li><li>其他资源的管理与调度</li></ul><p>实现要点：</p><ol type="1"><li>如何使用资源：调用操作系统提供的服务例程</li><li>如何复用中央处理器：调度程序，让其他程序在中央处理器空闲时运行</li><li>如何使中央处理器和输入/输出设备充分并行：设备控制器和通道</li><li>如何让正在运行的程序让出中央处理器：中断</li></ol><h3 id="操作控制计算机的视角">1.3.3 操作控制计算机的视角</h3><ol type="1"><li>计算机操作控制方式</li><li>脱机作业控制方式</li><li>联机作业控制方式</li><li>命令解释程序及其处理过程</li></ol><h4 id="计算机系统操作方式">计算机系统操作方式</h4><ol type="1"><li>操作系统规定了合理操作计算机的工作流程</li><li>操作系统的操作接口：系统程序</li><li>两类作业级接口：</li></ol><p>脱机作业控制方式、联机作业控制方式</p><h4 id="脱机作业控制方式">脱机作业控制方式</h4><p>例：shell程序</p><ul><li>操作系统：提供作业说明语言</li><li>用户：编写作业说明书，确定作业加工控制步骤，并与程序数据一起提交</li><li>操作员：通过控制台输入作业</li><li>操作系统：通过作业控制程序自动控制作业的执行</li></ul><h4 id="联机作业控制方式">联机作业控制方式</h4><p>例：分时操作系统的交互控制方式</p><ul><li>计算机：提供终端 (键盘、显示器)</li><li>用户：登录系统</li><li>操作系统：提供命令解释程序</li><li>用户：联机输入操作控制命令，直接控制作业的执行</li></ul><h4 id="命令解释程序">命令解释程序</h4><p>接受和执行一条用户提出的对作业的加工处理命令</p><ul><li>会话语言：可编程的命令解释语言</li><li>图形化的命令控制方式</li><li>多通道交互的命令控制方式</li></ul><p>处理过程：</p><ol type="1"><li>操作系统启动命令解释程序，输出命令提示符，等待键盘中断、鼠标点击、多通道识别</li><li>每当用户输入命令并按回车换行，将命令暂存在命令缓冲区后，申请中断</li><li>中央处理器响应后，将控制权交给命令解释器程序，读入命令缓冲区内容，分析命令、接受参数，执行处理代码</li></ol><p>前台命令和后台命令</p><ul><li><p>前台命令执行结束后，再次输出命令提示符，等待下一条命令</p></li><li><p>后台命令处理启动后，即可接收下一条命令</p></li></ul><h3 id="人机交互的视角">1.3.4 人机交互的视角</h3><h4 id="操作系统的人机交互部分">操作系统的人机交互部分</h4><ol type="1"><li>操作系统改善人机界面，为用户使用计算机提供良好的环境</li><li>人机交互设备包括传统终端设备和新型模式识别设备</li><li>人机交互部分用于控制有关设备运行、理解执行设备传来命令</li><li>人机交互功能决定了计算机系统的友善性</li></ol><h4 id="人机交互的发展">人机交互的发展</h4><p>交互式控制方式：</p><ul><li><p>行命令控制方式：1960年代开始使用</p></li><li><p>全屏幕控制方式：1970年代开始使用</p></li></ul><p>人，而不是技术，是人机交互的中心——&gt;鼠标、菜单、窗口控制</p><h4 id="wimp界面">WIMP界面</h4><p>窗口(Window)、图标(Icon)、菜单(Menu)、指示装置(Pointing Devices)</p><ul><li><p>1990年代开始广泛使用。</p></li><li><p>不足：不能同时使用多个交互通道，产生人机交互的不平衡。</p></li></ul><h4 id="多媒体计算机">多媒体计算机</h4><p>将音频视频、图形图像和人机交互控制结合，进行综合处理</p><h4 id="虚拟现实系统">虚拟现实系统</h4><p>例：VR</p><h3 id="程序接口的视角">1.3.5 程序接口的视角</h3><h4 id="操作系统的程序接口">操作系统的程序接口</h4><p>操作系统为程序运行扩充的编程接口。</p><p>系统调用：操作系统实现的完成某种特定功能的过程</p><p>POSIX支持</p><h4 id="系统调用的实现机制">系统调用的实现机制</h4><p>中断。</p><p>系统调用的实现要点：</p><ol type="1"><li>编写系统调用处理程序</li><li>系统调用入口地址表</li><li>系统调用时，需保存当时的处理器情况</li></ol><h4 id="系统调用的实现流程">系统调用的实现流程</h4><figure><img src="/image/计算机操作系统/系统调用的实现流程.png"alt="系统调用的实现流程" /><figcaption aria-hidden="true">系统调用的实现流程</figcaption></figure><h3 id="系统结构的视角">1.3.6 系统结构的视角</h3><p>操作系统是计算机软件发展史上第一个大规模软件系统。</p><h4 id="操作系统软件的结构设计">操作系统软件的结构设计</h4><ul><li>操作系统构件：内核、进程、线程、管程等</li><li>设计概念：模块化、层次化、虚拟化</li><li>内核设计是操作系统设计中最为复杂的部分</li></ul><h4 id="操作系统内核">操作系统内核</h4><ul><li>单内核：内核中各部件杂然混居</li><li>微内核：结构性部件与功能性部件分离</li><li>混合内核：微内核和单内核的折中，较多组件在核心态中运行以更快执行</li><li>外内核：减少内核的软件抽象化和传统微内核的消息传递机制，使得开发者专注于硬件的抽象化</li></ul><h4id="操作系统实现的一种层次式结构">操作系统实现的一种层次式结构：</h4><ul><li><p>用户模式：用户与文件系统</p></li><li><p>内核模式：进程交互、输入/输出设备管理、虚拟内存、基本进程管理、硬件</p></li></ul><p>另一种层次式结构：</p><ol type="1"><li>用户：命令、进程、库、环境</li><li>文件系统调用：用户进程管理、目录管理、设备文件、文件系统、管道等高阶通信</li><li>软硬件协同内核：内存与虚拟内存管理、块设备管理与输入/输出控制、核心进程管理和控制与通信原语、中断管理</li><li>硬件电路：过程机制、指令解译、电路执行</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件工程与计算II复习</title>
    <link href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/SEII%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/04/30/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/SEII%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="seii复习">SEII复习</h1><span id="more"></span><ul><li>软件需求工程</li><li>软件设计</li><li>软件构造</li><li>软件测试</li><li>软件交付</li><li>软件维护</li></ul><h2 id="包的原则">包的原则</h2><ul><li>重用发布等价原则（REP）</li><li>共同封闭原则（CCP）</li><li>共同重用原则（CRP）</li><li>无环依赖原则（ARP）</li><li>稳定依赖原则（SDP）</li><li>稳定抽象原则（SAP）</li></ul><h2 id="人机交互">人机交互</h2><h3 id="人机交互设计原则">人机交互设计原则</h3><ul><li><p>简洁</p></li><li><p>一致性</p></li><li><p>低出错</p></li><li><p>易记性</p></li><li><p>可视化</p></li><li><p>导航</p></li><li><p>反馈</p></li><li><p>差异性</p></li></ul><h2 id="耦合和内聚">耦合和内聚</h2><h3 id="耦合">耦合</h3><p>从高到低，越低越好，1、2、3不可接受</p><ol type="1"><li>内容耦合：一个模块直接修改另一个模块的内容</li><li>公共耦合：全局变量、文件、设备</li><li>重复耦合：重复代码</li><li>控制耦合：一个模块给其他模块传递控制信息</li><li>印记耦合：共享数据结构却只使用一部分</li><li>数据耦合：模块间传参只传需要的数据，最理想</li></ol><h3 id="内聚">内聚</h3><p>从高到低，越低越差，6、7不能接受</p><ol type="1"><li>信息内聚：模块进行许多操作，各自有各自的入又点，每个操作代码相对独立，而且所有操作都在相同的数据结构上进行</li><li>功能内聚：只执行一个操作或达到一个目的</li><li>通信内聚：对相同数据执行不同操作</li><li>过程内聚：含有不同步骤操作</li><li>时间内聚：具有时间相关性的相关操作</li><li>逻辑内聚：逻辑上相似但没有直接关联操作</li><li>偶然内聚：多个毫不相干的操作</li></ol><h2 id="设计原则">设计原则</h2><ol type="1"><li>全局变量有害</li><li>代码清晰可修改</li><li>避免重复</li><li>面向接口编程</li><li>迪米特法则：不能出现a.b.method()</li><li>接口隔离原则（接口最小化原则）</li><li>里氏替换原则：所有派生类都须可以替代其基类</li><li>组合代替继承</li><li>单一职责原则</li><li>最小化类和成员的可访问性</li><li>开放/封闭原则（OCP）：模块可扩展，不应修改（无switch、if/else）</li><li>依赖倒置原则（DIP）：高级模块不应依赖于低级，两者均应依赖抽象</li></ol><h2 id="设计模式">设计模式</h2><ul><li>策略模式</li><li>迭代器模式</li><li>抽象工厂模式</li><li>单件模式</li></ul><h2 id="代码设计">代码设计</h2><ul><li>单元测试用例的设计</li><li>契约式设计</li><li>防御式编程</li><li>表驱动</li></ul><h2 id="软件开发过程模型">软件开发过程模型</h2><ul><li>生命周期模型</li><li>构建-修复模型</li><li>瀑布模型</li><li>增量迭代模型</li><li>演化模型</li><li>原型模型</li><li>螺旋模型</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件工程与计算2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软工2-三-软件需求</title>
    <link href="/2023/04/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%B8%89-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/"/>
    <url>/2023/04/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%B8%89-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<p>单纯的软件系统是不能解决问题的，只有和现实世界之间形成有效互动才能实现问题的解决。</p><span id="more"></span><h1 id="第三部分-软件需求">第三部分 软件需求</h1><h2 id="一需求工程">一、需求工程</h2><h3 id="需求工程的概念">需求工程的概念</h3><p>所有需求处理活动的总和。它收集信息、分析问题、整合观点、记录需求并验证其正确性，最终描述出软件被应用后与其环境互动形成的期望效应。</p><p>三个主要任务：</p><ul><li><p>需求工程必须说明软件系统将被应用的应用环境及其目标，说明用来达成这些目标的软件行动（为什么、做什么）</p></li><li><p>需求工程必须将目标和功能反映到软件系统中，映射为可行的软件行为，并对软件行为进行准确的规格说明</p></li><li><p>现实世界是不断变化的世界，因此需求工程还需要妥善处理目标和功能随着时间演化的变动情况</p></li></ul><h3 id="需求工程的活动">需求工程的活动</h3><ul><li>需求开发<ul><li>需求获取</li><li>需求分析</li><li>需求规格说明</li><li>需求验证</li></ul></li><li>需求管理</li></ul><h4 id="需求获取">1. 需求获取</h4><p>从人、文档或者环境中利用各种方法和技术获取需求</p><ul><li>目标分析：根据问题确定目标、分析利害关系人确定目标</li><li>常见困难：用户与开发人员的认知差异</li><li>获取方法：面谈、问卷、文档分析、头脑风暴、专题讨论、原型</li></ul><h4 id="需求分析">2. 需求分析</h4><ol type="1"><li>通过建模整合各种信息</li><li>为问题定义出一个需求集合，该集合能界定一个问题的解决方案</li><li>检查需求中的错漏，加以修正</li></ol><h5 id="边界分析">(1) 边界分析</h5><ol type="1"><li>定义项目的范围</li><li>系统边界的定义要保证系统能和周围环境形成有效互动</li><li>系统用例图常被用于定义系统边界</li></ol><h5 id="需求建模">(2) 需求建模</h5><p>为展现和解释信息而进行的抽象描述活动</p><ul><li>常用类图、顺序图、状态图</li></ul><h4 id="需求规格说明">3. 需求规格说明</h4><p>在系统用户间交流需求信息</p><ul><li><p>要简洁、精确、一致和易于理解</p></li><li><p>需求工程师在该阶段的重要工作：定制文档模版、编写文档</p></li></ul><h4 id="需求验证">4. 需求验证</h4><p>需求规格说明文档的要求：</p><ol type="1"><li>每条需求都正确、准确地反映了用户意图</li><li>需求集在整体上具有整体性和一致性</li><li>文档的组织方式和需求的书写方式具有可读性和可修改性</li></ol><p>验证的方法：同级评审、原型、模拟</p><h3 id="需求管理">需求管理</h3><ol type="1"><li>保证需求作用的持续、稳定和有效发挥<ul><li>在需求开发活动后，设计、测试、实现等后续的软件系统开发活动都需要以围绕需求开展工作</li></ul></li><li>进行变更控制<ul><li>纳入实现合理的变更需求、拒绝不合理变更需求，控制变更成本和影响范围</li></ul></li></ol><h2 id="二需求基础">二、需求基础</h2><h3 id="需求的定义">需求的定义</h3><ul><li>用户为了解决问题或达到某种目标所需要的条件或能力</li><li>系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力</li><li>对上述中的一个条件或一种能力的一种文档化表述</li></ul><p>需求是一种解决问题后所能达到的期望。</p><p>问题域：</p><ul><li>现实世界运行规律的一种反映</li><li>需求的产生地与解决地</li><li>最终的软件产品要在现实中部署，它能够部分影响问题域，但不能任意改变现实<ul><li>软件开发必须尊重问题域，不能因为技术原因妄自修改现实情况</li></ul></li></ul><p>问题的解决：</p><ul><li>基础：模拟与共享现象</li><li>方法：直接、间接</li><li>解决方案：需求规格说明</li></ul><h3 id="需求开发的目标">需求开发的目标</h3><p>将现实世界问题域描述转化为计算世界的规格说明。</p><p>规格说明：软件产品的方案描述，以软件产品的运行机制为主要内容。</p><ul><li>关注对外交互的方式描述软件解决方案</li></ul><p>需求层次性</p><ul><li><p>业务需求：系统具备的特性</p></li><li><p>用户需求：系统能帮助用户做些什么</p></li><li><p>系统需求：用户对系统行为的期望</p></li></ul><h3 id="需求分类">需求分类</h3><h4 id="需求谱系">需求谱系</h4><ul><li>需求<ul><li>项目需求</li><li>过程需求</li><li>系统需求<ul><li>软件需求</li><li>硬件需求</li><li>其他需求</li></ul></li></ul></li><li>不切实际的期望</li></ul><h4 id="需求分类-1">需求分类</h4><ul><li>功能需求<ul><li>不考虑物理约束的情况下，用户希望系统能够执行的活动</li><li>主要表现为系统和环境之间的行为交互</li></ul></li><li>性能需求<ul><li>系统整体或系统组成部分应该拥有的性能特征</li></ul></li><li>质量属性<ul><li>系统完成工作的质量</li></ul></li><li>对外接口<ul><li>系统和环境中其他系统需要建立的接口</li></ul></li><li>约束<ul><li>进行系统构造时需要遵守的约束</li></ul></li></ul><h2 id="三需求分析">三、需求分析</h2><h3 id="需求分析的任务">需求分析的任务</h3><ul><li>建立分析模型，达成开发者和用户对需求信息的共同理解</li><li>依据共同的理解发挥创造性，创建软件系统解决方案</li></ul><h3 id="需求分析模型">需求分析模型</h3><p>模型是对事物的抽象，帮助人们在创建一个事物之前可以有更好的理解。</p><h4 id="面向对象方法模型">面向对象方法模型</h4><table><thead><tr class="header"><th>模型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>用例图</td><td>描述用户与系统的交互。从交互的角度说明了系统的边界和功能范围。</td></tr><tr class="even"><td>类图</td><td>描述应用领域中重要的概念以及概念之间的关系。它捕获了系统的静态结构。</td></tr><tr class="odd"><td>顺序图</td><td>描述系统中一次交互的行为过程，说明了在交互中的对象协作关系。</td></tr><tr class="even"><td>状态图</td><td>描述系统、用例或者对象在其整个生命期内的状态变化和行为过程。</td></tr></tbody></table><h4 id="结构化方法模型">结构化方法模型</h4><table><thead><tr class="header"><th>模型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>数据流图</td><td>从数据传递和加工的角度，描述了系统从输入到输出的功能处理过程。运用功能分解的方法，用层次结构简化处理复杂的问题。</td></tr><tr class="even"><td>实体关系图</td><td>描述系统中的数据对象及其关系，定义了系统中使用、处理和产生的所有数据。</td></tr></tbody></table><h4 id="建模">建模</h4><p>建立模型的过程被称为建模。</p><ul><li><p>建模是对系统进行思考和推理的一种方式</p></li><li><p>建模的目标是建立系统的一个表示，这个表示以精确一致的方式描述系统，使得系统的使用更加容易</p></li><li><p>建模的常用手段：抽象和分解</p></li></ul><h2 id="四面向对象分析">四、面向对象分析</h2><h3 id="简单过程">简单过程</h3><ul><li><p>系统用例图——细化系统的对外交互——&gt;用例模型/用例描述</p></li><li><p>用例模型/用例描述——明确用例中的协作对象——&gt;概念类图/领域模型</p></li><li><p>用例模型/用例描述——明确用例中的协作行为——&gt;顺序图、状态图、对象约束语言</p></li></ul><h3 id="用例图">1. 用例图</h3><h4 id="用例的定义">用例的定义</h4><p>在系统（或者子系统或者类）和外部对象的交互当中所执行的行为序列的描述，包括各种不同的序列和错误的序列，它们能够联合提供一种有价值的服务。</p><h4 id="用例图的基本元素">用例图的基本元素</h4><p>参与者、用例、关系、系统边界</p><ul><li>参与者（小人形）<ul><li>一个与正在开发的系统进行交互的用户或系统所扮演的角色</li><li>用例图中的一个参与者可以代表多个用户或系统、扮演多种角色</li></ul></li><li>用例（椭圆）</li><li>关系（不同的线和箭头及上面的补充文字）</li><li>系统边界（矩形）<ul><li>参与者总在系统边界外</li></ul></li></ul><h4 id="用例图的建立">用例图的建立</h4><ol type="1"><li>目标分析与解决方向的确定</li><li>寻找参与者</li><li>寻找用例</li><li>细化用例</li></ol><ul><li>如果用例的粒度不合适就需要进行细化和调整<ul><li>判断标准：用例描述了为应对一个业务事件，由一个用户发起，并在一个连续时间段内完成，可以增加业务价值的任务。</li></ul></li></ul><h4 id="常见错误">常见错误</h4><ul><li>不要把用例细化为单个操作<ul><li>例：不要将用户管理细化为增加、修改和删除三个更小的用例，因为它们要联合起来才能体现出业务价值。</li></ul></li><li>不要把同一个业务目标细化为不同用例<ul><li>例：特价策略制定和赠送策略制定。</li></ul></li><li>不要把没有业务价值的内容作为用例<ul><li>例：“登录”(应该描述为安全性质量需求)、“数据验证”(应该描述为数据需求)、“连接数据库”(属性软件内部实现而不是需求)等。</li></ul></li></ul><h3 id="概念类图">2. 概念类图</h3><p>概念类图又被称为领域模型。</p><p>类图是面向对象分析方法的核心，描述类和类之间的关系。</p><ul><li>和设计类图的不同：关注系统与外界的交互，而不是软件系统的内部构造机制</li><li>类型、方法、可见性等复杂的软件构造细节不会在概念类图中</li></ul><h4 id="概念类图的基本元素">概念类图的基本元素</h4><p>对象、类、链接、关联、继承</p><p>继承、组合、聚合、关联的图示：</p><pre><code class=" mermaid">classDiagram A &lt;|-- BC *-- DE o-- FG -- H</code></pre><h4 id="建立概念类图">建立概念类图</h4><p>先对每个用例文本描述，尤其是场景描述建立局部概念类图，再合并为整体概念类图。</p><ol type="1"><li>根据用例文本描述识别候选类<ul><li>软件系统与外界交互时可能设计的对象与类</li></ul></li><li>筛选候选类，确定概念类<ul><li>准则：依据系统需求；该类的对象实例的状态与行为是否完全必要</li><li>候选类向概念类的转化：<ul><li>需要维护状态、表现行为：概念类</li><li>需要维护状态，不需要表现行为：其他概念类的属性</li><li>不需要维护状态，需要表现行为：审视需求，转交行为</li><li>不需要维护状态、表现行为：剔除</li></ul></li></ul></li><li>识别关联</li><li>识别重要属性</li></ol><h3 id="顺序图">3. 顺序图</h3><p>也称交互图。</p><h4 id="消息种类">消息种类</h4><ul><li>同步消息：实线，实心三角箭头</li><li>异步消息：实线，&gt;</li><li>返回消息：虚线，&gt;</li></ul><h4 id="顺序图的建立">顺序图的建立</h4><ol type="1"><li>确定上下文环境</li><li>根据用例描述找到交互对象</li><li>按照用例描述中的流程顺序逐步添加信息</li></ol><h3 id="状态图">4. 状态图</h3><h4 id="概念">概念</h4><ul><li>状态：描述系统在特定时间行为的可视化状况的集合</li><li>状态转换：从一个状态到另一个状态</li><li>事件：导致系统表现一些可预测的行为</li><li>活动：作为状态转换的结果发生的过程</li></ul><h4 id="状态图的建立">状态图的建立</h4><ol type="1"><li>确立上下文环境</li><li>识别状态</li><li>建立状态转换</li><li>完善状态图</li></ol><h2 id="五需求文档化与验证">五、需求文档化与验证</h2><h3 id="用例文档">1. 用例文档</h3><p>在用户的角度以用例文本为主描述软件系统与外界的交互。</p><ul><li>基本职责是把问题域信息和需求传达给软件系统解决方案的设计者</li></ul><h4 id="用例文档结构示例">用例文档结构示例</h4><ul><li>文档的信息</li><li>用例图或用例列表</li><li>用例描述</li></ul><h3 id="软件需求规格说明文档">2. 软件需求规格说明文档</h3><p>在软件产品的角度以系统级需求列表的方式描述软件系统解决方案。</p><table><thead><tr class="header"><th>用例</th><th>系统规格</th></tr></thead><tbody><tr class="odd"><td>侧重于交互流程</td><td>侧重于独立需求</td></tr><tr class="even"><td>基于一次交互</td><td>基于一次交互中的软件系统处理细节</td></tr></tbody></table><h4 id="需求规格说明文档结构示例">需求规格说明文档结构示例</h4><ul><li>引言</li><li>总体描述</li><li>详细需求描述<ul><li>对外接口需求</li><li>功能需求</li><li>性能需求</li><li>约束</li><li>质量属性</li><li>其他需求</li></ul></li><li>附录</li><li>索引</li></ul><h3 id="文档化需求的注意事项">3. 文档化需求的注意事项</h3><h4 id="技术文档写作要点">技术文档写作要点</h4><ul><li>简洁</li><li>精确</li><li>易读<ul><li>有效使用引言、目录、索引等</li><li>使用系统化的方式组织内容信息<ul><li>使用相同的语句格式来组织相似、关联的信息</li><li>使用列表或表格来组织独立、并列的信息</li><li>使用编号来表达繁杂信息之间的关系，包括顺序、嵌套、层次关系</li></ul></li></ul></li><li>易修改<ul><li>独立性</li><li>ID</li><li>引用，不重复</li></ul></li></ul><h4 id="需求书写要点">需求书写要点</h4><ul><li>使用用户属于</li><li>可验证</li><li>可行性</li></ul><h4 id="需求规格说明文档书写要点">需求规格说明文档书写要点</h4><ul><li>充分利用标准文档模版，保持所有内容位置得当</li><li>保持文档内的需求集具有完备性和一致性</li><li>为需求划分优先级</li></ul><h3 id="验证需求文档">4. 验证需求文档</h3><p>方法：评审、开发系统测试用例、度量</p><h4 id="开发系统测试用例">开发系统测试用例</h4><ol type="1"><li>以需求为线索，开发测试用例套件</li><li>使用测试技术确定输入/输出数据，开发测试用例</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件工程与计算2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软工2-二-项目启动</title>
    <link href="/2023/04/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/"/>
    <url>/2023/04/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>原神，启动！</p><span id="more"></span><h1 id="第二部分-项目启动">第二部分-项目启动</h1><h2 id="项目和项目管理">1. 项目和项目管理</h2><h3 id="项目的概念">项目的概念</h3><p>项目是具有下列特征的一系列活动和任务：</p><ul><li>具有一个明确的目标</li><li>有限定的开始和结束日期</li><li>有成本限制</li><li>消耗人力和非人力资源</li><li>多工种合作</li></ul><h3 id="项目管理的目标">项目管理的目标</h3><p>在限定时间内、一定成本内、要求的质量水平上，高效使用资源，获得用户认可。</p><h3 id="过程组与活动">过程组与活动</h3><p>过程组：</p><ol type="1"><li>项目启动</li><li>项目计划</li><li>项目执行</li><li>项目跟踪</li><li>项目收尾</li></ol><p>活动：计划制定、团队管理、成本控制、质量保障、度量、过程管理、进度跟踪与控制、风险管理、配置管理</p><h2 id="团队组织与管理">2. 团队组织与管理</h2><ul><li>一个协作良好的团队是任何项目成功的基础</li><li>软件项目尤其依赖于有效的团队组织和管理</li><li>软件开发是一个以人为主的活动，人力资源是软件项目最大的资产</li></ul><h3 id="团队的概念">团队的概念</h3><p>为了一致的目的、绩效标准、方法而共担责任并且技能互补的少数人。</p><ul><li>团队内部要有一个明确的结构</li></ul><h3 id="团队的结构">团队的结构</h3><ul><li>主程序员团队</li><li>民主团队</li><li>开放团队</li></ul><h3 id="团队建设">团队建设</h3><ol type="1"><li><p>建立团队章程</p></li><li><p>持续成功</p><p>项目阶段性成功/团队活动成功</p></li><li><p>和谐沟通</p></li><li><p>避免团队杀手</p></li></ol><ul><li>防范式管理</li><li>官僚主义</li><li>地理分散</li><li>时间分割</li><li>产品质量的降低</li><li>虚假的最后期限</li><li>小圈子控制</li></ul><h2 id="软件质量保障">3. 软件质量保障</h2><p>软件工程师需要对软件产品的质量负责。</p><p>人们通常会选用系统的某些质量要素进行量化处理，建立质量特征，这些特征被称为质量属性。</p><p>为了根据质量属性描述和评价系统的整体质量，人们从很多质量属性的定义中选择了一些能够相互配合、相互联系的特征集，它们被称为质量模型。</p><p>质量模型的因素</p><ul><li>功能性、可靠性、易用性、效率、可维护性、可移植性</li></ul><h3 id="质量保障">质量保障</h3><table><thead><tr class="header"><th>里程碑</th><th>质量保障活动</th></tr></thead><tbody><tr class="odd"><td>需求开发</td><td>需求评审、需求度量</td></tr><tr class="even"><td>体系结构</td><td>体系结构评审、集成测试</td></tr><tr class="odd"><td>详细设计</td><td>详细设计评审、设计度量、集成测试</td></tr><tr class="even"><td>实现</td><td>代码评审、代码度量、测试</td></tr><tr class="odd"><td>测试</td><td>测试、测试度量</td></tr></tbody></table><h3 id="评审">评审</h3><ol type="1"><li><p>在规划阶段(Planning)，制定审查计划，决定审查会议的次数，安排每次审查会议的时间、地点、参与人员、审查内容等等。</p></li><li><p>在总体部署阶段(Overview)，向所有参与审查会议的人员描述待审查材料的内容、审查的目标以及一些假设，并分发文档。</p></li><li><p>在准备阶段(Preparation)，审查人员各自独立执行检查任务。在检查的过程当中，他们可能会被要求使用检查清单、场景等检查方法。检查中发现的问题会被记录下来，以准备开会讨论或者提交给收集人员。</p></li><li><p>在审查会议阶段(InspectionMeeting)，通过会议讨论，识别、确认、分类发现的错误。</p></li><li><p>在返工阶段(Rework)，修改发现的缺陷。</p></li><li><p>在跟踪阶段(Follow-up)，要确认所有发现的问题都得到了解决，所有的错误都得到了修正。</p></li></ol><h3 id="质量度量">质量度量</h3><p>度量是软件产品在特点属性的量化测试程度。</p><h2 id="软件配置管理">4. 软件配置管理</h2><h3 id="配置管理的概念">配置管理的概念</h3><p>用技术的和管理的指导和监督方法，来标识和说明配置项的功能和物理特征，控制对这些特征的变更，记录和报告变更处理及其实现状态，并验证与规格需求的一致性。</p><p>配置项：</p><p>置于软件配置管理之下的软件配置的各种有关项目，包括各类文档、评审记录与文档、软件文档、源码及其可执行码、运行所需的系统软件和支持软件以及有关数据等。</p><h3 id="配置管理活动">配置管理活动</h3><ul><li>标识配置项</li><li>版本管理</li><li>变更控制</li><li>配置审计</li><li>状态报告</li><li>软件发布管理</li></ul><h3 id="分支管理常见策略">分支管理常见策略</h3><ul><li>主分支</li><li>开发分支</li><li>临时分支<ul><li>功能</li><li>预发布</li><li>修补bug</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件工程与计算2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第十一章_并发控制</title>
    <link href="/2023/03/11/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/03/11/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第十一章-并发控制">第十一章 并发控制</h1><p>事务可以一个一个地串行执行，即每一刻都只有一个事务运行。</p><ul><li>在单处理器系统中，事务的并行执行实际上是这些并行事务的并行操作轮流交叉运行。</li><li>在多处理器系统中，可以实现真正多个事务的并行运行，称为同时并发方式。</li></ul><p>本章讨论的数据库并发控制以单处理器系统为基础。</p><h2 id="并发控制概述">11.1 并发控制概述</h2><p>事务是并发控制的基本单位。</p><p>数据库管理系统需要对并发操作进行正确调度，以保证事务的隔离性和一致性。</p><h3 id="并发操作带来的数据不一致性">并发操作带来的数据不一致性</h3><ul><li>丢失修改<ul><li>两个事务同时读入同一数据进行修改，导致其中一者的修改被丢失</li></ul></li><li>不可重复读<ul><li>一个事务读取数据后，另一个事务更新了数据，使得前一个事务再读取数据异常</li></ul></li><li>读“脏”数据（dirty read）<ul><li>一个事务修改数据，另一个事务读取了数据后，前一个事务被撤销</li></ul></li></ul><p>并发控制机制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务干扰，从而避免造成数据的不一致性。</p><p>并发控制的主要技术：</p><ul><li>封锁</li><li>时间戳</li><li>乐观控制法</li><li>多版本并发控制</li></ul><h2 id="封锁">11.2 封锁</h2><p>封锁是实现并发控制的一种非常重要的技术。封锁就是事务在操作某个数据对象前，先向系统发出请求对其加锁，避免其他事务干扰。</p><h3 id="基本的封锁类型">基本的封锁类型</h3><ul><li>排他锁（exclusive locks，又称X锁、写锁）<ul><li>事务T对数据对象A加上X锁后，只允许T读取和修改A，其他任何事务都不能对A加任何锁，直到T释放锁。</li><li>保证其他事务在T释放锁前不能再读取和修改A。</li></ul></li><li>共享锁（share locks，又称S锁、读锁）<ul><li>事务T对数据对象A加上S锁后，事务T可以读A但不能修改A，而其他事务也只能对A加S锁。</li><li>保证其他事务在T释放锁前不能修改A。</li></ul></li></ul><h3 id="封锁协议">封锁协议</h3><p>封锁协议是运用X锁和S锁的一些规则。</p><p>三级封锁协议的主要区别在于什么操作需要申请封锁，以及何时释放锁。</p><ul><li>封锁协议级别越高，一致性程度越高。</li></ul><h4 id="一级封锁协议">一级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放。</p><ul><li>不能保证可重复读和不读“脏”数据</li></ul><h4 id="二级封锁协议">二级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放；</p><p>事务T在读取数据R之前必须对其加S锁，读完即可释放S锁。</p><ul><li>不能保证可重复读</li></ul><h4 id="三级封锁协议">三级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放；</p><p>事务T在读取数据R之前必须对其加S锁，直到事务结束才释放。</p><h3 id="活锁和死锁">11.2.3 活锁和死锁</h3><h4 id="活锁">活锁</h4><p>事务由于一直被其他事务封锁而永远等待，这就是活锁。</p><p>避免活锁的简单办法是采用先来先服务的策略。</p><h4 id="死锁">死锁</h4><p>两个事务各自封锁了部分资源，又等待对方封锁的资源，这就形成了死锁。</p><p>解决死锁问题的方法：采取一定措施预防死锁；定期诊断系统中有无死锁，有则解除之。</p><h5 id="死锁的预防">死锁的预防</h5><ul><li>一次封锁法<ul><li>每个事务必须一次将所有要使用的数据全部加锁，否则就不能执行</li><li>可以有效防止死锁</li><li>缺点：<ul><li>一次加锁全部数据，扩大封锁范围，降低系统并发度</li><li>数据库数据不断变化，原本不要求封锁的数据可能也会变成封锁对象，很难事先确定每个事务要封锁的全部数据对象。为此只能进一步扩大封锁范围，降低并发度</li></ul></li></ul></li><li>顺序封锁法<ul><li>预先对数据对象规定一个封锁顺序</li><li>可以有效防止死锁</li><li>缺点：<ul><li>数据库系统中要封锁的数据对象太多，维护资源封锁顺序非常困难</li><li>事务的封锁请求可以随着事务的执行动态决定，很难事先确定，按顺序封锁</li></ul></li></ul></li></ul><h5 id="死锁的诊断和解除">死锁的诊断和解除</h5><p>一般使用超时法或事务等待图法。</p><ul><li>超时法<ul><li>一个事务的等待时间超过规定的时限，就认为发生了死锁</li><li>实现简单</li><li>缺点：<ul><li>容易误判死锁</li><li>时间若设置太长，死锁发生后不能及时发现</li></ul></li></ul></li><li>等待图法<ul><li>使用有向图表示的事务等待图动态地反映事务的等待情况。</li></ul></li></ul><p>解除死锁的方法：选择一个处理死锁代价最小的事务进行撤销，之后再加以恢复。</p><h2 id="并发调度的可串行性">11.3 并发调度的可串行性</h2><p>多个事务的并发调度是正确的，当且仅当其结果与按某一次序串行地执行这些事务的结果相同，这种调度策略称为可串行化调度。</p><p>可串行性是并发事务正确调度的准则。一个可串行化的并发调度才是正确的调度。</p><h3 id="可串行化调度的充分条件">可串行化调度的充分条件</h3><h4 id="冲突可串行化">冲突可串行化</h4><p>冲突操作是指不同的事务对同一个数据的读写操作和写写操作。</p><p>不同事务的冲突操作和同一事务的两个操作是不能交换的。</p><p>一个调度在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度。如果这另一个调度是串行的，则称原调度是冲突可串行化的调度。</p><ul><li><p>一个冲突可串行化的调度一定是可串行化的调度。</p><p>即，冲突可串行化是可串行化的充分条件。</p></li></ul><h4 id="两段锁协议">两段锁协议</h4><p>两段锁协议（简称2PL）是当前数据库管理系统普遍采用以实现并发调度可串行性的方法。</p><ul><li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁，称为扩展阶段</li><li>在释放一个封锁后，事务不再申请和获得其他封锁，称为收缩阶段</li></ul><p>事务遵守两段锁协议是可串行化调度的充分条件。</p><h2 id="封锁的粒度">11.4 封锁的粒度</h2><p>封锁对象的大小称为封锁粒度（granularity）。</p><ul><li><p>封锁粒度和系统的并发度和并发控制的开销密切相关。</p></li><li><p>一个系统同时支持多种封锁粒度供不同的事务选择是比较理想的，称为多粒度封锁。</p></li></ul><h3 id="多粒度封锁">多粒度封锁</h3><p>多粒度树：根结点是整个数据库，表示最大的数据粒度，叶结点表示最小的数据粒度。</p><p><strong>多粒度封锁协议</strong>允许多粒度树中的每一个结点被独立地加锁。</p><ul><li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样的锁<ul><li>显式封锁：应事务要求直接加到数据对象上的锁</li><li>隐式封锁：未被独立加锁，因为其上级结点加锁而被加锁</li></ul></li><li>对某个对象加锁，先要检查自身是否有显式封锁与之冲突，再要检查所有上级结点是否赋于它隐式封锁，最后还要检查其下级结点是否有冲突的显式封锁，这样效率太低<ul><li>引入意向锁</li></ul></li></ul><h3 id="意向锁">意向锁</h3><p>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；即任一结点加锁时，须对它的上层结点加意向锁。</p><p>三种常见意向锁：</p><ul><li>意向共享锁（Intent Share Lock，IS锁）<ul><li>对一个结点加S锁，先对其上级结点加IS锁</li></ul></li><li>意向排他锁（Intent Exclusive Lock，IX锁）<ul><li>对一个结点加X锁，先对其上层结点加IX锁</li></ul></li><li>共享意向排他锁（Share Intent Exclusive Lock，SIX锁）<ul><li>一个数据对象先被加了S锁，后被加了IX锁</li></ul></li></ul><p>锁的强度偏序：X—SIX—S/IX—IS</p><ul><li><p>以强锁代替弱锁是安全的，反之则不然</p></li><li><p>申请时自上而下检查，释放时自下而上</p></li></ul><h2 id="其他并发控制机制">11.5 其他并发控制机制</h2><p>时间戳方法、乐观控制法和多版本并发控制等。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第十章_数据库恢复技术</title>
    <link href="/2023/03/10/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/03/10/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第十章-数据库恢复技术">第十章 数据库恢复技术</h1><h2 id="事物的基本概念">10.1 事物的基本概念</h2><h3 id="事物">事物</h3><p>事物是用户定义的一个数据库操作序列，是一个不可分割的工作单位。</p><p>在SQL中，定义事务的语句一般有三条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>事务以<code>BEGIN TRANSACTION</code>开始，以<code>COMMIT</code>或<code>ROLLBACK</code>结束。</p><ul><li><code>COMMIT</code>表示提交</li><li><code>ROLLBACK</code>表示回滚，系统将该事务已经完成的操作全部撤销</li></ul><p>事务是恢复和并发控制的基本单位。</p><h3 id="事务的acid特性">事务的ACID特性</h3><ul><li>原子性（Atomicity）<ul><li>事务是数据库的逻辑工作单位，包括的操作要么都做，要么不做</li></ul></li><li>一致性（Consistency）<ul><li>事务执行的结果必须是数据库从一个一致性状态到另一个一致性状态</li></ul></li><li>隔离性（Isolation）<ul><li>一个事务的执行不能被其他事务干扰</li></ul></li><li>持续性（Durability）<ul><li>也称永久性，一个事务一旦提交，它对数据库中数据的改变就是永久的</li></ul></li></ul><p>保证事务ACID特性是事务管理的重要任务，可能破坏ACID的因素有：</p><ul><li>多个事务并行运行时，不同事务的操作交叉执行</li><li>事务在运行过程中被强行停止</li></ul><h2 id="数据库恢复概述">10.2 数据库恢复概述</h2><p>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态的功能。</p><ul><li>恢复子系统是数据库管理系统的一个重要组成部分</li></ul><h3 id="故障的种类">10.2.1 故障的种类</h3><ul><li>事务内部的故障<ul><li>非预期的，不能由应用程序处理的故障</li><li>恢复程序需要强行回滚该事务，这类恢复操作称为事务撤销（UNDO）</li></ul></li><li>系统故障<ul><li>又称软故障，指造成系统停止运转的任何事件，使得系统要重新启动</li><li>恢复子系统除需要撤销所有未完成的事务，还需要重做（REDO）所有已提交事务</li></ul></li><li>介质故障<ul><li>又称硬故障，指外存故障，如磁盘损坏、磁头碰撞等</li></ul></li><li>计算机病毒</li></ul><p>各类故障对数据库的影响有两种可能性：数据库本身被破坏；数据可能不正确。</p><p>恢复的基本原理：冗余</p><ul><li>数据库任何一部分被破坏或不正确的数据可以根据存储在系统别处的冗余数据来重建</li></ul><h3 id="恢复的实现技术">10.2.2 恢复的实现技术</h3><p>建立冗余数据最常用的技术是数据转储和登记日志文件。通常一个数据库系统会同时使用这两种方法。</p><h4 id="数据转储">数据转储</h4><p>数据转储是数据库恢复中采用的基本技术。数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存。这些备用的数据称为<strong>后备副本</strong>或后援副本。</p><ul><li>重装后备副本只能将数据库恢复到转储时的状态，故必须重新运行转储后的所有更新</li><li>转储十分耗费时间和资源，不能频繁进行</li></ul><p>转储可分为静态转储和动态转储：</p><ul><li>静态转储是在系统中无运行事务时进行的转储操作。<ul><li>简单，保证数据库的一致性，但会降低数据库的可用性</li></ul></li><li>动态转储是指转储期间允许对数据库进行存取或修改<ul><li>必须登记转储期间各事务对数据库的修改活动，建立日志文件</li></ul></li></ul><p>转储又可分为海量转储和增量转储：</p><ul><li>海量转储，一次转储全部数据库</li><li>增量转储，每次只转储上次转储后更新过的数据</li></ul><h4 id="日志文件">日志文件</h4><p>日志文件是用来记录事务对数据库的更新操作的文件，主要有两种格式：</p><ul><li>以记录为单位的日志文件</li><li>以数据块为单位的日志文件</li></ul><p>以记录为单位的日志文件需要登记的内容：</p><ul><li>各个事务的开始、结束标记</li><li>各个事务的所有更新操作</li></ul><p>这里每个事务的开始、结束标记和每个更新操作均作为日志文件的一个日志记录，包括：</p><ul><li>事务标识（表明是哪个事务）</li><li>操作的类型（更新、插入和删除）</li><li>操作对象</li><li>更新前数据的旧值（对于插入操作为空）</li><li>更新后数据的新值（对于删除操作为空）</li></ul><p>以数据块为单位的日志文件需要登记事务标识和被更新的数据块，将更新前和更新后的整个块放入日志文件中。</p><h5 id="日志文件的作用">日志文件的作用</h5><ul><li>事务故障恢复和系统故障恢复必须用日志文件</li><li>在动态转储方式中必须建立日志文件，结合后备副本和日志文件恢复数据库</li><li>在静态转储方式中也可以建立日志文件帮助恢复，不必重新运行已完成的事务</li></ul><h5 id="登记日志文件">登记日志文件</h5><p>为保证数据库可恢复，登记日志文件必须遵循两条原则：</p><ul><li>登记的次序严格按并发事务处理的时间顺序。</li><li>必须先写日志文件，后写数据库</li></ul><h3 id="恢复策略">10.2.3 恢复策略</h3><h4 id="事务故障的恢复">1. 事务故障的恢复</h4><p>事务故障是指事务在运行至正常终点前被终止，这时恢复子系统应利用日志文件做撤销：</p><ol type="1"><li>反向扫描日志文件，查找该事务的更新操作</li><li>对该事务的更新操作进行逆操作</li><li>继续扫描处理直到该事务的开始标记</li></ol><h4 id="系统故障的恢复">2. 系统故障的恢复</h4><p>系统故障的恢复是由系统在重新启动时自动完成的。</p><ol type="1"><li>正向扫描日志文件，找出故障发生前已经提交的事务，将其事务标记记入重做队列，同时找出故障发生时尚未完成的事务，记入撤销队列</li><li>对撤销队列中的各个事务进行撤销</li><li>对重做队列中的各个事务进行重做</li></ol><h4 id="介质故障的恢复">3. 介质故障的恢复</h4><p>恢复方法时重装数据库，重做已完成的事务。</p><ol type="1"><li>装入最新的数据库后备副本</li><li>装入相应的日志文件副本，重做已完成的事务</li></ol><h3 id="具有检查点的恢复技术">10.2.4 具有检查点的恢复技术</h3><p>在日志中增加一类新的记录——检查点记录，增加一个重新开始文件，让恢复子系统在登录日志期间动态维护日志。</p><p>检查点记录的内容：</p><ul><li>建立检查点时刻所有在执行的事务清单</li><li>这些进程是最近一个日志记录的地址</li></ul><p>动态维护日志的方法是：周期性地执行建立检查点、保存数据库状态的操作</p><ol type="1"><li>将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上。</li><li>在日志文件中写入一个检查点记录。</li><li>将当前数据缓冲区的所有数据记录写入磁盘的数据库中。</li><li>把检查点记录在日志文件中的地址写入一个重新开始文件</li></ol><p>使用检查点方法可以改善恢复效率。</p><p>系统使用检查点方法进行恢复的步骤：</p><ol type="1"><li><p>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。</p></li><li><p>由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。这里建立两个事务队列:</p><ul><li>UNDO-LIST：需要执行UNDO操作的事务集合；</li><li>REDO- LIST：需要执行REDO操作的事务集合。</li></ul></li><li><p>从检查点开始正向扫描日志文件。</p><ul><li>如有新开始的事务，把事务暂时放入UNDO-LIST队列；</li><li>如有提交的事务，把事务从UNDO-LIST队列移到REDO-LIST队列；</li></ul><p>直到日志文件结束。</p></li><li><p>对UNDO-LIST中的每个事务执行UNDO操作，对REDO-LIST中的每个事务执行REDO 操作。</p></li></ol><h3 id="数据库镜像">10.2.5 数据库镜像</h3><p>数据库镜像，即数据库管理系统根据数据管理员要求，自动把整个数据库或其中关键数据复制到另一个磁盘上。每当主数据库更新，数据库管理系统自动把更新后的数据复制过去，由数据库管理系统自动保证镜像数据和主数据库的一致性。</p><p>实际应用中，用户往往只选择对关键数据和日志文件进行镜像。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第八章_数据库编程</title>
    <link href="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AB%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/03/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AB%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第八章-数据库编程">第八章 数据库编程</h1><p>SQL编程技术可以有效克服SQL语言实现复杂应用方面的不足，提高应用系统和数据库管理系统间的互操作性。</p><p>在应用系统中使用SQL编程来访问和管理数据库中数据的方式主要有：嵌入式SQL、过程化SQL、存储过程和自定义函数、开放数据库互连、OLEDB、JDBC（Java数据库连接）等。</p><h2 id="嵌入式sql">8.1 嵌入式SQL</h2><p>将SQL语句嵌入程序设计语言中，一般采取预编译方法实现。</p><h3 id="嵌入式sql语句和主语言之间的通信">8.1.1嵌入式SQL语句和主语言之间的通信</h3><p>数据库工作单元与源程序工作单元之间的通信主要包括</p><ul><li>向主语言传递SQL语句的执行状态信息，使主语言能够据此信息控制程序流程，主要用SQL通信区（SQLCommunication Area，SQLCA）实现</li><li>主语言向SQL语句提供参数，主要用主变量实现</li><li>将SQL语句查询数据库的结果交由主语言处理，主要用主变量和游标实现</li></ul><h4 id="sql通信区">SQL通信区</h4><p>SQL语句执行后，系统反馈给应用的信息将被送到SQL通信区中。</p><ul><li>SQL通信区中变量SQLCODE用以存储每次执行SQL后返回的代码</li><li>应用每次执行完一条SQL语句后都应该测试SQLCODE的值</li></ul><h4 id="主变量">主变量</h4><p>SQL中使用的主语言程序变量简称为<strong>主变量</strong>。</p><ul><li>分为输入主变量和输出主变量<ul><li>输入主变量由应用程序赋值，SQL语句引用</li><li>输出主变量由SQL语句赋值，返回给应用程序</li></ul></li><li>一个主变量可以附带一个任选的指示变量<ul><li>指示变量是用以指示主变量的值或条件的整型变量</li></ul></li></ul><h4 id="游标">游标</h4><p>SQL面向集合，一条SQL语句可以产生或处理多条记录；主语言面向记录，一次只能处理一条记录，因此只用主变量不能完全满足SQL和主语言的协同。</p><p>游标是系统为用户开设的一个数据缓冲区，存放SQL的执行结果，每个游标区都有其名字。</p><ul><li>用户通过游标逐一获取记录并赋给主变量，交由主语言处理</li></ul><p>不用游标的SQL语句：</p><p>说明性语句、数据定义语句、数据控制语句、查询结果为单记录的选择语句、非CURRENT形式的增删改语句</p><p>使用游标的SQL语句：</p><p>多条记录的选择语句、CURRENT形式的UPDATE和DELETE语句。</p><h3 id="动态sql">8.1.2 动态SQL</h3><p>上述的嵌入式SQL语句中使用的主变量、查询目标列、条件等都是固定的，是静态SQL语句。但有些应用可能要到执行时才能够确定要提交的SQL语句，这就需要动态SQL语句。</p><h4 id="sql语句主变量">SQL语句主变量</h4><p>程序主变量包含SQL语句的内容，这样的变量称为SQL语句主变量。</p><h4 id="动态参数">动态参数</h4><p>动态参数通过PREPARE语句准备主变量和执行语句绑定数据或主变量来完成。</p><h2 id="过程化sql">8.2 过程化SQL</h2><p>过程化SQL是对SQL的扩展，使其增加了过程化语句功能。</p><p>过程化SQL的基本结构是块。所有的过程化SQL程序都是由块组成。这些块之间可以相互嵌套，每个块完成一个逻辑操作。</p><p>基本结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">定义部分：<span class="hljs-keyword">DECLARE</span> 变量、常量、游标、异常等<br><br>执行部分：<span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">SQL</span>语句、过程化<span class="hljs-keyword">SQL</span>的流程控制语句<br><span class="hljs-keyword">EXCEPTION</span> 异常处理<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>流程控制：IF-THEN-END IF、IF-THEN-ELSE-END IF</p><p>循环控制：LOOP-END LOOP、WHILE-LOOP-END LOOP、FOR-LOOP-END LOOP</p><p>错误处理：过程化SQL提供了完善的异常处理机制</p><h4 id="存储过程与函数">存储过程与函数</h4><p>过程化SQL块主要有两种类型：命名块和匿名块，上述均为匿名块，每次执行都要编译，不能存储到数据库中，也不能在其他过程化SQL块中调用。过程和函数是命名块，被编译后保存在数据库中，称为持久性存储模块，可以被反复调用。</p><p>存储过程是由过程化SQL语句编写的过程，经编译和优化后存储在数据库服务器中。</p><p>函数，也称自定义函数，是用户自己使用过程化SQL设计定义的，和存储过程不同的是必须指定返回的类型。</p><h2 id="odbc编程">8.3 ODBC编程</h2><p>提出和产生ODBC的原因是存在不同的数据库系统。</p><p>ODBC是微软公司开放体系的一部分，建立了一组访问数据库的应用程序编程接口规范（ApplicationProgramming Interface，API）。</p><ul><li>ODBC一方面规范应用开发，另一方面规范关系数据库管理系统应用接口</li></ul><p>ODBC由四部分组成：用户应用程序、ODBC驱动程序管理器、数据库驱动程序、数据源</p><h3 id="用户应用程序">用户应用程序</h3><p>使用ODBC来开发应用系统的程序简称为ODBC应用程序，包括内容：</p><ol type="1"><li>请求连接数据库</li><li>向数据源发送SQL语句</li><li>为SQL语句执行分配空间，定义所读取的数据格式</li><li>获取数据库操作结果或处理错误</li><li>进行数据处理并向用户提交处理结果</li><li>请求事务的提交和回滚操作</li><li>断开与数据源的连接</li></ol><h3 id="odbc驱动程序管理器">ODBC驱动程序管理器</h3><p>驱动程序管理器用来管理各种驱动程序。</p><p>ODBC驱动程序管理器管理应用程序和驱动程序之间的通信，主要功能包括：</p><ul><li><p>装载ODBC驱动程序</p></li><li><p>选择和连接正确的驱动程序</p></li><li><p>管理数据源（建立、配置和删除）</p></li><li><p>检查ODBC调用参数的合法性</p></li><li><p>记录ODBC函数的调用</p></li><li><p>当应用层需要时，返回驱动程序的有关信息</p></li></ul><h3 id="数据库驱动程序">数据库驱动程序</h3><p>ODBC通过数据库驱动程序来提供应用系统和数据库平台的独立性。</p><p>ODBC应用程序的操作通过驱动程序管理器提交给某个驱动程序，调用驱动程序支持的函数来存取数据库。</p><p>单束与多束：</p><ul><li>单束：数据源和应用程序在同一台机器上，驱动程序直接完成对数据文件的输入/输出操作，驱动程序相当于数据管理器</li><li>多束：支持网络环境下数据访问，驱动程序完成数据库访问请求的提交和结果集接受</li></ul><h3 id="odbc数据源管理">ODBC数据源管理</h3><p>数据源时最终用户需要访问的数据，包含了数据库位置和数据库类型等信息，是一种数据连接的抽象。</p><p>ODBC给每个被访问的数据源指定唯一的数据源名，映射到所有必要的、用来存取数据的低层软件。</p><p>在连接中，用数据源名来代表用户名、服务器名、所连接的数据库名等。最终用户无须知道数据库管理系统或其他数据管理软件、网络以及有关ODBC驱动程序的细节，数据源对最终用户是透明的。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第七章_数据库设计</title>
    <link href="/2023/03/07/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/03/07/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第七章-数据库设计">第七章 数据库设计</h1><h2 id="概述">7.1 概述</h2><p>数据库设计是指对于一个给定的应用环境，构造(设计)优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</p><ul><li><p>信息管理要求：在数据库中应该存储和管理哪些数据对象。</p></li><li><p>数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作。</p></li></ul><p>数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境。</p><p>高效率的运行环境：</p><ul><li>数据库数据的存取效率高</li><li>数据库存储空间的利用率高</li><li>数据库系统运行管理的效率高</li></ul><h3 id="数据库设计的特点">7.1.1 数据库设计的特点</h3><h4 id="数据库建设的基本规律">数据库建设的基本规律</h4><p>三分技术、七分管理、十二分基础数据</p><ul><li><p>管理：数据库建设项目管理、企业业务管理</p></li><li><p>基础数据：数据的收集、整理、组织和不断更新</p></li></ul><p>结构（数据）设计和行为（处理）设计相结合</p><ul><li>将数据库结构设计和数据处理设计密切结合</li><li>结构和行为分离的设计：<ul><li>传统软件工程：重行为设计</li><li>早期数据库设计：重结构设计</li></ul></li></ul><h3 id="数据库设计方法">7.1.2 数据库设计方法</h3><p>大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。</p><p>它要求多方面的知识和技术。主要包括：</p><ul><li><p>计算机的基础知识</p></li><li><p>软件工程的原理和方法</p></li><li><p>程序设计的方法和技巧</p></li><li><p>数据库的基本知识</p></li><li><p>数据库设计技术</p></li><li><p>应用领域的知识</p></li></ul><p>数据库设计方法：</p><ul><li>手工试凑法</li><li>规范设计法<ul><li>新奥尔良方法</li><li>基于E-R模型的数据库设计方法</li><li>3NF的设计方法</li><li>面向对象的数据库设计方法</li><li>统一建模语言（UML）方法</li></ul></li></ul><h3 id="数据库设计的基本步骤">7.1.3 数据库设计的基本步骤</h3><p>数据库设计的6个阶段：</p><ul><li>需求分析</li><li>概念结构设计：概念模型</li><li>逻辑结构设计：数据模型</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行和维护</li></ul><p>需求分析和概念设计独立于任何数据库管理系统；</p><p>逻辑设计和物理设计与选用的数据库管理系统密切相关。</p><p>参加数据库设计的人员</p><ul><li>系统分析人员和数据库设计人员<ul><li>自始至终参与数据库设计，其水平决定了数据库系统的 质量</li></ul></li><li>数据库管理员和用户代表<ul><li>主要参加需求分析与数据库的运行和维护</li></ul></li><li>应用开发人员<ul><li>包括程序员和操作员</li><li>在实施阶段参与进来，分别负责编制程序和准备软硬件 环境</li></ul></li></ul><h3 id="数据库设计过程中的各级模式">7.1.4数据库设计过程中的各级模式</h3><ul><li>需求分析阶段：综合分析应用要求</li><li>概念结构设计阶段：概念模式</li><li>逻辑结构设计阶段：逻辑模式与面向应用的外模式</li><li>物理结构设计阶段：内模式</li></ul><h2 id="需求分析">7.2 需求分析</h2><h4 id="数据字典">数据字典</h4><p>数据字典是关于数据库中数据的描述，即元数据，而非数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善的。它在数据库设计中占有重要地位。</p><p>数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。</p><ul><li>数据项：不可再分的数据单位</li><li>数据结构：由若干数据项组成，反映了数据之间的组合关系</li><li>数据流：数据结构在系统内传输的路径</li><li>数据存储：数据结构停留或保存的地方</li><li>处理过程：一般用判定表或判定树来描述</li></ul><p>需求分析阶段收集到的基础数据是下一步进行概念设计的基础。</p><h2 id="概念设计">7.3 概念设计</h2><p>将需求分析得到的用户需求抽象为信息结构的过程就是概念结构设计。</p><h3 id="概念结构设计">概念结构设计</h3><h4 id="实体与属性的划分">实体与属性的划分</h4><p>现实世界事物能作为属性的尽量作为属性对待以简化E-R图。</p><ul><li>作为属性，不能再具有需要描述的物质</li><li>属性不能与其他实体具有联系</li></ul><p>方法：自顶向下地进行需求分析，自底向上地设计概念结构</p><ul><li>首先设计各子系统E-R图，再进行集成、重构</li><li>各子系统E-R图的冲突：<ul><li>属性冲突：属性域、取值单位冲突</li><li>命名冲突：同名异义，异名同义</li><li>结构冲突</li></ul></li></ul><h3 id="e-r模型">E-R模型</h3><p>用实体-联系（E-R）图来描述现实世界的概念模型。</p><p>E-R图提供了表示实体型、属性和联系的方法。</p><ul><li>实体型用矩形表示，矩形内写明实体名</li><li>属性用椭圆形表示，用无向边将其与相应的实体型连接</li><li>联系用菱形表示，菱形内写明联系名，用无向边分别与有关实体型连接，同时在边旁标上联系的类型（1:1、1:n或m:n）</li></ul><p>E-R图的绘制：</p><p>先绘制实体属性图、实体联系图，再进行综合。</p><h4 id="e-r扩展">E-R扩展</h4><h5 id="isa联系">ISA联系</h5><p>某些实体型是某个实体型的子类型，这种父类-子类联系称为ISA联系。</p><p>ISA联系描述了实体型中实体的一种分类方法：</p><ul><li>分类属性<ul><li>使用分类属性的值把父实体型中的实体分派到子实体型中</li></ul></li><li>不相交约束和可重叠约束<ul><li>父类中的一个实体是否能同时属于多个子类中的实体集</li></ul></li><li>完备性约束<ul><li>父类中的一个实体是否必须是某一个子类中的实体<ul><li>是，称为完全特化，双线连接，否则为部分特化，单线连接</li></ul></li></ul></li></ul><h5 id="基数约束">基数约束</h5><p>基数约束是对实体之间一对一、一对多和多对多的细化。</p><p>约束使用一个数对min..max表示</p><ul><li>min = 1的约束为强制参与约束；min = 0的约束为非强制参与约束。</li></ul><h5 id="part-of联系">Part-of联系</h5><p>部分联系，表明某个实体型是另外一个实体型的一部分。</p><ul><li>非独占联系：整体被破坏，部分实体可以存在，用非强制参与联系表示<ul><li>称该部分实体为强实体型</li></ul></li><li>独占联系：整体被破坏，部分实体不能存在<ul><li>称该部分实体为弱实体型，用双矩形表示，用双菱形表示识别联系</li></ul></li></ul><h3 id="uml">UML</h3><p>暂略</p><h2 id="逻辑结构设计">7.4 逻辑结构设计</h2><p>逻辑结构设计的任务就是把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。</p><h3 id="e-r图向关系模型的转换">7.4.1 E-R图向关系模型的转换</h3><p>一般原则：</p><ul><li><p>一个实体型转换为一个关系模式，关系的属性和码就是实体的属性和码。</p></li><li><p>对于实体间的联系：</p><ul><li>1:1联系可以转换为一个独立的关系模式，也可以和任一端的关系模式合并</li><li>1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</li><li>m:n联系可以转换为一个关系模式，与该联系相连的各实体的码以及联系本身的属性均转换成关系的属性，各实体的码组成关系的码或其一部分</li><li>3个及以上实体间的一个多元联系可以转换为一个关系模式</li><li>具有相同码的关系模式可以合并</li></ul></li></ul><h3 id="数据模型的优化">7.4.2 数据模型的优化</h3><p>数据库逻辑设计的结果不是唯一的。</p><p>规范化理论指导的优化方法：</p><ol type="1"><li>确定数据依赖</li><li>对各个关系模式之间的数据依赖进行极小化处理，消除冗余联系</li><li>按照数据依赖的理论对关系模式逐一进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式</li><li>根据需求分析阶段得到的处理要求分析对于这样的应用环境这些模式是否合适，是否要对某些模式进行合并或分解<ul><li>并不是规范化程度越高的关系就越优</li></ul></li><li>对关系模式进行必要分解<ul><li>水平分解：把关系的元组分为若干子集合，定义每个子集合为一个子关系</li><li>垂直分解：把关系模式的属性分解为若干子集合，形成若干子关系模式</li></ul></li></ol><h3 id="设计用户子模式">7.4.3 设计用户子模式</h3><ul><li>使用更符合用户习惯的别名</li><li>可以对不同级别的用户定义不同的视图</li><li>简化用户对系统的使用</li></ul><h2 id="物理结构设计">7.5 物理结构设计</h2><p>数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。</p><p>为一个给定的逻辑模型选取最适合应用要求物理结构的过程，就是数据库的物理设计。其内容主要包括为关系模式选择存取方法，以及设计关系、索引等数据库文件的物理存储结构。</p><p>物理设计一般分为两步：</p><ol type="1"><li>确定数据库物理结构，在关系数据库中主要指存取方法和存储结构</li><li>对物理结构进行评价，评价的重点是时间和空间效率</li></ol><h3 id="关系模式存取方法">7.5.1 关系模式存取方法</h3><p>常用的存取方法为索引方法和聚簇方法。</p><ul><li>B+树索引存取方法</li><li>hash索引存取方法</li><li>聚簇存取方法<ul><li>为了提高某个或某些属性的查询速度，把这个或这些属性上具有相同值的元组集中存放在连续的物理块中称为聚簇，该属性或属性组称为聚簇码</li></ul></li></ul><h3 id="确定数据库的存储结构">7.5.2 确定数据库的存储结构</h3><p>确定数据库物理结构主要指确定数据的存放位置和存储结构，需要综合考虑存取时间、存取空间利用率和维护代价三方面因素。</p><h2 id="数据库的实施和维护">7.6 数据库的实施和维护</h2><h3 id="数据的载入和应用程序的调试">7.6.1数据的载入和应用程序的调试</h3><p>数据库实施阶段包括两项重要工作：数据的载入、应用程序的编码与调试</p><ul><li>组织数据入库是数据库实施阶段最主要的工作。<ul><li>数据装载办法：人工、计算机辅助数据入库</li></ul></li><li>数据库应用程序的设计应该与数据库设计同时进行</li></ul><h3 id="数据库的试运行">7.6.2 数据库的试运行</h3><ul><li>先输入小批量数据调试，合格后再输入大批量数据，逐步完成运行评价</li><li>做好数据库转储和恢复工作</li></ul><h3 id="数据库的运行和维护">7.6.3 数据库的运行和维护</h3><ul><li>数据库的转储和恢复</li><li>数据库的安全性、完整性控制</li><li>数据库性能的监督、分析和改造</li><li>数据库的重组织和重构造</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第六章_关系数据理论</title>
    <link href="/2023/03/06/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
    <url>/2023/03/06/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第六章-关系数据理论">第六章 关系数据理论</h1><h2 id="关系模式与范式">6.1 关系模式与范式</h2><h3 id="数据依赖">数据依赖</h3><p>数据依赖是一个关系内部属性和属性之间的一种约束关系，这种约束关系是通过属性间值的相等与否体现出来的数据间相关联系，是数据内在的性质，语义的体现。</p><p>最重要的数据依赖：</p><ul><li>函数依赖（Functional Dependency，FD）</li><li>多值依赖（Multi-Valued Dependency，MVD）</li></ul><h3 id="关系模式">关系模式</h3><p>在第2章中的五元组关系模式：R(U,D,DOM,F)</p><ul><li>R为符号化的元组语义</li><li>U为一组属性</li><li>D为属性组U的属性所来自的域</li><li>DOM为属性到域的映射</li><li>F为U上的一组数据依赖</li></ul><p>由于D、DOM与模式设计关系不大，本章中把关系模式看作三元组R&lt;U,F&gt;，当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系。</p><h4 id="第一范式1nf">第一范式（1NF）</h4><p>每一个分量都是不可分的数据项的关系模式。</p><p>1NF的问题：</p><p>例：U={Sno,Sdept,Mname,Cno,Grade} //学号、系、系主任名、课程号、成绩</p><ul><li><p>数据冗余</p><p>每个系的系主任名重复出现</p></li><li><p>更新异常</p><p>数据冗余使得更新数据库的代价较大</p></li><li><p>插入异常</p><p>无学生的系无法存入系和系主任的信息</p></li><li><p>删除异常</p><p>学生全部毕业，则系和系主任信息也被删除</p></li></ul><p>改进：分成三个关系模式：</p><ul><li><p>S(Sno,Sdept,Sno-&gt;Sdept)</p></li><li><p>SC(Sno,Cno,Grade,(Sno,Cno)-&gt;Grade)</p></li><li><p>DEPT(Sdept,Mname,Sdept-&gt;Mname)</p></li></ul><h2 id="规范化">6.2 规范化</h2><h3 id="函数依赖">6.2.1 函数依赖</h3><p>定义较为抽象，总结为：</p><ul><li>关系R中两个属性组X和Y，对于Y的任一取值有唯一X确定它，则Y函数依赖于X<ul><li>记为X-&gt;Y</li><li>Y包含于X，此时为平凡的函数依赖</li></ul></li><li>不存在X的真子集能函数确定Y，则Y完全函数依赖于X，否则为部分函数依赖<ul><li>完全函数依赖在箭头上写F，部分写P</li></ul></li><li>Z平凡函数依赖于Y，Y平凡函数依赖于X，则Z传递函数依赖于X</li></ul><p>以下为定义：</p><p>设R(U)是属性集U上的关系模式，X和Y是U的子集，若对R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则X函数确定Y或Y函数依赖于X，记作X-&gt;Y。</p><p>函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。</p><ul><li>X-&gt;Y，Y不包含于X，则称X-&gt;Y为非平凡的函数依赖，一般都讨论这样的函数依赖</li><li>X-&gt;Y，Y包含于X，则称X-&gt;Y为平凡的函数依赖，它对任意关系模式都必然成立</li><li>X-&gt;Y，X称为这个函数依赖的决定属性组，称为决定因素</li><li>X-&gt;Y，Y-&gt;X，记作X&lt;--&gt;Y</li></ul><p>在R(U)中，如果X-&gt;Y，并且对于X的任意真子集X'，都有X'不函数确定Y，则称Y对X完全函数依赖，记作X-&gt;^FY，</p><p>若X-&gt;Y，但Y不对X完全函数依赖，则称Y对X部分函数依赖，记作X-&gt;^PY</p><p>在R(U)中，如果X-&gt;Y不平凡，Y-&gt;Z不平凡，则称Z对X传递函数依赖，记为X-&gt;^{传递}Z</p><ul><li>如果X-&gt;Y平凡，此处为直接函数依赖</li></ul><h3 id="码">6.2.2 码</h3><p>设K是R&lt;U,F&gt;中的属性或属性组合，若U完全函数依赖于K，则K为R的候选码。</p><ul><li>若U部分函数依赖于K，则K称为超码。候选码是最小的超码。</li></ul><p>若候选码多于一个，则选定其中的一个为主码。</p><ul><li><p>包含在任何一个候选码中的属性称为主属性，反之为非主属性或非码属性。</p></li><li><p>整个属性组是码，称为全码</p></li></ul><p>关系模式R中属性或属性组X并非R的码，但是另一个关系模式的码，称X为R的外码。</p><h3 id="范式">6.2.3 范式</h3><p>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</p><p>高级范式真包含于低级范式，从高到低有5NF、4NF、BCNF、3NF、2NF、1NF。</p><p>一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程称为规范化。</p><p>定义抽象，小结：</p><ul><li>1NF：候选码能函数确定每个非主属性</li><li>2NF：候选码能完全函数确定每个非主属性</li><li>3NF：存在码能直接（而非传递）完全函数确定每个非主属性</li><li>BCNF：每个码都能函数确定任意非主属性</li></ul><h4 id="nf">2NF</h4><p>若R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R属于2NF。</p><h4 id="nf-1">3NF</h4><p>若R属于1NF，且每一个非主属性既不传递依赖于码，也不部分依赖于码，则R属于3NF。</p><h4 id="bcnf">BCNF</h4><p>关系模式R中，若每一个决定因素都包含码，则R属于BCNF。</p><ul><li>所有非主属性对每一个码都是完全函数依赖</li><li>所有主属性对每一个不包含它的码也是完全函数依赖</li><li>没有任何属性完全依赖于非码的任何一组属性</li></ul><h4 id="多值依赖">多值依赖</h4><p>设R(U)是属性集U上的一个关系模式，X，Y，Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X-&gt;-&gt;Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。</p><p>性质：</p><ul><li>对称性：X-&gt;-&gt;Y， 则X-&gt;-&gt;Z，其中Z=U-X-Y。</li><li>传递性：X-&gt;-&gt;Y，Y-&gt;-&gt;Z，则X-&gt;-&gt;Z-Y</li><li>函数依赖是多值依赖的特殊情况</li><li>若X-&gt;-&gt;Y，X-&gt;-&gt;Z，则X-&gt;-&gt;YZ，X-&gt;-&gt;Y交Z，X-&gt;-&gt;Y-Z，X-&gt;-&gt;Z-Y</li></ul><p>特点：</p><ul><li><p>多值依赖的有效性与属性集的范围有关</p></li><li><p>若函数依赖X-&gt;-&gt;Y在R(U)上成立，则对于任何Y‘包含于Y，均有X-&gt;-&gt;Y'成立。而多值依赖X-&gt;-&gt;Y若在R(U)上成立，却不能断言对于任何Y'包含于Y有X-&gt;-&gt;Y'成立。</p></li></ul><h4 id="nf-2">4NF</h4><p>限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</p><h3 id="规范化小结">6.2.4 规范化小结</h3><p>规范化的基本思想是逐步消除数据依赖的不合适部分，实质上是概念的单一化。</p><p>关系模式的规范化过程是通过对关系模式的分解来实现的。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第五章_数据库完整性</title>
    <link href="/2023/03/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    <url>/2023/03/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第五章-数据库完整性">第五章 数据库完整性</h1><p>数据库的完整性是指数据的正确性和相容性。</p><ul><li>数据的正确性是指数据是复合现实世界语义，反映当前实际情况的</li><li>数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的</li></ul><p>数据库管理系统为维护数据库完整性而实现的功能：</p><ul><li>提供定义完整性约束条件的机制</li><li>提供完整性检查的方法</li><li>进行违约处理</li></ul><p>关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能够为所有用户和应用提供一致的数据库完整性。</p><h2 id="实体完整性">5.1 实体完整性</h2><p>关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。</p><ul><li>对单属性构成的码，可以在列级定义，也可以在表级定义<ul><li>Sno CHAR(9) PRIMARY KEY</li><li>PRIMARY KEY (Sno)</li></ul></li><li>对多属性构成的码，只能在表级定义<ul><li>PRIMARY KEY(Sno, Cno)</li></ul></li></ul><p>实体完整性检查和违约处理</p><ul><li>检查主码的各个属性是否为空，有一个为空就拒绝插入或修改</li><li>检查主码值是否唯一，如果不唯一就拒绝插入或修改<ul><li>方法：全表扫描、B+树索引</li></ul></li></ul><h2 id="参照完整性">5.2 参照完整性</h2><p>关系模型的参照完整性在CREATE TABLE中用FOREIGNKEY来定义哪些列尾外码，用REFERENCES短语指明这些外码参照哪些表的主码。</p><p>参照完整性检查和违约处理</p><table><thead><tr class="header"><th>被参照表</th><th>参照表</th><th>违约处理</th></tr></thead><tbody><tr class="odd"><td>可能破坏参照完整性</td><td>插入元组</td><td>拒绝</td></tr><tr class="even"><td>可能破坏参照完整性</td><td>修改外码值</td><td>拒绝</td></tr><tr class="odd"><td>删除元组</td><td>可能破坏参照完整性</td><td>拒绝/级联删除/设置为空值</td></tr><tr class="even"><td>修改主码值</td><td>可能破坏参照完整性</td><td>拒绝/级联删除/设置为空值</td></tr></tbody></table><ul><li>拒绝（NO ACTION），一般为默认策略</li></ul><h2 id="用户定义的完整性">5.3 用户定义的完整性</h2><p>用户定义的完整性就是针对某一具体应用的数据必须满足的语义条件。</p><ul><li><p>属性上的约束条件</p><ul><li><p>非空（NOT NULL）</p></li><li><p>唯一（UNIQUE）</p></li><li><p>用CHECK语句指定列值条件</p><p><code>Sex CHAR(2) CHECK (Sex IN('男','女'))</code></p></li><li><p>修改或插入时检查；违约处理：拒绝执行</p></li></ul></li><li><p>元组上的约束条件</p><ul><li>用CHECK指定元组约束条件</li><li>修改或插入时检查；违约处理：拒绝执行</li></ul></li></ul><h2 id="完整性约束命名子句">5.4 完整性约束命名子句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>完整性约束条件名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>完整性约束条件<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student <br>(Sno <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">6</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span> (Sno <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">90000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">99999</span>), <br> Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C2 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br> Sage <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>), <br> Ssex <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C4 <span class="hljs-keyword">CHECK</span>(SSex <span class="hljs-keyword">IN</span>(<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>)), <br><span class="hljs-keyword">CONSTRAINT</span> StudentKey <span class="hljs-keyword">PRIMARY</span> KEY(Sno)<br>;)<br></code></pre></td></tr></table></figure><p>修改例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C3;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><h2 id="域中的完整性限制">5.5 域中的完整性限制</h2><p>域是一组具有相同数据类型的值的集合。</p><p>SQL中，可以用CREATEDOMAIN来创建一个域以及其应该满足的完整性约束条件以定义属性。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DOMAIN GenderDomain <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">CONSTRAINT</span> GD <span class="hljs-keyword">CHECK</span>(<span class="hljs-keyword">VALUE</span> <span class="hljs-keyword">IN</span>(<span class="hljs-string">&#x27;男&#x27;</span>，<span class="hljs-string">&#x27;女&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="断言">5.6 断言</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ASSERTION <span class="hljs-operator">&lt;</span>断言名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">CHECK</span>子句<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h2 id="触发器">5.7 触发器</h2><p>触发器（trigger）是用户定义在关系表上的一类由事件驱动的特殊过程。</p><ul><li>触发器又叫事件-条件-动作规则。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span><br>&#123;BEFORE<span class="hljs-operator">|</span>AFTER&#125; <span class="hljs-operator">&lt;</span>触发事件<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-comment">/* 指明触发器激活时间在事件前后 */</span><br><span class="hljs-keyword">REFERENCING</span> <span class="hljs-keyword">NEW</span><span class="hljs-operator">|</span><span class="hljs-keyword">OLD</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>变量<span class="hljs-operator">&gt;</span>  <span class="hljs-comment">/* 指明引用的变量 */</span><br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> &#123;<span class="hljs-type">ROW</span><span class="hljs-operator">|</span>STATEMENT&#125;<br>[<span class="hljs-keyword">WHEN</span> <span class="hljs-operator">&lt;</span>触发条件<span class="hljs-operator">&gt;</span>] <span class="hljs-operator">&lt;</span>触发动作体<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只有表的拥有者才能在表上创建触发器，且触发器数量有限</li><li>同一模式下，触发器名必须是唯一的，且触发器名和表名必须在同一模式下</li><li>触发器只能定义在基本表上，不能定义在视图上</li><li>触发事件可以是INSERT、DELETE或UPDATE，也可以是其组合</li><li>行级触发器每行都执行，语句级触发器只触发一次</li></ul><p>删除触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第四章_数据库安全性</title>
    <link href="/2023/03/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <url>/2023/03/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第四章-数据库安全性">第四章 数据库安全性</h1><h2 id="数据库安全性概述">4.1 数据库安全性概述</h2><p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</p><p>系统安全保护措施是否有效是数据库系统的主要技术指标之一。</p><h3 id="数据库的不安全因素">数据库的不安全因素</h3><ul><li>非授权用户对数据库的恶意存取和破坏</li><li>数据库中重要或敏感的数据被泄露</li><li>安全环境的脆弱性</li></ul><h3 id="安全标准简介">安全标准简介</h3><p>TCSEC/TDI</p><table><thead><tr class="header"><th>安全级别</th><th>定义</th></tr></thead><tbody><tr class="odd"><td>A1</td><td>验证设计</td></tr><tr class="even"><td>B3</td><td>安全域</td></tr><tr class="odd"><td>B2</td><td>结构化保护</td></tr><tr class="even"><td>B1</td><td>标记安全保护</td></tr><tr class="odd"><td>C2</td><td>受控的存取保护</td></tr><tr class="even"><td>C1</td><td>自主安全保护</td></tr><tr class="odd"><td>D</td><td>最小保护</td></tr></tbody></table><ul><li><p>D级，最低级别，一切不符合更高标准的系统均归于D组</p></li><li><p>C1：能够实现对用户和数据的分离，进行自主存取控制(DAC)</p></li><li><p>B1：对系统数据加以标记，并对被标记的主客体实施强制存取控制(MAC)以及审计</p></li><li><p>B1以上为安全产品</p></li></ul><p>CC（Common Criteria）：安全功能要求和安全保证要求</p><h2 id="数据库安全性控制">4.2 数据库安全性控制</h2><p>主要内容：</p><ul><li>用户身份鉴别</li><li>多层存取控制</li><li>审计</li><li>视图</li><li>数据加密</li></ul><h3 id="用户身份鉴别">4.2.1 用户身份鉴别</h3><p>常见方法：</p><ul><li>静态口令鉴别</li><li>动态口令鉴别</li><li>生物特征鉴别</li><li>智能卡鉴别</li></ul><h3 id="存取控制">4.2.2 存取控制</h3><p>存取控制机制的组成：</p><ul><li>定义用户权限<ul><li>提供适当语言以定义用户权限，编译后存储在数据字典中，称为安全规则</li></ul></li><li>合法权限检查<ul><li>根据安全规则进行合法权限检查</li></ul></li><li>定义用户权限和合法权限检查机制一起组成了数据库管理系统的存取控制子系统。</li></ul><p>C2级的数据库管理系统支持自主存取控制（Discretionary AccessControl，DAC）；</p><p>B1级的数据库管理系统支持强制存取控制（Mandatory AccessControl，MAC）。</p><ul><li>在自主存取控制中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，用户可将其拥有的存取权限转授给其他用户</li><li>在强制存取控制中，每个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取</li></ul><h4 id="自主存取控制">自主存取控制</h4><p>用户权限的两个要素：数据库对象和操作类型</p><ul><li>在数据库系统中，定义存取权限称为授权</li></ul><p>关系数据库系统中，存取控制的对象不仅有数据本身，还有数据库模式</p><table><thead><tr class="header"><th>对象类型</th><th>对象</th></tr></thead><tbody><tr class="odd"><td>数据</td><td>基本表和视图、属性列</td></tr><tr class="even"><td>数据库模式</td><td>模式、基本表、视图、索引</td></tr></tbody></table><p>SQL使用GRANT语句向用户授予权限，REVOKE语句收回已经授予用户的权限。</p><h5 id="grant">GRANT</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION]<br></code></pre></td></tr></table></figure><ul><li>如果制定了WITH GRANTOPTION子句，则授权的用户可以把这种权限转授。</li><li>GRANT ALL PRIVILEGES可以将全部操作权限授予用户</li><li>授予全部用户：TO PUBLIC</li><li>对属性列授权时必须明确指出相应的属性列名</li></ul><h5 id="revoke">REVOKE</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...[CASCADE<span class="hljs-operator">|</span>RESTRICT];<br></code></pre></td></tr></table></figure><ul><li>一般默认CASCADE，将收回全部直接或间接从该用户获得的对应权限，而RESTRICT只收回指定用户的权限</li></ul><h5 id="创建数据库模式的权限">创建数据库模式的权限</h5><p>创建数据库模式一类的数据库对象的授权由数据库管理员在创建用户时完成。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WITH</span>] [DBA<span class="hljs-operator">|</span>RESOURCE<span class="hljs-operator">|</span><span class="hljs-keyword">CONNECT</span>];<br></code></pre></td></tr></table></figure><ul><li>只有系统的超级用户才有权创建一个新的数据库用户</li><li>新创建的数据库用户有三种权限：CONNECT、RESOURCE、DBA，默认CONNECT<ul><li>CONNECT权限用户不能创建新用户、模式、基本表</li><li>RESOURCE权限用户可以创建基本表，不能创建新用户和模式</li><li>DBA权限用户是系统的超级用户，可以创建新用户、模式和基本表，拥有所有数据库对象的存取权限</li></ul></li></ul><h5 id="数据库角色-role">数据库角色 ROLE</h5><p>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。</p><ul><li>为一组具有相同权限的用户创建一个角色，简化授权的过程</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ROLE <span class="hljs-operator">&lt;</span>角色名<span class="hljs-operator">&gt;</span>;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">3</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> ADMIN OPTION]<br><br><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br></code></pre></td></tr></table></figure><ul><li>如果指定了WITH ADMIN OPTION，那么获得权限的用户可以转授该权限。</li></ul><h4 id="强制存取控制">强制存取控制</h4><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类。</p><ul><li><p>主体是系统中的活动实体，既包括数据管理系统所管理的实际用户，也包括代表用户的各进程</p></li><li><p>客体是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引等。</p></li><li><p>对于主体和客体，数据库管理系统为它们每个实例指派一个敏感度标记（label）</p><p>敏感度标记被分为若干级别，如绝密（TopSecret，TS），机密（Secret，S），可信（Confidential，C），公开（Public，P），TS&gt;=S&gt;=C&gt;=P</p><p>主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级</p><ul><li>仅当主体的许可证级别大于等于客体的密级时，该主体才能读取该客体</li><li>仅当主体的许可证级别小于等于客体的密级时，该主体才能写该客体</li><li>即用户只能读低于或等于自己许可的数据，创建高于或等于自己许可的数据，以防止高级用户将数据泄露给低级用户</li></ul></li><li><p>强制存取控制对数据本身加以的密级标识和数据时一个整体</p></li></ul><h5id="自主存取控制强制存取控制dacmac">自主存取控制+强制存取控制（DAC+MAC）</h5><p>先进行自主存取控制审查，在进行强制存取控制检查</p><h2 id="一些安全性保护办法">4.3 一些安全性保护办法</h2><h3 id="视图机制">4.3.1 视图机制</h3><p>把要保密的数据对无权存取的用户隐藏起来，为数据提供一定程度的安全保护。</p><h3 id="审计audit">4.3.2 审计（audit）</h3><p>审计功能把用户对数据库的所有操作自动记录下来放入审计日志（auditlog）。</p><ul><li>审计通常是很费时间和空间的，所以数据库系统往往都将审计设置成可选的</li><li>审计设置以及审计日志一般存储在数据字典中，必须开启审计开关（设置audit_trail为true），才能在系统表SYS_AUDITTRAIL中看到审计信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">AUDIT <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>;<br><br>NOAUDIT <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>审计一般可以分为用户级审计和系统级审计。</p><p>数据库安全审计系统提供了一种事后检查的安全机制。安全审计机制将特定用户或者特定对象相关的操作记录到系统审计日志中，作为后续对操作的查询分析和追踪的依据。通过审计机制，可以约束用户可能的恶意操作。</p><h3 id="数据加密">4.3.3 数据加密</h3><p>加密的基本思想是依据一定的算法将原始数据——明文（plaintext）变换为不可直接识别的格式——密文（cipher text）。</p><p>数据加密主要包括存储加密和传输加密。</p><ul><li>存储加密<ul><li>透明存储加密：内核级加密保护，对用户完全透明</li><li>非透明存储加密：通过多个加密函数实现</li></ul></li><li>传输加密<ul><li>链路加密：对传输数据在链路层进行加密，加密报文和报头</li><li>端到端加密：在发送端加密，接收端解密，加密报文</li></ul></li></ul><h3 id="其他安全性保护">4.3.4 其他安全性保护</h3><ul><li><p>推理控制：避免由低级数据推导出高级数据</p></li><li><p>隐蔽信道：间接信息传递</p></li><li><p>数据隐私：控制不愿他人知道或他人不便知道的个人数据的能力</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第三章_SQL</title>
    <link href="/2023/03/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%89%E7%AB%A0_SQL/"/>
    <url>/2023/03/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%89%E7%AB%A0_SQL/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第三章-sql">第三章 SQL</h1><p>结构化查询语言（Structured QueryLanguage，SQL）是关系数据库标准语言，功能包括</p><ul><li>数据库的查询</li><li>数据库模式创建</li><li>数据库数据的插入与修改</li><li>数据库安全性完整性定义与控制</li><li>……</li></ul><h2 id="sql概述">3.1 SQL概述</h2><h3 id="sql的特点">3.1.1 SQL的特点</h3><ul><li>综合统一<ul><li>集数据定义语言、数据操纵语言、数据控制语言于一体</li></ul></li><li>高度非过程化<ul><li>存取路径的选择以及SQL的操作过程由系统自动完成</li></ul></li><li>面向集合的操作方式<ul><li>操作对象、查找结果都可以是元组的集合</li></ul></li><li>以同一种语法结构提供多种使用方式<ul><li>能嵌入到C++、Java中</li></ul></li><li>语言简洁，易学易用<ul><li>数据查询：SELECT</li><li>数据定义：CREATE、DROP、ALTER</li><li>数据操纵：INSERT、UPDATE、DELETE</li><li>数据控制：GRANT、REVOKE</li></ul></li></ul><h3 id="sql的基本概念">3.1.2 SQL的基本概念</h3><h4 id="sql与三级模式">SQL与三级模式</h4><ul><li>内模式：存储文件</li><li>模式：基本表</li><li>外模式：视图</li></ul><p>用户可以用SQL对基本表和视图进行查询或其他操作。基本表和视图都是关系。</p><p>基本表是本事独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表，一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。</p><p>存储文件的逻辑结构组成了关系数据库的内模式，其逻辑结构对用户是隐蔽的。</p><p>视图是一个或几个基本表导出的表，它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据。这些数据仍存放在导出视图的基本表中，因而视图仅仅是一个虚表。用户可以在视图上再定义视图。</p><h2 id="数据定义">3.2 数据定义</h2><p>层次化的数据库对象命名机制：</p><p>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</p><p>SQL的数据定义：模式定义、表定义、视图定义和索引定义</p><table><thead><tr class="header"><th>操作对象</th><th>创建</th><th>删除</th><th>修改</th></tr></thead><tbody><tr class="odd"><td>模式</td><td>CREATE SCHEMA</td><td>DROP SCHEMA</td><td></td></tr><tr class="even"><td>表</td><td>CREATE TABLE</td><td>DROP TABLE</td><td>ALTER TABLE</td></tr><tr class="odd"><td>视图</td><td>CREATE VIEW</td><td>DROP VIEW</td><td></td></tr><tr class="even"><td>索引</td><td>CREATE INDEX</td><td>DROP INDEX</td><td>ALTER INDEX</td></tr></tbody></table><h3 id="模式">模式</h3><p>定义模式即定义了一个命名空间，在此空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">AUTHORIZATION</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-operator">&lt;</span>表定义子句<span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>视图定义子句<span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>授权定义子句<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure><p>不指定模式名时，模式名将隐含为用户名。</p><p>删除模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>CASCADE<span class="hljs-operator">|</span>RESTRICT<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><ol type="1"><li>CASCADE：删除模式的同时删除该模式中所有数据库对象</li><li>RESTRICT：如果该模式中定义了下属的数据库对象，则拒绝执行删除</li></ol><h3 id="基本表">基本表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]<br>[，<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]]<br>…<br>[，<span class="hljs-operator">&lt;</span>表级完整性约束条件<span class="hljs-operator">&gt;</span>]);<br></code></pre></td></tr></table></figure><p>列级完整性：PRIMARY KEY、UNIQUE、NOT NULL等</p><p>表级完整性：PRIMARY KEY(Sno, Cno)；FOREIGN KEY(Cno) REFERENCESCourse(Cno)</p><table><thead><tr class="header"><th>数据类型</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>CHAR(n),CHARACTER(n)</td><td>长度为n的定长字符串</td></tr><tr class="even"><td>VARCHAR(n)</td><td>最大长度为n的变长字符串</td></tr><tr class="odd"><td>CLOB</td><td>字符串大对象</td></tr><tr class="even"><td>BLOB</td><td>二进制大对象</td></tr><tr class="odd"><td>INT，INTEGER</td><td>长整数(4字节)</td></tr><tr class="even"><td>SMALLINT</td><td>短整数(2字节)</td></tr><tr class="odd"><td>BIGINT</td><td>大整数(8字节)</td></tr><tr class="even"><td>NUMERIC(p，d)</td><td>定点数，由p位数字(不包括符号、小数点)组成，小数后面有d位数字</td></tr><tr class="odd"><td>DECIMAL(p, d), DEC(p, d)</td><td>同NUMERIC</td></tr><tr class="even"><td>REAL</td><td>取决于机器精度的单精度浮点数</td></tr><tr class="odd"><td>DOUBLE PRECISION</td><td>取决于机器精度的双精度浮点数</td></tr><tr class="even"><td>FLOAT(n)</td><td>可选精度的浮点数，精度至少为n位数字</td></tr><tr class="odd"><td>BOOLEAN</td><td>逻辑布尔量</td></tr><tr class="even"><td>DATE</td><td>日期，包含年、月、日，格式为YYYY-MM-DD</td></tr><tr class="odd"><td>TIME</td><td>时间，包含一日的时、分、秒，格式为HH:MM:SS</td></tr><tr class="even"><td>TIMESTAMP</td><td>时间戳类型</td></tr><tr class="odd"><td>INTERVAL</td><td>时间间隔类型</td></tr></tbody></table><p>修改基本表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <br>[<span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>新列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [完整性约束]]<br>[<span class="hljs-keyword">ADD</span> <span class="hljs-operator">&lt;</span>表级完整性约束<span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">DROP</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [CASCADE<span class="hljs-operator">|</span> RESTRICT]]<br>[<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span><span class="hljs-operator">&lt;</span>完整性约束名<span class="hljs-operator">&gt;</span>[RESTRICT <span class="hljs-operator">|</span> CASCADE]]<br>[<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>]；<br></code></pre></td></tr></table></figure><ul><li><p>ADD用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件</p></li><li><p>DROP COLUMN用于删除表中列</p></li><li><p>DROP CONSTRAINT用于删除指定的完整性约束条件</p></li><li><p>ALTER COLUMN用于修改原有列定义，包括列名和数据类型</p></li></ul><h3 id="索引">索引</h3><p>作用：加快查询速度</p><p>建立索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>顺序<span class="hljs-operator">&gt;</span>]…);<br></code></pre></td></tr></table></figure><ul><li><p>顺序：</p><ul><li>升序：ASC</li><li>降序：DESC</li><li>缺省值：ASC</li></ul></li><li><p>UNIQUE：每个索引值只对应唯一的数据记录</p></li><li><p>CLUSTER：表示要建立的索引是聚簇索引</p></li></ul><p>修改索引：<code>ALTER INDEX &lt;旧名称&gt; RENAME TO &lt;新名称&gt;</code>;</p><p>删除索引：<code>DROP INDEX &lt;名称&gt;;</code></p><h2 id="数据查询">3.3 数据查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span><span class="hljs-operator">|</span><span class="hljs-keyword">DISTINCT</span>] <span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span>]…<br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表<span class="hljs-operator">/</span>视图名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>表<span class="hljs-operator">/</span>视图名<span class="hljs-operator">&gt;</span>]… <span class="hljs-operator">|</span> (<span class="hljs-keyword">SELECT</span>语句) [<span class="hljs-keyword">AS</span>] <span class="hljs-operator">&lt;</span>别名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件表达式<span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>条件表达式<span class="hljs-operator">&gt;</span>]]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]<br></code></pre></td></tr></table></figure><ul><li>DISTINCT：去除重复行，缺省为ALL</li><li>WHERE表示指定条件，作用于表<ul><li>BETWEEN AND（范围）、IN（集合）、LIKE（匹配字符）、ISNULL（空值）、AND OR（多重条件查询）、ORDER BY（升降排列）</li></ul></li><li>聚集函数只用于SELECT和GROUP BY中的HAVING子句<ul><li>COUNT、SUM、AVG、MAX、MIN（需要指定DISTINCT或ALL）</li></ul></li><li>GROUP BY按照某一列或多列的值分组<ul><li>指定属性值相同的元组为一组，然后对每一组作用聚集函数进行计算</li></ul></li></ul><table><thead><tr class="header"><th>查询条件</th><th>谓词</th></tr></thead><tbody><tr class="odd"><td>比较</td><td>=, &gt;, &lt;, &gt;=, &lt;=, !=, &lt;&gt;, !&gt;, !&lt;;NOT+上述比较运算符</td></tr><tr class="even"><td>确定范围</td><td>BETWEEN AND, NOT BETWEEN AND</td></tr><tr class="odd"><td>确定集合</td><td>IN, NOT IN</td></tr><tr class="even"><td>字符匹配</td><td>LIKE, NOT LIKE</td></tr><tr class="odd"><td>空值</td><td>IS NULL, IS NOT NULL</td></tr><tr class="even"><td>多重条件(逻辑运算)</td><td>AND, OR, NOT</td></tr></tbody></table><h4 id="字符匹配">字符匹配</h4><p>匹配串可以是一个完整的字符串，也可以含有通配符%(任意长度字符串)和_(任意单个字符)</p><p>用。</p><h4 id="空值">空值</h4><ul><li>产生：没赋值/修改/外连接/关系运算</li><li>判断：IS NULL / IS NOT NULL (注意IS一直有)</li><li>约束条件：NOT NULL / UNIQUE / PRIMARY KEY不能取空值</li><li>逻辑运算：TRUE FALSE UNKNOWN</li></ul><h4 id="聚集函数">聚集函数</h4><p>统计元组个数：COUNT(*)</p><p>统计一列中值的个数：COUNT([DISTINCT | ALL] <列名>)</p><p>计算一列值的总和(必须为数值型)：SUM([DISTINCT | ALL] <列名>)</p><p>计算一列值的平均值(必须为数值型)：AVG([DISTINCT | ALL] <列名>)</p><p>求最大最小值：MAX / MIN([DISTINCT | ALL] 列名)</p><h4 id="连接查询">连接查询</h4><p>连接查询即同时涉及两个以上表的查询，连接条件或连接谓词是连接两表的条件</p><p><列1> <比较运算符> <列2></p><p><列1> BETWEEN <列2> AND <列3></p><p>连接字段：连接谓词中的列名称。</p><ul><li><p>等值/自然连接：连接运算符为=。</p></li><li><p>自身连接：表与自己进行连接：需要给表起别名，并使用别名前缀以示区别。</p></li><li><p>多表连接</p></li></ul><p>连接操作的执行过程</p><ol type="1"><li>嵌套循环</li></ol><p>逐个对表1中每个元组执行遍历表2的连接操作。</p><ol start="2" type="1"><li>排序合并</li></ol><p>首先按连接属性对两表排序，然后查找表1中元组在表2中的连接，查找到大于表1字段值的元组后，查询不再继续。</p><ol start="3" type="1"><li>索引连接</li></ol><p>对表2按连接字段建立索引，依次查询表1中各元组的连接。</p><p>外连接：以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</p><p>SELECT <字段名> FROM <表名> LEFT JOIN <表名> ON <连接条件></p><h4 id="嵌套查询">嵌套查询</h4><p><字段名> IN/比较运算符 (ANY/ALL) <查询语句> (NOT) EXISTS<查询语句></p><h4 id="集合操作">集合操作</h4><ul><li>并 UNION、交 INTERSECT、差 EXCEPT</li></ul><p>参与集合操作的各查询结果的列数和各数据类型必须相同。</p><p>UNION：合并多个查询结果，去掉重复元组</p><p>UNION ALL：合并多个查询结果，保留重复元组</p><h4 id="派生表查询">派生表查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> (查询语句);<br></code></pre></td></tr></table></figure><p>若子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT语句子句后列名为其缺省属性。</p><h2 id="数据更新">3.4 数据更新</h2><ul><li><p>插入：INSERT INTO <表名> [<属性列>,…] VALUES (<常量>,…)</p><ul><li>指定要插入数据的表名及属性列，插入的元组在其余属性列取空值。</li><li>未指定属性列：插入完整元组，且属性列属性的顺序和表一致。</li><li>VALUES提供的值的个数与类型必须与INTO子句匹配。</li></ul></li><li><p>修改：UPDATE <表名> SET <列名>=<表达式>,… [WHERE 条件]</p></li><li><p>删除：DELETE FROM <表名> [WHERE 条件]</p></li></ul><h2 id="视图">3.5 视图</h2><p>视图是虚表，从一个或几个基本表导出，只存放定义而无数据，基表中数据变化，视图中数据也随之改变。</p><p>视图的更新是同步于基本表的，一般来说，行列子集视图可以更新，其他（如AVG）不可。</p><p>视图的作用：</p><ul><li>简化用户的操作</li><li>使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性<ul><li>外模式不变，即使模式变更也不影响</li></ul></li><li>对机密数据提供安全保护<ul><li>每个用户看到的视图不同</li></ul></li><li>可以更清晰地表达查询</li></ul><p>视图做不到的：</p><ul><li>部分特殊视图不允许更新</li><li>视图消解有局限性，有时不能正确地查询</li></ul><h3 id="建立视图">建立视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>,…)]<br><span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>子查询<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure><ul><li><p>WITH CHECKOPTION：对视图进行UPDATE、INSERT和DELETE时要保证更新的行满足视图定义中的谓词条件(即子查询中的条件表达式)。</p><ul><li>子查询可以是任意的select语句。</li></ul></li><li><p>行列子集视图：从单个表导出某些列，保留主码</p></li><li><p>组成视图的属性列名：全部省略或全部指定</p></li><li><p>实现增删改视图--&gt;增删改基本表：不写聚集函数</p></li></ul><p>关系数据库管理系统在执行CREATEVIEW的时候只是将视图定义存入数据字典，并不执行SELECT。查询时，按定义将其查出。</p><h3 id="删除视图">删除视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [CASCADE];<br></code></pre></td></tr></table></figure><p>CASCADE：级联地删除视图及其导出的视图。</p><h3 id="查询视图">查询视图</h3><p>用户查询视图与查询基本表一致。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第二章_关系数据库</title>
    <link href="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/03/02/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第二章-关系数据库">第二章 关系数据库</h1><h2 id="关系数据结构及其形式化定义">2.1 关系数据结构及其形式化定义</h2><h3 id="关系">2.1.1 关系</h3><h4 id="关系数据结构的形式化定义">关系数据结构的形式化定义</h4><ol type="1"><li>域（domain）</li></ol><p>域是一组具有相同数据类型的值的集合</p><ol start="2" type="1"><li>笛卡尔积（cartesian product）</li></ol><p>笛卡尔积是域上的一种集合运算。</p><p>给定一组域<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>，允许其中某些域是相同的，<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>的笛卡尔积为</p><p><span class="math inline">\(D_1\times D_2\times ...\timesD_n=\{(d_1,d_2,...,d_n)|d_i\in D_i,i=1,2,...,n\}\)</span></p><p>其中，每个元素<spanclass="math inline">\((d_1,d_2,...,d_n)\)</span>称作一个n元组（n-tuple），或简称元组。元组中的每一个值<spanclass="math inline">\(d_i\)</span>称为一个分量。</p><p>一个域允许的不同取值个数称为这个域的基数（cardinal number）。</p><p>若<span class="math inline">\(D_i\)</span>为有限集，其基数为<spanclass="math inline">\(m_i(i=1,2,...,n)\)</span>，则<spanclass="math inline">\(D_1\times D_2\times ...\timesD_n\)</span>的基数M为</p><p><span class="math inline">\(M=\prod_{i=1}^n m_i\)</span></p><ol start="3" type="1"><li>关系</li></ol><p><span class="math inline">\(D_1\times D_2\times ...\timesD_n\)</span>的子集称为在域<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>上的关系，表示为<spanclass="math inline">\(R(D_1,D_2,...,D_n)\)</span>。</p><p>这里R表示关系的名字，n是关系的目或度（degree），关系中的每个元素是关系中的元组，通常用t表示。</p><ul><li>当<spanclass="math inline">\(n=1\)</span>时，称该关系为一元关系（unaryrelation）</li><li>当<spanclass="math inline">\(n=2\)</span>时，称该关系为二元关系（binaryrelation）</li></ul><p>关系是笛卡尔积的有限子集，故关系是一张每行对应一个元组的二维表，表的每列对应一个域。每列的名字为属性，n目关系必有n个属性。</p><p>若关系中的某一属性组能唯一地标识一个元组而其子集不能，则称该属性组为候选码（candidatekey）。</p><p>若一个关系有多个候选码，则选定其中一个为主码（primary key）。</p><p>候选码地各个属性为主属性（primeattribute）。不包含在任何候选码中的属性称为非主属性或非码属性。</p><p>在最简单地情况下，候选码只包含一个属性，在最极端地情况下，关系模式地所有属性是这个关系模式地候选码，称为全码（all-key）。</p><h5 id="关系的三种类型">关系的三种类型</h5><p>基本表、查询表和视图表，其中基本表为实际存在的表，查询表是查询结果对应的表，视图表是由基本表或其他视图表导出的表，是虚表。</p><h5 id="基本关系的性质">基本关系的性质</h5><ol type="1"><li>列是同质的，每一列中的分量是同一类型的数据，来自同一个域</li><li>不同的列可来自同一个域，但有不同的属性名</li><li>列和行都是无序的</li><li>任意两个元组的候选码不能取相同值</li><li>每个分量都是不可分的数据项</li></ol><p>关系模型要求关系必须是规范化的，满足一定的规范条件。规范化的关系称为范式（NormalForm，NF）。</p><h3 id="关系模式与关系数据库">2.1.2 关系模式与关系数据库</h3><p>关系的描述称为关系模式，可以形式化地表示为<spanclass="math inline">\(R(U,D,DOM,F)\)</span>。</p><p>其中R是关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间关系的依赖关系集合。</p><p>其中，<span class="math inline">\(DOM(属性名)=域名\)</span>。</p><p>关系模式可以简记为<spanclass="math inline">\(R(U)或R(A_1,A_2,...,A_n)\)</span>。其中<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>为属性名。</p><p>关系数据库的型称为关系数据库模式，包括若干域的定义和在这些域上定义的若干关系模式，是对关系数据库的描述。</p><p>关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</p><h2 id="关系操作">2.2 关系操作</h2><h3 id="基本关系操作">2.2.1 基本关系操作</h3><p>关系操作的对象和结果都是集合，这种方式也称为一次一集合方式，相应地，非关系数据模型的数据操作方式则为一次一记录的方式。</p><p>关系模型中常用的关系操作包括查询(query)操作和插入(insert)、删除(delete)、修改(update)操作两部分。</p><p>查询操作是关系操作中最主要的部分，包括：</p><p>选择(select)、投影(project)、连接(join)、除(divide)、并(union)、差(except)、交(intersection)、笛卡尔积等。</p><p>查询操作中，选择、投影、并、差、笛卡尔积是5种基本操作，其他操作可用基本操作来定义和导出。</p><h3 id="关系数据语言的分类">2.2.2 关系数据语言的分类</h3><p>早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数（relationalgebra）和关系演算（relation calculus）。</p><ul><li>关系代数用对关系的运算来表达查询要求</li><li>关系演算则用谓词来表达查询要求<ul><li>关系演算按谓词变元的基本对象是元组还是域变量分为元组关系演算和域关系演算</li></ul></li></ul><p>一个关系数据语言能够表示关系代数可以表示的查询，称为具有完备的表达能力，简称关系完备性。已经证明关系代数、元组关系演算和域关系演算在表达能力上是等价的。</p><p>结构化查询语言（Structured QueryLanguage，SQL）介于关系代数和关系演算之间。</p><p>SQL兼具查询、数据定义、数据控制功能，是集查询、数据定义语言、数据操纵语言和数据控制语言为一体的关系数据语言。</p><ul><li>SQL是一种高度非过程化的语言。</li></ul><h2 id="关系的完整性">2.3 关系的完整性</h2><p>关系模型中有三类完整性约束：实体完整性（entityintegrity）、参照完整性（referentialintegrity）和用户定义的完整性（user-defined integrity）</p><h3 id="实体完整性">实体完整性</h3><p>实体完整性规则：若属性A（一个或一组属性）是基本关系R的主属性，则A不能取空值</p><h3 id="参照完整性">参照完整性</h3><p>设F是基本关系R的一个或一组属性，但不是关系R的码，<spanclass="math inline">\(K_S\)</span>是基本关系S的主码。如果F与<spanclass="math inline">\(K_s\)</span>对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。</p><p>参照完整性规则：若属性F是基本关系R的外码，它与基本关系S的主码<spanclass="math inline">\(K_s\)</span>相对应，则对于R中每个原则在F上的值必须或者取空值，或者等于S中某个元组的主码值。</p><h3 id="用户定义的完整性">用户定义的完整性</h3><p>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</p><h2 id="关系代数">2.4 关系代数</h2><p>关系代数用对关系的运算来表达查询。</p><ul><li>关系代数的运算又分为传统的集合运算和专门的关系运算两类<ul><li>集合运算符：并<span class="math inline">\(\cup\)</span>、差<spanclass="math inline">\(-\)</span>、交<spanclass="math inline">\(\cap\)</span>、笛卡尔积<spanclass="math inline">\(\times\)</span></li><li>专门关系运算符：选择<spanclass="math inline">\(\sigma\)</span>、投影<spanclass="math inline">\(\prod\)</span>、连接<spanclass="math inline">\(\Join\)</span>、除<spanclass="math inline">\(\div\)</span></li></ul></li></ul><h3 id="传统的集合运算">2.4.1 传统的集合运算</h3><p>传统的集合运算是二目运算，包括并、差、交、笛卡尔积4种运算</p><p>（1）并（union）：<span class="math inline">\(R\cup S=\{t|t\in R \veet\in S\}\)</span></p><p>（2）差（except）：<span class="math inline">\(R-S=\{t|t\in R\wedget\notin S\}\)</span></p><p>（3）交（intersection）：<span class="math inline">\(R\cap S=\{t|t\inR\wedge t\in S\}\)</span></p><p>（4）笛卡尔积（cartesian product）：<spanclass="math inline">\(R\times S=\{t_rt_s|t_r\in R\wedge t_s\inS\}\)</span></p><h3 id="专门的关系运算">2.4.2 专门的关系运算</h3><p>专门的关系运算包括选择、投影、连接、除运算等。</p><p>引入几个记号：</p><ul><li><p>设关系模式为 <spanclass="math inline">\(R(A_1,A_2,...,A_n)\)</span>，它的一个关系设为<spanclass="math inline">\(R\)</span>。<span class="math inline">\(t\inR\)</span> 表示 <span class="math inline">\(t\)</span> 是 <spanclass="math inline">\(R\)</span> 的一个元组。<spanclass="math inline">\(t[A_i]\)</span> 则表示元组 <spanclass="math inline">\(t\)</span> 中相应于属性 <spanclass="math inline">\(A_i\)</span> 的一个分量。</p></li><li><p>若 <spanclass="math inline">\(A=\{A_{i1},A_{i2},...,A_{ik}\}\)</span>，其中<span class="math inline">\(A_{i1},A_{i2},...,A_{ik}\)</span> 是 <spanclass="math inline">\(A_1,A_2,...,A_n\)</span> 中的一部分，称<spanclass="math inline">\(A\)</span>为属性列或属性组。<spanclass="math inline">\(t[A]=(t[A_{i1}],t[A_{i2}],...,t[A_{in}])\)</span>为元组<spanclass="math inline">\(t\)</span>在属性列<spanclass="math inline">\(A\)</span>上诸分量的集合，<spanclass="math inline">\(\overline{A}\)</span>则表示<spanclass="math inline">\(\{A_1,A_2,...,A_n\}\)</span>中去掉<spanclass="math inline">\(\{A_{i1},A_{i2},...,A_{in}\}\)</span>后剩余的属性组。</p></li><li><p><span class="math inline">\(R\)</span>为<spanclass="math inline">\(n\)</span>目关系，<spanclass="math inline">\(S\)</span>为m目关系。<spanclass="math inline">\(t_r\in R\)</span>，<spanclass="math inline">\(t_s\in S\)</span>，<spanclass="math inline">\(t_rt_s\)</span>称为元组的连接或串接。它是一个<spanclass="math inline">\(n+m\)</span>列的新元组，前<spanclass="math inline">\(n\)</span>个分量为<spanclass="math inline">\(R\)</span>中的一个<spanclass="math inline">\(n\)</span>元组，后<spanclass="math inline">\(m\)</span>个分量为<spanclass="math inline">\(S\)</span>中的一个<spanclass="math inline">\(m\)</span>元组。</p></li><li><p>给定一个关系<span class="math inline">\(R(X,Y)\)</span>，<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Z\)</span>为属性组。当<spanclass="math inline">\(t[X]=x\)</span>时，<spanclass="math inline">\(x\)</span>在<spanclass="math inline">\(R\)</span>中的象集定义为</p><p><span class="math inline">\(Z_=\{t[Z]|t\in R,t[X]=x\}\)</span></p><p>它表示<span class="math inline">\(R\)</span>在属性组<spanclass="math inline">\(X\)</span>上值为<spanclass="math inline">\(x\)</span>的诸元组在<spanclass="math inline">\(Z\)</span>上分量的集合。</p></li></ul><h4 id="专门关系运算的定义">专门关系运算的定义</h4><h5 id="选择selection">选择（selection）</h5><p>选择又称为限制（restriction），是在关系<spanclass="math inline">\(R\)</span>中选择满足给定条件的诸元组，记作<spanclass="math inline">\(\sigma _F(R)=\{t|t\in R\wedgeF(t)=true\}\)</span></p><p>其中<spanclass="math inline">\(F\)</span>表示选择条件，它是一个逻辑表达式，取逻辑值真或假。</p><h5 id="投影projection">投影（projection）</h5><p>关系 <span class="math inline">\(R\)</span> 上的投影是从 <spanclass="math inline">\(R\)</span>中选择出若干属性列组成新的关系，记作</p><p><span class="math inline">\(\prod _{A}(R)=\{t[A]|t\inR\}\)</span></p><p>其中 <span class="math inline">\(A\)</span> 为 <spanclass="math inline">\(R\)</span> 的属性列。</p><h5 id="连接join">连接（join）</h5><p>连接也称为<spanclass="math inline">\(\theta\)</span>连接。它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作</p><p><span class="math inline">\(R\Join _{A\theta B}S=\{t_rt_s|t_r\in R\ort_s\in S\or t_r[A]\theta t_s[B] \}\)</span></p><p>其中，<span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 分别为 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 上列数相等且可比的属性组，<spanclass="math inline">\(\theta\)</span>是比较运算符。连接运算从 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 的笛卡尔积 <spanclass="math inline">\(R\times S\)</span> 中选取 <spanclass="math inline">\(R\)</span> 关系在 <spanclass="math inline">\(A\)</span> 属性组上的值与 <spanclass="math inline">\(S\)</span> 关系在 <spanclass="math inline">\(B\)</span> 属性组上的值满足比较关系 <spanclass="math inline">\(\theta\)</span>的元组。</p><ul><li><p><span class="math inline">\(\theta\)</span> 为 =的连接运算称为等值连接，它是从关系 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 的笛卡尔积中选取 <spanclass="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span>属性值相等的那些元组。</p></li><li><p>自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中去除重复属性列</p><ul><li>一般的连接操作是从行的角度进行运算，自然连接还需要去除重复列，因而是同时从行和列的角度进行运算</li><li>自然连接中被舍弃的元组称为悬浮元组（danglingtuple），把悬浮元组也保存在结果关系中，而在其他属性值上写<spanclass="math inline">\(null\)</span>，这种连接称为外连接；只保留左关系的悬浮元组称为左外连接，反之为右外连接</li></ul></li></ul><h5 id="除运算division">除运算（division）</h5><p>//以下定义过于抽象，其实就是选择R(X,Y)中Y与S(Y,Z)中的Y具有相同值的所有对应X。</p><p>设关系 <span class="math inline">\(R\)</span> 除以关系 <spanclass="math inline">\(S\)</span> 的结果为关系 <spanclass="math inline">\(T\)</span>，则 <spanclass="math inline">\(T\)</span> 包含所有在 <spanclass="math inline">\(R\)</span> 但不在 <spanclass="math inline">\(S\)</span> 中的属性及其值，且 <spanclass="math inline">\(T\)</span> 的元组与 <spanclass="math inline">\(S\)</span> 的元组的所有组合都在 <spanclass="math inline">\(R\)</span> 中。</p><p>除法的象集定义：</p><p>给定关系 <span class="math inline">\(R(X,Y)\)</span> 和 <spanclass="math inline">\(S(Y,Z)\)</span>，其中<spanclass="math inline">\(X\)</span>、<spanclass="math inline">\(Y\)</span>、<spanclass="math inline">\(Z\)</span>为属性组。<spanclass="math inline">\(R\)</span> 中的 <spanclass="math inline">\(Y\)</span> 与 <spanclass="math inline">\(S\)</span> 中的 <spanclass="math inline">\(Y\)</span>可以有不同的属性名，但必须出自相同的域集。</p><p><span class="math inline">\(R\)</span> 与 <spanclass="math inline">\(S\)</span> 的除运算得到一个新的关系 <spanclass="math inline">\(P(X)\)</span>，<spanclass="math inline">\(P\)</span> 是 <spanclass="math inline">\(R\)</span> 中满足下列条件的元组在 <spanclass="math inline">\(X\)</span> 属性列上的投影：元组在 <spanclass="math inline">\(X\)</span> 上分量值 <spanclass="math inline">\(x\)</span> 的象集 <spanclass="math inline">\(Y_x\)</span> 包含 <spanclass="math inline">\(S\)</span> 在 <spanclass="math inline">\(Y\)</span> 上投影的集合。记作</p><p><span class="math inline">\(R\div S=\{t_r[X] |t_r\in R \and \prod_Y(S)\subseteq Y_X \}\)</span></p><p>除操作也是同时从行和列的角度进行运算。</p><p>关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。</p><h2 id="关系演算">2.5 关系演算</h2><p>不考，暂略</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第一章_绪论</title>
    <link href="/2023/03/01/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/03/01/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第一章-绪论">第一章 绪论</h1><h2 id="数据库系统概述">1.1 数据库系统概述</h2><h3 id="数据库的4个基本概念">1.1.1 数据库的4个基本概念</h3><p>数据、数据库、数据库管理系统、数据库系统</p><h4 id="数据data">数据（Data）</h4><p>数据是数据库中存储的基本对象，是描述事物的符号记录。</p><p>数据有多种表现形式，可以经过数字化后存入计算机。</p><p>数据的含义称为数据的语义，数据与其语义是不可分的。</p><h4 id="数据库databasedb">数据库（Database，DB）</h4><p>数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，可为各种用户共享。</p><p>数据库数据具有永久存储、有组织和可共享三个基本特点。</p><h4id="数据库管理系统database-management-systemdbms">数据库管理系统（DatabaseManagement System，DBMS）</h4><p>数据库管理系统是计算机的基础软件，主要功能包含以下几个方面：</p><h5 id="数据定义">(1) 数据定义</h5><p>提供数据定义语言（Data DefinitionLanguage，DDL），用以对数据库中的数据对象的组成与结构进行定义</p><h5 id="数据组织存储和管理">(2) 数据组织、存储和管理</h5><h5 id="数据操纵">(3) 数据操纵</h5><p>提供数据操纵语言（Data ManipulationLanguage，DML），用以操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。</p><h5 id="数据库的事务管理和运行管理">(4) 数据库的事务管理和运行管理</h5><h5 id="数据库的建立和维护">(5) 数据库的建立和维护</h5><h5 id="其他功能">(6) 其他功能</h5><p>包括数据库管理系统与网络中其他软件系统的通信功能，异构数据库之间的互访和互操作功能等。</p><h4 id="数据库系统database-systemdbs">数据库系统（DatabaseSystem，DBS）</h4><p>数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DatabaseAdministrator，DBA）组成的存储、管理、处理和维护数据的系统。</p><h3 id="数据库系统的特点">1.1.2 数据库系统的特点</h3><ul><li>文件系统管理数据的缺点：整体无结构，共享性低，冗余度高，独立性差</li></ul><h4 id="数据结构化">数据结构化</h4><p>数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。</p><p>整体结构化是指数据库中的数据不再仅仅针对一个应用，而是面向整个组织或企业；不仅数据内部是结构化的，而且整体是结构化的，数据之间是具有联系的。</p><h4id="数据的共享性高冗余度低且易扩充">数据的共享性高、冗余度低且易扩充</h4><p>数据共享可以大大减少数据冗余，节约存储空间，数据共享还能避免数据之间的不相容性与不一致性。</p><h4 id="数据独立性高">数据独立性高</h4><p>数据库的数据独立性包括数据的物理独立性和逻辑独立性。</p><ul><li><p>物理独立性是指用户的应用程序与数据库中数据的物理存储是相互独立的。</p></li><li><p>逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</p></li></ul><h4id="数据由数据库管理系统统一管理和控制">数据由数据库管理系统统一管理和控制</h4><p>为了保证数据库的并发共享与数据库中数据的正确与一致，数据库管理系统提供以下的数据控制功能：</p><h5 id="数据的安全性保护">(1) 数据的安全性保护</h5><p>保护数据以防止不合法使用造成的数据泄密和破坏。</p><h5 id="数据的完整性检查">(2) 数据的完整性检查</h5><p>数据的完整性指数据的正确性、有效性和相容性。</p><h5 id="并发控制">(3) 并发控制</h5><h5 id="数据库恢复">(4) 数据库恢复</h5><p>数据库管理系统必须具有将数据库从错误状态恢复到某一已知的正确状态的功能。</p><p>数据库是长期存储在计算机内有组织、大量、共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。</p><p>数据库系统的出现使信息系统从以加工数据的程序为中心转为围绕共享的数据库为中心的新阶段。</p><h2 id="数据模型">1.2 数据模型</h2><p>数据模型是对现实世界数据特征的抽象，是数据库系统的核心和基础。</p><p>数据模型分为两类，第一类为概念模型，第二类是逻辑模型和物理模型。</p><ul><li><p>概念模型也称信息模型，它按用户的观点来对数据和信息建模，主要用于数据库设计。</p></li><li><p>逻辑模型主要包括层次模型、网状模型、关系模型、面向对象数据模型和对象关系数据模型、半结构化数据模型等，它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。</p></li><li><p>物理模型是对数据最底层的抽象，描述数据在系统内部的表示和存取方式。物理模型的具体实现是数据库管理系统的任务，数据库设计人员要了解和选择物理模型，最终用户则不需考虑物理级细节。</p></li></ul><p>先将现实世界抽象为信息世界（概念模型），再将信息世界转换为机器世界。</p><h3 id="概念模型">1.2.1 概念模型</h3><p>概念模型是对现实世界的抽象，用于信息世界的建模。</p><h4 id="信息世界的基本概念">信息世界的基本概念</h4><ol type="1"><li>实体（entity）</li></ol><p>客观存在并可相互区别的事物称为实体。</p><ol start="2" type="1"><li>属性（attribute）</li></ol><p>实体所具有的某一特性。</p><ol start="3" type="1"><li>码（key）</li></ol><p>唯一标识实体的属性集称为码</p><ol start="4" type="1"><li>实体型（entity type）</li></ol><p>用实体及其属性名集合来抽象和刻画同类实体，称为实体型。</p><ol start="5" type="1"><li>实体集（entity set）</li></ol><p>同一类型实体的集合称为实体集。</p><ol start="6" type="1"><li>联系（relationship）</li></ol><p>实体内部的联系通常指组成实体的各属性之间的联系，实体之间的联系通常指不同实体集之间的联系。</p><p>实体之间的联系有一对一、一对多、多对多等多种类型。</p><h4id="概念模型的一种表示方法实体-联系方法entity-relationship-approach">概念模型的一种表示方法：实体-联系方法（Entity-Relationshipapproach）</h4><p>该方法用实体-联系图（E-Rdiagram）来描述现实世界的概念模型，E-R方法也称E-R模型。</p><h3 id="数据模型的组成要素">1.2.2 数据模型的组成要素</h3><p>数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成。</p><ol type="1"><li>数据结构</li></ol><p>数据结构描述数据库的组成对象以及对象之间的联系。</p><ol start="2" type="1"><li>数据操作</li></ol><p>数据操作是指对数据库中各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则。</p><ol start="3" type="1"><li>数据的完整性约束条件</li></ol><p>数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。</p><h3 id="常用的数据模型">1.2.3 常用的数据模型</h3><ul><li>层次模型（hierarchical model）</li><li>网状模型（network model）</li><li>关系模型（relational model）</li><li>面向对象数据模型（object oriented data model）</li><li>对象关系数据模型（object relational data model）</li><li>半结构化数据模型（semistructure data model）</li></ul><p>其中层次模型和网状模型称为格式化模型。</p><h4 id="层次模型">层次模型</h4><ol type="1"><li>有且只有一个结点没有双亲结点，该结点为根结点；</li><li>根以外的其他结点有且只有一个双亲结点。</li></ol><p>优点：结构简单清晰、查询效率高、完整性支持好</p><p>缺点：现实世界很多联系是非层次性的</p><h4 id="网状模型">网状模型</h4><ol type="1"><li>允许一个以上的结点没有双亲；</li><li>一个结点可以有一个以上的双亲。</li></ol><p>优点：直观地描述现实世界、存取效率高</p><p>缺点：结构复杂，因而DDL与DML也十分复杂</p><h2 id="数据库系统的结构">1.3 数据库系统的结构</h2><h3 id="数据库系统模式的概念">1.3.1 数据库系统模式的概念</h3><p>数据模型中，型（type）是对某一类数据的结构和属性的说明，值（value）是型的一个具体赋值。</p><p>模式（schema）是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体值。模式的一个具体值称为模式的一个实例。</p><p>模式是相对稳定的，实例时相对变动的。</p><h3 id="数据库系统的三级模式结构">1.3.2 数据库系统的三级模式结构</h3><p>数据库系统由外模式、模式和内模式三级构成。</p><ol type="1"><li>模式</li></ol><p>模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p><ol start="2" type="1"><li>外模式</li></ol><p>外模式也称子模式（subschema）或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用相关的数据的逻辑表示。</p><p>外模式通常是模式的子集。</p><ol start="3" type="1"><li>内模式</li></ol><p>内模式也称存储模式（storageschema），是数据物理结构和存储方式的描述，是数据库内部数据的组织方式。</p><p>一个数据库只有一个内模式</p><h3 id="数据库的二级映像功能与数据独立性">1.3.3数据库的二级映像功能与数据独立性</h3><ol type="1"><li>外模式/模式映像</li></ol><p>模式改变时，数据库管理员对各个外模式/模式映像作相应改变，使外模式保持不变，保证数据逻辑独立性。</p><ol start="2" type="1"><li>模式/内模式映像</li></ol><p>数据库存储结构改变时，数据库管理员对模式/内模式映像作相应改变，使模式保持不变，保证数据物理独立性。</p><p>数据与程序之间的独立性使得数据的定义和描述从应用程序中分离。数据的存取由数据库管理系统管理，简化了应用程序的编制，减少了应用程序的维护与修改。</p><ul><li>文件系统数据独立性是文件间相互独立，而数据库系统数据独立性是逻辑、物理独立性</li></ul><h2 id="数据库系统的组成">1.4 数据库系统的组成</h2><ol type="1"><li><p>硬件平台及数据库</p><ul><li>足够大的内存存放操作系统、数据库管理系统的核心模块、数据缓冲区和应用程序</li><li>足够大的磁盘存放数据库，足够大的磁带作数据备份</li><li>系统有较高的通道能力以提高数据传送率</li></ul></li><li><p>软件</p><ul><li>数据库管理系统</li><li>支持数据库管理系统运行的操作系统</li><li>具有与数据库接口的高级语言及其编译系统，便于开发应用程序</li><li>以数据库管理系统为核心的应用开发工具</li></ul></li><li><p>人员</p><ul><li><p>数据库管理员</p></li><li><p>系统分析员与数据库设计人员</p></li><li><p>应用程序员</p></li><li><p>用户</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-4.0_树</title>
    <link href="/2022/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter4.0_Tree/"/>
    <url>/2022/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter4.0_Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter4.0tree-树">Chapter4.0：Tree 树</h1><span id="more"></span><h4 id="两类数据结构">两类数据结构</h4><ul><li>线性：列表、栈、队列、字符串</li><li>非线性：树、图</li></ul><h2 id="一树">一、树</h2><h3 id="定义">定义</h3><p>一棵树是一些结点的集合。<br />集合可以为空，否则，这棵树具有一个特殊的称为根的结点，以及零棵或更多非空子树。</p><h3 id="术语">术语</h3><p>结点的度数为其所具有的后代数。<br />树的度数是其结点度数的最大值。<br />度数为0的结点称为叶，度数非0的结点称为枝。<br />层级：根的层级为0(1)，其余结点的层级为其父结点加1。<br />树高：结点的最高层级。</p><h2 id="二二叉树">二、二叉树</h2><h3 id="定义-1">定义</h3><p>一棵二叉树是一些有限个结点的(可以为空)集合。</p><p>当二叉树非空： * 它有一个根结点。 *其余的结点被分为两个二叉树，称为根的左子树和右子树。</p><p>二叉树与树的区别 1.二叉树的每个结点都有且仅有两个子树(可以为空)，而树的每个结点可以有任意个子树。2. 二叉树的结点的左右子树是有顺序区别的，而树的结点的子树是无序的。</p><h3 id="二叉树的性质">二叉树的性质</h3><ol type="1"><li>有n个结点的二叉树有n-1条边。</li><li>在第i层的结点树最多为2^i。</li><li>高度为h的二叉树最少有h+1个结点，最多有2^(h+1)-1个结点</li><li>如果叶的数量为x，度数为2的结点树为y，那么x=y+1</li><li>包含n个结点的二叉树的树高最多为n-1，虽少为[log(n+1)]-1。(底为2)</li></ol><h4 id="满二叉树">满二叉树</h4><p>树高h，包含2^(h+1)-1个结点的二叉树为满二叉树。</p><h4 id="完全二叉树">完全二叉树</h4><p>一棵树高为k的有n个结点的二叉树，如果对树中的结点按从上到下、从左到右的顺序进行编号，编号为i的结点与满二叉树中编号为i的结点位置相同，则这棵二叉树为完全二叉树。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-3.1_栈与队列</title>
    <link href="/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter3.1_Stack&amp;Queue/"/>
    <url>/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter3.1_Stack&amp;Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter3.1stack-queue-栈与队列">Chapter3.1：Stack Queue栈与队列</h1><span id="more"></span><h2 id="一栈">一、栈</h2><p>栈是插入与删除发生在同一端的列表，该端称为顶部，另一端称为底部。栈也被称为LIFO(Last In First Out)列表</p><h3 id="栈的模型">栈的模型</h3><p>Abstract Data Type: Stack：<br />instances: list of elements<br />operations:<br />Create(): Create an empty stack<br />IsEmpty()<br />IsFull()<br />Top(): Return top element of the stack<br />Add(x): add element x to the stack<br />Delete(x) :Delete top element from stack and put it in x</p><h3 id="栈的链表实现">栈的链表实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span>&#123;topOfStack = <span class="hljs-literal">null</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> topOfStack == <span class="hljs-literal">null</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">()</span>&#123;topOfStack = <span class="hljs-literal">null</span>;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(object x)</span>&#123;<br>    topOfStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(x, topOfStack);<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">top</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> topOFStack.element;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Underflow&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty())<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Underflow</span>();<br>    topOfStack = topOfStack.next;<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">topAndPop</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">topItem</span> <span class="hljs-operator">=</span> topOfStack.element;<br>    topOfStack = topOfStack.next;<br>    <span class="hljs-keyword">return</span> topItem;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> ListNode topOfStack;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈的数组实现">栈的数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span>&#123;<span class="hljs-built_in">this</span>(DEFAULT_CAPACITY);&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>    array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">object</span>[capacity];<br>    topOfStack = -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> topOfStack==-<span class="hljs-number">1</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> topOfStack==theArray.length–<span class="hljs-number">1</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">()</span>&#123;topOfStack=-<span class="hljs-number">1</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(object x)</span> <span class="hljs-keyword">throws</span> overflow&#123;<br>    <span class="hljs-keyword">if</span>(isFull()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Overflow</span>();<br>    array[++topOfStack] = x;<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">top</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> array[topOfStack];<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Underflow&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Underflow</span>();<br>    array[topOfStack--] = <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">topAndPop</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">topItem</span> <span class="hljs-operator">=</span> top();<br>    array[topOfStack--] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> topItem;<br>  &#125;<br>  <span class="hljs-keyword">private</span> object[] array;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> topOfStack;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>多个栈的存在会导致空间的浪费，当只有两个栈时，我们可以将两个栈在同一个线性表的两端进行存储，两者向中间延伸。</p><h3 id="栈的应用">栈的应用</h3><ul><li>括号匹配</li></ul><h2 id="二队列">二、队列</h2><p>队列是插入和删除发送在两端的线性表，新元素插入的地方称为尾部，旧元素删除的地方称为首部。队列也被称为FIFO(First In First Out)列表。</p><h3 id="队列的模型">队列的模型</h3><p>Abstract Data Type: Queue: instances: ordered list of elementsoperations: Create(): Create an empty queue IsEmpty() IsFull() First():return first element of the queue Last(): return last element of thequeue Add(x): add element x to the queue Delete(x): delete front elementfrom the queue and put it in x</p><h3 id="队列的数组实现">队列的数组实现</h3><p>元素的增加：++back; array[back]=x;<br />元素的删除：两种办法<br />1. ++front; O(1)<br />2. 将整个队列左移 O(n)<br />可以使用循环数组来表示队列，方法有二<br />1. 分类讨论头和尾抵达了数组边界的情况 2. back = (back+1)%array.length;front = (front+1)%array.length</p><h3 id="队列的链表实现">队列的链表实现</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-2.0_算法分析</title>
    <link href="/2022/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter2.0_AlgorithmAnalysis/"/>
    <url>/2022/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter2.0_AlgorithmAnalysis/</url>
    
    <content type="html"><![CDATA[<h2 id="chapter2.0算法分析">Chapter2.0：算法分析</h2><span id="more"></span><p>算法是为解决问题而定义的一系列方法。算法分析主要在于算法占用的时间与空间。算法分析的两个方法：性能分析和性能度量</p><h3 id="空间复杂度">1. 空间复杂度</h3><p>运行完成程序需要的内存空间 组成：指令、数据、环境栈空间此处讨论的存储器主要指内存。 #### (1) 指令空间程序编译成的二进制码的空间大小 又称代码空间本课程中，我们默认忽略指令空间原因：操作系统对代码所占的内存具有一些管理机制，代码所占内存有限 ####(2) 数据空间 定长部分：包含指令、简单变量、定长度的成员变量、常量的内存变长部分：随数据变化而变化的部分，如递归栈、动态分配区域一般而言，变长部分更为重要。 #### (3) 环境栈空间</p><h3 id="时间复杂度">2. 时间复杂度</h3><p>运行完成程序需要的时间长度<br />编译时间不被计算进时间复杂度。<br />计算程序的时间复杂度，关键操作个数是核心，循环中操作个数格外重要。</p><h4 id="最好最差和平均的复杂度分析">最好、最差和平均的复杂度分析</h4><p>平均复杂度往往难以定义。<br />使用算术平均值作为平均复杂度(假设所有情况等概率)是简化的运算，不能完全代表平均情况。</p><p>步骤数计算：count++；</p><h4 id="算法的渐进分析">算法的渐进分析</h4><p>记号：O、𝛺、o、𝜃</p><h5 id="o表示法">O表示法</h5><p>表示算法复杂度的上限<br />定义：f(n)=O(g(n))，即当n尽量大时，存在c，f(n)&lt;=cg(n)。</p><h5 id="o表示法-1">o表示法</h5><p>定义：f(n)=o(g(n))，即当n尽量大时，存在c，f(n)&lt;cg(n)。当前算法复杂度小于该量级。</p><h5 id="𝛺表示法">𝛺表示法</h5><p>表示算法复杂度的下界<br />定义：f(n)=𝛺(g(n))，即当n尽量大时，存在c，f(n)&gt;=cg(n)。</p><h5 id="𝜃表示法">𝜃表示法</h5><p>表示和算法复杂度同等的两级<br />f(n)=𝜃(g(n))，即当n尽量大，存在，，使g(n)&lt;=f(n)&lt;=g(n)。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-1.0_绪论</title>
    <link href="/2022/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter1.0_Intro/"/>
    <url>/2022/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter1.0_Intro/</url>
    
    <content type="html"><![CDATA[<h2 id="chapter1.0绪论">Chapter1.0：绪论</h2><span id="more"></span><p>课程主要是学习数据结构而不倾于算法结构</p><ol type="1"><li><p>关心数据类型和数据处理步骤</p></li><li><p>处理更加复杂、难以计算的部分</p></li><li><p>不依赖于特定编程语言</p></li><li><p>介绍常用算法和数据结构</p></li><li><p>后置课程 ·编译原理 ·操作系统 ·数据库</p></li></ol><h3 id="什么是数据结构">什么是数据结构</h3><ol type="1"><li>数据 数据是信息的载体，是数字、字符和其他符号组成的集合。数据可用于描述客观世界。表示数据的符号可以输入计算机，被计算机识别和处理。 数据分类：</li></ol><ol type="1"><li>数值型(numerical)：int, float, complex</li><li>非数值型(non-numerical)：character, string, graph, voice</li></ol><ol start="2" type="1"><li>数据结构 数据结构是数据对象以及对象各成员间关系的统称。数据结构分类：线性结构(linear structure)与非线性(non-linear)结构</li></ol><p>数据结构是分层的 数据结构涉及三个方面：数据的逻辑结构——从用户视图看，是面向问题的。数据的物理结构——从具体实现视图看，是面向计算机的。相关的操作及其实现。</p><p>Example：学生表 逻辑结构——线性表 物理结构——数组、链表操作——插入、删除、查找</p><p>数据类型：具有操作该类值的操作集的值的集合 大多编程语言具有Atom DataTypes和Structure Data Types两类预定义的数据结构。</p><ol start="3" type="1"><li>ADT和OO ADT：Abstract Data Types 抽象数据类型是将类型和与这个类型有关的操作集合封装在一起的数据模型。OO：Object-oriented 三个方面（考试）：封装、继承、多态 类与继承</li></ol><h3 id="算法">算法</h3><p>算法定义：为了解决某个问题的一系列操作 特点： 1. 明确输入 2. 明确输出3. 确定性 4. 可行性 5. 有穷性</p><p>Deterministic算法：当给固定输入，会有固定输出程序：用编程语言编写，可以在机器上运行，不满足有穷性。</p><h3 id="数学复习">数学复习</h3><p>log底数默认为2。<br />同余：A≡B(mod N)<br />数学归纳法：<br />1. Basis 2. Inductive hypothesis 3. Inductive proof 反证法</p><p>算法思想：递归、分治、贪心、线性规划</p><p>递归：Base cases + Making progress<br />* 直接递归：函数自己调用自己<br />* 间接递归：多个函数相互调用形成环状调用的递归</p><p>泛型 Generic<br />将类型设置为变量。<br />应当尽量避免代码克隆。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIME</title>
    <link href="/2022/10/30/network/MIME/"/>
    <url>/2022/10/30/network/MIME/</url>
    
    <content type="html"><![CDATA[<p>媒体类型(Multipurpose Internet MailExtensions，MIME)是用来表示文档、文件或字节流的性质和格式的一种标准。<span id="more"></span></p><h2 id="语法">语法</h2><h3 id="通用结构">通用结构</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span>/<span class="hljs-keyword">subtype</span><br></code></pre></td></tr></table></figure><p>由类型和子类型两个字符串中间用'/'分隔组成，不允许空格存在。type为可以被分为多个子类的独立类别，subtype为细分后的每个类型。MIME对大小写不敏感，但一般使用小写。</p><table><thead><tr class="header"><th style="text-align: center;">类型</th><th style="text-align: center;">描述</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>text</code></td><td style="text-align: center;">普通文本</td><tdstyle="text-align: center;"><code>text/plain</code>,<code>text/html</code>,<code>text/css</code>,<code>text/javascript</code></td></tr><tr class="even"><td style="text-align: center;"><code>image</code></td><td style="text-align: center;">某种图像，包括动态图但补包括视频</td><tdstyle="text-align: center;"><code>image/gif</code>,<code>image/png</code>,<code>image/jpeg</code></td></tr><tr class="odd"><td style="text-align: center;"><code>audio</code></td><td style="text-align: center;">某种音频文件</td><tdstyle="text-align: center;"><code>audio/midi</code>,<code>audio/mpeg</code>,<code>audio/wav</code></td></tr><tr class="even"><td style="text-align: center;"><code>video</code></td><td style="text-align: center;">某种视频文件</td><tdstyle="text-align: center;"><code>video/webm</code>,<code>video/ogg</code></td></tr><tr class="odd"><td style="text-align: center;"><code>application</code></td><td style="text-align: center;">某种二进制数据</td><tdstyle="text-align: center;"><code>application/octet-stream</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>networkProject</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程</title>
    <link href="/2022/10/25/network/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/10/25/network/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>网络编程是指编写运行在多个通过网络连接的主机的程序。<span id="more"></span></p><blockquote><p>java.net包提供了两种网络协议的支持：TCP和UDP<br />* TCP（Transmission ControlProtocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP层是位于IP层之上，应用层之下的中间层。TCP保障了两个应用程序之间的可靠通信。通常用于互联网协议，称为TCP/IP。<br />* UDP（User Datagram Protocol，用户数据报协议）位于 OSI模型的传输层，是一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。</p></blockquote><h2 id="一java-socket编程">一、Java Socket编程</h2><p>在网络编程中，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</p><p>Socket套接字是支持TCP/IP协议的网络通信的基本操作单元，它包含了进行网络通信必须的五种信息：</p><ul><li>连接使用的协议<br /></li><li>本地主机的IP地址<br /></li><li>本地进程的协议端口<br /></li><li>远程主机的IP地址<br /></li><li>远程进程的协议端口</li></ul><h3 id="套接字的连接过程">1、套接字的连接过程</h3><p>服务器监听、客户端请求、连接确认 1.服务器套接字处于等待连接的状态，实时监控网络状态 2.客户端的套接字提出连接请求以连接服务端套接字。为此，客户端套接字需要服务器套接字的地址和端口号3.服务器套接字监听到并响应客户端套接字，建立一个新的线程，将服务端套接字的描述发给客户端。</p><h3 id="socket的基本工作过程">2、Socket的基本工作过程：</h3><ol type="1"><li>创建Socket</li><li>创建连接Socket的IO流</li><li>按一定协议对Socket进行读写操作</li><li>关闭Socket</li></ol><h3 id="java-socket简单的服务端与客户端程序">3、JavaSocket：简单的服务端与客户端程序</h3><h4 id="服务端">服务端：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">sock</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(sock.getInputStream());<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);<br>            String message;<br>            message = bufferedReader.readLine();<br>            System.out.println(message);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Server</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();<br>        server.execute();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="客户端">客户端：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(socket.getOutputStream());<br>            <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream());<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);<br>            System.out.println(<span class="hljs-string">&quot;Connection succeeded.&quot;</span>);<br>            writer.println(<span class="hljs-string">&quot;Happy Birthday!&quot;</span>);<br>            writer.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>();<br>        client.execute();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二io-模型">二、IO 模型</h2><h3 id="同步和异步">1、同步和异步</h3><ul><li>同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回</li><li>异步：异步就是发起一个调用后，立即得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他请求。</li></ul><p>被调用者通常依靠事件、回调等机制来通知调用者其返回结果。<br />两者的最大区别在于，异步的情况下，调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。</p><h3 id="阻塞和非阻塞">2、阻塞和非阻塞</h3><ul><li>阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li><li>非阻塞：非阻塞就是发起一个请求，调用者不用已知等着结果返回，可以从事其他任务。</li></ul><p>Java Socket在调用accept、read等方法时，会发生阻塞</p><h3 id="java支持的三种io模型">3、Java支持的三种IO模型</h3><ul><li>BIO（Blocking IO，同步阻塞IO）：一个线程处理一个连接</li><li>NIO（Non-blocking IO，同步非阻塞IO）：一个线程处理多个连接</li><li>AIO（Asynchronous IO，异步非阻塞IO）：通道异步</li></ul><h4 id="bio">BIO</h4><p>在Server中建立ServerSocket对象，绑定端口，等待连接，若连接成功就新建一个进程去处理连接。</p><p>BIO的缺点：资源的浪费，每个客户端的连接都需要占用一个进程。</p><h4 id="nio">NIO</h4><p>相关类处于java.nio包中。</p><figure><img src="/image/networkProject/NIO图解.jpeg" title="NIO 图解"alt="NIO 图解" /><figcaption aria-hidden="true">NIO 图解</figcaption></figure><p>NIO的三大核心部分：Selector(选择器)、Channel(通道)、Buffer(缓冲区)</p><ul><li><p>Buffer：数据从Channel读入Buffer，又从Buffer写入Channel<br />在Java中，Buffer是一个抽象类，具有ByteBuffer、CharBuffer等子类，采用相似方法管理不同数据类型。<br />具有的基本属性：</p><ul><li>容量：Buffer作为一个内存块所具有的一定大小，不能为负且创建后不可更改。</li><li>限制：Buffer中可以操作数据的大小，不能为负且小于等于其容量。写入模式下，限制等于buffer的容量，读取模式下，限制等于写入的数据量。</li><li>位置：下一个要读取或写入的数据的索引，不能为负且不能大于限制。</li><li>标记：通过mark方法指定Buffer中一个特定的位置，之后可以调用reset方法恢复到这个位置。</li></ul><p>Java Buffer存取数据的两个基本办法：</p><ul><li>put() 在Buffer的当前位置写入内容</li><li>get() 获取Buffer数据</li></ul></li><li><p>Channel：IO源与目标打开的连接，不能直接访问数据，只能与Buffer进行交互。<br />在Java中，Channel是一个接口，具有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等实现</p><p>Java Channel读写数据的基本办法：</p><ul><li>read()</li><li>write()</li></ul></li><li><p>Selector<br />Selector会不断轮询注册在上的所有channel，并发现处于就绪状态的channel。<br />使用步骤：</p></li></ul><ol type="1"><li>使用静态工厂办法open()获取选择器： <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span> = <span class="hljs-keyword">Selector</span>.open()<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li><li>获取可选择通道。该通道必须实现SelectableChannel接口并为非阻塞模式。</li><li>将通道注册到选择器，并告知监控的事件： <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">SelectableChannel.register(<span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span>, int ops)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li><li>调用Selector.select()，该方法将就绪事件放在SelectedKey集合中，并返回就绪事件数，这是个阻塞方法，直到至少有一个就绪事件，或其它县城调用当前Selector对象的wakeup()方法，或当前线程中断时返回。<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-keyword">while</span>(selector.<span class="hljs-built_in">select</span>() &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">Set</span>&lt;SelectionKey&gt; <span class="hljs-built_in">keys</span> = selector.selectedKeys();<br>&#125;<br></code></pre></td></tr></table></figure>给select()赋予一个long类型的参数可以限制其阻塞时间；selectNode()不阻塞，无就绪事件则返回0。<br /></li><li>处理就绪事件</li></ol><p>Channel和Buffer的基本操作 1. 分别建立连接文件和Socket的Channel 2.建立所需类型（Byte，等等）的Buffer，分配内存 3.从Channel中将数据读入Buffer/使用Channel从Buffer中读取数据 4.关闭Channel</p>]]></content>
    
    
    <categories>
      
      <category>networkProject</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Geternitier的博客</title>
    <link href="/2022/06/30/%E5%A4%A9%E9%A9%AC%E6%AD%8C/"/>
    <url>/2022/06/30/%E5%A4%A9%E9%A9%AC%E6%AD%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="天马歌">天马歌</h3><span id="more"></span><p>唐·李白</p><p>天马来出月支窟，背为虎文龙翼骨。<br />嘶青云，振绿发， 兰筋权奇走灭没。<br />腾昆仑，历西极，四足无一蹶。<br />鸡鸣刷燕晡秣越，神行电迈蹑慌惚。<br />天马呼，飞龙趋， 目明长庚臆双凫。<br />尾如流星首渴乌，口喷红光汗沟朱。 曾陪时龙蹑天衢，羁金络月照皇都。<br />逸气棱棱凌九区，白璧如山谁敢沽。<br />回头笑紫燕，但觉尔辈愚。<br />天马奔， 恋君轩，駷跃惊矫浮云翻。<br />万里足踯躅，遥瞻阊阖门。<br />不逢寒风子，谁采逸景孙。<br />白云在青天，丘陵远崔嵬。 盐车上峻坂，倒行逆施畏日晚。<br />伯乐翦拂中道遗，少尽其力老弃之。<br />愿逢田子方，恻然为我悲。<br />虽有玉山禾，不能疗苦饥。<br />严霜五月凋桂枝，伏枥衔冤摧两眉。<br />请君赎献穆天子，犹堪弄影舞瑶池。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
