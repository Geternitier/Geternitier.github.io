<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据管理基础-第七章_数据库设计</title>
    <link href="/2023/06/07/%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/06/07/%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第七章-数据库设计">第七章 数据库设计</h1><h2 id="概述">7.1 概述</h2><p>数据库设计是指对于一个给定的应用环境，构造(设计)优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</p><ul><li><p>信息管理要求：在数据库中应该存储和管理哪些数据对象。</p></li><li><p>数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作。</p></li></ul><p>数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境。</p><p>高效率的运行环境：</p><ul><li>数据库数据的存取效率高</li><li>数据库存储空间的利用率高</li><li>数据库系统运行管理的效率高</li></ul><h3 id="数据库设计的特点">7.1.1 数据库设计的特点</h3><h4 id="数据库建设的基本规律">数据库建设的基本规律</h4><p>三分技术、七分管理、十二分基础数据</p><ul><li><p>管理：数据库建设项目管理、企业业务管理</p></li><li><p>基础数据：数据的收集、整理、组织和不断更新</p></li></ul><p>结构（数据）设计和行为（处理）设计相结合</p><ul><li>将数据库结构设计和数据处理设计密切结合</li><li>结构和行为分离的设计：<ul><li>传统软件工程：重行为设计</li><li>早期数据库设计：重结构设计</li></ul></li></ul><h3 id="数据库设计方法">7.1.2 数据库设计方法</h3><p>大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。</p><p>它要求多方面的知识和技术。主要包括：</p><ul><li><p>计算机的基础知识</p></li><li><p>软件工程的原理和方法</p></li><li><p>程序设计的方法和技巧</p></li><li><p>数据库的基本知识</p></li><li><p>数据库设计技术</p></li><li><p>应用领域的知识</p></li></ul><p>数据库设计方法：</p><ul><li>手工试凑法</li><li>规范设计法<ul><li>新奥尔良方法</li><li>基于E-R模型的数据库设计方法</li><li>3NF的设计方法</li><li>面向对象的数据库设计方法</li><li>统一建模语言（UML）方法</li></ul></li></ul><h3 id="数据库设计的基本步骤">7.1.3 数据库设计的基本步骤</h3><p>数据库设计的6个阶段：</p><ul><li>需求分析</li><li>概念结构设计：概念模型</li><li>逻辑结构设计：数据模型</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行和维护</li></ul><p>需求分析和概念设计独立于任何数据库管理系统；</p><p>逻辑设计和物理设计与选用的数据库管理系统密切相关。</p><p>参加数据库设计的人员</p><ul><li>系统分析人员和数据库设计人员<ul><li>自始至终参与数据库设计，其水平决定了数据库系统的 质量</li></ul></li><li>数据库管理员和用户代表<ul><li>主要参加需求分析与数据库的运行和维护</li></ul></li><li>应用开发人员<ul><li>包括程序员和操作员</li><li>在实施阶段参与进来，分别负责编制程序和准备软硬件 环境</li></ul></li></ul><h3 id="数据库设计过程中的各级模式">7.1.4数据库设计过程中的各级模式</h3><ul><li>需求分析阶段：综合分析应用要求</li><li>概念结构设计阶段：概念模式</li><li>逻辑结构设计阶段：逻辑模式与面向应用的外模式</li><li>物理结构设计阶段：内模式</li></ul><h2 id="需求分析">7.2 需求分析</h2><h4 id="数据字典">数据字典</h4><p>数据字典是关于数据库中数据的描述，即元数据，而非数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善的。它在数据库设计中占有重要地位。</p><p>数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。</p><ul><li>数据项：不可再分的数据单位</li><li>数据结构：由若干数据项组成，反映了数据之间的组合关系</li><li>数据流：数据结构在系统内传输的路径</li><li>数据存储：数据结构停留或保存的地方</li><li>处理过程：一般用判定表或判定树来描述</li></ul><p>需求分析阶段收集到的基础数据是下一步进行概念设计的基础。</p><h2 id="概念设计">7.3 概念设计</h2><p>将需求分析得到的用户需求抽象为信息结构的过程就是概念结构设计。</p><h3 id="概念结构设计">概念结构设计</h3><h4 id="实体与属性的划分">实体与属性的划分</h4><p>现实世界事物能作为属性的尽量作为属性对待以简化E-R图。</p><ul><li>作为属性，不能再具有需要描述的物质</li><li>属性不能与其他实体具有联系</li></ul><p>方法：自顶向下地进行需求分析，自底向上地设计概念结构</p><ul><li>首先设计各子系统E-R图，再进行集成、重构</li><li>各子系统E-R图的冲突：<ul><li>属性冲突：属性域、取值单位冲突</li><li>命名冲突：同名异义，异名同义</li><li>结构冲突</li></ul></li></ul><h3 id="e-r模型">E-R模型</h3><p>用实体-联系（E-R）图来描述现实世界的概念模型。</p><p>E-R图提供了表示实体型、属性和联系的方法。</p><ul><li>实体型用矩形表示，矩形内写明实体名</li><li>属性用椭圆形表示，用无向边将其与相应的实体型连接</li><li>联系用菱形表示，菱形内写明联系名，用无向边分别与有关实体型连接，同时在边旁标上联系的类型（1:1、1:n或m:n）</li></ul><p>E-R图的绘制：</p><p>先绘制实体属性图、实体联系图，再进行综合。</p><h4 id="e-r扩展">E-R扩展</h4><h5 id="isa联系">ISA联系</h5><p>某些实体型是某个实体型的子类型，这种父类-子类联系称为ISA联系。</p><p>ISA联系描述了实体型中实体的一种分类方法：</p><ul><li>分类属性<ul><li>使用分类属性的值把父实体型中的实体分派到子实体型中</li></ul></li><li>不相交约束和可重叠约束<ul><li>父类中的一个实体是否能同时属于多个子类中的实体集</li></ul></li><li>完备性约束<ul><li>父类中的一个实体是否必须是某一个子类中的实体<ul><li>是，称为完全特化，双线连接，否则为部分特化，单线连接</li></ul></li></ul></li></ul><h5 id="基数约束">基数约束</h5><p>基数约束是对实体之间一对一、一对多和多对多的细化。</p><p>约束使用一个数对min..max表示</p><ul><li>min = 1的约束为强制参与约束；min = 0的约束为非强制参与约束。</li></ul><h5 id="part-of联系">Part-of联系</h5><p>部分联系，表明某个实体型是另外一个实体型的一部分。</p><ul><li>非独占联系：整体被破坏，部分实体可以存在，用非强制参与联系表示<ul><li>称该部分实体为强实体型</li></ul></li><li>独占联系：整体被破坏，部分实体不能存在<ul><li>称该部分实体为弱实体型，用双矩形表示，用双菱形表示识别联系</li></ul></li></ul><h3 id="uml">UML</h3><p>暂略</p><h2 id="逻辑结构设计">7.4 逻辑结构设计</h2><p>逻辑结构设计的任务就是把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。</p><h3 id="e-r图向关系模型的转换">7.4.1 E-R图向关系模型的转换</h3><p>一般原则：</p><ul><li><p>一个实体型转换为一个关系模式，关系的属性和码就是实体的属性和码。</p></li><li><p>对于实体间的联系：</p><ul><li>1:1联系可以转换为一个独立的关系模式，也可以和任一端的关系模式合并</li><li>1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</li><li>m:n联系可以转换为一个关系模式，与该联系相连的各实体的码以及联系本身的属性均转换成关系的属性，各实体的码组成关系的码或其一部分</li><li>3个及以上实体间的一个多元联系可以转换为一个关系模式</li><li>具有相同码的关系模式可以合并</li></ul></li></ul><h3 id="数据模型的优化">7.4.2 数据模型的优化</h3><p>数据库逻辑设计的结果不是唯一的。</p><p>规范化理论指导的优化方法：</p><ol type="1"><li>确定数据依赖</li><li>对各个关系模式之间的数据依赖进行极小化处理，消除冗余联系</li><li>按照数据依赖的理论对关系模式逐一进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式</li><li>根据需求分析阶段得到的处理要求分析对于这样的应用环境这些模式是否合适，是否要对某些模式进行合并或分解<ul><li>并不是规范化程度越高的关系就越优</li></ul></li><li>对关系模式进行必要分解<ul><li>水平分解：把关系的元组分为若干子集合，定义每个子集合为一个子关系</li><li>垂直分解：把关系模式的属性分解为若干子集合，形成若干子关系模式</li></ul></li></ol><h3 id="设计用户子模式">7.4.3 设计用户子模式</h3><ul><li>使用更符合用户习惯的别名</li><li>可以对不同级别的用户定义不同的视图</li><li>简化用户对系统的使用</li></ul><h2 id="物理结构设计">7.5 物理结构设计</h2><p>数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。</p><p>为一个给定的逻辑模型选取最适合应用要求物理结构的过程，就是数据库的物理设计。其内容主要包括为关系模式选择存取方法，以及设计关系、索引等数据库文件的物理存储结构。</p><p>物理设计一般分为两步：</p><ol type="1"><li>确定数据库物理结构，在关系数据库中主要指存取方法和存储结构</li><li>对物理结构进行评价，评价的重点是时间和空间效率</li></ol><h3 id="关系模式存取方法">7.5.1 关系模式存取方法</h3><p>常用的存取方法为索引方法和聚簇方法。</p><ul><li>B+树索引存取方法</li><li>hash索引存取方法</li><li>聚簇存取方法<ul><li>为了提高某个或某些属性的查询速度，把这个或这些属性上具有相同值的元组集中存放在连续的物理块中称为聚簇，该属性或属性组称为聚簇码</li></ul></li></ul><h3 id="确定数据库的存储结构">7.5.2 确定数据库的存储结构</h3><p>确定数据库物理结构主要指确定数据的存放位置和存储结构，需要综合考虑存取时间、存取空间利用率和维护代价三方面因素。</p><h2 id="数据库的实施和维护">7.6 数据库的实施和维护</h2><h3 id="数据的载入和应用程序的调试">7.6.1数据的载入和应用程序的调试</h3><p>数据库实施阶段包括两项重要工作：数据的载入、应用程序的编码与调试</p><ul><li>组织数据入库是数据库实施阶段最主要的工作。<ul><li>数据装载办法：人工、计算机辅助数据入库</li></ul></li><li>数据库应用程序的设计应该与数据库设计同时进行</li></ul><h3 id="数据库的试运行">7.6.2 数据库的试运行</h3><ul><li>先输入小批量数据调试，合格后再输入大批量数据，逐步完成运行评价</li><li>做好数据库转储和恢复工作</li></ul><h3 id="数据库的运行和维护">7.6.3 数据库的运行和维护</h3><ul><li>数据库的转储和恢复</li><li>数据库的安全性、完整性控制</li><li>数据库性能的监督、分析和改造</li><li>数据库的重组织和重构造</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第六章_关系数据理论</title>
    <link href="/2023/06/06/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
    <url>/2023/06/06/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第六章-关系数据理论">第六章 关系数据理论</h1><h2 id="关系模式与范式">6.1 关系模式与范式</h2><h3 id="数据依赖">数据依赖</h3><p>数据依赖是一个关系内部属性和属性之间的一种约束关系，这种约束关系是通过属性间值的相等与否体现出来的数据间相关联系，是数据内在的性质，语义的体现。</p><p>最重要的数据依赖：</p><ul><li>函数依赖（Functional Dependency，FD）</li><li>多值依赖（Multi-Valued Dependency，MVD）</li></ul><h3 id="关系模式">关系模式</h3><p>在第2章中的五元组关系模式：R(U,D,DOM,F)</p><ul><li>R为符号化的元组语义</li><li>U为一组属性</li><li>D为属性组U的属性所来自的域</li><li>DOM为属性到域的映射</li><li>F为U上的一组数据依赖</li></ul><p>由于D、DOM与模式设计关系不大，本章中把关系模式看作三元组R&lt;U,F&gt;，当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系。</p><h4 id="第一范式1nf">第一范式（1NF）</h4><p>每一个分量都是不可分的数据项的关系模式。</p><p>1NF的问题：</p><p>例：U={Sno,Sdept,Mname,Cno,Grade} //学号、系、系主任名、课程号、成绩</p><ul><li><p>数据冗余</p><p>每个系的系主任名重复出现</p></li><li><p>更新异常</p><p>数据冗余使得更新数据库的代价较大</p></li><li><p>插入异常</p><p>无学生的系无法存入系和系主任的信息</p></li><li><p>删除异常</p><p>学生全部毕业，则系和系主任信息也被删除</p></li></ul><p>改进：分成三个关系模式：</p><ul><li><p>S(Sno,Sdept,Sno-&gt;Sdept)</p></li><li><p>SC(Sno,Cno,Grade,(Sno,Cno)-&gt;Grade)</p></li><li><p>DEPT(Sdept,Mname,Sdept-&gt;Mname)</p></li></ul><h2 id="规范化">6.2 规范化</h2><h3 id="函数依赖">6.2.1 函数依赖</h3><p>设R(U)是属性集U上的关系模式，X和Y是U的子集，若对R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则X函数确定Y或Y函数依赖于X，记作X-&gt;Y。</p><p>函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。</p><ul><li>X-&gt;Y，Y不包含于X，则称X-&gt;Y为非平凡的函数依赖，一般都讨论这样的函数依赖</li><li>X-&gt;Y，Y包含于X，则称X-&gt;Y为平凡的函数依赖，它对任意关系模式都必然成立</li><li>X-&gt;Y，X称为这个函数依赖的决定属性组，称为决定因素</li><li>X-&gt;Y，Y-&gt;X，记作X&lt;--&gt;Y</li></ul><p>在R(U)中，如果X-&gt;Y，并且对于X的任意真子集X'，都有X'不函数确定Y，则称Y对X完全函数依赖，记作<spanclass="math inline">\(X\rightarrow^FY\)</span>，若X-&gt;Y，但Y不对X完全函数依赖，则称Y对X部分函数依赖，记作<spanclass="math inline">\(X\rightarrow^P Y\)</span></p><p>在R(U)中，如果X-&gt;Y不平凡，Y-&gt;Z不平凡，则称Z对X传递函数依赖，记为<spanclass="math inline">\(X\rightarrow^{传递} Z\)</span></p><ul><li>如果X-&gt;Y平凡，此处为直接函数依赖</li></ul><h3 id="码">6.2.2 码</h3><p>设K是R&lt;U,F&gt;中的属性或属性组合，若U完全函数依赖于K，则K为R的候选码。</p><ul><li>若U部分函数依赖于K，则K称为超码。候选码是最小的超码。</li></ul><p>若候选码多于一个，则选定其中的一个为主码。</p><ul><li><p>包含在任何一个候选码中的属性称为主属性，反之为非主属性或非码属性。</p></li><li><p>整个属性组是码，称为全码</p></li></ul><p>关系模式R中属性或属性组X并非R的码，但是另一个关系模式的码，称X为R的外码。</p><h3 id="范式">6.2.3 范式</h3><p>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</p><p>高级范式真包含于低级范式，从高到低有5NF、4NF、BCNF、3NF、2NF、1NF。</p><p>一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程称为规范化。</p><h4 id="nf">2NF</h4><p>若R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R属于2NF。</p><h4 id="nf-1">3NF</h4><p>若R属于1NF，且每一个非主属性既不传递依赖于码，也不部分依赖于码，则R属于3NF。</p><h4 id="bcnf">BCNF</h4><p>关系模式R中，若每一个决定因素都包含码，则R属于BCNF。</p><ul><li>所有非主属性对每一个码都是完全函数依赖</li><li>所有主属性对每一个不包含它的码也是完全函数依赖</li><li>没有任何属性完全依赖于非码的任何一组属性</li></ul><h4 id="多值依赖">多值依赖</h4><p>设R(U)是属性集U上的一个关系模式，X，Y，Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X-&gt;-&gt;Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。</p><p>性质：</p><ul><li>对称性：X-&gt;-&gt;Y， 则X-&gt;-&gt;Z，其中Z=U-X-Y。</li><li>传递性：X-&gt;-&gt;Y，Y-&gt;-&gt;Z，则X-&gt;-&gt;Z-Y</li><li>函数依赖是多值依赖的特殊情况</li><li>若X-&gt;-&gt;Y，X-&gt;-&gt;Z，则X-&gt;-&gt;YZ，X-&gt;-&gt;Y交Z，X-&gt;-&gt;Y-Z，X-&gt;-&gt;Z-Y</li></ul><p>特点：</p><ul><li><p>多值依赖的有效性与属性集的范围有关</p></li><li><p>若函数依赖X-&gt;-&gt;Y在R(U)上成立，则对于任何Y‘包含于Y，均有X-&gt;-&gt;Y'成立。而多值依赖X-&gt;-&gt;Y若在R(U)上成立，却不能断言对于任何Y'包含于Y有X-&gt;-&gt;Y'成立。</p></li></ul><h4 id="nf-2">4NF</h4><p>限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</p><h3 id="规范化小结">6.2.4 规范化小结</h3><p>规范化的基本思想是逐步消除数据依赖的不合适部分，实质上是概念的单一化。</p><p>关系模式的规范化过程是通过对关系模式的分解来实现的。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第五章_数据库完整性</title>
    <link href="/2023/06/05/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    <url>/2023/06/05/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第五章-数据库完整性">第五章 数据库完整性</h1><p>数据库的完整性是指数据的正确性和相容性。</p><ul><li>数据的正确性是指数据是复合现实世界语义，反映当前实际情况的</li><li>数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的</li></ul><p>数据库管理系统为维护数据库完整性而实现的功能：</p><ul><li>提供定义完整性约束条件的机制</li><li>提供完整性检查的方法</li><li>进行违约处理</li></ul><p>关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能够为所有用户和应用提供一致的数据库完整性。</p><h2 id="实体完整性">5.1 实体完整性</h2><p>关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。</p><ul><li>对单属性构成的码，可以在列级定义，也可以在表级定义<ul><li>Sno CHAR(9) PRIMARY KEY</li><li>PRIMARY KEY (Sno)</li></ul></li><li>对多属性构成的码，只能在表级定义<ul><li>PRIMARY KEY(Sno, Cno)</li></ul></li></ul><p>实体完整性检查和违约处理</p><ul><li>检查主码的各个属性是否为空，有一个为空就拒绝插入或修改</li><li>检查主码值是否唯一，如果不唯一就拒绝插入或修改<ul><li>方法：全表扫描、B+树索引</li></ul></li></ul><h2 id="参照完整性">5.2 参照完整性</h2><p>关系模型的参照完整性在CREATE TABLE中用FOREIGNKEY来定义哪些列尾外码，用REFERENCES短语指明这些外码参照哪些表的主码。</p><p>参照完整性检查和违约处理</p><table><thead><tr class="header"><th>被参照表</th><th>参照表</th><th>违约处理</th></tr></thead><tbody><tr class="odd"><td>可能破坏参照完整性</td><td>插入元组</td><td>拒绝</td></tr><tr class="even"><td>可能破坏参照完整性</td><td>修改外码值</td><td>拒绝</td></tr><tr class="odd"><td>删除元组</td><td>可能破坏参照完整性</td><td>拒绝/级联删除/设置为空值</td></tr><tr class="even"><td>修改主码值</td><td>可能破坏参照完整性</td><td>拒绝/级联删除/设置为空值</td></tr></tbody></table><ul><li>拒绝（NO ACTION），一般为默认策略</li></ul><h2 id="用户定义的完整性">5.3 用户定义的完整性</h2><p>用户定义的完整性就是针对某一具体应用的数据必须满足的语义条件。</p><ul><li><p>属性上的约束条件</p><ul><li><p>非空（NOT NULL）</p></li><li><p>唯一（UNIQUE）</p></li><li><p>用CHECK语句指定列值条件</p><p><code>Sex CHAR(2) CHECK (Sex IN('男','女'))</code></p></li><li><p>修改或插入时检查；违约处理：拒绝执行</p></li></ul></li><li><p>元组上的约束条件</p><ul><li>用CHECK指定元组约束条件</li><li>修改或插入时检查；违约处理：拒绝执行</li></ul></li></ul><h2 id="完整性约束命名子句">5.4 完整性约束命名子句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>完整性约束条件名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>完整性约束条件<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student <br>(Sno <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">6</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span> (Sno <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">90000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">99999</span>), <br> Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C2 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br> Sage <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>), <br> Ssex <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C4 <span class="hljs-keyword">CHECK</span>(SSex <span class="hljs-keyword">IN</span>(<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>)), <br><span class="hljs-keyword">CONSTRAINT</span> StudentKey <span class="hljs-keyword">PRIMARY</span> KEY(Sno)<br>;)<br></code></pre></td></tr></table></figure><p>修改例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C3;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><h2 id="域中的完整性限制">5.5 域中的完整性限制</h2><p>域是一组具有相同数据类型的值的集合。</p><p>SQL中，可以用CREATEDOMAIN来创建一个域以及其应该满足的完整性约束条件以定义属性。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DOMAIN GenderDomain <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">CONSTRAINT</span> GD <span class="hljs-keyword">CHECK</span>(<span class="hljs-keyword">VALUE</span> <span class="hljs-keyword">IN</span>(<span class="hljs-string">&#x27;男&#x27;</span>，<span class="hljs-string">&#x27;女&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="断言">5.6 断言</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ASSERTION <span class="hljs-operator">&lt;</span>断言名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">CHECK</span>子句<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h2 id="触发器">5.7 触发器</h2><p>触发器（trigger）是用户定义在关系表上的一类由事件驱动的特殊过程。</p><ul><li>触发器又叫事件-条件-动作规则。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span><br>&#123;BEFORE<span class="hljs-operator">|</span>AFTER&#125; <span class="hljs-operator">&lt;</span>触发事件<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-comment">/* 指明触发器激活时间在事件前后 */</span><br><span class="hljs-keyword">REFERENCING</span> <span class="hljs-keyword">NEW</span><span class="hljs-operator">|</span><span class="hljs-keyword">OLD</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>变量<span class="hljs-operator">&gt;</span>  <span class="hljs-comment">/* 指明引用的变量 */</span><br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> &#123;<span class="hljs-type">ROW</span><span class="hljs-operator">|</span>STATEMENT&#125;<br>[<span class="hljs-keyword">WHEN</span> <span class="hljs-operator">&lt;</span>触发条件<span class="hljs-operator">&gt;</span>] <span class="hljs-operator">&lt;</span>触发动作体<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只有表的拥有者才能在表上创建触发器，且触发器数量有限</li><li>同一模式下，触发器名必须是唯一的，且触发器名和表名必须在同一模式下</li><li>触发器只能定义在基本表上，不能定义在视图上</li><li>触发事件可以是INSERT、DELETE或UPDATE，也可以是其组合</li><li>行级触发器每行都执行，语句级触发器只触发一次</li></ul><p>删除触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第四章_数据库安全性</title>
    <link href="/2023/06/04/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <url>/2023/06/04/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第四章-数据库安全性">第四章 数据库安全性</h1><h2 id="数据库安全性概述">4.1 数据库安全性概述</h2><p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</p><p>系统安全保护措施是否有效是数据库系统的主要技术指标之一。</p><h3 id="数据库的不安全因素">数据库的不安全因素</h3><ul><li>非授权用户对数据库的恶意存取和破坏</li><li>数据库中重要或敏感的数据被泄露</li><li>安全环境的脆弱性</li></ul><h3 id="安全标准简介">安全标准简介</h3><p>TCSEC/TDI</p><table><thead><tr class="header"><th>安全级别</th><th>定义</th></tr></thead><tbody><tr class="odd"><td>A1</td><td>验证设计</td></tr><tr class="even"><td>B3</td><td>安全域</td></tr><tr class="odd"><td>B2</td><td>结构化保护</td></tr><tr class="even"><td>B1</td><td>标记安全保护</td></tr><tr class="odd"><td>C2</td><td>受控的存取保护</td></tr><tr class="even"><td>C1</td><td>自主安全保护</td></tr><tr class="odd"><td>D</td><td>最小保护</td></tr></tbody></table><ul><li><p>D级，最低级别，一切不符合更高标准的系统均归于D组</p></li><li><p>C1：能够实现对用户和数据的分离，进行自主存取控制(DAC)</p></li><li><p>B1：对系统数据加以标记，并对被标记的主客体实施强制存取控制(MAC)以及审计</p></li><li><p>B1以上为安全产品</p></li></ul><p>CC（Common Criteria）：安全功能要求和安全保证要求</p><h2 id="数据库安全性控制">4.2 数据库安全性控制</h2><p>主要内容：</p><ul><li>用户身份鉴别</li><li>多层存取控制</li><li>审计</li><li>视图</li><li>数据加密</li></ul><h3 id="用户身份鉴别">4.2.1 用户身份鉴别</h3><p>常见方法：</p><ul><li>静态口令鉴别</li><li>动态口令鉴别</li><li>生物特征鉴别</li><li>智能卡鉴别</li></ul><h3 id="存取控制">4.2.2 存取控制</h3><p>存取控制机制的组成：</p><ul><li>定义用户权限<ul><li>提供适当语言以定义用户权限，编译后存储在数据字典中，称为安全规则</li></ul></li><li>合法权限检查<ul><li>根据安全规则进行合法权限检查</li></ul></li><li>定义用户权限和合法权限检查机制一起组成了数据库管理系统的存取控制子系统。</li></ul><p>C2级的数据库管理系统支持自主存取控制（Discretionary AccessControl，DAC）；</p><p>B1级的数据库管理系统支持强制存取控制（Mandatory AccessControl，MAC）。</p><ul><li>在自主存取控制中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，用户可将其拥有的存取权限转授给其他用户</li><li>在强制存取控制中，每个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取</li></ul><h4 id="自主存取控制">自主存取控制</h4><p>用户权限的两个要素：数据库对象和操作类型</p><ul><li>在数据库系统中，定义存取权限称为授权</li></ul><p>关系数据库系统中，存取控制的对象不仅有数据本身，还有数据库模式</p><table><thead><tr class="header"><th>对象类型</th><th>对象</th></tr></thead><tbody><tr class="odd"><td>数据</td><td>基本表和视图、属性列</td></tr><tr class="even"><td>数据库模式</td><td>模式、基本表、视图、索引</td></tr></tbody></table><p>SQL使用GRANT语句向用户授予权限，REVOKE语句收回已经授予用户的权限。</p><h5 id="grant">GRANT</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION]<br></code></pre></td></tr></table></figure><ul><li><p>如果制定了WITH GRANTOPTION子句，则授权的用户可以把这种权限转授。</p></li><li><p>GRANT ALL PRIVILEGES可以将全部操作权限授予用户</p></li><li><p>对属性列授权时必须明确指出相应的属性列名</p></li></ul><h5 id="revoke">REVOKE</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...[CASCADE<span class="hljs-operator">|</span>RESTRICT];<br></code></pre></td></tr></table></figure><ul><li>一般默认CASCADE，将收回全部直接或间接从该用户获得的对应权限，而RESTRICT只收回指定用户的权限</li></ul><h5 id="创建数据库模式的权限">创建数据库模式的权限</h5><p>创建数据库模式一类的数据库对象的授权由数据库管理员在创建用户时完成。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WITH</span>] [DBA<span class="hljs-operator">|</span>RESOURCE<span class="hljs-operator">|</span><span class="hljs-keyword">CONNECT</span>];<br></code></pre></td></tr></table></figure><ul><li>只有系统的超级用户才有权创建一个新的数据库用户</li><li>新创建的数据库用户有三种权限：CONNECT、RESOURCE、DBA，默认CONNECT<ul><li>CONNECT权限用户不能创建新用户、模式、基本表</li><li>RESOURCE权限用户可以创建基本表，不能创建新用户和模式</li><li>DBA权限用户是系统的超级用户，可以创建新用户、模式和基本表，拥有所有数据库对象的存取权限</li></ul></li></ul><h5 id="数据库角色-role">数据库角色 ROLE</h5><p>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。</p><ul><li>为一组具有相同权限的用户创建一个角色，简化授权的过程</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ROLE <span class="hljs-operator">&lt;</span>角色名<span class="hljs-operator">&gt;</span>;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">3</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> ADMIN OPTION]<br><br><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br></code></pre></td></tr></table></figure><ul><li>如果指定了WITH ADMIN OPTION，那么获得权限的用户可以转授该权限。</li></ul><h4 id="强制存取控制">强制存取控制</h4><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类。</p><ul><li><p>主体是系统中的活动实体，既包括数据管理系统所管理的实际用户，也包括代表用户的各进程</p></li><li><p>客体是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引等。</p></li><li><p>对于主体和客体，数据库管理系统为它们每个实例指派一个敏感度标记（label）</p><p>敏感度标记被分为若干级别，如绝密（TopSecret，TS），机密（Secret，S），可信（Confidential，C），公开（Public，P），TS&gt;=S&gt;=C&gt;=P</p><p>主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级</p><ul><li>仅当主体的许可证级别大于等于客体的密级时，该主体才能读取该客体</li><li>仅当主体的许可证级别小于等于客体的密级时，该主体才能写该客体</li><li>即用户只能读低于或等于自己许可的数据，创建高于或等于自己许可的数据，以防止高级用户将数据泄露给低级用户</li></ul></li><li><p>强制存取控制对数据本身加以的密级标识和数据时一个整体</p></li></ul><h5id="自主存取控制强制存取控制dacmac">自主存取控制+强制存取控制（DAC+MAC）</h5><p>先进行自主存取控制审查，在进行强制存取控制检查</p><h2 id="一些安全性保护办法">4.3 一些安全性保护办法</h2><h3 id="视图机制">4.3.1 视图机制</h3><p>把要保密的数据对无权存取的用户隐藏起来，为数据提供一定程度的安全保护。</p><h3 id="审计audit">4.3.2 审计（audit）</h3><p>审计功能把用户对数据库的所有操作自动记录下来放入审计日志（auditlog）。</p><ul><li>审计通常是很费时间和空间的，所以数据库系统往往都将审计设置成可选的</li><li>审计设置以及审计日志一般存储在数据字典中，必须开启审计开关（设置audit_trail为true），才能在系统表SYS_AUDITTRAIL中看到审计信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">AUDIT <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>;<br><br>NOAUDIT <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>审计一般可以分为用户级审计和系统级审计。</p><p>数据库安全审计系统提供了一种事后检查的安全机制。安全审计机制将特定用户或者特定对象相关的操作记录到系统审计日志中，作为后续对操作的查询分析和追踪的依据。通过审计机制，可以约束用户可能的恶意操作。</p><h3 id="数据加密">4.3.3 数据加密</h3><p>加密的基本思想是依据一定的算法将原始数据——明文（plaintext）变换为不可直接识别的格式——密文（cipher text）。</p><p>数据加密主要包括存储加密和传输加密。</p><ul><li>存储加密<ul><li>透明存储加密：内核级加密保护，对用户完全透明</li><li>非透明存储加密：通过多个加密函数实现</li></ul></li><li>传输加密<ul><li>链路加密：对传输数据在链路层进行加密，加密报文和报头</li><li>端到端加密：在发送端加密，接收端解密，加密报文</li></ul></li></ul><h3 id="其他安全性保护">4.3.4 其他安全性保护</h3><ul><li><p>推理控制：避免由低级数据推导出高级数据</p></li><li><p>隐蔽信道：间接信息传递</p></li><li><p>数据隐私：控制不愿他人知道或他人不便知道的个人数据的能力</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第三章_SQL</title>
    <link href="/2023/06/03/%E7%AC%AC%E4%B8%89%E7%AB%A0_SQL/"/>
    <url>/2023/06/03/%E7%AC%AC%E4%B8%89%E7%AB%A0_SQL/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第三章-sql">第三章 SQL</h1><p>结构化查询语言（Structured QueryLanguage，SQL）是关系数据库标准语言，功能包括</p><ul><li>数据库的查询</li><li>数据库模式创建</li><li>数据库数据的插入与修改</li><li>数据库安全性完整性定义与控制</li><li>……</li></ul><h2 id="sql概述">3.1 SQL概述</h2><h3 id="sql的特点">3.1.1 SQL的特点</h3><ul><li>综合统一<ul><li>集数据定义语言、数据操纵语言、数据控制语言于一体</li></ul></li><li>高度非过程化<ul><li>存取路径的选择以及SQL的操作过程由系统自动完成</li></ul></li><li>面向集合的操作方式<ul><li>操作对象、查找结果都可以是元组的集合</li></ul></li><li>以同一种语法结构提供多种使用方式<ul><li>能嵌入到C++、Java中</li></ul></li><li>语言简洁，易学易用<ul><li>数据查询：SELECT</li><li>数据定义：CREATE、DROP、ALTER</li><li>数据操纵：INSERT、UPDATE、DELETE</li><li>数据控制：GRANT、REVOKE</li></ul></li></ul><h3 id="sql的基本概念">3.1.2 SQL的基本概念</h3><h4 id="sql与三级模式">SQL与三级模式</h4><ul><li>内模式：存储文件</li><li>模式：基本表</li><li>外模式：视图</li></ul><p>用户可以用SQL对基本表和视图进行查询或其他操作。基本表和视图都是关系。</p><p>基本表是本事独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表，一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。</p><p>存储文件的逻辑结构组成了关系数据库的内模式，其逻辑结构对用户是隐蔽的。</p><p>视图是一个或几个基本表导出的表，它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据。这些数据仍存放在导出视图的基本表中，因而视图仅仅是一个虚表。用户可以在视图上再定义视图。</p><h2 id="数据定义">3.2 数据定义</h2><p>层次化的数据库对象命名机制：</p><p>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</p><p>SQL的数据定义：模式定义、表定义、视图定义和索引定义</p><table><thead><tr class="header"><th>操作对象</th><th>创建</th><th>删除</th><th>修改</th></tr></thead><tbody><tr class="odd"><td>模式</td><td>CREATE SCHEMA</td><td>DROP SCHEMA</td><td></td></tr><tr class="even"><td>表</td><td>CREATE TABLE</td><td>DROP TABLE</td><td>ALTER TABLE</td></tr><tr class="odd"><td>视图</td><td>CREATE VIEW</td><td>DROP VIEW</td><td></td></tr><tr class="even"><td>索引</td><td>CREATE INDEX</td><td>DROP INDEX</td><td>ALTER INDEX</td></tr></tbody></table><h3 id="模式">模式</h3><p>定义模式即定义了一个命名空间，在此空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引。</p><p>CREATE SCHEMA <模式名> AUTHORIZATION <用户名> [<表定义子句> |<视图定义子句> | <授权定义子句>]</p><p>不指定模式名时，模式名将隐含为用户名。</p><p>删除模式：DROP SCHEMA <模式名> &lt;CASCADE|RESTRICT&gt;</p><ol type="1"><li>CASCADE：删除模式的同时删除该模式中所有数据库对象</li><li>RESTRICT：如果该模式中定义了下属的数据库对象，则拒绝执行删除</li></ol><h3 id="基本表">基本表</h3><p>CREATE TABLE <表名> (<列名> <数据类型> [<列级完整性约束条件>]</p><p>[，<列名> <数据类型> [<列级完整性约束条件>]]</p><p>…</p><p>[，<表级完整性约束条件>]);</p><p>列级完整性：PRIMARY KEY、UNIQUE、NOT NULL等</p><p>表级完整性：PRIMARY KEY(Sno, Cno)；FOREIGN KEY(Cno) REFERENCESCourse(Cno)</p><table><thead><tr class="header"><th>数据类型</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>CHAR(n),CHARACTER(n)</td><td>长度为n的定长字符串</td></tr><tr class="even"><td>VARCHAR(n)</td><td>最大长度为n的变长字符串</td></tr><tr class="odd"><td>CLOB</td><td>字符串大对象</td></tr><tr class="even"><td>BLOB</td><td>二进制大对象</td></tr><tr class="odd"><td>INT，INTEGER</td><td>长整数(4字节)</td></tr><tr class="even"><td>SMALLINT</td><td>短整数(2字节)</td></tr><tr class="odd"><td>BIGINT</td><td>大整数(8字节)</td></tr><tr class="even"><td>NUMERIC(p，d)</td><td>定点数，由p位数字(不包括符号、小数点)组成，小数后面有d位数字</td></tr><tr class="odd"><td>DECIMAL(p, d), DEC(p, d)</td><td>同NUMERIC</td></tr><tr class="even"><td>REAL</td><td>取决于机器精度的单精度浮点数</td></tr><tr class="odd"><td>DOUBLE PRECISION</td><td>取决于机器精度的双精度浮点数</td></tr><tr class="even"><td>FLOAT(n)</td><td>可选精度的浮点数，精度至少为n位数字</td></tr><tr class="odd"><td>BOOLEAN</td><td>逻辑布尔量</td></tr><tr class="even"><td>DATE</td><td>日期，包含年、月、日，格式为YYYY-MM-DD</td></tr><tr class="odd"><td>TIME</td><td>时间，包含一日的时、分、秒，格式为HH:MM:SS</td></tr><tr class="even"><td>TIMESTAMP</td><td>时间戳类型</td></tr><tr class="odd"><td>INTERVAL</td><td>时间间隔类型</td></tr></tbody></table><p>修改基本表</p><ul><li><p>ALTER TABLE <表名></p><p>[ADD [COLUMN] <新列名> <数据类型> [完整性约束]]</p><p>[ADD <表级完整性约束>]</p><p>[DROP [COLUMN] <列名> [CASCADE| RESTRICT]]</p><p>[DROP CONSTRAINT<完整性约束名>[RESTRICT | CASCADE]]</p><p>[ALTER COLUMN <列名><数据类型>]；</p></li><li><p>ADD用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件</p><p>DROP COLUMN用于删除表中列</p><p>DROP CONSTRAINT用于删除指定的完整性约束条件</p><p>ALTER COLUMN用于修改原有列定义，包括列名和数据类型</p></li></ul><h3 id="索引">索引</h3><p>作用：加快查询速度</p><p>建立索引：</p><p>CREATE [UNIQUE] [CLUSTER] INDEX <索引名> ON <表名> (<列名>[<顺序>]…);</p><ul><li><p>顺序：</p><ul><li>升序：ASC</li><li>降序：DESC</li><li>缺省值：ASC</li></ul></li><li><p>UNIQUE：每个索引值只对应唯一的数据记录</p></li><li><p>CLUSTER：表示要建立的索引时聚簇索引</p></li></ul><p>修改索引：ALTER INDEX <旧名称> RENAME TO <新名称></p><p>删除索引：DROP INDEX <名称></p><h2 id="数据查询">3.3 数据查询</h2><p>SELECT [ALL|DISTINCT] <目标列表达式> [,<目标列表达式>]…</p><p>FROM <表/视图名> [,<表/视图名>]… | (SELECT语句) [AS] <别名></p><p>[WHERE <条件表达式>]</p><p>[GROUP BY <列名1> [HAVING <条件表达式>]]</p><p>[ORDER BY <列名2>]</p><ul><li>DISTINCT：去除重复行，缺省为ALL</li><li>WHERE表示指定条件，作用于表<ul><li>BETWEEN AND（范围）、IN（集合）、LIKE（匹配字符）、ISNULL（空值）、AND OR（多重条件查询）、ORDER BY（升降排列）</li></ul></li><li>聚集函数只用于SELECT和GROUP BY中的HAVING子句<ul><li>COUNT、SUM、AVG、MAX、MIN（需要指定DISTINCT或ALL）</li></ul></li><li>GROUP BY按照某一列或多列的值分组<ul><li>指定属性值相同的元组为一组，然后对每一组作用聚集函数进行计算</li></ul></li></ul><table><thead><tr class="header"><th>查询条件</th><th>谓词</th></tr></thead><tbody><tr class="odd"><td>比较</td><td>=, &gt;, &lt;, &gt;=, &lt;=, !=, &lt;&gt;, !&gt;, !&lt;;NOT+上述比较运算符</td></tr><tr class="even"><td>确定范围</td><td>BETWEEN AND, NOT BETWEEN AND</td></tr><tr class="odd"><td>确定集合</td><td>IN, NOT IN</td></tr><tr class="even"><td>字符匹配</td><td>LIKE, NOT LIKE</td></tr><tr class="odd"><td>空值</td><td>IS NULL, IS NOT NULL</td></tr><tr class="even"><td>多重条件(逻辑运算)</td><td>AND, OR, NOT</td></tr></tbody></table><h4 id="字符匹配">字符匹配</h4><p>匹配串可以是一个完整的字符串，也可以含有通配符%(任意长度字符串)和_(任意单个字符)</p><p>用。</p><h4 id="空值">空值</h4><ul><li>产生：没赋值/修改/外连接/关系运算</li><li>判断：IS NULL/IS NOT NULL (注意IS一直有)</li><li>约束条件：NOT NULL/UNIQUE/PRIMARY KEY不能取空值</li><li>逻辑运算：TRUE FALSE UNKNOWN</li></ul><h4 id="聚集函数">聚集函数</h4><p>统计元组个数：COUNT(*)</p><p>统计一列中值的个数：COUNT([DISTINCT|ALL] <列名>)</p><p>计算一列值的总和(必须为数值型)：SUM([DISTINCT|ALL] <列名>)</p><p>计算一列值的平均值(必须为数值型)：AVG([DISTINCT|ALL] <列名>)</p><p>求最大最小值：MAX/MIN([DISTINCT|ALL] 列名)</p><h4 id="连接查询">连接查询</h4><p>连接查询即同时涉及两个以上表的查询，连接条件或连接谓词是连接两表的条件</p><p><列1> <比较运算符> <列2></p><p><列1> BETWEEN <列2> AND <列3></p><p>连接字段：连接谓词中的列名称。</p><ul><li><p>等值/自然连接：连接运算符为=。</p></li><li><p>自身连接：表与自己进行连接：需要给表起别名，并使用别名前缀以示区别。</p></li><li><p>多表连接</p></li></ul><p>连接操作的执行过程</p><ol type="1"><li>嵌套循环</li></ol><p>逐个对表1中每个元组执行遍历表2的连接操作。</p><ol start="2" type="1"><li>排序合并</li></ol><p>首先按连接属性对两表排序，然后查找表1中元组在表2中的连接，查找到大于表1字段值的元组后，查询不再继续。</p><ol start="3" type="1"><li>索引连接</li></ol><p>对表2按连接字段建立索引，依次查询表1中各元组的连接。</p><p>外连接：以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</p><p>SELECT <字段名> FROM <表名> LEFT JOIN <表名> ON <连接条件></p><h4 id="嵌套查询">嵌套查询</h4><p><字段名> IN/比较运算符 (ANY/ALL) <查询语句> (NOT) EXISTS<查询语句></p><h4 id="集合操作">集合操作</h4><ul><li>并UNION、交INTERSECT、差EXCEPT</li></ul><p>参与集合操作的各查询结果的列数和各数据类型必须相同。</p><p>UNION：合并多个查询结果，去掉重复元组</p><p>UNION ALL：合并多个查询结果，保留重复元组</p><h4 id="派生表查询">派生表查询</h4><p>SELECT <列名> FROM (查询语句)</p><p>若子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT语句子句后列名为其缺省属性。</p><h2 id="数据更新">3.4 数据更新</h2><ul><li><p>插入：INSERT INTO <表名> [<属性列>,…] VALUES (<常量>,…)</p><ul><li>指定要插入数据的表名及属性列，插入的元组在其余属性列取空值。</li><li>未指定属性列：插入完整元组，且属性列属性的顺序和表一致。</li><li>VALUES提供的值的个数与类型必须与INTO子句匹配。</li></ul></li><li><p>修改：UPDATE <表名> SET <列名>=<表达式>,… [WHERE 条件]</p></li><li><p>删除：DELETE FROM <表名> [WHERE 条件]</p></li></ul><h2 id="视图">3.5 视图</h2><p>视图是虚表，从一个或几个基本表导出，只存放定义而无数据，基表中数据变化，视图中数据也随之改变。</p><p>视图的更新是同步于基本表的，一般来说，行列子集视图可以更新，其他（如AVG）不可。</p><p>视图的作用：</p><ul><li>简化用户的操作</li><li>使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性<ul><li>外模式不变，即使模式变更也不影响</li></ul></li><li>对机密数据提供安全保护<ul><li>每个用户看到的视图不同</li></ul></li><li>可以更清晰地表达查询</li></ul><p>视图做不到的：</p><ul><li>部分特殊视图不允许更新</li><li>视图消解有局限性，有时不能正确地查询</li></ul><h3 id="建立视图">建立视图</h3><p>CREATE VIEW <视图名> [(<列名>,…)]</p><p>AS <子查询></p><p>[WITH CHECK OPTION]</p><ul><li><p>WITH CHECKOPTION：对视图进行UPDATE、INSERT和DELETE时要保证更新的行满足视图定义中的谓词条件(即子查询中的条件表达式)。</p><ul><li>子查询可以是任意的select语句。</li></ul></li><li><p>行列子集视图：从单个表导出某些列，保留主码</p></li><li><p>组成视图的属性列名：全部省略或全部指定</p></li><li><p>实现增删改视图--&gt;增删改基本表：不写聚集函数</p></li></ul><p>关系数据库管理系统在执行CREATEVIEW的时候只是将视图定义存入数据字典，并不执行SELECT。查询时，按定义将其查出。</p><h3 id="删除视图">删除视图</h3><p>DROP VIEW <视图名> [CASCADE]</p><p>CASCADE：级联地删除视图及其导出的视图。</p><h3 id="查询视图">查询视图</h3><p>用户查询与查询基本表一致。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第二章_关系数据库</title>
    <link href="/2023/06/02/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/06/02/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第二章-关系数据库">第二章 关系数据库</h1><h2 id="关系数据结构及其形式化定义">2.1 关系数据结构及其形式化定义</h2><h3 id="关系">2.1.1 关系</h3><h4 id="关系数据结构的形式化定义">关系数据结构的形式化定义</h4><ol type="1"><li>域（domain）</li></ol><p>域是一组具有相同数据类型的值的集合</p><ol start="2" type="1"><li>笛卡尔积（cartesian product）</li></ol><p>笛卡尔积是域上的一种集合运算。</p><p>给定一组域<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>，允许其中某些域是相同的，<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>的笛卡尔积为</p><p><span class="math inline">\(D_1\times D_2\times ...\timesD_n=\{(d_1,d_2,...,d_n)|d_i\in D_i,i=1,2,...,n\}\)</span></p><p>其中，每个元素<spanclass="math inline">\((d_1,d_2,...,d_n)\)</span>称作一个n元组（n-tuple），或简称元组。元组中的每一个值<spanclass="math inline">\(d_i\)</span>称为一个分量。</p><p>一个域允许的不同取值个数称为这个域的基数（cardinal number）。</p><p>若<span class="math inline">\(D_i\)</span>为有限集，其基数为<spanclass="math inline">\(m_i(i=1,2,...,n)\)</span>，则<spanclass="math inline">\(D_1\times D_2\times ...\timesD_n\)</span>的基数M为</p><p><span class="math inline">\(M=\prod_{i=1}^n m_i\)</span></p><ol start="3" type="1"><li>关系</li></ol><p><span class="math inline">\(D_1\times D_2\times ...\timesD_n\)</span>的子集称为在域<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>上的关系，表示为<spanclass="math inline">\(R(D_1,D_2,...,D_n)\)</span>。</p><p>这里R表示关系的名字，n是关系的目或度（degree），关系中的每个元素是关系中的元组，通常用t表示。</p><ul><li>当<spanclass="math inline">\(n=1\)</span>时，称该关系为一元关系（unaryrelation）</li><li>当<spanclass="math inline">\(n=2\)</span>时，称该关系为二元关系（binaryrelation）</li></ul><p>关系是笛卡尔积的有限子集，故关系是一张每行对应一个元组的二维表，表的每列对应一个域。每列的名字为属性，n目关系必有n个属性。</p><p>若关系中的某一属性组能唯一地标识一个元组而其子集不能，则称该属性组为候选码（candidatekey）。</p><p>若一个关系有多个候选码，则选定其中一个为主码（primary key）。</p><p>候选码地各个属性为主属性（primeattribute）。不包含在任何候选码中的属性称为非主属性或非码属性。</p><p>在最简单地情况下，候选码只包含一个属性，在最极端地情况下，关系模式地所有属性是这个关系模式地候选码，称为全码（all-key）。</p><h5 id="关系的三种类型">关系的三种类型</h5><p>基本表、查询表和视图表，其中基本表为实际存在的表，查询表是查询结果对应的表，视图表是由基本表或其他视图表导出的表，是虚表。</p><h5 id="基本关系的性质">基本关系的性质</h5><ol type="1"><li>列是同质的，每一列中的分量是同一类型的数据，来自同一个域</li><li>不同的列可来自同一个域，但有不同的属性名</li><li>列和行都是无序的</li><li>任意两个元组的候选码不能取相同值</li><li>每个分量都是不可分的数据项</li></ol><p>关系模型要求关系必须是规范化的，满足一定的规范条件。规范化的关系称为范式（NormalForm，NF）。</p><h3 id="关系模式与关系数据库">2.1.2 关系模式与关系数据库</h3><p>关系的描述称为关系模式，可以形式化地表示为<spanclass="math inline">\(R(U,D,DOM,F)\)</span>。</p><p>其中R是关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间关系的依赖关系集合。</p><p>其中，<span class="math inline">\(DOM(属性名)=域名\)</span>。</p><p>关系模式可以简记为<spanclass="math inline">\(R(U)或R(A_1,A_2,...,A_n)\)</span>。其中<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>为属性名。</p><p>关系数据库的型称为关系数据库模式，是对关系数据库的描述。</p><p>关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</p><h2 id="关系操作">2.2 关系操作</h2><h3 id="基本关系操作">2.2.1 基本关系操作</h3><p>关系操作的对象和结果都是集合，这种方式也称为一次一集合方式，相应地，非关系数据模型的数据操作方式则为一次一记录的方式。</p><p>关系模型中常用的关系操作包括查询(query)操作和插入(insert)、删除(delete)、修改(update)操作两部分。</p><p>查询操作是关系操作中最主要的部分，包括：</p><p>选择(select)、投影(project)、连接(join)、除(divide)、并(union)、差(except)、交(intersection)、笛卡尔积等。</p><p>查询操作中，选择、投影、并、差、笛卡尔积是5种基本操作，其他操作可用基本操作来定义和导出。</p><h3 id="关系数据语言的分类">2.2.2 关系数据语言的分类</h3><p>早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数（relationalgebra）和关系演算（relation calculus）。</p><ul><li>关系代数用对关系的运算来表达查询要求</li><li>关系演算则用谓词来表达查询要求<ul><li>关系演算按谓词变元的基本对象是元组还是域变量分为元组关系演算和域关系演算</li></ul></li></ul><p>一个关系数据语言能够表示关系代数可以表示的查询，称为具有完备的表达能力，简称关系完备性。已经证明关系代数、元组关系演算和域关系演算在表达能力上是等价的。</p><p>结构化查询语言（Structured QueryLanguage，SQL）介于关系代数和关系演算之间。</p><p>SQL兼具查询、数据定义、数据控制功能，是集查询、数据定义语言、数据操纵语言和数据控制语言为一体的关系数据语言。</p><ul><li>SQL是一种高度非过程化的语言。</li></ul><h2 id="关系的完整性">2.3 关系的完整性</h2><p>关系模型中有三类完整性约束：实体完整性（entityintegrity）、参照完整性（referentialintegrity）和用户定义的完整性（user-defined integrity）</p><h3 id="实体完整性">实体完整性</h3><p>实体完整性规则：若属性A（一个或一组属性）是基本关系R的主属性，则A不能取空值</p><h3 id="参照完整性">参照完整性</h3><p>设F是基本关系R的一个或一组属性，但不是关系R的码，<spanclass="math inline">\(K_S\)</span>是基本关系S的主码。如果F与<spanclass="math inline">\(K_s\)</span>对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。</p><p>参照完整性规则：若属性F是基本关系R的外码，它与基本关系S的主码<spanclass="math inline">\(K_s\)</span>相对应，则对于R中每个原则在F上的值必须或者取空值，或者等于S中某个元组的主码值。</p><h3 id="用户定义的完整性">用户定义的完整性</h3><p>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</p><h2 id="关系代数">2.4 关系代数</h2><p>关系代数用对关系的运算来表达查询。</p><ul><li>关系代数的运算又分为传统的集合运算和专门的关系运算两类<ul><li>集合运算符：并<span class="math inline">\(\cup\)</span>、差<spanclass="math inline">\(-\)</span>、交<spanclass="math inline">\(\cap\)</span>、笛卡尔积<spanclass="math inline">\(\times\)</span></li><li>专门关系运算符：选择<spanclass="math inline">\(\sigma\)</span>、投影<spanclass="math inline">\(\prod\)</span>、连接<spanclass="math inline">\(\Join\)</span>、除<spanclass="math inline">\(\div\)</span></li></ul></li></ul><h3 id="传统的集合运算">2.4.1 传统的集合运算</h3><p>传统的集合运算是二目运算，包括并、差、交、笛卡尔积4种运算</p><p>（1）并（union）：<span class="math inline">\(R\cup S=\{t|t\in R \veet\in S\}\)</span></p><p>（2）差（except）：<span class="math inline">\(R-S=\{t|t\in R\wedget\notin S\}\)</span></p><p>（3）交（intersection）：<span class="math inline">\(R\cap S=\{t|t\inR\wedge t\in S\}\)</span></p><p>（4）笛卡尔积（cartesian product）：<spanclass="math inline">\(R\times S=\{t_rt_s|t_r\in R\wedge t_s\inS\}\)</span></p><h3 id="专门的关系运算">2.4.2 专门的关系运算</h3><p>专门的关系运算包括选择、投影、连接、除运算等。</p><p>引入几个记号：</p><ul><li><p>设关系模式为 <spanclass="math inline">\(R(A_1,A_2,...,A_n)\)</span>，它的一个关系设为<spanclass="math inline">\(R\)</span>。<span class="math inline">\(t\inR\)</span> 表示 <span class="math inline">\(t\)</span> 是 <spanclass="math inline">\(R\)</span> 的一个元组。<spanclass="math inline">\(t[A_i]\)</span> 则表示元组 <spanclass="math inline">\(t\)</span> 中相应于属性 <spanclass="math inline">\(A_i\)</span> 的一个分量。</p></li><li><p>若 <spanclass="math inline">\(A=\{A_{i1},A_{i2},...,A_{ik}\}\)</span>，其中<span class="math inline">\(A_{i1},A_{i2},...,A_{ik}\)</span> 是 <spanclass="math inline">\(A_1,A_2,...,A_n\)</span> 中的一部分，称<spanclass="math inline">\(A\)</span>为属性列或属性组。<spanclass="math inline">\(t[A]=(t[A_{i1}],t[A_{i2}],...,t[A_{in}])\)</span>为元组<spanclass="math inline">\(t\)</span>在属性列<spanclass="math inline">\(A\)</span>上诸分量的集合，<spanclass="math inline">\(\overline{A}\)</span>则表示<spanclass="math inline">\(\{A_1,A_2,...,A_n\}\)</span>中去掉<spanclass="math inline">\(\{A_{i1},A_{i2},...,A_{in}\}\)</span>后剩余的属性组。</p></li><li><p><span class="math inline">\(R\)</span>为<spanclass="math inline">\(n\)</span>目关系，<spanclass="math inline">\(S\)</span>为m目关系。<spanclass="math inline">\(t_r\in R\)</span>，<spanclass="math inline">\(t_s\in S\)</span>，<spanclass="math inline">\(t_rt_s\)</span>称为元组的连接或串接。它是一个<spanclass="math inline">\(n+m\)</span>列的新元组，前<spanclass="math inline">\(n\)</span>个分量为<spanclass="math inline">\(R\)</span>中的一个<spanclass="math inline">\(n\)</span>元组，后<spanclass="math inline">\(m\)</span>个分量为<spanclass="math inline">\(S\)</span>中的一个<spanclass="math inline">\(m\)</span>元组。</p></li><li><p>给定一个关系<span class="math inline">\(R(X,Y)\)</span>，<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Z\)</span>为属性组。当<spanclass="math inline">\(t[X]=x\)</span>时，<spanclass="math inline">\(x\)</span>在<spanclass="math inline">\(R\)</span>中的象集定义为</p><p><span class="math inline">\(Z_=\{t[Z]|t\in R,t[X]=x\}\)</span></p><p>它表示<span class="math inline">\(R\)</span>在属性组<spanclass="math inline">\(X\)</span>上值为<spanclass="math inline">\(x\)</span>的诸元组在<spanclass="math inline">\(Z\)</span>上分量的集合。</p></li></ul><h4 id="专门关系运算的定义">专门关系运算的定义</h4><h5 id="选择selection">选择（selection）</h5><p>选择又称为限制（restriction），是在关系<spanclass="math inline">\(R\)</span>中选择满足给定条件的诸元组，记作<spanclass="math inline">\(\sigma _F(R)=\{t|t\in R\wedgeF(t)=true\}\)</span></p><p>其中<spanclass="math inline">\(F\)</span>表示选择条件，它是一个逻辑表达式，取逻辑值真或假。</p><h5 id="投影projection">投影（projection）</h5><p>关系 <span class="math inline">\(R\)</span> 上的投影是从 <spanclass="math inline">\(R\)</span>中选择出若干属性列组成新的关系，记作</p><p><span class="math inline">\(\prod _{A}(R)=\{t[A]|t\inR\}\)</span></p><p>其中 <span class="math inline">\(A\)</span> 为 <spanclass="math inline">\(R\)</span> 的属性列。</p><h5 id="连接join">连接（join）</h5><p>连接也称为<spanclass="math inline">\(\theta\)</span>连接。它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作</p><p><span class="math inline">\(R\Join _{A\theta B}S=\{t_rt_s|t_r\in R\ort_s\in S\or t_r[A]\theta t_s[B] \}\)</span></p><p>其中，<span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 分别为 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 上列数相等且可比的属性组，<spanclass="math inline">\(\theta\)</span>是比较运算符。连接运算从 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 的笛卡尔积 <spanclass="math inline">\(R\times S\)</span> 中选取 <spanclass="math inline">\(R\)</span> 关系在 <spanclass="math inline">\(A\)</span> 属性组上的值与 <spanclass="math inline">\(S\)</span> 关系在 <spanclass="math inline">\(B\)</span> 属性组上的值满足比较关系 <spanclass="math inline">\(\theta\)</span>的元组。</p><ul><li><p><span class="math inline">\(\theta\)</span> 为 =的连接运算称为等值连接，它是从关系 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 的笛卡尔积中选取 <spanclass="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span>属性值相等的那些元组。</p></li><li><p>自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中去除重复属性列</p><ul><li>一般的连接操作是从行的角度进行运算，自然连接还需要去除重复列，因而是同时从行和列的角度进行运算</li><li>自然连接中被舍弃的元组称为悬浮元组（danglingtuple），把悬浮元组也保存在结果关系中，而在其他属性值上写<spanclass="math inline">\(null\)</span>，这种连接称为外连接；只保留左关系的悬浮元组称为左外连接，反之为右外连接</li></ul></li></ul><h5 id="除运算division">除运算（division）</h5><p>设关系 <span class="math inline">\(R\)</span> 除以关系 <spanclass="math inline">\(S\)</span> 的结果为关系 <spanclass="math inline">\(T\)</span>，则 <spanclass="math inline">\(T\)</span> 包含所有在 <spanclass="math inline">\(R\)</span> 但不在 <spanclass="math inline">\(S\)</span> 中的属性及其值，且 <spanclass="math inline">\(T\)</span> 的元组与 <spanclass="math inline">\(S\)</span> 的元组的所有组合都在 <spanclass="math inline">\(R\)</span> 中。</p><p>除法的象集定义：</p><p>给定关系 <span class="math inline">\(R(X,Y)\)</span> 和 <spanclass="math inline">\(S(Y,Z)\)</span>，其中<spanclass="math inline">\(X\)</span>、<spanclass="math inline">\(Y\)</span>、<spanclass="math inline">\(Z\)</span>为属性组。<spanclass="math inline">\(R\)</span> 中的 <spanclass="math inline">\(Y\)</span> 与 <spanclass="math inline">\(S\)</span> 中的 <spanclass="math inline">\(Y\)</span>可以有不同的属性名，但必须出自相同的域集。</p><p><span class="math inline">\(R\)</span> 与 <spanclass="math inline">\(S\)</span> 的除运算得到一个新的关系 <spanclass="math inline">\(P(X)\)</span>，<spanclass="math inline">\(P\)</span> 是 <spanclass="math inline">\(R\)</span> 中满足下列条件的元组在 <spanclass="math inline">\(X\)</span> 属性列上的投影：元组在 <spanclass="math inline">\(X\)</span> 上分量值 <spanclass="math inline">\(x\)</span> 的象集 <spanclass="math inline">\(Y_x\)</span> 包含 <spanclass="math inline">\(S\)</span> 在 <spanclass="math inline">\(Y\)</span> 上投影的集合。记作</p><p><span class="math inline">\(R\div S=\{t_r[X] |t_r\in R \and \prod_Y(S)\subseteq Y_X \}\)</span></p><p>除操作也是同时从行和列的角度进行运算。</p><p>关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。</p><h2 id="关系演算">2.5 关系演算</h2><p>不考，暂略</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第一章_绪论</title>
    <link href="/2023/06/01/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/06/01/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第一章-绪论">第一章 绪论</h1><h2 id="数据库系统概述">1.1 数据库系统概述</h2><h3 id="数据库的4个基本概念">1.1.1 数据库的4个基本概念</h3><p>数据、数据库、数据库管理系统、数据库系统</p><h4 id="数据data">数据（Data）</h4><p>数据是数据库中存储的基本对象，是描述事物的符号记录。</p><p>数据有多种表现形式，可以经过数字化后存入计算机。</p><p>数据的含义称为数据的语义，数据与其语义是不可分的。</p><h4 id="数据库databasedb">数据库（Database，DB）</h4><p>数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，可为各种用户共享。</p><p>数据库数据具有永久存储、有组织和可共享三个基本特点。</p><h4id="数据库管理系统database-management-systemdbms">数据库管理系统（DatabaseManagement System，DBMS）</h4><p>数据库管理系统是计算机的基础软件，主要功能包含以下几个方面：</p><h5 id="数据定义">(1) 数据定义</h5><p>提供数据定义语言（Data DefinitionLanguage，DDL），用以对数据库中的数据对象的组成与结构进行定义</p><h5 id="数据组织存储和管理">(2) 数据组织、存储和管理</h5><h5 id="数据操纵">(3) 数据操纵</h5><p>提供数据操纵语言（Data ManipulationLanguage，DML），用以操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。</p><h5 id="数据库的事务管理和运行管理">(4) 数据库的事务管理和运行管理</h5><h5 id="数据库的建立和维护">(5) 数据库的建立和维护</h5><h5 id="其他功能">(6) 其他功能</h5><p>包括数据库管理系统与网络中其他软件系统的通信功能，异构数据库之间的互访和互操作功能等。</p><h4 id="数据库系统database-systemdbs">数据库系统（DatabaseSystem，DBS）</h4><p>数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DatabaseAdministrator，DBA）组成的存储、管理、处理和维护数据的系统。</p><h3 id="数据库系统的特点">1.1.2 数据库系统的特点</h3><h4 id="数据结构化">数据结构化</h4><p>数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。</p><p>整体结构化是指数据库中的数据不再仅仅针对一个应用，而是面向整个组织或企业；不仅数据内部是结构化的，而且整体是结构化的，数据之间是具有联系的。</p><h4id="数据的共享性高冗余度低且易扩充">数据的共享性高、冗余度低且易扩充</h4><p>数据共享可以大大减少数据冗余，节约存储空间，数据共享还能避免数据之间的不相容性与不一致性。</p><h4 id="数据独立性高">数据独立性高</h4><p>数据库的数据独立性包括数据的物理独立性和逻辑独立性。</p><ul><li><p>物理独立性是指用户的应用程序与数据库中数据的物理存储是相互独立的。</p></li><li><p>逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</p></li></ul><h4id="数据由数据库管理系统统一管理和控制">数据由数据库管理系统统一管理和控制</h4><p>为了保证数据库的并发共享与数据库中数据的正确与一致，数据库管理系统提供以下的数据控制功能：</p><h5 id="数据的安全性保护">(1) 数据的安全性保护</h5><p>保护数据以防止不合法使用造成的数据泄密和破坏。</p><h5 id="数据的完整性检查">(2) 数据的完整性检查</h5><p>数据的完整性指数据的正确性、有效性和相容性。</p><h5 id="并发控制">(3) 并发控制</h5><h5 id="数据库恢复">(4) 数据库恢复</h5><p>数据库管理系统必须具有将数据库从错误状态恢复到某一已知的正确状态的功能。</p><p>数据库是长期存储在计算机内有组织、大量、共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。</p><p>数据库系统的出现使信息系统从以加工数据的程序为中心转为围绕共享的数据库为中心的新阶段。</p><h2 id="数据模型">1.2 数据模型</h2><p>数据模型是对现实世界数据特征的抽象，是数据库系统的核心和基础。</p><p>数据模型分为两类，第一类为概念模型，第二类是逻辑模型和物理模型。</p><ul><li><p>概念模型也称信息模型，它按用户的观点来对数据和信息建模，主要用于数据库设计。</p></li><li><p>逻辑模型主要包括层次模型、网状模型、关系模型、面向对象数据模型和对象关系数据模型、半结构化数据模型等，它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。</p></li><li><p>物理模型是对数据最底层的抽象，描述数据在系统内部的表示和存取方式。物理模型的具体实现是数据库管理系统的任务，数据库设计人员要了解和选择物理模型，最终用户则不需考虑物理级细节。</p></li></ul><p>先将现实世界抽象为信息世界（概念模型），再将信息世界转换为机器世界。</p><h3 id="概念模型">1.2.1 概念模型</h3><p>概念模型是对现实世界的抽象，用于信息世界的建模。</p><h4 id="信息世界的基本概念">信息世界的基本概念</h4><ol type="1"><li>实体（entity）</li></ol><p>客观存在并可相互区别的事物称为实体。</p><ol start="2" type="1"><li>属性（attribute）</li></ol><p>实体所具有的某一特性。</p><ol start="3" type="1"><li>码（key）</li></ol><p>唯一标识实体的属性集称为码</p><ol start="4" type="1"><li>实体型（entity type）</li></ol><p>用实体及其属性名集合来抽象和刻画同类实体，称为实体型。</p><ol start="5" type="1"><li>实体集（entity set）</li></ol><p>同一类型实体的集合称为实体集。</p><ol start="6" type="1"><li>联系（relationship）</li></ol><p>实体内部的联系通常指组成实体的各属性之间的联系，实体之间的联系通常指不同实体集之间的联系。</p><p>实体之间的联系有一对一、一对多、多对多等多种类型。</p><h4id="概念模型的一种表示方法实体-联系方法entity-relationship-approach">概念模型的一种表示方法：实体-联系方法（Entity-Relationshipapproach）</h4><p>该方法用实体-联系图（E-Rdiagram）来描述现实世界的概念模型，E-R方法也称E-R模型。</p><h3 id="数据模型的组成要素">1.2.2 数据模型的组成要素</h3><p>数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成。</p><ol type="1"><li>数据结构</li></ol><p>数据结构描述数据库的组成对象以及对象之间的联系。</p><ol start="2" type="1"><li>数据操作</li></ol><p>数据操作是指对数据库中各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则。</p><ol start="3" type="1"><li>数据的完整性约束条件</li></ol><p>数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。</p><h3 id="常用的数据模型">1.2.3 常用的数据模型</h3><ul><li>层次模型（hierarchical model）</li><li>网状模型（network model）</li><li>关系模型（relational model）</li><li>面向对象数据模型（object oriented data model）</li><li>对象关系数据模型（object relational data model）</li><li>半结构化数据模型（semistructure data model）</li></ul><p>其中层次模型和网状模型称为格式化模型。</p><h2 id="数据库系统的结构">1.3 数据库系统的结构</h2><h3 id="数据库系统模式的概念">1.3.1 数据库系统模式的概念</h3><p>数据模型中，型（type）是对某一类数据的结构和属性的说明，值（value）是型的一个具体赋值。</p><p>模式（schema）是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体值。模式的一个具体值称为模式的一个实例。</p><p>模式是相对稳定的，实例时相对变动的。</p><h3 id="数据库系统的三级模式结构">1.3.2 数据库系统的三级模式结构</h3><p>数据库系统由外模式、模式和内模式三级构成。</p><ol type="1"><li>模式</li></ol><p>模式也称逻辑模式，时数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p><ol start="2" type="1"><li>外模式</li></ol><p>外模式也称子模式（subschema）或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用相关的数据的逻辑表示。</p><p>外模式通常是模式的子集。</p><ol start="3" type="1"><li>内模式</li></ol><p>内模式也称存储模式（storageschema），是数据物理结构和存储方式的描述，是数据库内部数据的组织方式。</p><p>一个数据库只有一个内模式</p><h3 id="数据库的二级映像功能与数据独立性">1.3.3数据库的二级映像功能与数据独立性</h3><ol type="1"><li>外模式/模式映像</li></ol><p>模式改变时，数据库管理员对各个外模式/模式映像作相应改变，使外模式保持不变，保证数据逻辑独立性。</p><ol start="2" type="1"><li>模式/内模式映像</li></ol><p>数据库存储结构改变时，数据库管理员对模式/内模式映像作相应改变，使模式保持不变，保证数据物理独立性。</p><p>数据与程序之间的独立性使得数据的定义和描述从应用程序中分离。数据的存取由数据库管理系统管理，简化了应用程序的编制，减少了应用程序的维护与修改。</p><h2 id="数据库系统的组成">1.4 数据库系统的组成</h2><ol type="1"><li><p>硬件平台及数据库</p><ul><li>足够大的内存存放操作系统、数据库管理系统的核心模块、数据缓冲区和应用程序</li><li>足够大的磁盘存放数据库，足够大的磁带作数据备份</li><li>系统有较高的通道能力以提高数据传送率</li></ul></li><li><p>软件</p><ul><li>数据库管理系统</li><li>支持数据库管理系统运行的操作系统</li><li>具有与数据库接口的高级语言及其编译系统，便于开发应用程序</li><li>以数据库管理系统为核心的应用开发工具</li></ul></li><li><p>人员</p><ul><li><p>数据库管理员</p></li><li><p>系统分析员与数据库设计人员</p></li><li><p>应用程序员</p></li><li><p>用户</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第六章_并发程序设计</title>
    <link href="/2023/05/06/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/06/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>长风破浪会有时，直挂云帆济沧海！</p><span id="more"></span><h1 id="第六章-并发程序设计">第六章 并发程序设计</h1><h2 id="并发进程">6.1 并发进程</h2><h3 id="顺序程序设计">6.1.1 顺序程序设计</h3><p>进程在处理器上的顺序执行是严格按序的，一个操作结束后，才能开始后续操作。</p><p>顺序程序设计：把一个程序设计成顺序执行的程序模块。</p><ul><li>顺序不仅在一个程序模块内部，也在多个程序模块之间。</li></ul><p>顺序程序设计的特点：</p><ul><li>程序执行的顺序性</li><li>程序环境的封闭性</li><li>执行结果的确定性</li><li>计算过程的可再现性</li></ul><h3 id="进程的并发性">6.1.2 进程的并发性</h3><p>进程的并发性（Concurrency）是指一组进程的执行在时间上是重叠的。</p><ul><li>宏观上，并发性反映一个时间段中几个进程都在同一处理器上，处于运行还未运行结束状态</li><li>微观上，任一时刻仅有一个进程在处理器上运行</li></ul><h4 id="并发程序设计">并发程序设计</h4><p>使一个程序分成若干个可同时执行的程序模块的方法称为并发程序设计（concurrentprogramming），每个程序模块和它执行时所处理的数据就组成一个进程。</p><p>并发进程的分类：无关的、交互的</p><ul><li>无关的并发进程：一个进程的执行与其他并发进程的进展无关<ul><li>并发进程的无关性是进程的执行与时间无关的一个充分条件，又称为Bernstein条件</li></ul></li><li>交互的并发进程：一个进程的执行可能影响其他并发进程的结果</li></ul><h4 id="bernstein条件">Bernstein条件</h4><ul><li><p>程序<spanclass="math inline">\(p_i\)</span>在执行期间引用的变量集，记为<spanclass="math inline">\(R(p_i)=\{a_{i1},a_{i2},...,a_{in}\}\)</span>，</p></li><li><p>程序<spanclass="math inline">\(p_i\)</span>在执行期间改变的变量集，记为<spanclass="math inline">\(W(p_i)=\{b_{i1},b_{i2},...,b_{im}\}\)</span></p></li><li><p>若两个进程的程序<span class="math inline">\(p_1\)</span>和<spanclass="math inline">\(p_2\)</span>能满足Beinstein条件，即满足</p><p><span class="math inline">\((R(p_1)\cap W(p_2))\cup (R(p_2)\capW(p_1))\cup (W(p_1)\cap W(p_2))=\varnothing\)</span>，</p><p>则这两个并发进程的执行与时间无关</p></li></ul><p>与时间有关的错误：对于一组交互的并发进程，执行的相对速度无法相互控制，各种与时间有关的错误就有可能出现。</p><ul><li>与时间有关错误的表现形式：结果不唯一、永远等待</li></ul><h3 id="进程的交互竞争和协作">6.1.3 进程的交互：竞争和协作</h3><p>进程之间存在两种基本关系：竞争关系和协作关系</p><ul><li>竞争关系：一个进程的执行可能影响到同其竞争资源的其他进程，如果两个进程要访问同一资源，那么一个进程通过操作系统分配得到该资源，另一个将不得不等待</li><li>协作关系：某些进程为了完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的信号之前应阻塞自己，直到其他合作进程发来协调信号后方被唤醒并继续执行。</li></ul><h4 id="资源竞争的两个控制问题">资源竞争的两个控制问题</h4><ul><li>死锁：一组进程如果都获得了部分的资源，还想要得到其他进程所占有的资源，最终所有的进程都将陷入死锁</li><li>饥饿：一个进程由于其他进程总是优先于它而被无限期拖延</li><li>操作系统需要保证诸进程能互斥地访问临界资源，既要解决饥饿问题，又要解决死锁问题</li></ul><h4 id="进程的互斥与同步">进程的互斥与同步</h4><p>进程的互斥（mutual exclusion）是解决进程间竞争关系的手段。</p><ul><li>若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源</li></ul><p>进程的同步（Synchronization）是解决进程间协作关系的手段。</p><ul><li>两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的信号，当一个进程没有得到来自于另一个进程的信号则需等待。</li></ul><p>进程的互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，是对进程使用资源次序上的一种协调。</p><h2 id="临界区管理">6.2 临界区管理</h2><h3 id="互斥与临界区">6.2.1 互斥与临界区</h3><ul><li><p>并发进程中与共享变量有关的程序段称为临界区（criticalsection）</p><p>共享变量代表的资源称为临界资源</p></li><li><p>与同一变量有关的临界区分散在各进程的程序段中，而各进程的执行速度不可预见</p></li><li><p>如果保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问互斥，就不会造成与时间有关的错误。</p></li></ul><p>临界区调度原则（Dijkstra，1965）</p><ul><li>一次至多一个进程能够进入临界区内执行</li><li>如果已有进程在临界区，其他试图进入的进程应等待</li><li>进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入</li></ul><h3 id="临界区管理-1">6.2.2 临界区管理</h3><p>临界区管理的简单方法（忙式等待/反复测试）：</p><ul><li>Peterson算法</li><li>关中断</li><li>对换指令</li><li>测试并建立指令</li></ul><p>存在的问题：</p><ul><li>对不能进入临界区的进程，采用忙式等待测试法，浪费CPU时间</li><li>将测试能否加入临界区的责任推给各个竞争的进程会削弱系统的可靠性，加重编程负担</li></ul><p>通用的解决方案：信号量与PV操作</p><h4 id="peterson算法">Peterson算法</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">bool</span> inside[<span class="hljs-number">2</span>];<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">enum</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125; turn;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">P0</span><span class="hljs-params">()</span></span>&#123;<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>turn = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(inside[<span class="hljs-number">1</span>]&amp;&amp;turn==<span class="hljs-number">1</span>);<br>&#123;临界区&#125;;<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P1</span><span class="hljs-params">()</span></span>&#123;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(inside[<span class="hljs-number">0</span>]&amp;&amp;turn==<span class="hljs-number">0</span>)<br>&#123;临界区&#125;;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 1:1交替</span><br><span class="hljs-keyword">enum</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125; turn;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">P0</span><span class="hljs-params">()</span></span>&#123;<br>turn = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(turn==<span class="hljs-number">1</span>);<br>&#123;临界区&#125;;<br>turn = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P1</span><span class="hljs-params">()</span></span>&#123;<br>turn = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(turn==<span class="hljs-number">0</span>);<br>&#123;临界区&#125;;<br>turn = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关中断">关中断</h4><ul><li>实现互斥的最简单方法</li></ul><h4 id="测试并建立指令">测试并建立指令</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//TS指令实现进程互斥</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TS</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(x)&#123;<br>    x = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> s = <span class="hljs-literal">true</span>;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">Pi</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">TS</span>(s)); <span class="hljs-comment">//上锁</span><br>  &#123;临界区&#125;;<br>  s = <span class="hljs-literal">true</span>;      <span class="hljs-comment">//开锁</span><br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h4 id="对换指令">对换指令</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//对换指令实现进程互斥</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SWAP</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> &amp;a, <span class="hljs-built_in">bool</span> &amp;b</span>)</span>&#123;<br><span class="hljs-built_in">bool</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-built_in">bool</span> <span class="hljs-keyword">lock</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">Process <span class="hljs-title">Pi</span>()</span>&#123;<br><span class="hljs-built_in">bool</span> key = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">do</span>&#123;<br>SWAP(key, <span class="hljs-keyword">lock</span>);<br>&#125;<span class="hljs-keyword">while</span>(key);<span class="hljs-comment">//上锁</span><br>&#123;临界区&#125;;<br>SWAP&#123;key, <span class="hljs-keyword">lock</span>&#125;;<span class="hljs-comment">//开锁</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号量与pv操作">6.3 信号量与PV操作</h2><h3id="信号量与pv操作的数据结构与原语操作">信号量与PV操作的数据结构与原语操作</h3><p>设s为一个记录型数据结构，一个分量为整型量value，另一个为信号量队列queue，P和V操作原语的定义：</p><ul><li>P(s)：将信号量s减去1，若结果小于0，则调用P(s)的进程被设置成等待信号量s的状态</li><li>V(s)：将信号量s加1，若结果不大于0，则释放一个等待信号量s的进程，其转为就绪态</li></ul><p>对于信号量，只允许使用P和V原语操作访问，不能直接对信号量的整型值和队列作操作</p><p>原语：CPU处于内核态，在关中断环境下执行的一段指令序列</p><ul><li>原子性：不被中断，确保安全且完整执行这段指令序列</li></ul><h4 id="几个经典问题">几个经典问题</h4><h5 id="哲学家就餐问题互斥">哲学家就餐问题（互斥）</h5><p>有五个哲学家围坐在一圆桌旁，桌中央有一盘通心面，每人面前有一只空盘子，每两人之间放一把叉子。每个哲学家思考、饥饿、然后吃通心面。为了吃面，每个哲学家必须获得两把叉子，且每人只能直接从自己左边或右边去取叉子。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">semaphore fork<span class="hljs-literal">[<span class="hljs-number">5</span>]</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>fork<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=<span class="hljs-number">1</span>;<br>semaphore room=<span class="hljs-number">4</span>; <span class="hljs-comment">//增加一个侍者，设想有两个房间1号房间是会议室，2号房间是餐厅</span><br>cobegin<br>process philosopher<span class="hljs-constructor">_i()</span>&#123; <span class="hljs-comment">//i=0,1,2,3,4</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>think<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">room</span>)</span>; <span class="hljs-comment">//控制最多允许4位哲学家进入2号房间餐厅取叉子</span><br><span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>; <span class="hljs-comment">//偶数哲学家先右手</span><br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span> % <span class="hljs-number">5</span> ]); <span class="hljs-comment">//后左手</span><br>eat<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>;<br>V (fork<span class="hljs-literal">[(<span class="hljs-identifier">i</span>+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span> % <span class="hljs-number">5</span> ]); <span class="hljs-comment">//奇数哲学家，先左手</span><br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>; <span class="hljs-comment">//后右手</span><br>eat<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span>%<span class="hljs-number">5</span>]);<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>;<br>&#125;<br><span class="hljs-constructor">V(<span class="hljs-params">room</span>)</span>;<br>&#125;<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h5 id="生产者与消费者问题同步">生产者与消费者问题（同步）</h5><p>有n个生产者和m个消费者，连接在一个有k个单位缓冲 区的有界缓冲上。</p><p>其中，生产者进程<spanclass="math inline">\(Producer_i\)</span>和消费者进程<spanclass="math inline">\(Consumer_j\)</span>都是并发进程，只要缓冲区未满，生产者<spanclass="math inline">\(Producer_i\)</span>生产的产品就可投入缓冲区；只要缓冲区不空，消费者进程<spanclass="math inline">\(Consumer_j\)</span>就可从缓冲区取走并消耗产品。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">产品 Buffer<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>semaphore put = k, get = <span class="hljs-number">0</span>;<span class="hljs-comment">//可以put或get的缓冲区数</span><br><span class="hljs-built_in">int</span> putPos = getPos = <span class="hljs-number">0</span>;<span class="hljs-comment">//put或get的位置</span><br>semaphore p = g = <span class="hljs-number">1</span>;<span class="hljs-comment">//互斥使用put或get的位置</span><br><br>process <span class="hljs-constructor">Producer_i()</span>&#123;<br>&#123;生产产品&#125;;<br><span class="hljs-constructor">P(<span class="hljs-params">put</span>)</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">p</span>)</span>;<br>Buffer<span class="hljs-literal">[<span class="hljs-identifier">putPos</span>]</span> = 产品;<br>putPos = (putPos + <span class="hljs-number">1</span>) % k;<br><span class="hljs-constructor">V(<span class="hljs-params">p</span>)</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">get</span>)</span>;<br>&#125;<br><br>process <span class="hljs-constructor">Consumer_i()</span>&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">get</span>)</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">g</span>)</span>;<br>产品 = Buffer<span class="hljs-literal">[<span class="hljs-identifier">getPos</span>]</span>;<br>getPos = (getPos + <span class="hljs-number">1</span>) % k;<br><span class="hljs-constructor">V(<span class="hljs-params">g</span>)</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">put</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管程">6.4 管程</h2><h3 id="管程和条件变量">6.4.1 管程和条件变量</h3><p>管程的引入：</p><ul><li>把分散在各进程中的临界区集中管理</li><li>防止进程的违法同步操作</li><li>便于用高级语言来编写程序</li></ul><h4 id="管程的定义">管程的定义</h4><p>由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。</p><p>管程的属性：共享性、安全性、互斥性</p><h4 id="管程的形式">管程的形式</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">type 管程名<span class="hljs-operator">=</span>monitor &#123;<br>局部变量说明<span class="hljs-comment">;</span><br>  条件变量说明<span class="hljs-comment">;</span><br>  初始化语句<span class="hljs-comment">;</span><br>define 管程内定义的，管程外可调用的过程或函数名列表<span class="hljs-comment">;</span><br>use 管程外定义的，管程内将调用的过程或函数名列表<span class="hljs-comment">;</span><br>过程名/函数名(形式参数表) &#123;<br>&lt;过程/函数体&gt;<span class="hljs-comment">;</span><br>&#125;<br>...<br>过程名/函数名(形式参数表) &#123;<br>&lt;过程/函数体&gt;<span class="hljs-comment">;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管程的条件变量">管程的条件变量</h4><p>只有在管程中才能被访问，它对管程内所有过程是全局的，只能通过两个原语操作来控制</p><ul><li><p>wait()：阻塞调用进程并释放管程，直到另一个进程在该条件变量上执行signal()</p></li><li><p>signal()：释放由于对条件变量执行wait()而被阻塞的其他进程，若无，信号不被保存</p></li><li><p>使用signal释放等待进程时，可能出现两个进程同时停留在管程内</p><ul><li><p>执行signal的进程等待，直到被释放进程退出管程或等待另一个条件变量</p></li><li><p>被释放进程等待，直到执行signal的进程退出管程或等待另一个条件</p></li><li><p>Hoare采用前一种方法。</p></li></ul></li></ul><h3 id="管程的实现">6.4.2 管程的实现</h3><p>Hoare管程</p><p>Hoare使用P和V操作原语来实现对管程中过程的互斥调用，以及实现对共享资源互斥使用的管理。</p><ul><li>wait和signal操作可被设计成可以中断的进程</li></ul><h4 id="hoare管程数据结构">Hoare管程数据结构</h4><ol type="1"><li>mutex</li></ol><ul><li>对于每个管程，使用用于管程中过程互斥调用的信号量mutex（初值为1）</li><li>进程调用管程中的任何过程时，应执行P(mutex)，进程退出管程时，需要判断是否有进程在next信号量等待，如果有（即next_count&gt;0），则通过V(next)唤醒一个发出signal的进程，否则应执行V(mutex)开放管程，以便让其他调用者进入</li><li>为了使进程在等待资源期间，其他进程能进入管程，在wait操作中也必须执行V(mutex)</li></ul><ol start="2" type="1"><li>next和next-count</li></ol><ul><li><p>对每个管程，引入信号量next（初值为0），发出signal操作的进程应该用P(next)阻塞自己，直到被释放进程退出管程或产生其他等待条件</p></li><li><p>next-count（初值为0），记录next上等待的进程个数</p></li></ul><ol start="3" type="1"><li>x-sem和x-count</li></ol><ul><li>x-sem（初值为0），申请资源无法满足时，执行P(x-sem)阻塞。由于释放资源时，需知道是否有其他进程在等待资源，用计数器x-count（初值为0）记录等待资源的进程数</li><li>执行signal操作时，应让等待资源的诸进程中的某个进程立即恢复运行，而不让其他进程抢先进入管程，这使用V(x-sem)实现</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">typedef <span class="hljs-keyword">struct</span> Monitor&#123;<br>semaphore mutex;<br>semaphore next;<br><span class="hljs-built_in">int</span> next_count;<br>&#125;<br>mutex = <span class="hljs-number">1</span>;<br>next = <span class="hljs-number">0</span>;<br>next_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//enter()和leave()操作</span><br>void enter(Monitor &amp;m)&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<br>&#125;<br>void leave<span class="hljs-literal">()</span>&#123;Monitor &amp;m&#125;&#123;<br><span class="hljs-keyword">if</span>(m.next_count&gt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">//wait()</span><br>void wait(semaphore &amp;x_sem, <span class="hljs-built_in">int</span> x_count, Monitor &amp;m)&#123;<br>x_count++;<span class="hljs-comment">//等待资源进程个数加1</span><br><span class="hljs-keyword">if</span>(m.next_count&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//判断是否有发出过signal的进程</span><br><span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<span class="hljs-comment">//释放</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<span class="hljs-comment">//开放管程</span><br><span class="hljs-constructor">P(<span class="hljs-params">x_sem</span>)</span>;<span class="hljs-comment">//等待资源进程阻塞自己</span><br>x_count--;<span class="hljs-comment">//等待资源进程个数减1</span><br>&#125;<br><br><span class="hljs-comment">//signal()</span><br>void signal(semaphore &amp;x_sem, <span class="hljs-built_in">int</span> x_count, Monitor &amp;m)&#123;<br><span class="hljs-keyword">if</span>(x_count&gt;<span class="hljs-number">0</span>)&#123;<br>m.next_count++;<span class="hljs-comment">//发出signal进程数加1</span><br><span class="hljs-constructor">V(<span class="hljs-params">x_sem</span>)</span>;<span class="hljs-comment">//释放一个等待资源的进程</span><br><span class="hljs-constructor">P(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<span class="hljs-comment">//发出signal的进程阻塞自己</span><br>m.next_count--;<span class="hljs-comment">//发出signal的进程个数减1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管程求解进程的同步和互斥问题">6.4.3管程求解进程的同步和互斥问题</h3><p>互斥问题：读者写者问题、哲学家就餐问题</p><p>同步问题：生产者与消费者问题、苹果桔子问题</p><h4 id="哲学家就餐问题">哲学家就餐问题</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs perl">type philosophers=monitor<br>enum &#123;thinking,hungry,eating&#125; <span class="hljs-keyword">state</span>[<span class="hljs-number">5</span>];<br>semaphore self[<span class="hljs-number">5</span>]; <span class="hljs-keyword">int</span> self_count[<span class="hljs-number">5</span>]; Monitor M;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++) <span class="hljs-keyword">state</span>[i] = thinking;<br>define pickup, putdown;<br><span class="hljs-keyword">use</span> enter, leave, <span class="hljs-keyword">wait</span>, signal;<br><br>void pickup(<span class="hljs-keyword">int</span> i)&#123;<br>enter(M);<br><span class="hljs-keyword">state</span>[i] = hungry;<br>test(i);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">state</span>[i] != eating)<br><span class="hljs-keyword">wait</span>(self[i], self_count[i], M);<br>leave(M);<br>&#125;<br><br>void putdown(<span class="hljs-keyword">int</span> i)&#123; <span class="hljs-regexp">//i</span>=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,..,<span class="hljs-number">4</span><br>enter(M);<br>  <span class="hljs-keyword">state</span>[i] = thinking;<br>    test((i-<span class="hljs-number">1</span>)%5);<br>    test((i+<span class="hljs-number">1</span>)%5);<br>leave(M);<br>&#125;<br><br>void test(<span class="hljs-keyword">int</span> k)&#123; <span class="hljs-regexp">//</span>k=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,...,<span class="hljs-number">4</span> <br><span class="hljs-keyword">if</span>((<span class="hljs-keyword">state</span>[(k-<span class="hljs-number">1</span>)%5] != eating) &amp;&amp; (<span class="hljs-keyword">state</span>[k] == hungry) <br>&amp;&amp;(<span class="hljs-keyword">state</span>[(k+<span class="hljs-number">1</span>)%5] != eating)) <br><span class="hljs-keyword">state</span>[k]=eating;<br>signal(self[k], self_count[k], IM);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生产者与消费者问题">生产者与消费者问题</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> <span class="hljs-built_in">product</span>=monitor<br>item Buffer[k];//缓冲区<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">in</span>, <span class="hljs-keyword">out</span>;//存取位置<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>;<br>semaphore full, empty;<br><span class="hljs-built_in">int</span> full_count, empty_count;<br>Monitor m;<br>define append, take;<br><span class="hljs-keyword">use</span> enter, leave, <span class="hljs-keyword">wait</span>, signal;<br><br>void append(item x)&#123;<br>enter(m);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">count</span> == k) <span class="hljs-keyword">wait</span>(full, full_count, m);<br>Buffer[<span class="hljs-keyword">in</span>] = x;<br><span class="hljs-keyword">in</span> = (<span class="hljs-keyword">in</span> + <span class="hljs-number">1</span>) % k;<br><span class="hljs-built_in">count</span>++;<br>signal(empty, empty_count, m);<br>leave(m);<br>&#125;<br><br>void take(item x)&#123;<br>enter(m);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">count</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">wait</span>(empty, empty_count, m);<br>x = Buffer[<span class="hljs-keyword">out</span>];<br><span class="hljs-keyword">out</span> = (<span class="hljs-keyword">out</span> + <span class="hljs-number">1</span>) % k;<br><span class="hljs-built_in">count</span>--;<br>signal(full, full_count, m);<br>leave(m);<br>&#125;<br><br>cobegin<br>process producer_i()&#123;<br><span class="hljs-built_in">product</span>.append(x);<br>&#125;<br>process consumer_i()&#123;<br><span class="hljs-built_in">product</span>.take(x);<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h2 id="进程通信">6.5 进程通信</h2><h3 id="进程通信-1">6.5.1 进程通信</h3><p>当进程互相交互时，必须满足两个基本要求：同步和通信</p><ul><li>为实施互斥，进程间需要同步</li><li>为了协作，进程间需要交换信息</li></ul><p>消息传递提供了最典型的消息传递原语：send和receive</p><h4 id="进程直接通信">进程直接通信</h4><ul><li>对称直接寻址，发送进程和接收进程必须命名对方以便通信，原语定义如下：<ul><li><code>send(P, message)</code>发送消息到进程P</li><li><code>receive(Q, message)</code>接收来自进程Q的消息</li></ul></li><li>非对称直接寻址，只要发送者命名接收者，而接收者不需命名发送者<ul><li><code>send(P, message)</code>发送消息到进程P</li><li><code>receive(id, message)</code>接收来自任何进程的消息，id置为与其通信的进程名称</li></ul></li></ul><p>进程P向Q发送消息：</p><pre><code class=" mermaid">graph LR进程P--&gt;内核--&gt;进程Q</code></pre><p>消息格式：消息头与消息体（即消息内容），</p><ul><li>消息头包括：消息类型、目标ID、源ID、消息长度、控制信息</li></ul><h4 id="进程间接通信">进程间接通信</h4><ul><li><p>消息不是直接从发送者发送到接收者，而是发送到由临时保存这些信息的队列组成的一个共享数据结构，这些队列通常称为信箱。</p></li><li><p>一个进程给合适的信箱发送消息，另一进程从信箱中获得消息。</p></li><li><p>间接通信的通信原语定义：</p><ul><li><p><code>send(A, message)</code>把消息传送到信箱A</p></li><li><p><code>receive(A, message)</code>从信箱A接收消息</p></li></ul></li></ul><p>信箱可以分成信箱头和信箱体两部分，信箱头指出信箱容量、信件格式、存放信件位置的指针等；信箱体用来存放信件。信箱体分成若干个可容纳一封信的区。</p><ul><li>send：若指定信箱未满，将信件送入信箱中指针指示的位置，并释放该信箱中信件的等待者，否则，发送信件者被置为等待信箱状态</li><li>receive：如果指定信箱中有信，则取出一封信件，并释放等待信箱的等待者，否则，接收信件者被置成等待信箱中信件的状态</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> box = record<br><span class="hljs-built_in">int</span> size;<span class="hljs-comment">//信箱大小</span><br><span class="hljs-built_in">int</span> count;<span class="hljs-comment">//现有信件数</span><br>message<span class="hljs-literal">[<span class="hljs-identifier">n</span>]</span> letter;<br>semaphore s1, s2;<span class="hljs-comment">//等信箱和等信件信号量</span><br><br>procedure send(box B, message M)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>size) <span class="hljs-constructor">W(B.<span class="hljs-params">s1</span>)</span>;<span class="hljs-comment">//R和W时让进程入队和出队的两个过程</span><br><span class="hljs-built_in">int</span> i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count + <span class="hljs-number">1</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = M;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count = i;<br><span class="hljs-constructor">R(B.<span class="hljs-params">s2</span>)</span>;<br>&#125;<br><br>procedure receive(box B, message M)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) <span class="hljs-constructor">W(B.<span class="hljs-params">s2</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count - <span class="hljs-number">1</span>;<br>x = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count;i++)&#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span> + <span class="hljs-number">1</span>]</span>;<br>&#125;<br>&#125;<br><span class="hljs-constructor">R(B.<span class="hljs-params">s1</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消息传递的若干问题">消息传递的若干问题</h4><ul><li>信箱容量问题</li><li>多进程与信箱相连的信箱接收问题</li><li>信箱的所有权问题<ul><li>信箱为操作系统所有，是指操作系统统一设置信箱，归系统所有，供相互通信的进程共享，例：消息缓冲机制</li></ul></li><li>信件的格式问题和其他有关问题</li><li>通信进程的同步问题</li></ul><h4 id="消息缓冲通信">消息缓冲通信</h4><h3 id="高级进程通信机制">6.5.2 高级进程通信机制</h3><h2 id="死锁">6.6 死锁</h2>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第五章_文件管理</title>
    <link href="/2023/05/05/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/05/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>长风破浪会有时，直挂云帆济沧海！</p><span id="more"></span><h1 id="第五章-文件管理">第五章 文件管理</h1><h2 id="文件系统概述">5.1 文件系统概述</h2><h3 id="文件的概念">5.1.1 文件的概念</h3><p>具有符号名的，在逻辑上具有完整意义的一组相关信息项的序列</p><p>文件名是由字母、数字和其他符号组成的一个字符串，其格式和长度因系统而异</p><h4 id="文件的命名">文件的命名</h4><ul><li>一般包括文件名和扩展名<ul><li>前者用于识别文件，后者用于标识文件特性，两者用小数点隔开</li></ul></li><li>每个操作系统都有约定的扩展名，Windows系统中有：<ul><li>.com表示可执行的二进制代码文件</li><li>.exe表示可执行的浮动二进制代码文件</li><li>.lib表示库程序文件</li><li>.bat表示批命令文件</li><li>.obj表示编译或汇编生成的目标文件</li></ul></li></ul><h4 id="文件的分类">文件的分类</h4><ul><li>按用途：系统文件、库文件、用户文件</li><li>按保护级别：只读文件、读写文件、不保护文件</li><li>按信息时限：临时文件、永久文件、档案文件</li><li>按设备类型：磁盘文件、磁带文件、光盘文件、软盘文件</li><li>还可以按文件的逻辑结构或物理结构分类</li></ul><h4 id="引入文件的优点">引入文件的优点</h4><ul><li>用户使用方便</li><li>文件安全可靠</li><li>文件可备份</li><li>文件可共享</li></ul><h3 id="文件系统及其功能">5.1.2 文件系统及其功能</h3><h4 id="文件系统的概念">文件系统的概念</h4><p>操作系统中负责存取和管理信息的模块，用统一方式管理用户和系统信息的存储、检索、更新、共享和保护，为用户提供一整套方便有效的文件使用和操作方法。</p><ul><li>文件系统中的文件和用户概念中的逻辑结构以及存储器中的存储结构密切相关，因此，同一个文件需要从逻辑文件和物理文件两个侧面观察。</li></ul><h4 id="文件系统的功能">文件系统的功能</h4><p>文件系统面向用户的功能：</p><ul><li>文件的按名存取</li><li>文件的共享和保护</li><li>文件的操作和使用</li></ul><p>为了实现这些功能，操作系统必须考虑：</p><ul><li>文件目录的建立和维护</li><li>存储空间的分配和回收</li><li>数据的保密和保护</li><li>监督用户存取和修改文件的权限</li><li>实现在不同存储介质上信息的表示方式、编址方式、存储次序，以及信息检索等问题</li></ul><h4 id="文件系统的组成">文件系统的组成</h4><pre><code class=" mermaid">graph文件系统---文件的组织---组织方法---逻辑结构:\n流式文件\n记录式文件组织方法---物理结构:\n顺序文件\n连接文件\n直接文件\n索引文件文件系统---文件的存取---存取方法:\n顺序存取\n索引存取\n文件系统---文件的控制---控制系统:\n逻辑控制系统\n物理控制系统文件系统---文件的使用---文件操作:\n打开\n关闭\n读\n写\n控制</code></pre><h2 id="文件的组织">5.2 文件的组织</h2><h3 id="文件的存储">5.2.1 文件的存储</h3><h4 id="卷和块">卷和块</h4><p>文件存储介质有磁带、光盘和磁盘</p><ul><li>卷是存储介质的物理单位，对应于一盘磁带、一块软盘、一片光盘、一个硬盘分区</li><li>块是存储介质上连续信息所组成的一个区域，也称为物理记录<ul><li>块是主存储器和辅助存储器进行信息交换的物理单位，每次总是交换一块或整数块信息</li><li>决定块的大小要考虑用户使用方式、数据传输效率和存储设备类型等因素</li><li>不同类型的存储介质，块的长短常常不同；对同一类型的存储介质，块的大小一般相同，但也可以不同</li><li>外围设备由于机械动作或识别不同块的要求，两个相邻块之间必须留有间隙，间隙是块之间不记录用户代码信息的区域</li></ul></li></ul><h4 id="顺序存取存储设备的信息安排">顺序存取存储设备的信息安排</h4><p>顺序存储设备是严格依赖信息的物理位置次序进行定位和读写的存储设备。</p><ul><li>磁带是最常用的一种顺序存取存储设备，它具有存储容量大、稳定可靠、卷可装卸和易于保存等优点，广泛用于存档<ul><li>磁带的突出特点是块长的变化范围较大，块可以很小，也可以很大，原则上没有限制</li></ul></li><li>光盘也是一种顺序存取存储设备</li></ul><h4 id="直接存取存储设备的信息安排">直接存取存储设备的信息安排</h4><ul><li>磁盘是一种直接存取存储设备，又称为随机存取存储设备<ul><li>移臂与旋转两维组织，存取速度高</li><li>每个物理地址有确定的位置和唯一的地址，存取任何一个物理块所需的时间几乎不依赖于此信息的位置</li></ul></li></ul><h3 id="文件的逻辑结构">5.2.2 文件的逻辑结构</h3><p>逻辑文件，又称为文件的逻辑结构</p><ul><li>独立于物理环境的，用户概念中的抽象信息组织方式</li><li>用户能观察到并加以处理的数据集合</li></ul><p>文件的逻辑结构分为两种：流式文件和记录式文件</p><h4 id="流式文件">流式文件</h4><p>文件内的数据不再组成记录，只是由一串依次的字节组成的信息流序列。</p><ul><li>这种文件常常按长度来读取所需信息，也可以用插入的特殊字符作为分界。</li></ul><h4 id="记录式文件">记录式文件</h4><p>一种有结构的文件，是若干逻辑记录信息所组成的记录流文件。</p><ul><li>逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位</li></ul><p>记录式文件与数据库</p><ul><li>数据库管理系统也支持逻辑记录</li><li>有别于记录式文件的是，数据库中的记录之间可以通过数据冗余构成某种联系</li><li>数据库管理系统支持基于联系的数据查询，文件系统则不行</li></ul><h4 id="记录的成组与分解">记录的成组与分解</h4><p>一个物理记录只存放一个逻辑记录可能造成极大的浪费。</p><p>若干个逻辑记录合并成一组，写入一个块，称为记录的成组。</p><ul><li>每块中的逻辑记录数称为块因子</li></ul><p>对于流式文件，一个物理记录可以存放很多个连续字节</p><h5 id="成组与分解操作">成组与分解操作</h5><ol type="1"><li>系统设置独立于用户数据区的输入/输出缓冲区</li><li>记录的成组操作在输出缓冲区内进行，凑满一块后才将缓冲区内的信息写到存储介质上</li><li>当存储介质上的一个物理记录读进输入缓冲区后，把逻辑记录从块中分离出来的操作称为记录的分解操作</li></ol><p>成组与分解的特征：</p><ul><li>优点：记录成组与分解节省存储空间，减少输入/输出操作次数，提高系统效率</li><li>提前读与推迟写<ul><li>提前读：用户读请求，导致包含该逻辑记录的物理块读如输入缓冲区，这一操作可能读入了多个逻辑记录</li><li>推迟写：用户写请求，首先是写入输出缓冲区，只有当该缓冲区中的逻辑记录满后才会引起实际输出</li></ul></li></ul><h3 id="文件的物理结构">5.2.3 文件的物理结构</h3><p>文件的物理结构和组织是指文件在物理存储空间中的存放方法和组织关系，又称为物理文件。</p><ul><li>文件的存储结构涉及块的划分、记录的排列、索引的组织、信息的搜索等问题</li><li>直接影响文件系统性能</li></ul><h4 id="顺序文件">顺序文件</h4><p>将一个文件中逻辑上连续的信息存放到存储介质的依次相邻的块中形成顺序结构，这类文件称为顺序文件，也称连续文件。</p><ul><li><p>例：磁带文件、光盘文件</p></li><li><p>优点：顺序存取记录时速度较快</p><ul><li>常用于批处理文件和系统文件</li><li>采用磁带存放顺序文件，总可以保持快速存取存储的优点</li></ul></li><li><p>缺点：建立文件前需要能预先确定文件长度以便分配存储空间；修改、插入和增加文件记录有困难</p></li></ul><h4 id="连接文件">连接文件</h4><p>连接文件又称串联文件，使用连接字来表示文件中各个物理块之间的先后次序</p><ul><li><p>第一块文件信息的物理地址由文件目录给出，每一块的连接字指出了文件的下一个物理块位置，连接字内容为0时，表示文件至本块结束。</p></li><li><p>输入井、输出井都是连接文件</p></li><li><p>优点：易于对文件记录做增、删、改，易于动态增长记录；不必预先确知文件长度；存储空间利用率高</p></li><li><p>缺点：存放指针需要额外的存储空间，由于存取需通过缓冲区，待获得连接字后，才能找到下一物理块的地址，因而仅适用于顺序存取</p></li></ul><h4 id="直接文件">直接文件</h4><p>直接文件又称散列文件，通过计算记录的关键字建立与其物理存储地址之间的对应关系，这种变换通常采用散列。</p><ul><li>计算寻址结构可能出现冲突，解决办法有拉链法、循环探查法、二次散列法、溢出区法等</li></ul><h4 id="索引文件">索引文件</h4><p>索引文件为每个文件建立了一张索引表，其中每个表目包含一个记录的键（逻辑记录号）及其存储地址</p><ul><li>索引表的地址可由文件目录指出，查阅索引表先找到相应记录键，然后获得数据存储地址</li></ul><p>访问方式：</p><ul><li>索引文件在文件存储器上分为索引区和数据区</li><li>访问索引文件的两步操作：查找索引表，获得记录的物理地址</li><li>需要两次访问辅助存储器，若文件索引表已预先掉入主存储器，可减少一次内外存信息交换</li></ul><p>索引结构时连接结构的一种扩展，克服了连接文件只能作顺序存取的缺点，但增加了索引表的空间开销和查找时间。</p><p>索引表的组织：一级索引、二级索引、多级索引</p><h2 id="文件目录">5.3 文件目录</h2><h3 id="文件目录结构">5.3.1 文件目录结构</h3><p>文件目录是实现文件的按名存取的关键数据结构。</p><ul><li>文件系统的基本功能之一就是负责文件目录的建立、维护和检索，要求编排的目录便于查找、防止冲突</li><li>文件目录需要永久保存，因此也组织成文件存放在磁盘上</li></ul><p>一级目录结构：</p><p>在操作系统中构造一张线性表，与每个文件的相关属性占一个目录项，构成一级目录结构</p><ul><li>由于用户与文件众多，容易重名，不利于记忆</li></ul><p>二级目录结构：</p><ul><li>第一级为主文件目录，用于管理所有用户文件目录，目录项登记系统接受的用户名和该用户文件目录的地址</li><li>第二级为用户文件目录，为该用户的每个文件保存一个登记栏，内容与一级目录的目录项相同</li><li>每个用户只允许查看自己的文件目录</li></ul><p>二级目录结构的特点：</p><ul><li>可以检查访问文件者的存取权限，实现对文件的保密和保护</li><li>对同一个用户而言，依然存在文件多、易重名的问题</li></ul><p>树形目录结构：</p><p>每一级目录可以登记下一级目录，也可以登记文件，形成层次文件目录结构，一般采用树形目录结构，根是根目录，非叶节点为子目录，叶节点为文件</p><ul><li>较好地反映现实世界中具有层次关系的数据集合，较准确地反映系统内部文件的组织结构</li><li>不位于同一末端子目录的不同文件可以重名</li><li>易于规定不同层次货子树中文件的不同存取权限，便于文件的保护、保密和共享</li></ul><p>树形目录结构的文件定位</p><ul><li>一个文件的全名包括从根目录到文件为止的所有子目录路径</li><li>各子目录名间用文件分隔符分开</li><li>一个硬盘分区组织成一棵子树<ul><li>每棵子树对应一个逻辑盘符（Windows）</li><li>众多子树嫁接成一棵大树（UNIX）</li></ul></li></ul><h3 id="文件目录的管理">5.3.2 文件目录的管理</h3><h4 id="文件查找">文件查找</h4><p>系统跟去用户提供的文件路径（绝对/相对）搜索各级文件目录，找到文件。</p><ul><li>现代操作系统都有改变工作目录的命令。</li></ul><h4 id="目录项查找">目录项查找</h4><p>搜索具体目录项时，可以采用顺序查找法或二分查找、杂凑法等方式查找。</p><ul><li>目录项按一定顺序编排时可用二分查找</li><li>杂凑法，把每个文件名经过变换函数变换成唯一的目录表表项。</li></ul><h4 id="活动文件表">活动文件表</h4><ul><li><p>树形目录结构存在的问题：一个文件经过许多目录节点时，使用不方便，系统在沿路径查找目录时，要多次访问文件存储器，使访问速度大大减慢。</p></li><li><p>若将所有文件的目录都复制到主存，访问速度加快但主存开销大。</p></li><li><p>一种办法是，把常用的和正在使用的文件目录复制进主存</p></li></ul><p>系统为每个用户进程建立一张活动文件表，用户使用一个文件前，先通过打开操作，把该文件有关目录信息复制到指定主存区域，有关信息填入活动文件表，以建立用户进程和该文件索引的联系。</p><p>不再使用该文件时，使用关闭操作，切断用户进程和这个文件的联系，同时若该目录已被修改过，更新辅存中对应的文件目录。</p><h2 id="文件的共享保护和保密">5.4 文件的共享、保护和保密</h2><p>文件是计算机系统的重要资源，文件系统需要具有保障文件安全的手段，提供文件保密的措施，有效实现文件共享。</p><ul><li>文件共享是指不同用户共同使用某些文件</li><li>文件保护是指防止文件被破坏</li><li>文件保密是指防止文件及其内容被其他用户窃取</li></ul><h3 id="文件的共享">1. 文件的共享</h3><p>文件共享是计算机用户完成共同任务所必需的。</p><ul><li>好处：减少用户大量重复性劳动；免除系统复制文件的工作；节省文件占用的存储空间；减少程序设计输入/输出文件的次数</li></ul><p>文件共享的并发控制：</p><ul><li>在允许文件共享的系统中，操作系统应提供手段实现对共享文件的同步控制</li><li>多个进程可能同时存取一个文件如果它们同时进行读操作，操作系统应对文件进行公用控制</li><li>如果有进程进行写操作，操作系统须提供同步控制机制以保证文件数据完整性</li></ul><p>文件的保密：</p><ul><li>文件保密是指文件及其内容不能被未经文件主授权的其他用户窃取</li><li>保密措施：<ul><li>隐蔽文件目录</li><li>设置口令</li><li>使用密码</li></ul></li></ul><h3 id="文件的保护">2. 文件的保护</h3><p>文件保护是指防止文件被破坏。操作系统须提供文件保护机制，实现文件完整性。</p><p>常见的文件保护方法：文件副本；文件存取矩阵；文件属性</p><h4 id="文件副本">文件副本</h4><p>文件系统必须要有防止硬软件故障，保存信息完整性的能力，文件副本是主要实现机制。</p><ul><li>动态多副本技术</li><li>转储、备份和恢复</li></ul><h5 id="动态多副本">动态多副本</h5><p>在多个介质上维持同一内容的文件，在更新内容时同时进行。</p><p>增加了设备费用和系统负载，一般适用于容量较小且较为重要的文件，当文件发生故障时只需切换到备用设备即可。</p><p>一般适用于不需更新的系统文件及专用文件，</p><h5 id="文件转储">文件转储</h5><p>定时将文件复制转储到其他介质上，当某介质上出现故障时，复原转储文件。</p><p>转储的两种方式：</p><ul><li>一，一定时间间隔或一个单位处理结束时，系统自动复写更新过的文件和数据</li><li>二，每天或每周把文件信息全部复写，需要时再通过装入转储文件来恢复系统</li></ul><h4 id="文件的存取控制矩阵">文件的存取控制矩阵</h4><p>系统为每个用户设置访问每个文件对象的存取属性，则全部用户对全部文件的存取属性就组成一个二维矩阵，称为存取控制矩阵。</p><ul><li>由于操作系统具有很多用户和众多文件，存取控制矩阵是一个稀疏矩阵，可以将其简化为一张存取控制表<ul><li>每行包括：用户、文件、存取属性</li><li>仅登记那些对文件拥有存取属性的部分</li></ul></li></ul><p>基于存取控制矩阵/表的文件保护：</p><ul><li>存取属性：可以有访问、读、写、执行、创建、删除、授权等</li><li>系统通过查阅矩阵/表核对用户对文件的存取权限</li><li>文件主通过命令进行授权甚至授权权的转授</li><li>系统管理用户等同于文件主权限，获得对系统文件的授访问权权限</li></ul><h4 id="文件属性">文件属性</h4><p>存取控制表的一种简化方法是用户分类，再针对每类用户规定文件属性。</p><ul><li>用户分类：属主、合作者、其他</li><li>文件属性：读、写、执行</li><li>文件属性可以放在文件目录项中，管理大为简化</li><li>用户使用文件时，通过核对文件属性，实现保护</li></ul><h2 id="文件的使用">5.5 文件的使用</h2><h3 id="文件存取方法">5.5.1 文件存取方法</h3><p>文件存取方法是操作系统为用户程序提供的使用文件的技术和手段，在某种程度上依赖于文件的物理结构。</p><h4 id="顺序存取">顺序存取</h4><p>按记录顺序进行读写操作的存取方法。</p><ul><li>读操作根据读指针读出当前记录，同时推进读指针，指向下一次要读出的记录</li><li>写操作则设置写指针，把一个记录写到文件末端，同时推进写指针</li><li>允许对读指针进行前进或后退整数个记录的操作</li></ul><h4 id="直接存取">直接存取</h4><p>快速地以任意次序直接读写某个记录。</p><h4 id="索引存取">索引存取</h4><p>基于索引文件的索引存取方法。</p><ul><li>信息块的地址可以通过查找记录键换算出</li><li>也可以采用顺序存取或直接存取的方法</li><li>实际都采用多级索引加速记录查找</li></ul><h3 id="文件的使用-1">5.5.2 文件的使用</h3><p>用户通过两类接口与文件系统联系。</p><ul><li>一类是与文件有关的操作命令</li><li>另一类是提供给用户程序的文件类系统调用，如下</li></ul><h4 id="建立文件">建立文件</h4><p>参数：文件名、设备类、文件属性及存取控制信息</p><p>流程：在相应设备上建立一个文件目录项，分配第一个物理块，在活动文件表中申请一个项，登记有关目录信息，返回一个文件句柄。</p><h4 id="撤销文件">撤销文件</h4><p>参数：文件名、设备类</p><p>流程：若文件未关闭，先关闭文件；若为共享文件，进行联访处理；在目录文件中删除对应目录项，释放文件占用的文件存储空间</p><h4 id="打开文件">打开文件</h4><p>参数：文件名、设备类、打开方式</p><p>流程：在主存活动文件表中申请一个项，返回一个文件句柄；跟踪文件名查找目录文件，把目录信息复制到活动文件表相应栏，按存取控制说明检查访问的合法性；对共享文件进行相应的额外处理</p><h4 id="关闭文件">关闭文件</h4><p>参数：文件句柄</p><p>流程：将活动文件表中该文件的当前使用用户数减一，若此值为0，则收回此活动文件表，完成推迟写；若活动文件表目内容已被改过，则应先将表目内容写回文件存储器上相应表目中，使文件目录保存最新状态。</p><h4 id="读写文件">读写文件</h4><p>参数：文件句柄、用户数据区地址、读写的记录或字节数</p><p>按文件句柄从活动文件表中找到该目录的目录项信息；根据目录项指出的该文件逻辑和物理组织方式，把相关逻辑记录转换成物理块</p><h4 id="定位文件">定位文件</h4><p>调整所打开文件的读写指针位置</p><p>参数：文件句柄，定位指针</p><h2 id="文件系统的实现">5.6 文件系统的实现</h2><h3 id="辅存空间管理">1. 辅存空间管理</h3><h4 id="辅存空间的分配方式">辅存空间的分配方式</h4><ul><li>连续分配：存放在辅存空间连续存储区中（连续的存储块号）<ul><li>优点是顺序访问速度快，管理简单</li><li>为了获得足够大的连续存储区，需要定时进行碎片整理</li></ul></li><li>非连续分配：动态分配给若干扇区或簇，不要求连续<ul><li>辅存空间管理效率高，便于文件动态增长和收缩</li></ul></li></ul><h4 id="空闲块的管理">空闲块的管理</h4><h5 id="位示图">位示图</h5><p>使用若干字节构成一张表，表中每一字位对应一个物理块，字位的顺序和块的相对次序一致，字位为1表示相应块已占用，字位为0表示该块空闲。</p><p>优点：可以把位示图全部或大部分保存在主存中，配合位操作指令实现高速物理块分配与去配。</p><h5 id="空闲块成组连接法">空闲块成组连接法</h5><h3 id="文件系统的实现层次">2. 文件系统的实现层次</h3><ul><li>用户接口：接受用户发来的系统调用，进行语法检查，进入逻辑文件控制子系统</li><li>逻辑文件控制子系统：根据文件路径名，搜索文件目录，建立活动文件表，根据文件结构和存取方法，把逻辑记录转换成相对物理块号和块内相对地址</li><li>文件保护子系统：识别调用者身份，验证存取权限，判定本次文件操作的合法性</li><li>物理文件控制子系统：实现缓冲区管理，根据物理结构，将对应相对物理块号转换为实际物理块号，负责文件存储空间的分配，生存输入/输出控制系统调用形式</li><li>输入/输出控制子系统：执行具体的物理块输入/输出操作</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第四章_设备管理</title>
    <link href="/2023/05/04/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/04/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>长风破浪会有时，直挂云帆济沧海！</p><span id="more"></span><h1 id="第四章-设备管理">第四章 设备管理</h1><h2 id="设备管理基础">4.1 设备管理基础</h2><h3 id="设备管理概述">4.1.1 设备管理概述</h3><h4 id="输入输出设备及其分类">1. 输入/输出设备及其分类</h4><ul><li><p>输入/输出设备，又称外围设备、外设，用于计算机系统与外部世界的信息交换或存储。</p></li><li><p>输入/输出操作：内存和外设间的信息传送操作</p><ul><li>影响计算机系统的通用性和可扩展性</li><li>影响计算机系统综合处理能力及性价比</li></ul></li></ul><p>输入/输出设备分类：</p><ul><li>信息传输视角：分为输入设备、输出设备和输入输出设备</li><li>交互功能视角：分为人机交互设备、存储设备和机机通信设备</li><li>设备管理视角：分为字符设备、块设备和网络设备</li></ul><h4 id="设备管理的目标">2. 设备管理的目标</h4><p>解决设备和CPU速度的不匹配，使主机和设备充分并行工作，提高设备使用效率。</p><p>屏蔽设备的物理细节和操作过程，配置驱动程序，提供同一界面。</p><ul><li>抽象为裸设备</li><li>抽象为设备文件</li></ul><h4 id="设备管理的功能">3. 设备管理的功能</h4><ul><li>设备中断管理</li><li>缓冲区管理</li><li>设备的分配与去配</li><li>设备驱动调度</li><li>虚拟设备的实现</li></ul><h4 id="设备管理的实现层次">4. 设备管理的实现层次</h4><ul><li>输入/输出硬件<ul><li>输入/输出设备及其借口线路</li><li>控制部件</li><li>通道</li></ul></li><li>输入/输出软件<ul><li>系统输入/输出软件</li><li>用户空间输入/输出软件</li></ul></li></ul><h3 id="输入输出控制方式">4.1.2 输入/输出控制方式</h3><h4 id="设备控制器">1. 设备控制器</h4><p>为达到模块化和通用性的设计目标，通常分开设置设备的机械部件和电子部件。</p><p>电子部件成为设备控制器，又称为设备适配器、输入/输出控制器(模块/接口等)。</p><p>系统与控制器交互，而非与设备交互，设备控制器具体控制设备进行输入/输出。</p><h5 id="设备控制器的功能">设备控制器的功能</h5><p>设备控制器是CPU与设备之间的接口。</p><ul><li>接受和识别CPU或通道发来的命令</li><li>实现数据交换</li><li>发现和记录设备及其自身的状态信息，供CPU处理时使用</li><li>当连接多台设备时，识别设备地址</li></ul><h4 id="三种基本输入输出控制方式">2. 三种基本输入/输出控制方式</h4><h5 id="轮询方式">轮询方式</h5><ul><li>处理器向控制器发送输入/输出命令，轮询输入/输出结果</li><li>若设备未就绪，则重复测试过程，直至设备就绪</li><li>执行内存数据交换</li><li>等待输入/输出操作完成后，处理器才可以继续其他操作</li></ul><h5 id="中断方式">中断方式</h5><ul><li>处理器向控制器发出具体输入/输出命令，然后继续执行后续指令<ul><li>若进程支持异步输入/输出，后续指令仍然可以是该进程中指令</li><li>否则该进程在这个中断上挂起，处理器执行其他工作</li></ul></li><li>控制器检查设备状态，就绪后发出中断</li><li>CPU响应中断，进行中断处理，执行内存数据交换</li></ul><h5 id="dmadirect-memory-access直接存储器访问方式">DMA（Direct MemoryAccess，直接存储器访问）方式</h5><p>DMA模块：替代处理器来控制主存和设备控制器间的数据交换</p><ul><li>处理器向DMA模块发出输入/输出命令</li><li>处理器继续执行其他工作，DMA模块负责传送全部数据</li><li>数据传送结束后，DMA中断处理器</li></ul><h5 id="dma方式中的周期窃取">DMA方式中的周期窃取</h5><p>DMA和CPU同时通过总线访问内存，CPU会把总线的占有权让给DMA一个或几个主存周期。</p><p>周期窃取对CPU与主存的数据交换影响不大</p><ul><li>数据传送过程是不连续、不规则的</li><li>CPU大部分情况下与Cache进行数据交换，直接访问内存较少</li></ul><p>总结：</p><ul><li>轮询：CPU等待设备就绪，参与内存数据交换</li><li>中断：CPU不等待设备就绪，响应中断后参与内存数据交换</li><li>DMA：CPU不等待设备就绪，不参与主存数据交换</li></ul><h4 id="输入输出通道及其工作方式">3. 输入/输出通道及其工作方式</h4><h5 id="输入输出通道">输入/输出通道</h5><p>又称为通道控制器、输入/输出处理器，用于完成逻辑上独立的输入/输出任务。</p><p>采用四级连接：处理器、通道、控制器、设备</p><ul><li>通道可控制多台同类或不同类设备</li></ul><p>处理器不再执行输入/输出指令，而是在主存中组织通道程序，由输入/输出通道执行。</p><h5 id="输入输出通道的工作流程">输入/输出通道的工作流程</h5><ol type="1"><li>CPU遇到输入/输出任务，组织通道程序，置通道程序地址字CAW，启动指定通道</li><li>通道从CAW获得通道程序，控制输入/输出设备进行操作，CPU执行其他任务</li><li>输入/输出操作完成后，输入/输出通道发出中断，CPU处理中断，并从通道程序状态字CSW获得通道执行情况，处理输入/输出操作</li></ol><ul><li>CPU与通道高度并行工作</li></ul><h3 id="总线与输入输出">4.1.3 总线与输入/输出</h3><h4 id="总线对输入输出的影响">1. 总线对输入/输出的影响</h4><ul><li>输入/输出和CPU速度不匹配、各设备输入/输出速度不匹配</li><li>总线使主机和设备充分并行，提高系统效率</li></ul><h4 id="几种经典总线模型">2. 几种经典总线模型</h4><h5 id="单总线结构模型">单总线结构模型</h5><p>将CPU、主存和输入/输出模块连接到同一总线</p><ul><li><p>优点：结构简单、易于扩充</p></li><li><p>缺点：设备多时总线压力大，传输时间延长，慢速外设占用带宽多</p></li></ul><h5 id="三级总线模型">三级总线模型</h5><p>主存和Cache通过主存总线连接，主存总线和扩展总线上的输入/输出设备通过扩展总线接口缓冲</p><ul><li>优点：主存和输入/输出之间的数据传送、处理器的内存活动分离，可以支持更多输入/输出设备</li><li>缺点：不适用于输入/输出设备数据速率相差太大的情形</li></ul><h5id="南桥输入输出控制器与北桥主存控制器">南桥（输入/输出控制器）与北桥（主存控制器）</h5><p>通过存储总线、PCI总线、E(ISA)总线分别连接主存、高速输入/输出设备和低速输入/输出设备。</p><p>优点：可以支持不同数据速率的输入输出设备。</p><pre><code class=" mermaid">graph LRCPU--处理器总线---北桥--存储总线---Cache北桥--桥间接口---南桥南桥---PCI总线---E总线</code></pre><h5 id="一种基于通道的服务器总线模型">一种基于通道的服务器总线模型</h5><p>支持CPU、主存和多个输入/输出通道之间的数据传送</p><p>支持输入/输出通道和输入/输出控制器，以及输入/输出控制器和设备之间的数据传送。</p><ul><li>CPU通过主存控制器连接主存</li><li>CPU、主存和主存控制器均连接在一条与各个输入/输出通道连接的总线上</li><li>各个输入/输出通道分别与负责的输入/输出控制器连接</li><li>各个输入/输出控制器分别与负责的设备连接</li></ul><h2 id="设备管理软件">4.2 设备管理软件</h2><h3 id="输入输出软件的实现层次">4.2.1 输入/输出软件的实现层次</h3><h4 id="输入输出软件的设计">1. 输入/输出软件的设计</h4><p>设计目标：</p><ul><li>高效率：改善设备效率，尤其是磁盘输入/输出操作的效率</li><li>通用性：用统一标准来管理所有设备</li></ul><p>设计思路：</p><ul><li>把软件组织成层次结构，底层软件用来屏蔽硬件细节，高层软件向用户提供简洁、友善、统一的界面</li></ul><p>设计需要考虑的问题：</p><ul><li>设备无关性：访问设备的程序与具体设备无关</li><li>出错处理：低层软件能处理的错误不让高层软件感知</li><li>同步/异步传输：支持阻塞和中断驱动两种工作方式</li><li>缓冲技术：建立内存数据缓冲区，提高吞吐量</li></ul><h4 id="输入输出软件的实现层次-1">2. 输入/输出软件的实现层次</h4><p>从低到高有：</p><ol type="1"><li>输入/输出硬件：执行输入/输出操作</li><li>输入/输出中断处理程序：处理输入/输出中断，报告输入/输出错误，唤醒输入/输出设备驱动程序</li><li>输入/输出设备驱动程序：设备寄存器初始化，启动输入/输出操作，检查输入/输出状态</li><li>独立于设备的输入/输出软件：设备的命名、保护、阻塞、缓冲、分配、跟踪</li><li>用户空间的输入/输出软件：输入/输出系统调研、输入/输出格式化、SPOOLing</li></ol><h3 id="输入输出软件的实现">4.2.2 输入/输出软件的实现</h3><h4 id="输入输出中断处理程序">1. 输入/输出中断处理程序</h4><p>输入/输出中断处理程序位于操作系统底层，与硬件设备密切相关，与系统其余部分尽可能少地发生联系。</p><ul><li>进程请求输入/输出操作时，通常被阻塞</li><li>数据传输结束后产生输入/输出中断</li><li>CPU响应请求并转入中断处理程序</li></ul><h5 id="输入输出中断处理程序的功能">输入/输出中断处理程序的功能</h5><p>检查设备状态寄存器，判断中断原因，根据输入/输出操作完成情况进行相应处理</p><ul><li>如果数据传输有误，向上层软件报告设备出错信息，实施重新执行</li><li>如果正常结束，唤醒等待传输的进程，使其转换为就绪态</li><li>如果有等待传输的输入/输出命令，通知相应软件开启下一个输入/输出请求</li></ul><h4 id="设备驱动程序">2. 设备驱动程序</h4><ul><li>包括与设备密切相关的所有代码</li><li>从独立于设备的软件中接受输入/输出请求</li><li>把用户提交的逻辑输入/输出请求转化为物理输入/输出操作的启动和执行</li><li>监督设备是否正确执行，访问数据缓冲区，进行必要的纠错处理</li></ul><h5 id="设备驱动程序的功能">设备驱动程序的功能</h5><ul><li>设备初始化：在设备传输数据时，预置设备、控制器以及通道状态</li><li>执行设备驱动例程：负责启动设备，进行数据传输；对于通道，负责组织通道程序，启动通道工作</li><li>执行与设备相关的具体中断处理，负责处理设备、控制器及通道所发出的各种具体中断</li></ul><h5 id="设备驱动程序的层次">设备驱动程序的层次</h5><p>每个设备驱动程序原则上只处理一种设备，或者一类紧密相关的设备。</p><p>设备驱动程序的分层实现：</p><ul><li>高层/处理类设备，底层/处理具体设备</li><li>系统建立栈，接到输入/输出请求时先调用栈顶的驱动程序，然后继续向下调用底层驱动程序，直至所有物理操作被处理</li><li>这一方式使设备驱动的实现结构清晰，易于移植，但会增加一部分系统开销</li></ul><h4 id="独立于设备的输入输出软件">3. 独立于设备的输入/输出软件</h4><p>执行适用于所有设备的常用输入/输出功能，并向用户层软件提供一致性接口，包括：</p><ul><li>设备命名：通过路径名寻址设备</li><li>设备保护：用户是否有权访问设备</li><li>提供与设备无关的数据单位：字符、块</li><li>缓冲技术：调整CPU与输入/输出速度不匹配</li><li>分配和状态跟踪：分配设备</li><li>错误处理与报告：驱动无法处理的错误</li></ul><h4 id="用户空间的输入输出软件">4. 用户空间的输入/输出软件</h4><ul><li>库函数：操作系统内核外，使用库函数实现的输入/输出软件，运行时与应用程序链接</li><li>虚拟设备：用一类设备模拟另一类设备的仿真输入/输出软件</li></ul><h3 id="输入输出缓冲">4.2.3 输入/输出缓冲</h3><h4 id="输入输出缓冲-1">1. 输入/输出缓冲</h4><h5 id="设置输入输出缓冲的目的">设置输入/输出缓冲的目的</h5><ul><li>解决CPU与设备之间速度不匹配的矛盾</li><li>协调逻辑记录大小和物理记录大小不一致的问题</li><li>提高CPU和设备的并行性</li><li>减少输入/输出操作对CPU的中断次数</li><li>放宽对CPU中断响应时间的要求</li></ul><h5 id="输入输出缓冲区">输入/输出缓冲区</h5><p>在内存中开辟的存储区，专门用于临时存放输入/输出操作的数据</p><p>操作过程：</p><ul><li>写操作：将数据送至缓冲区，直到写满或需要写出，待适当时候系统将缓冲区内容写到设备上</li><li>读操作：系统将设备上的物理记录读至缓冲区，根据要求将当前所需要的数据从缓冲区中读出并传送给进程</li></ul><h4 id="几种缓冲技术">2. 几种缓冲技术</h4><h5 id="单缓冲技术">单缓冲技术</h5><p>操作系统在主存系统区中开设一个缓冲区。</p><ul><li>输入：先把数据读至缓冲区，再把缓冲区数据送至用户区，应用程序处理数据，如此往复，系统继续读入后续数据</li><li>输出，把数据从用户区传送至缓冲区，再将数据输出至设备，应用程序继续请求输出</li></ul><h5 id="双缓冲技术">双缓冲技术</h5><p>操作系统在主存系统区开设两个缓冲区。</p><ul><li>输入：先把数据输入缓冲区1，再从缓冲区1把数据传到用户区，供应用程序处理（同时设备可将数据传送到缓冲区2）</li><li>输出：先将数据从用户区传送到缓冲区1，再将数据传送到设备（同时应用程序可将数据传送到缓冲区2）</li></ul><h5 id="循环缓冲技术">循环缓冲技术</h5><p>操作系统分配一组缓冲区，每个缓冲区有指向下一个缓冲区的链接指针，构成循环</p><ul><li>调节设备和进程速度不匹配的问题</li></ul><h2 id="独占型外围设备的分配">4.3 独占型外围设备的分配</h2><h3 id="设备独立性">4.3.1 设备独立性</h3><ul><li><p>用户通常不指定物理设备，而是指定逻辑设备，使得用户进程和物理设备分离，再通过其他途径建立逻辑设备和物理设备间的映射。</p></li><li><p>设备管理中需要将逻辑设备名转换为物理设备名，为此系统需要提供逻辑设备名和物理设备名的对应表以供转换使用</p></li></ul><h4 id="设备独立性的优点">设备独立性的优点</h4><ul><li>应用程序与具体物理设备无关，系统增减或变更设备时不需要修改原程序</li><li>易于应对各种输入/输出设备故障，提高系统的可靠性</li><li>增加设备分配的灵活性，有利于更加有效地利用设备资源，实现多道程序设计</li></ul><h3 id="独占型外围设备的分配-1">4.3.2 独占型外围设备的分配</h3><h4 id="设备分配方式">设备分配方式</h4><p>独占型外围设备：一次只能由一个进程独占使用</p><p>分配方式：</p><ul><li>静态分配：进程运行前申请<ul><li>实现简单，能防止系统发生死锁，但会降低设备利用率</li></ul></li><li>动态分配：进程随用随申请<ul><li>提高设备利用率</li></ul></li></ul><h4 id="设备分配的数据结构">设备分配的数据结构</h4><p>设备类表</p><ul><li>每类设备对应于设备类表中的一栏</li><li>包括设备类、总台数、空闲台数、设备表起始地址等</li><li>支持设备独立性</li></ul><p>设备表</p><ul><li>每类设备有各自的设备表，用来登记这类设备的每台物理设备</li><li>包括：物理设备名，逻辑设备名，占有设备的进程，分配标志，好/坏标志等</li></ul><h2 id="共享型外围设备的驱动">4.4 共享型外围设备的驱动</h2><h3 id="磁盘的物理结构">4.4.1 磁盘的物理结构</h3><h4 id="磁盘结构">1. 磁盘结构</h4><ul><li>磁盘一般由多个盘片组成</li><li>每个盘片一般由两个盘面</li><li>盘面包括多个同心圆结构的磁道，不同盘面上位于相同位置的磁道构成柱面</li><li>每个磁道分为固定多个扇区，相邻扇区组合成簇</li><li>物理块的地址：<ul><li>柱面号，磁道号，扇区号</li><li>0面0道1扇区（此处面指磁头而不是柱面）</li></ul></li></ul><h4 id="磁盘读写数据的方式">2. 磁盘读写数据的方式</h4><p>读写数据时，磁头必须定位到指定磁道上的指定扇区的开始处，过程为：</p><ol type="1"><li>寻道：控制移动臂到达指定柱面</li><li>旋转：等待要读写的扇区旋转到磁头下</li><li>选择磁头号，进行数据传送</li></ol><h4 id="磁盘存取时间">3. 磁盘存取时间</h4><p>磁盘完成数据读写所需要的时间，是寻道时间、旋转延迟、传送时间的总和。</p><p><spanclass="math inline">\(T_a=T_s+\frac{1}{2r}+\frac{b}{rN}\)</span></p><p>其中，<span class="math inline">\(T_a\)</span>为存取时间，<spanclass="math inline">\(T_s\)</span>为寻道时间，<spanclass="math inline">\(r\)</span>为磁盘旋转速度（转/秒），<spanclass="math inline">\(b\)</span>为要传送的字节数，<spanclass="math inline">\(N\)</span>为一个磁道中的字节数。</p><h3 id="磁盘的驱动调度">4.4.2 磁盘的驱动调度</h3><p>磁盘可能同时接收到若干输入/输出请求，如果随机响应，性能会很差。</p><p>驱动调度：操作系统的磁盘调度策略，按照最佳次序执行处理访问磁盘的多个输入/输出请求，以减少磁盘访问的总处理时间。</p><p>驱动调度策略有移臂调度和旋转调度。</p><h4 id="移臂调度及其算法">移臂调度及其算法</h4><ul><li><p>目的：使移动臂的移动时间最短以减少寻道总时间</p></li><li><p>算法：</p><ul><li>先来先服务：移臂距离大，性能差</li><li>最短查找时间优先<ul><li>先执行查找时间最短的请求，寻道性能较好</li><li>存在“饥饿”现象</li></ul></li><li>单向扫描：移动臂向一个方向扫描，归途不提供服务</li><li>双向扫描：移动臂向一个方向移动，到达最后一个柱面再向反方向移动</li><li>电梯调度：改进双向扫描，当前移动方向没有访问请求时就改变方向</li></ul></li></ul><h4 id="旋转调度及其策略">旋转调度及其策略</h4><p>目的：使旋转延迟的总时间最少</p><p>循环排序：</p><ul><li><p>通过优化输入/输出请求排序，在最少旋转圈数内完成位于同一柱面的访问请求</p></li><li><p>旋转位置测定硬件和多磁头同时读写技术有利于提高旋转调度的效率</p></li></ul><p>优化分布：</p><ul><li>通过信息在存储空间的排列方式来减少旋转延迟</li><li>交替排序：由于磁盘匀速旋转，可能处理当前扇区数据时，下个扇区已经跳过。因此，可对扇区间隔编号，交叉因子为n:1表示相邻编号间间隔n-1个扇区</li><li>相邻扇区集中成簇读写</li><li>按柱面集中存储数据，可以减少数据读写时的移臂操作</li></ul><h2 id="虚拟设备">4.5 虚拟设备</h2><h3 id="spooling系统">4.5.1 SPOOLing系统</h3><h4 id="虚拟设备-1">1. 虚拟设备</h4><p>使用一类物理设备模拟另一类物理设备的技术。</p><p>示例：</p><ul><li>内存模拟磁盘</li><li>块设备模拟字符设备</li><li>输入输出重定向</li></ul><h4 id="spooling系统-1">2. SPOOLing系统</h4><p>SPOOLing（Simultaneous Peripheral OperationsOn-Line，外部设备联机并行操作），是关于慢速字符设备如何与计算机主机交换信息的一种技术，通常称为“假脱机技术”。</p><p>一个经典的SPOOLing系统：</p><ul><li>用高速的磁盘设备来模拟慢速的字符设备，缩短进程在内存中的驻留时间</li><li>慢速输出设备先输出到输出井</li><li>进程运行过程中只从输入井读入数据，只向输出井输出数据，使得全部输入/输出都基于磁盘</li><li>加快进程周转时间，提高系统吞吐量</li></ul><p>该系统的软件组成：</p><ul><li>预输入系统：预先把数据从输入设备传送到磁盘输入井</li><li>缓输出设备：把数据从磁盘输出并传送到输出设备</li><li>井管理程序：控制进程和井之间的数据交换（输入/输出重定向）</li></ul><p>打印SPOOLing系统：打印机守护进程和SPOOLing打印目录</p><ul><li>守护进程是唯一有特权使用打印机设备的进程</li><li>打印文件前，用户进程先产生完整的待输出文件，存放在打印目录下</li><li>打印机空闲时，启动守护进程，打印待输出文件</li></ul><h3 id="批处理系统的作业管理">4.5.2 批处理系统的作业管理</h3><ul><li>作业说明语言：用于作业控制的语言</li><li>作业说明书：刻画具体作业的控制方式</li><li>作业状态：输入状态（预输入）、后备状态（空闲）、运行状态（运行）、完成状态（缓输出）</li><li>作业调度：从后备状态作业中选择部分进入运行状态</li><li>作业调度算法：优先数、短作业、响应比、设备搭配等</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第一章_概述</title>
    <link href="/2023/05/01/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/05/01/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>长风破浪会有时，直挂云帆济沧海！</p><span id="more"></span><h1 id="第一章-计算机操作系统概述">第一章 计算机操作系统概述</h1><h2 id="计算机系统">1.1 计算机系统</h2><h3 id="计算机系统概述">1.1.1 计算机系统概述</h3><p>电子数字计算机：能够自行按照已设定的程序进行数据处理的电子设备。</p><h4 id="计算机发展历史">计算机发展历史</h4><ul><li><p>1945～：电子真空管、机器语言，应用于科学计算</p></li><li><p>1956～：晶体管、批处理控制、Fortran/COBOL，扩展到数据处理</p></li><li><p>1959～：集成电路、多道程序、操作系统/数据库/高级语言</p></li><li><p>1976～：大规模集成电路，向快速化、小型化、系统化、网络化、智能化发展</p></li><li><p>1980～：微机出现</p></li><li><p>1990～：图形化人机交互</p></li><li><p>2003～：移动计算</p></li></ul><h4 id="计算机系统组成">计算机系统组成</h4><p>包括硬件子系统和软件子系统</p><ul><li><p>硬件：借助电、磁、光、机械等原理构成的各种物理部件的有机组合</p></li><li><p>软件：各种程序和文件，包括系统软件、支撑软件和应用软件</p><ul><li>关键系统软件：操作系统和语言处理程序</li></ul></li></ul><h4 id="计算机系统视图">计算机系统视图</h4><ul><li><p>用户视图：应用、语言处理、操作系统、计算机硬件</p></li><li><p>应用程序员视图：语言处理、操作系统、计算机硬件</p></li><li><p>语言处理程序设计者视图：操作系统、计算机硬件</p></li><li><p>操作系统设计者视图：计算机硬件</p></li></ul><h3 id="计算机硬件系统">1.1.2 计算机硬件系统</h3><h4 id="一计算机硬件系统的组成">一、计算机硬件系统的组成</h4><ol type="1"><li>中央处理器：运算单元、控制单元</li><li>主存储器</li><li>外围设备：输入/输出设备、存储设备、网络通信设备</li><li>总线</li></ol><h4 id="二冯氏计算机存储程序计算机">二、冯氏计算机：存储程序计算机</h4><p>冯·诺伊曼等人在1946年总结提出，称为冯·诺伊曼计算机模型</p><ol type="1"><li>以运算单元为中心，控制流由指令流产生</li><li>采用存储程序原理，面向主存组织数据流</li><li>主存是按地址访问、线性编址的空间</li><li>指令由操作码和地址码组成</li><li>数据以二进制编码</li></ol><h4 id="三总线">三、总线</h4><p>总线是计算机各种功能部件之间传送信息的公共通信干线，是CPU、内存、输入输出设备传递信息的公用通道。</p><p>计算机各个部件通过总线相连接，外围设备通过相应的接口电路与总线相连接，形成了计算机硬件系统。</p><p>总线的组成：一组控制线、一组数据线、一组地址线</p><p>总线的类型：</p><ol type="1"><li>内部总线：用于CPU芯片内部连接各元件</li><li>系统总线：用于连接CPU、存储器和各种输入/输出模块等主要部件</li><li>通信总线：用于计算机系统间通信</li></ol><p>片上系统 (SoC: System on a Chip)</p><p>在单个芯片上集成一个完整的系统(包括中央处理器、存储器以及外围电路等)，对所有或部分必要的电子电路进行包分组的技术。</p><p>SoC是与其他技术(如绝缘硅，提高增强时钟频率，降低功耗)并行发展的。</p><h4 id="四中央处理器">四、中央处理器</h4><p>中央处理器是计算机的运算核心和控制单元，主要包括：</p><ol type="1"><li>运算逻辑部件：一个或多个运算器</li><li>寄存器部件：包括通用寄存器、控制与状态寄存器、高速缓冲存储器</li><li>控制部件：实现各部件之间联系的数据、控制与状态内部总线；指令译码、控制指令执行、实现数据传输等功能的部件</li></ol><figure><img src="image/中央处理器.png" alt="中央处理器" /><figcaption aria-hidden="true">中央处理器</figcaption></figure><p>存储器组织层次：越往下，容量越大、速度越慢、价格越低</p><p>L0：寄存器</p><p>L1：L1 Cache</p><p>L2：L2 Cache</p><p>L3：L3 Cache</p><p>L4：主存</p><p>L5：本地固态硬盘</p><p>L6：本地硬盘</p><p>外围设备：输入/输出设备、存储设备、通信设备</p><p>输入/输出控制方式：</p><ol type="1"><li>轮询：CPU忙式控制输入/输出，执行内存数据交换</li><li>中断：CPU启动输入/输出设备，设备中断CPU</li><li>DMA方式：CPU启动DMA，DMA独立进行输入/输出和内存数据交换，DMA中断CPU</li></ol><h3 id="计算机软件系统">1.1.3 计算机软件系统</h3><h4 id="一计算机软件系统的组成">一、计算机软件系统的组成</h4><ol type="1"><li>系统软件</li></ol><p>操作系统、实用程序、语言处理程序、数据库管理系统</p><ol start="2" type="1"><li>支撑软件</li></ol><p>接口软件、工具软件、环境数据库，也可认为是系统软件的一部分</p><ol start="3" type="1"><li>应用软件</li></ol><p>用户按其需要自行编写的专用程序</p><h4 id="二程序员的计算机系统视图">二、程序员的计算机系统视图</h4><ol type="1"><li>机器语言：计算机硬件系统</li><li>机器指令：操作系统和实用程序</li><li>数据库语言：数据库管理系统</li><li>高级语言：支撑软件</li><li>更高：支撑软件</li></ol><p>软件开发的不同层次</p><ol type="1"><li>计算机硬件系统：机器语言</li><li>操作系统资源管理：机器语言+广义指令</li><li>操作系统文件系统：机器语言+系统调用</li><li>数据库管理系统：数据库语言</li><li>语言处理程序：面向问题的语言</li></ol><h4 id="三计算机程序的执行过程">三、计算机程序的执行过程</h4><figure><img src="image/计算机程序执行过程.png" alt="计算机程序执行过程" /><figcaption aria-hidden="true">计算机程序执行过程</figcaption></figure><h2 id="计算机操作技术">1.2 计算机操作技术</h2><h3 id="计算机操作技术的发展">1.2.1 计算机操作技术的发展</h3><h4 id="操作平台与操作系统">1. 操作平台与操作系统：</h4><p>任何一台机器都有其操作平台与操作系统，操作平台的精细化和系统化，产生了操作系统。</p><h4 id="计算机人工操作">2. 计算机人工操作</h4><p>计算机手工操作的问题：手工操作速度和电子计算速度不匹配</p><p>装入程序的引进：</p><ol type="1"><li>引入卡片和打孔纸带描述程序指令和数据</li><li>装入程序：自动化执行程序装入，必要时进行地址切换，存放在ROM中</li></ol><p>外存储设备变迁：过去的磁带与软盘，使用逐渐减少的光盘</p><p>计算机控制</p><p>汇编语言：先将汇编语言程序编译为可执行程序，再由计算机执行</p><p>高级语言：高级语言程序编译为目标代码，后编译成可执行程序，再执行</p><h4 id="简单批处理系统的操作方式">3. 简单批处理系统的操作方式</h4><p>简单批处理系统的操作控制：</p><p>引入作业控制语言，用户编写作业说明书，描述对一次计算机作业的控制。</p><p>操作员控制计算机成批输入作业，成批执行作业。</p><p>这一方式缩短了手工操作时间，提高了计算机系统的使用效率。</p><p>进展：</p><ol type="1"><li>出现了初步的资源管理程序，屏蔽了硬件处理细节</li><li>输入/输出中断出现，实现CPU与输入/输出设备并行</li><li>磁带出现，磁盘文件系统形成，但输入/输出效率还是不支持多道程序</li></ol><h4 id="操作系统与自动化操作方式">4. 操作系统与自动化操作方式</h4><p>操作系统与自动化操作控制：</p><ol type="1"><li>电子计算速度与机械输入/输出速度的矛盾</li><li>程序执行过程中输入作业，重叠时间</li></ol><p>需要多道程序同时执行，程序切换需要高速外存储设备</p><ol start="3" type="1"><li>磁盘设备出现，于是有了计算机操作系统，实现自动化控制</li></ol><h3 id="计算机操作系统">1.2.2 计算机操作系统</h3><h4 id="操作系统基本概念">1. 操作系统基本概念</h4><h4id="操作系统是计算机系统最基础的系统软件管理软硬件资源控制程序执行改善人机界面合理组织计算机工作流程为用户使用计算机提供良好运行环境">操作系统是计算机系统最基础的系统软件，管理软硬件资源、控制程序执行、改善人机界面，合理组织计算机工作流程，为用户使用计算机提供良好运行环境。</h4><h4 id="操作系统组成">2. 操作系统组成</h4><ol type="1"><li>进程调度子系统</li><li>进程通信子系统</li><li>内存管理子系统</li><li>设备管理子系统</li><li>文件管理子系统</li><li>网络通信子系统</li><li>作业控制子系统</li></ol><h4 id="操作系统分类">3. 操作系统分类</h4><p>从操作方式看：</p><ol type="1"><li>多道批处理操作系统，脱机控制方式</li><li>分时操作系统，交互式操作系统</li><li>实时操作系统</li></ol><p>按应用领域分类：</p><p>服务器操作系统、并行操作系统、网络操作系统、分布式操作系统、个人机操作系统、手机操作系统、嵌入式操作系统、传感器操作系统</p><p>普适计算 Pervasive/Ubiquitous Computing</p><p>物联网 Things of Internet, CPS</p><p>移动计算 Mobile Computing (移动互联网)</p><p>嵌入式的操作系统: μC/OS-II, VxWorks, LiteOS, 翼辉SylixOS......</p><p>移动终端的操作系统： Android, iOS, 鸿蒙OS......</p><p>C机器的OS: 微软的桌面系统</p><p>服务器的OS: CentOS, Ubuntu等Linux各类发行版, EulerOS, ...</p><h2 id="操作系统的不同视角">1.3 操作系统的不同视角</h2><h3 id="一资源管理的视角">一、资源管理的视角</h3><ol type="1"><li>计算机系统资源</li><li>软硬件资源管理</li><li>屏蔽资源底层使用细节</li><li>资源共享与分配</li></ol><p>计算机系统的资源：</p><p>· 硬件资源：处理器、内存、外设</p><p>· 信息资源：数据、程序</p><p>软硬件资源管理：</p><ol type="1"><li>处理器资源：占有处理器运行的程序</li><li>内存资源：程序、数据在内存中的分布</li><li>设备资源：分配、去配和使用资源</li><li>信息资源管理：访问文件信息</li><li>信号量资源：管理进程间通信</li></ol><p>屏蔽资源使用的底层细节</p><p>· 驱动程序：最底层的、直接控制和监视各类硬件资源的地方</p><p>隐藏底层硬件的具体细节，为其他部分提供抽象、具体的接口</p><p>资源的共享：独占与并发</p><p>资源的分配：</p><ol type="1"><li>静态分配：进程运行前一次拿到所有全部独占资源</li><li>动态分配：使用资源前临时申请</li></ol><p>可能产生竞争资源的死锁</p><p>资源抢占方式：被抢占资源的进程需要回滚执行</p><h3 id="二控制程序执行的视角">二、控制程序执行的视角</h3><ol type="1"><li>多道程序设计的概念</li><li>多道程序同时计算</li><li>多道程序设计优点</li><li>多道程序设计实现</li></ol><p>由于中央处理器速度和输入/输出速度不匹配的矛盾，只有让多道程序同时进入内存争抢中央处理器运行，才可以使中央处理器与外围设备充分并行，提高计算机系统使用效率。</p><p>多道程序设计：让多个程序同时进入计算机主存储器进行计算</p><p>特点：</p><ol type="1"><li>中央处理器与外部设备充分并行</li><li>外部设备间充分并行</li><li>发挥中央处理器使用效率</li><li>提高单位时间算题量</li><li>单道程序的运算时间会增加</li></ol><p>多道程序系统的实现：</p><ol type="1"><li>为进入内存执行的程序建立管理实体：进程</li><li>操作系统管理和控制进程程序的执行</li><li>操作系统协调管理各类资源在进程间使用</li></ol><p>· 处理器的管理与调度</p><p>· 主存储器的管理与调度</p><p>· 其他资源的管理与调度</p><p>实现要点：</p><ol type="1"><li>如何使用资源：调用操作系统提供的服务例程</li><li>如何复用中央处理器：调度程序，让其他程序在中央处理器空闲时运行</li><li>如何使中央处理器和输入/输出设备充分并行：设备控制器和通道</li><li>如何让正在运行的程序让出中央处理器：中断</li></ol><h3 id="三操作控制计算机的视角">三、操作控制计算机的视角</h3><ol type="1"><li>计算机操作控制方式</li><li>脱机作业控制方式</li><li>联机作业控制方式</li><li>命令解释程序及其处理过程</li></ol><p>计算机系统操作方式</p><ol type="1"><li>操作系统规定了合理操作计算机的工作流程</li><li>操作系统的操作接口：系统程序</li><li>两类作业级接口：</li></ol><p>脱机作业控制方式、联机作业控制方式</p><p>脱机作业控制方式(例如shell程序)</p><p>· 操作系统：提供作业说明语言</p><p>·用户：编写作业说明书，确定作业加工控制步骤，并与程序数据一起提交</p><p>· 操作员：通过控制台输入作业</p><p>· 操作系统：通过作业控制程序自动控制作业的执行</p><p>联机作业控制方式 (例如分时操作系统的交互控制方式)</p><p>· 计算机：提供终端 (键盘、显示器)</p><p>· 用户：登录系统</p><p>· 操作系统：提供命令解释程序</p><p>· 用户：联机输入操作控制命令，直接控制作业的执行</p><p>命令解释程序：接受和执行一条用户提出的对作业的加工处理命令</p><p>· 会话语言：可编程的命令解释语言</p><p>· 图形化的命令控制方式</p><p>· 多通道交互的命令控制方式</p><p>处理过程：</p><ol type="1"><li>操作系统启动命令解释程序，输出命令提示符，等待键盘中断、鼠标点击、多通道识别</li><li>每当用户输入命令并按回车换行，将命令暂存在命令缓冲区后，申请中断</li><li>中央处理器响应后，将控制权交给命令解释器程序，读入命令缓冲区内容，分析命令、接受参数，执行处理代码</li></ol><p>前台命令和后台命令</p><p>· 前台命令执行结束后，再次输出命令提示符，等待下一条命令</p><p>· 后台命令处理启动后，即可接收下一条命令</p><h3 id="四人机交互的视角">四、人机交互的视角</h3><ol type="1"><li>操作系统的人机交互部分</li><li>操作系统人机交互技术的发展</li><li>操作系统WIMP界面</li><li>多媒体计算机的人机交互</li><li>虚拟现实系统的人机交互</li></ol><p>操作系统的人机交互部分</p><ol type="1"><li>操作系统改善人机界面，为用户使用计算机提供良好的环境</li><li>人机交互设备包括传统终端设备和新型模式识别设备</li><li>人机交互部分用于控制有关设备运行、理解执行设备传来命令</li><li>人机交互功能决定了计算机系统的友善性</li></ol><p>人机交互的发展</p><p>交互式控制方式：</p><p>· 行命令控制方式：1960年代开始使用</p><p>· 全屏幕控制方式：1970年代开始使用</p><p>人，而不是技术，是人机交互的中心</p><p>——&gt;鼠标、菜单、窗口控制</p><p>WIMP界面：</p><p>窗口(Window)、图标(Icon)、菜单(Menu)、指示装置(Pointing Devices)</p><p>1990年代开始广泛使用。</p><p>不足：不能同时使用多个交互通道，产生人机交互的不平衡。</p><p>多媒体计算机：将音频视频、图形图像和人机交互控制结合，进行综合处理</p><p>虚拟现实系统：VR</p><h3 id="五-程序接口的视角">五、 程序接口的视角</h3><ol type="1"><li>操作系统的程序接口</li><li>系统调用的实现机制</li><li>系统调用的实现要点</li><li>系统调用的实现流程</li></ol><p>操作系统的程序接口：操作系统为程序运行扩充的编程接口</p><p>系统调用：操作系统实现的完成某种特定功能的过程</p><p>POSIX支持</p><p>系统调用的实现机制：中断</p><p>系统调用的实现要点：</p><ol type="1"><li>编写系统调用处理程序</li><li>系统调用入口地址表</li><li>系统调用时，需保存当时的处理器情况</li></ol><p>系统调用的实现流程</p><figure><img src="image/系统调用的实现流程.png" alt="系统调用的实现流程" /><figcaption aria-hidden="true">系统调用的实现流程</figcaption></figure><h3 id="六系统结构的视角">六、系统结构的视角</h3><ol type="1"><li>操作系统软件的规模</li><li>操作系统的构件和设计原则</li><li>操作系统内核</li><li>操作系统实现的层次式结构模型</li></ol><p>操作系统时计算机软件发展史上第一个大规模软件系统。</p><p>操作系统软件的结构设计</p><p>· 操作系统构件：内核、进程、线程、管程等</p><p>· 设计概念：模块化、层次化、虚拟化</p><p>· 内核设计是操作系统设计中最为复杂的部分</p><p>操作系统内核</p><ol type="1"><li>单内核：内核中各部件杂然混居</li><li>微内核：结构性部件与功能性部件分离</li><li>混合内核：微内核和单内核的折中，较多组件在核心态中运行以更快执行</li><li>外内核：减少内核的软件抽象化和传统微内核的消息传递机制，使得开发者专注于硬件的抽象化</li></ol><p>操作系统实现的一种层次式结构：</p><p>· 用户模式：用户与文件系统</p><p>·内核模式：进程交互、输入/输出设备管理、虚拟内存、基本进程管理、硬件</p><p>另一种层次式结构：</p><ol type="1"><li>用户：命令、进程、库、环境</li><li>文件系统调用：用户进程管理、目录管理、设备文件、文件系统、管道等高阶通信</li><li>软硬件协同内核：内存与虚拟内存管理、块设备管理与输入/输出控制、核心进程管理和控制与通信原语、中断管理</li><li>硬件电路：过程机制、指令解译、电路执行</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-4.0_树</title>
    <link href="/2022/12/30/Chapter4.0_Tree/"/>
    <url>/2022/12/30/Chapter4.0_Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter4.0tree-树">Chapter4.0：Tree 树</h1><span id="more"></span><h4 id="两类数据结构">两类数据结构</h4><ul><li>线性：列表、栈、队列、字符串</li><li>非线性：树、图</li></ul><h2 id="一树">一、树</h2><h3 id="定义">定义</h3><p>一棵树是一些结点的集合。<br />集合可以为空，否则，这棵树具有一个特殊的称为根的结点，以及零棵或更多非空子树。</p><h3 id="术语">术语</h3><p>结点的度数为其所具有的后代数。<br />树的度数是其结点度数的最大值。<br />度数为0的结点称为叶，度数非0的结点称为枝。<br />层级：根的层级为0(1)，其余结点的层级为其父结点加1。<br />树高：结点的最高层级。</p><h2 id="二二叉树">二、二叉树</h2><h3 id="定义-1">定义</h3><p>一棵二叉树是一些有限个结点的(可以为空)集合。</p><p>当二叉树非空： * 它有一个根结点。 *其余的结点被分为两个二叉树，称为根的左子树和右子树。</p><p>二叉树与树的区别 1.二叉树的每个结点都有且仅有两个子树(可以为空)，而树的每个结点可以有任意个子树。2. 二叉树的结点的左右子树是有顺序区别的，而树的结点的子树是无序的。</p><h3 id="二叉树的性质">二叉树的性质</h3><ol type="1"><li>有n个结点的二叉树有n-1条边。</li><li>在第i层的结点树最多为2^i。</li><li>高度为h的二叉树最少有h+1个结点，最多有2^(h+1)-1个结点</li><li>如果叶的数量为x，度数为2的结点树为y，那么x=y+1</li><li>包含n个结点的二叉树的树高最多为n-1，虽少为[log(n+1)]-1。(底为2)</li></ol><h4 id="满二叉树">满二叉树</h4><p>树高h，包含2^(h+1)-1个结点的二叉树为满二叉树。</p><h4 id="完全二叉树">完全二叉树</h4><p>一棵树高为k的有n个结点的二叉树，如果对树中的结点按从上到下、从左到右的顺序进行编号，编号为i的结点与满二叉树中编号为i的结点位置相同，则这棵二叉树为完全二叉树。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-3.1_栈与队列</title>
    <link href="/2022/12/06/Chapter3.1_Stack&amp;Queue/"/>
    <url>/2022/12/06/Chapter3.1_Stack&amp;Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter3.1stack-queue-栈与队列">Chapter3.1：Stack Queue栈与队列</h1><span id="more"></span><h2 id="一栈">一、栈</h2><p>栈是插入与删除发生在同一端的列表，该端称为顶部，另一端称为底部。栈也被称为LIFO(Last In First Out)列表</p><h3 id="栈的模型">栈的模型</h3><p>Abstract Data Type: Stack：<br />instances: list of elements<br />operations:<br />Create(): Create an empty stack<br />IsEmpty()<br />IsFull()<br />Top(): Return top element of the stack<br />Add(x): add element x to the stack<br />Delete(x) :Delete top element from stack and put it in x</p><h3 id="栈的链表实现">栈的链表实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span>&#123;topOfStack = <span class="hljs-literal">null</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> topOfStack == <span class="hljs-literal">null</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">()</span>&#123;topOfStack = <span class="hljs-literal">null</span>;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(object x)</span>&#123;<br>    topOfStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(x, topOfStack);<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">top</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> topOFStack.element;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Underflow&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty())<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Underflow</span>();<br>    topOfStack = topOfStack.next;<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">topAndPop</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">topItem</span> <span class="hljs-operator">=</span> topOfStack.element;<br>    topOfStack = topOfStack.next;<br>    <span class="hljs-keyword">return</span> topItem;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> ListNode topOfStack;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈的数组实现">栈的数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span>&#123;<span class="hljs-built_in">this</span>(DEFAULT_CAPACITY);&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>    array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">object</span>[capacity];<br>    topOfStack = -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> topOfStack==-<span class="hljs-number">1</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> topOfStack==theArray.length–<span class="hljs-number">1</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">()</span>&#123;topOfStack=-<span class="hljs-number">1</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(object x)</span> <span class="hljs-keyword">throws</span> overflow&#123;<br>    <span class="hljs-keyword">if</span>(isFull()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Overflow</span>();<br>    array[++topOfStack] = x;<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">top</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> array[topOfStack];<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Underflow&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Underflow</span>();<br>    array[topOfStack--] = <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">topAndPop</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">topItem</span> <span class="hljs-operator">=</span> top();<br>    array[topOfStack--] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> topItem;<br>  &#125;<br>  <span class="hljs-keyword">private</span> object[] array;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> topOfStack;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>多个栈的存在会导致空间的浪费，当只有两个栈时，我们可以将两个栈在同一个线性表的两端进行存储，两者向中间延伸。</p><h3 id="栈的应用">栈的应用</h3><ul><li>括号匹配</li></ul><h2 id="二队列">二、队列</h2><p>队列是插入和删除发送在两端的线性表，新元素插入的地方称为尾部，旧元素删除的地方称为首部。队列也被称为FIFO(First In First Out)列表。</p><h3 id="队列的模型">队列的模型</h3><p>Abstract Data Type: Queue: instances: ordered list of elementsoperations: Create(): Create an empty queue IsEmpty() IsFull() First():return first element of the queue Last(): return last element of thequeue Add(x): add element x to the queue Delete(x): delete front elementfrom the queue and put it in x</p><h3 id="队列的数组实现">队列的数组实现</h3><p>元素的增加：++back; array[back]=x;<br />元素的删除：两种办法<br />1. ++front; O(1)<br />2. 将整个队列左移 O(n)<br />可以使用循环数组来表示队列，方法有二<br />1. 分类讨论头和尾抵达了数组边界的情况 2. back = (back+1)%array.length;front = (front+1)%array.length</p><h3 id="队列的链表实现">队列的链表实现</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-2.0_算法分析</title>
    <link href="/2022/12/06/Chapter2.0_AlgorithmAnalysis/"/>
    <url>/2022/12/06/Chapter2.0_AlgorithmAnalysis/</url>
    
    <content type="html"><![CDATA[<h2 id="chapter2.0算法分析">Chapter2.0：算法分析</h2><span id="more"></span><p>算法是为解决问题而定义的一系列方法。算法分析主要在于算法占用的时间与空间。算法分析的两个方法：性能分析和性能度量</p><h3 id="空间复杂度">1. 空间复杂度</h3><p>运行完成程序需要的内存空间 组成：指令、数据、环境栈空间此处讨论的存储器主要指内存。 #### (1) 指令空间程序编译成的二进制码的空间大小 又称代码空间本课程中，我们默认忽略指令空间原因：操作系统对代码所占的内存具有一些管理机制，代码所占内存有限 ####(2) 数据空间 定长部分：包含指令、简单变量、定长度的成员变量、常量的内存变长部分：随数据变化而变化的部分，如递归栈、动态分配区域一般而言，变长部分更为重要。 #### (3) 环境栈空间</p><h3 id="时间复杂度">2. 时间复杂度</h3><p>运行完成程序需要的时间长度<br />编译时间不被计算进时间复杂度。<br />计算程序的时间复杂度，关键操作个数是核心，循环中操作个数格外重要。</p><h4 id="最好最差和平均的复杂度分析">最好、最差和平均的复杂度分析</h4><p>平均复杂度往往难以定义。<br />使用算术平均值作为平均复杂度(假设所有情况等概率)是简化的运算，不能完全代表平均情况。</p><p>步骤数计算：count++；</p><h4 id="算法的渐进分析">算法的渐进分析</h4><p>记号：O、𝛺、o、𝜃</p><h5 id="o表示法">O表示法</h5><p>表示算法复杂度的上限<br />定义：f(n)=O(g(n))，即当n尽量大时，存在c，f(n)&lt;=cg(n)。</p><h5 id="o表示法-1">o表示法</h5><p>定义：f(n)=o(g(n))，即当n尽量大时，存在c，f(n)&lt;cg(n)。当前算法复杂度小于该量级。</p><h5 id="𝛺表示法">𝛺表示法</h5><p>表示算法复杂度的下界<br />定义：f(n)=𝛺(g(n))，即当n尽量大时，存在c，f(n)&gt;=cg(n)。</p><h5 id="𝜃表示法">𝜃表示法</h5><p>表示和算法复杂度同等的两级<br />f(n)=𝜃(g(n))，即当n尽量大，存在，，使g(n)&lt;=f(n)&lt;=g(n)。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-1.0_绪论</title>
    <link href="/2022/12/06/Chapter1.0_Intro/"/>
    <url>/2022/12/06/Chapter1.0_Intro/</url>
    
    <content type="html"><![CDATA[<h2 id="chapter1.0绪论">Chapter1.0：绪论</h2><span id="more"></span><p>课程主要是学习数据结构而不倾于算法结构</p><ol type="1"><li><p>关心数据类型和数据处理步骤</p></li><li><p>处理更加复杂、难以计算的部分</p></li><li><p>不依赖于特定编程语言</p></li><li><p>介绍常用算法和数据结构</p></li><li><p>后置课程 ·编译原理 ·操作系统 ·数据库</p></li></ol><h3 id="什么是数据结构">什么是数据结构</h3><ol type="1"><li>数据 数据是信息的载体，是数字、字符和其他符号组成的集合。数据可用于描述客观世界。表示数据的符号可以输入计算机，被计算机识别和处理。 数据分类：</li></ol><ol type="1"><li>数值型(numerical)：int, float, complex</li><li>非数值型(non-numerical)：character, string, graph, voice</li></ol><ol start="2" type="1"><li>数据结构 数据结构是数据对象以及对象各成员间关系的统称。数据结构分类：线性结构(linear structure)与非线性(non-linear)结构</li></ol><p>数据结构是分层的 数据结构涉及三个方面：数据的逻辑结构——从用户视图看，是面向问题的。数据的物理结构——从具体实现视图看，是面向计算机的。相关的操作及其实现。</p><p>Example：学生表 逻辑结构——线性表 物理结构——数组、链表操作——插入、删除、查找</p><p>数据类型：具有操作该类值的操作集的值的集合 大多编程语言具有Atom DataTypes和Structure Data Types两类预定义的数据结构。</p><ol start="3" type="1"><li>ADT和OO ADT：Abstract Data Types 抽象数据类型是将类型和与这个类型有关的操作集合封装在一起的数据模型。OO：Object-oriented 三个方面（考试）：封装、继承、多态 类与继承</li></ol><h3 id="算法">算法</h3><p>算法定义：为了解决某个问题的一系列操作 特点： 1. 明确输入 2. 明确输出3. 确定性 4. 可行性 5. 有穷性</p><p>Deterministic算法：当给固定输入，会有固定输出程序：用编程语言编写，可以在机器上运行，不满足有穷性。</p><h3 id="数学复习">数学复习</h3><p>log底数默认为2。<br />同余：A≡B(mod N)<br />数学归纳法：<br />1. Basis 2. Inductive hypothesis 3. Inductive proof 反证法</p><p>算法思想：递归、分治、贪心、线性规划</p><p>递归：Base cases + Making progress<br />* 直接递归：函数自己调用自己<br />* 间接递归：多个函数相互调用形成环状调用的递归</p><p>泛型 Generic<br />将类型设置为变量。<br />应当尽量避免代码克隆。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MIME</title>
    <link href="/2022/10/30/MIME/"/>
    <url>/2022/10/30/MIME/</url>
    
    <content type="html"><![CDATA[<p>媒体类型(Multipurpose Internet MailExtensions，MIME)是用来表示文档、文件或字节流的性质和格式的一种标准。<span id="more"></span></p><h2 id="语法">语法</h2><h3 id="通用结构">通用结构</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span>/<span class="hljs-keyword">subtype</span><br></code></pre></td></tr></table></figure><p>由类型和子类型两个字符串中间用'/'分隔组成，不允许空格存在。type为可以被分为多个子类的独立类别，subtype为细分后的每个类型。MIME对大小写不敏感，但一般使用小写。</p><table><thead><tr class="header"><th style="text-align: center;">类型</th><th style="text-align: center;">描述</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>text</code></td><td style="text-align: center;">普通文本</td><tdstyle="text-align: center;"><code>text/plain</code>,<code>text/html</code>,<code>text/css</code>,<code>text/javascript</code></td></tr><tr class="even"><td style="text-align: center;"><code>image</code></td><td style="text-align: center;">某种图像，包括动态图但补包括视频</td><tdstyle="text-align: center;"><code>image/gif</code>,<code>image/png</code>,<code>image/jpeg</code></td></tr><tr class="odd"><td style="text-align: center;"><code>audio</code></td><td style="text-align: center;">某种音频文件</td><tdstyle="text-align: center;"><code>audio/midi</code>,<code>audio/mpeg</code>,<code>audio/wav</code></td></tr><tr class="even"><td style="text-align: center;"><code>video</code></td><td style="text-align: center;">某种视频文件</td><tdstyle="text-align: center;"><code>video/webm</code>,<code>video/ogg</code></td></tr><tr class="odd"><td style="text-align: center;"><code>application</code></td><td style="text-align: center;">某种二进制数据</td><tdstyle="text-align: center;"><code>application/octet-stream</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>networkProject</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程</title>
    <link href="/2022/10/25/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/10/25/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>网络编程是指编写运行在多个通过网络连接的主机的程序。<span id="more"></span></p><blockquote><p>java.net包提供了两种网络协议的支持：TCP和UDP<br />* TCP（Transmission ControlProtocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP层是位于IP层之上，应用层之下的中间层。TCP保障了两个应用程序之间的可靠通信。通常用于互联网协议，称为TCP/IP。<br />* UDP（User Datagram Protocol，用户数据报协议）位于 OSI模型的传输层，是一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。</p></blockquote><h2 id="一java-socket编程">一、Java Socket编程</h2><p>在网络编程中，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。<br />Socket套接字是支持TCP/IP协议的网络通信的基本操作单元，它包含了进行网络通信必须的五种信息：- 连接使用的协议<br />- 本地主机的IP地址<br />- 本地进程的协议端口<br />- 远程主机的IP地址<br />- 远程进程的协议端口</p><h3 id="套接字的连接过程">1、套接字的连接过程</h3><p>服务器监听、客户端请求、连接确认 1.服务器套接字处于等待连接的状态，实时监控网络状态 2.客户端的套接字提出连接请求以连接服务端套接字。为此，客户端套接字需要服务器套接字的地址和端口号3.服务器套接字监听到并响应客户端套接字，建立一个新的线程，将服务端套接字的描述发给客户端。</p><h3 id="socket的基本工作过程">2、Socket的基本工作过程：</h3><ol type="1"><li>创建Socket</li><li>创建连接Socket的IO流</li><li>按一定协议对Socket进行读写操作</li><li>关闭Socket</li></ol><h3 id="java-socket简单的服务端与客户端程序">3、JavaSocket：简单的服务端与客户端程序</h3><h4 id="服务端">服务端：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">sock</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(sock.getInputStream());<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);<br>            String message;<br>            message = bufferedReader.readLine();<br>            System.out.println(message);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Server</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();<br>        server.execute();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="客户端">客户端：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(socket.getOutputStream());<br>            <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream());<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);<br>            System.out.println(<span class="hljs-string">&quot;Connection succeeded.&quot;</span>);<br>            writer.println(<span class="hljs-string">&quot;Happy Birthday!&quot;</span>);<br>            writer.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>();<br>        client.execute();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二io-模型">二、IO 模型</h2><h3 id="同步和异步">1、同步和异步</h3><ul><li>同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回</li><li>异步：异步就是发起一个调用后，立即得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他请求。</li></ul><p>被调用者通常依靠事件、回调等机制来通知调用者其返回结果。<br />两者的最大区别在于，异步的情况下，调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。</p><h3 id="阻塞和非阻塞">2、阻塞和非阻塞</h3><ul><li>阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li><li>非阻塞：非阻塞就是发起一个请求，调用者不用已知等着结果返回，可以从事其他任务。</li></ul><p>Java Socket在调用accept、read等方法时，会发生阻塞</p><h3 id="java支持的三种io模型">3、Java支持的三种IO模型</h3><ul><li>BIO（Blocking IO，同步阻塞IO）：一个线程处理一个连接</li><li>NIO（Non-blocking IO，同步非阻塞IO）：一个线程处理多个连接</li><li>AIO（Asynchronous IO，异步非阻塞IO）：通道异步</li></ul><h4 id="bio">BIO</h4><p>在Server中建立ServerSocket对象，绑定端口，等待连接，若连接成功就新建一个进程去处理连接。</p><p>BIO的缺点：资源的浪费，每个客户端的连接都需要占用一个进程。</p><h4 id="nio">NIO</h4><p>相关类处于java.nio包中。<br /><img src="/img/networkProject/NIO图解.jpeg" title="NIO 图解"alt="NIO 图解" /><br />NIO的三大核心部分：Selector(选择器)、Channel(通道)、Buffer(缓冲区)<br />* Buffer：数据从Channel读入Buffer，又从Buffer写入Channel<br />在Java中，Buffer是一个抽象类，具有ByteBuffer、CharBuffer等子类，采用相似方法管理不同数据类型。<br />具有的基本属性：<br />- 容量：Buffer作为一个内存块所具有的一定大小，不能为负且创建后不可更改。-限制：Buffer中可以操作数据的大小，不能为负且小于等于其容量。写入模式下，限制等于buffer的容量，读取模式下，限制等于写入的数据量。- 位置：下一个要读取或写入的数据的索引，不能为负且不能大于限制。 -标记：通过mark方法指定Buffer中一个特定的位置，之后可以调用reset方法恢复到这个位置。</p><p>Java Buffer存取数据的两个基本办法： - put()在Buffer的当前位置写入内容 - get() 获取Buffer数据 *Channel：IO源与目标打开的连接，不能直接访问数据，只能与Buffer进行交互。<br />在Java中，Channel是一个接口，具有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等实现</p><p>Java Channel读写数据的基本办法： - read() - write()</p><ul><li>Selector<br />Selector会不断轮询注册在上的所有channel，并发现处于就绪状态的channel。<br />使用步骤：</li></ul><ol type="1"><li>使用静态工厂办法open()获取选择器： <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span> = <span class="hljs-keyword">Selector</span>.open()<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li><li>获取可选择通道。该通道必须实现SelectableChannel接口并为非阻塞模式。</li><li>将通道注册到选择器，并告知监控的事件： <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">SelectableChannel.register(<span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span>, int ops)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li><li>调用Selector.select()，该方法将就绪事件放在SelectedKey集合中，并返回就绪事件数，这是个阻塞方法，直到至少有一个就绪事件，或其它县城调用当前Selector对象的wakeup()方法，或当前线程中断时返回。<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-keyword">while</span>(selector.<span class="hljs-built_in">select</span>() &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">Set</span>&lt;SelectionKey&gt; <span class="hljs-built_in">keys</span> = selector.selectedKeys();<br>&#125;<br></code></pre></td></tr></table></figure>给select()赋予一个long类型的参数可以限制其阻塞时间；selectNode()不阻塞，无就绪事件则返回0。<br /></li><li>处理就绪事件</li></ol><p>Channel和Buffer的基本操作 1. 分别建立连接文件和Socket的Channel 2.建立所需类型（Byte，等等）的Buffer，分配内存 3.从Channel中将数据读入Buffer/使用Channel从Buffer中读取数据 4.关闭Channel</p><h4 id="aio">AIO</h4>]]></content>
    
    
    <categories>
      
      <category>networkProject</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Geternitier的博客</title>
    <link href="/2022/10/20/%E5%A4%A9%E9%A9%AC%E6%AD%8C/"/>
    <url>/2022/10/20/%E5%A4%A9%E9%A9%AC%E6%AD%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="天马歌">天马歌</h3><span id="more"></span><p>唐·李白</p><p>天马来出月支窟，背为虎文龙翼骨。<br />嘶青云，振绿发， 兰筋权奇走灭没。<br />腾昆仑，历西极，四足无一蹶。<br />鸡鸣刷燕晡秣越，神行电迈蹑慌惚。<br />天马呼，飞龙趋， 目明长庚臆双凫。<br />尾如流星首渴乌，口喷红光汗沟朱。 曾陪时龙蹑天衢，羁金络月照皇都。<br />逸气棱棱凌九区，白璧如山谁敢沽。<br />回头笑紫燕，但觉尔辈愚。<br />天马奔， 恋君轩，駷跃惊矫浮云翻。<br />万里足踯躅，遥瞻阊阖门。<br />不逢寒风子，谁采逸景孙。<br />白云在青天，丘陵远崔嵬。 盐车上峻坂，倒行逆施畏日晚。<br />伯乐翦拂中道遗，少尽其力老弃之。<br />愿逢田子方，恻然为我悲。<br />虽有玉山禾，不能疗苦饥。<br />严霜五月凋桂枝，伏枥衔冤摧两眉。<br />请君赎献穆天子，犹堪弄影舞瑶池。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
