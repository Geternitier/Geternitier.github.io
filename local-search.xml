<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>软件质量管理_工程技术</title>
    <link href="/2024/06/24/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/4.%20%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/06/24/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/4.%20%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="工程技术">4. 工程技术</h1><h2 id="需求">4.1 需求</h2><ol type="1"><li>需求开发</li></ol><p>需求是一切工程活动的基础。</p><p>需求类别：</p><ul><li>客户需求</li><li>产品需求</li><li>产品组件需求</li></ul><ol start="2" type="1"><li>需求获取</li></ol><p>客户所受到的限制也应当作为需求开发过程中需要重点关注的内容。</p><ul><li><p>通常采取所谓的需求“诱导”方式进行。</p></li><li><p>“诱导”一词的含义不仅仅是普通的需求采集，它隐含了应更加积极地、前瞻性地识别那些客户没有明确提供的额外需求。</p></li></ul><ol start="3" type="1"><li>需求汇总</li></ol><ul><li>整理各种来源的信息，识别缺失的信息</li><li>解决冲突的需求</li><li>需求的整理和转化</li><li>推导未显式描述的需求内容</li></ul><ol start="4" type="1"><li>需求验证</li></ol><p>对需求进行分析和确认，以确保符合使用者预期</p><p>典型活动包括</p><ul><li>建立和维护操作概念和相关的场景</li><li>分析需求</li><li>确认需求</li></ul><ol start="5" type="1"><li>需求文档</li></ol><p>需求开发工作完成的一个基本标志是形成了一份完整的、规范的、经过评审的需求规格说明书。</p><p>需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。</p><p>特征：内聚、完整、一致、原子、可跟踪、非过期、可行性、非二义性、强制、可验证</p><h2 id="设计">4.2 设计</h2><p>考虑点：</p><ol type="1"><li><p>团队智慧</p><p>发挥团队智慧两大挑战：</p><ul><li>确定整体架构之前很难进行分工</li><li>鼓励团队成员在讨论和评审会议中的参与程度</li></ul></li><li><p>设计标准</p><p>命名规范、接口标准、系统出错信息、设计表示标准</p></li><li><p>复用</p><p>建立一套复用管理流程，具体而言，包括</p><ul><li><p>复用接口标准</p></li><li><p>复用文档标准</p></li><li><p>复用质量保证机制</p></li></ul></li><li><p>可测试性</p><p>尽可能减少测试代码的数量，制作合理的测试计划。</p></li><li><p>可用性</p><ul><li>在设计阶段就开始考虑。</li><li>针对每一个关键功能都定义操作概念和操作场景。</li><li>可以邀请最终用户参与场景的评审，使用模拟、原型等技术，更好的把握用户真实意图。</li></ul></li></ol><h2 id="实现">4.3 实现</h2><p>考虑点：评审、复用、可用性。</p><h2 id="集成">4.4 集成</h2><ul><li>大爆炸集成策略</li><li>逐一添加集成策略</li><li>集簇集成策略</li><li>扁平化集成策略</li></ul><h2 id="验证和确认">4.5 验证和确认</h2><p>都是为了提升最终产品的质量而采取的措施。</p><p>目的不同。</p><ul><li><p>验证是目的是确保选定的工作产品与事先指定给该工作产品的需求一致。</p></li><li><p>确认的目标则是确保开发完成的产品或者产品组件在即将要使用该产品或者产品组件的环境中工作正确。</p></li></ul><p>验证和确认活动：</p><ol type="1"><li><p>环境准备</p></li><li><p>对象选择</p></li><li><p>活动实施</p></li><li><p>结果分析</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件质量管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件质量管理_质量管理</title>
    <link href="/2024/06/23/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/3.%20%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    <url>/2024/06/23/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/3.%20%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="质量管理">3. 质量管理</h1><h2 id="概念">3.0 概念</h2><p>软件质量：</p><p>与软件产品满足规定的和隐含的需求能力有关的特征或者特性的全体。</p><h3 id="面向用户的质量观">3.0.1 面向用户的质量观</h3><p>定义质量为满足用户需求的程度。在这个定义中，就需要进一步明确：</p><ul><li>用户究竟是谁？</li><li>用户需求的优先级是什么？</li><li>这种用户的优先级对软件产品的开发过程产生什么样的影响？</li><li>怎样来度量这种质量观下的质量水平？</li></ul><h3 id="质量管理策略">3.0.2 质量管理策略</h3><p>用缺陷管理来替代质量管理。</p><ul><li><p>高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷。</p></li><li><p>PSP：各个组件的高质量是通过高质量评审来实现的</p></li></ul><h4 id="测试消除缺陷流程">测试消除缺陷流程</h4><ol type="1"><li>发现异常行为</li><li>理解工作方式</li><li>找出出错原因</li><li>确定修改方案</li><li>测试修改有效</li></ol><h4 id="评审发现缺陷流程">评审发现缺陷流程</h4><ol type="1"><li>理解程序流程</li><li>发现缺陷的位置和原因</li><li>修正缺陷</li></ol><h2 id="评审">3.1 评审</h2><h3 id="质量控制指标">3.1.1 质量控制指标</h3><h4 id="yield">Yield</h4><p>度量每个阶段在消除缺陷方面的效率。</p><ul><li>Phase Yield = <spanclass="math inline">\(100\times\frac{某阶段发现的缺陷个数}{某阶段注入的缺陷个数+进入该阶段前遗留的缺陷个数}\)</span></li><li>Process Yield = <spanclass="math inline">\(100\times\frac{第一次编译前发现的缺陷个数}{第一次编译前注入的缺陷个数}\)</span></li></ul><h4 id="afr">A/FR</h4><p>PSP质检成本/PSP失效成本。</p><ul><li>理论上，A/FR的值越大，往往意味着越高的质量。</li><li>过高的A/FR往往意味着做了过多的评审，反而会导致开发效率的下降。</li><li>作为指南，在PSP中A/FR的期望值就是2.0。</li></ul><h4 id="pqi">PQI</h4><p>5个数据乘积：</p><ul><li>设计质量：设计的时间应该大于编码的时间</li><li>设计评审质量：设计评审的时间应该大于设计时间的50%</li><li>代码评审质量：代码评审时间应该大于编码时间的50%</li><li>代码质量：代码的编译缺陷密度应当小于10个/千行</li><li>程序质量：代码单元测试缺陷密度应当小于5个/千行</li></ul><h4 id="评审速度">评审速度</h4><p>评审速度(Review Rate)是一个用以指导软件工程师开展有效评审的指标。</p><ul><li>高质量的评审需要软件工程师投入足够的时间进行评审。</li><li>在PSP的实践中，代码评审速度小于200 LOC/小时，文档评审速度小于4Page/小时。</li></ul><h4 id="drl">DRL</h4><p>缺陷消除效率比，度量的是不同缺陷消除手段消除缺陷的效率。</p><ul><li><p>计算方式：</p><p>以某个测试阶段（一般为单元测试）每小时发现的缺陷数为基础，其他阶段每小时发现缺陷数与该测试阶段每小时发现的缺陷的比值就是DRL。</p></li></ul><h3 id="其他因素">3.1.2 其他因素</h3><p>打印后评审往往效果更好</p><ul><li>单个屏幕可以展现的内容比较有限</li><li>评审人员的注意力</li></ul><p>评审时机选择：编译（UT）之前 VS. 之后</p><p>个人评审和小组评审</p><ul><li><p>小组评审意义</p></li><li><p>先后顺序</p></li></ul><h2 id="质量路径">3.2 质量路径</h2><h3 id="质量路径-1">3.2.1 质量路径</h3><p>Step 1：各种测试</p><p>Step 2：进入测试之前的产物质量提升</p><p>Step 3：评审过程度量和稳定</p><p>Step 4：质量意识和主人翁态度</p><p>Step 5：个体review的度量和稳定</p><p>Step 6：诉诸设计</p><p>Step 7：缺陷预防</p><p>Step 8：用户质量观——其他质量属性</p><h3 id="设计">3.2.2 设计</h3><h4 id="设计内容">设计内容</h4><table><thead><tr class="header"><th></th><th><strong>动态信息</strong></th><th><strong>静态信息</strong></th></tr></thead><tbody><tr class="odd"><td><strong>外部信息</strong></td><td>交互信息（服务、消息等）</td><td>功能（继承、类结构等）</td></tr><tr class="even"><td><strong>内部信息</strong></td><td>行为信息（状态机）</td><td>结构信息（属性、业务逻辑等）</td></tr></tbody></table><h5 id="psp设计模板">PSP设计模板</h5><ul><li><p>操作规格模板（Operational Specification Template，简称OST）</p></li><li><p>功能规格模板（Functional Specification Template，简称FST）</p></li><li><p>状态规格模板（State Specification Template，简称SST）</p></li><li><p>逻辑规格模板（Logical Specification Template，简称LST）</p></li></ul><table><thead><tr class="header"><th></th><th><strong>动态信息</strong></th><th><strong>静态信息</strong></th></tr></thead><tbody><tr class="odd"><td><strong>外部信息</strong></td><td>OST/FST</td><td>FST</td></tr><tr class="even"><td><strong>内部信息</strong></td><td>SST</td><td>LST</td></tr></tbody></table><h5 id="uml图">UML图</h5><table><thead><tr class="header"><th></th><th><strong>动态信息</strong></th><th><strong>静态信息</strong></th></tr></thead><tbody><tr class="odd"><td><strong>外部信息</strong></td><td>用例图、时序图</td><td>类图</td></tr><tr class="even"><td><strong>内部信息</strong></td><td>状态机图</td><td>？</td></tr></tbody></table><h4 id="设计层次">设计层次</h4><figure><img src="/image/软件质量管理/设计层次.png" alt="设计层次" /><figcaption aria-hidden="true">设计层次</figcaption></figure><p>PSP模板</p><figure><img src="/image/软件质量管理/PSP设计模板.png" alt="PSP设计模板" /><figcaption aria-hidden="true">PSP设计模板</figcaption></figure><h3 id="设计评审">3.2.3 设计评审</h3><h4 id="状态机验证">状态机验证</h4><p>正确状态机：完整、正交</p><p>验证方法：</p><ul><li>检验状态机，消除死循环和陷阱状态。</li><li>检查状态转换，验证完整性和正交性。</li><li>评价状态机，检验是否体现设计意图。</li></ul><h4 id="符号化执行">符号化执行</h4><p>符号化验证方法的基本思想是将描述设计的逻辑规格（一般用伪代码程序表示）用代数符号来表示，然后系统地开展分析和验证。具体步骤如下：</p><ol type="1"><li>识别伪码程序中的关键变量</li><li>将这些变量用代数符号表示，重写伪码程序</li><li>分析伪码程序的行为</li></ol><p>优缺点：</p><ol type="1"><li><p>实施简单，可以给出一般化的验证结果。</p></li><li><p>通常用在验证一些复杂算法中，特别是对遗留系统的改造中，往往应用这种方法来识别和理解原有的设计。</p></li><li><p>不适用于有复杂逻辑的场合，而且，纯手工的验证方法也容易引入一些人为的错误。</p></li></ol><h4 id="执行表">执行表</h4><p>用一种有序的方法来跟踪伪码程序的执行状况，分析程序行为，从而验证设计。具体步骤如下：</p><ol type="1"><li>识别伪码程序的关键变量</li><li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量</li><li>初始化被选定的变量</li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ol><h4 id="跟踪表">跟踪表</h4><p>跟踪表验证方法是对执行表验证方法的一种扩充。具体步骤如下：</p><ol type="1"><li>识别伪码程序的关键变量</li><li>构建表格，表格左侧填入主要程序步骤，右侧填入关键变量</li><li>初始化被选定的变量</li><li>识别将伪码程序符号化的机会，并加以符号化</li><li>定义并且优化用例组合</li><li>跟踪被选择的关键变量的变化情况，从而判断程序行为。</li></ol><h4 id="正确性检验">正确性检验</h4><p>将伪码程序当成数学定理，采用形式化方法加以推理和验证。这种方法的步骤如下：</p><ol type="1"><li>分析和识别用例</li><li>对于复杂伪码程序的结构，应用正确性检验的标准问题逐项加以验证</li><li>对于不能明确判断的复杂程序结构，使用跟踪表等辅助验证。</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件质量管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件质量管理_项目管理</title>
    <link href="/2024/06/22/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/2.%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <url>/2024/06/22/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/2.%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="项目管理">2. 项目管理</h1><p>管理的三大关键要素：</p><ul><li>目标</li><li>状态</li><li>纠偏</li></ul><h2 id="概念">2.0 概念</h2><p>应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。</p><h3 id="三大目标">三大目标</h3><p>成本、质量、工期。</p><h2 id="团队动力学">2.1 团队动力学</h2><h3 id="知识工作">2.1.1 知识工作</h3><p>软件开发是一项既复杂又富有创造性的知识工作。</p><ul><li>处理和讨论极其抽象的概念</li><li>把不同的部分（不可见）整合成一个可以工作的系统</li></ul><h4 id="知识工作管理">知识工作管理</h4><p>关键规则：管理者无法管理工作者，知识工作者必须实现并且学会自我管理。</p><p>知识工作者必须</p><ul><li>有积极性</li><li>能做出准确的估算和计划</li><li>懂得协商承诺</li><li>有效跟踪他们的计划</li><li>持续地按计划交付高质量产物</li></ul><h4 id="领导者">领导者</h4><p>知识工作者的管理需要的是领导者，而不是经理。</p><h4 id="激励手段">激励手段</h4><p>三种主要手段</p><ol type="1"><li>威逼</li><li>利诱</li><li>鼓励承诺</li></ol><h5 id="领导方式">领导方式</h5><p>交易型</p><ul><li>承诺奖励激励</li><li>人们通常能找到新的方式来获得奖励，同时少做工作。</li><li>威逼和利诱属于交易型领导方式。</li></ul><p>转变型</p><ul><li>用成就激励</li><li>鼓励承诺属于转变型领导方式。</li></ul><p>交易型领导方式很少能产生成功并且有创造性的团队，因此转变型领导方式是首选。</p><h6 id="承诺激励">承诺激励</h6><p>个人级别的差异</p><ul><li>有些人对待承诺十分认真。</li><li>有些人对待承诺十分轻率。</li></ul><p>当满足以下情况，团队承诺比个人承诺的激励作用更大</p><ul><li>所有团队成员共同参与作出承诺。</li><li>团队依赖于每一位成员履行自己的承诺。</li></ul><p>一个软件开发团队在制定承诺时，要保证</p><ul><li>承诺是自愿的</li><li>承诺是公开的</li><li>承诺是可信（行）的</li><li>向团队承诺</li></ul><h6 id="维持激励">维持激励</h6><p>维持激励需要及时的绩效反馈。</p><p>包括</p><ul><li>根据一个详细计划衡量进度</li><li>当前计划不准确时重做计划</li><li>为漫长而富有挑战性的项目提供中间反馈，即里程碑</li></ul><h5 id="马斯洛需求层次理论">马斯洛需求层次理论</h5><figure><img src="/image/软件质量管理/maslo.png" alt="maslo" /><figcaption aria-hidden="true">maslo</figcaption></figure><ol type="1"><li>自我实现是最高的层次</li><li>激励来自为没有满足的需求而努力奋斗</li><li>低层次的需求必须在高层次需求满足之前得到满足</li><li>满足高层次的需求的途径比满足低层次的途径更为广泛</li></ol><h5 id="期望理论">期望理论</h5><ol type="1"><li><p>海兹伯格：</p><ul><li>激励因素（内在因素）：<ul><li>成就感，责任感，晋升，被赏识、认可</li></ul></li><li>保健因素（外在因素）：<ul><li>工作环境，薪金，工作关系，安全等</li></ul></li></ul></li><li><p>麦克勒格X理论</p><ul><li>不喜欢他们的工作并努力逃避工作</li><li>缺乏进取心，没有解决问题与创造的能力</li><li>更喜欢经常的指导，避免承担责任，缺乏主动性</li><li>自我中心，对组织需求反应淡漠，反对变革</li></ul><p>用马斯洛的底层需求（生理和安全）进行激励。</p></li><li><p>麦克勒格Y理论</p><ul><li>如果给予适当的激励和支持性的工作氛围，会达到很高的绩效预期</li><li>具有创造力，想象力，雄心和信心来实现组织目标</li><li>能够自我约束，自我导向与控制，渴望承担责任</li></ul><p>用马斯洛的高层需求（自尊和自我实现）进行激励。</p></li><li><p>期望理论</p><p>人们在下列情况下能够受到激励并且出大量成果<spanclass="math inline">\(M=V\times E\)</span></p><ul><li>相信他们的努力很可能会产生成功的结果（V）</li><li>他们也相信自己会因为成功得到相应的回报（E）</li></ul></li></ol><h3 id="自主团队">2.1.2 自主团队</h3><p>自主团队具备如下的特点：</p><ul><li>自行定义项目的目标</li><li>自行决定团队组成形式以及成员的角色</li><li>自行决定项目的开发策略</li><li>自行定义项目的开发过程</li><li>自行制定项目的开发计划</li><li>自行度量、管理和控制项目工作</li></ul><h4 id="外部环境">外部环境</h4><p>项目启动阶段获得管理层的支持。</p><ul><li>体现出已经尽最大的可能在满足管理层的需求的工作态度。</li><li>在计划中体现定期需要向管理层报告的内容。</li><li>向管理层证明他们所制定的工作计划是合理的。</li><li>在计划中体现为了追求高质量而开展的工作。</li><li>在工作计划中允许必要的项目变更。</li><li>向管理层寻求必要的帮助。</li></ul><p>在项目进展过程中获得管理层的支持</p><ul><li>严格遵循定义好的开发过程开展项目开发工作。</li><li>维护和更新项目成员的个人计划和团队计划。</li><li>对产品质量进行管理。</li><li>跟踪项目进展，并定期向管理层报告。</li><li>持续地向管理层展现优异的项目表现。</li></ul><h4 id="tsp启动过程">TSP启动过程</h4><ol type="1"><li>第一次会议：建立产品目标和业务目标</li><li>第二次会议：角色分配、小组目标定义</li><li>第三次会议：开发流程定义与策略选择</li><li>第四次会议：整体计划</li><li>第五次会议：质量计划</li><li>第六次会议：个人计划以及计划平衡</li><li>第七次会议：风险评估</li><li>第八次会议：准备向管理层汇报计划</li><li>第九次会议：向管理层汇报计划内容</li><li>启动总结</li></ol><h4 id="tsp角色和职责">TSP角色和职责</h4><p>领导者和经理的区别</p><table><thead><tr class="header"><th><strong>角色经理</strong></th><th><strong>团队领导者</strong></th></tr></thead><tbody><tr class="odd"><td>告知</td><td>倾听</td></tr><tr class="even"><td>指导</td><td>询问</td></tr><tr class="odd"><td>说服</td><td>激励/挑战</td></tr><tr class="even"><td>决定</td><td>促进达成一致</td></tr><tr class="odd"><td>控制</td><td>教练</td></tr><tr class="even"><td>监控</td><td>授权</td></tr><tr class="odd"><td>设定目标</td><td>挑战</td></tr></tbody></table><ol type="1"><li><p>项目组长：</p><ul><li>建设和维持高效率的团队。</li><li>激励团队成员积极工作。</li><li>合理处理团队成员的问题。</li><li>向管理层提供项目进度相关的完整信息。</li><li>充当合格的会议组织者和协调者。</li></ul></li><li><p>计划经理：</p><p>开发完整的、准确的团队计划和个人计划，每周准确的报告项目小组状态。</p></li><li><p>开发经理：</p><p>开发优秀的软件产品，充分利用团队成员的技能。</p></li><li><p>质量经理：</p><ul><li><p>项目团队严格按照质量计划开展工作，开发出高质量的软件产品</p></li><li><p>所有的小组评审工作都正常开展，并且都形成了评审报告</p></li></ul></li><li><p>过程经理：</p><ul><li>所有团队成员准确的记录、报告和跟踪过程数据。</li><li>所有的团队会议都有相应会议记录。</li></ul></li><li><p>支持经理</p><ul><li>项目小组在整个开发过程中都有合适的工具和环境</li><li>跟踪项目小组的风险和问题</li><li>项目小组在开发过程中满足复用目标</li></ul></li><li><p>开发人员</p></li></ol><h4 id="scrum角色和职责">SCRUM角色和职责</h4><p>典型SCRUM团队由一名产品负责人、开发团队和一名SCRUM Master组成。</p><ul><li>SCRUM团队是跨职能的自组织团队</li></ul><ol type="1"><li><p>产品负责人：</p><p>职责：将开发团队开发的产品价值最大化。</p><p>工作：管理产品待办列表的唯一负责人。</p></li><li><p>开发团队：</p><p>负责在每个 Sprint 结束时交付潜在可发布并且“完成”的产品增量。</p></li><li><p>Scrum Master：</p><p>促进和支持SCRUM，帮助每个人理解 SCRUM理论、实践、规则和价值。</p></li></ol><h2 id="估算计划和跟踪">2.2 估算、计划和跟踪</h2><h3 id="估算">2.2.1 估算</h3><p>目的：给各类计划提供决策依据</p><p>对象：规模、时间和日程</p><p>怎么做估算？</p><ol type="1"><li><p>估算要的是过程，而非结果；估算的过程是相关干系人达成一致共识的过程</p></li><li><p>最终目标是达成共识</p></li><li><p>建立信心</p><ul><li><p>足够详细</p></li><li><p>依赖数据</p></li><li><p>最好的猜测（注意检验猜测所依据的假设）</p></li></ul></li></ol><h4 id="probe估算方法">PROBE估算方法</h4><p>精确度量往往不便于早期估算，有助于早期估算的度量往往难以产生精确结果。</p><p>PROBE：精确度量和早期规划之间的桥梁。</p><p>PROBE估算流程：</p><ol type="1"><li>概要设计</li><li>代理识别和代理规模</li><li>估算并调整程序规模/资源</li><li>计算预测区间</li></ol><p>概要设计过程：</p><ol type="1"><li>确定产品功能，以及产生这些功能所需的程序组件/模块</li><li>将这些程序组件/模块与你以前写的程序相比较，估算它们的规模</li><li>将程序组件/模块估算综合给出总规模</li></ol><p>估算结果整合：</p><ul><li>整合一个开发人员做的多个估算<ul><li>累积各个部分的估算</li><li>进行一次线性回归计算</li><li>计算一个预测区间</li></ul></li><li>多个开发人员可以整合独立进行的估算，通过以下方式<ul><li>进行单独的线性回归预测</li><li>将计划的规模或者时间相加</li><li>将个人范围的平方相加，再对其计算平方根获得预测区间</li></ul></li></ul><h4 id="srum故事点">SRUM故事点</h4><p>度量实现一个故事需要付出的工作量。</p><ul><li><strong>抽象：</strong>混合了对于开发特性所要付出的努力、开发复杂度、个中风险以及类似东西</li><li><strong>相对：</strong>设定标准之后，考虑其他特性与标准之间的相对大小关系</li></ul><h3 id="计划">2.2.2 计划</h3><h4 id="工作分解结构">工作分解结构</h4><p>创建方法：</p><ol type="1"><li>识别和分析可交付成果及相关工作；</li><li>确定工作分解结构的结构与编排方法；</li><li>自上而下逐层细化分解；</li><li>为工作分解结构组成部分制定和分配标志编码；</li><li>核实工作分解的程度是必要且充分的。</li></ol><p>检查标准：</p><ol type="1"><li>最底层要素不能重复，即任何一个工作包只应该在 WBS中的一个地方出现。</li><li>所有要素必须清晰完整定义，即相应的数据词典必须完整定义。</li><li>最底层要素必须有定义清晰的责任人，可以支持成本估算和进度安排。</li><li>最底层的要素是实现目标的成分必要条件，即项目的工作范围得到完整体现。</li></ol><h4 id="通用计划框架">通用计划框架</h4><figure><img src="/image/软件质量管理/通用计划框架.png" alt="通用计划框架" /><figcaption aria-hidden="true">通用计划框架</figcaption></figure><h4 id="各类计划">各类计划</h4><ol type="1"><li><p>质量计划</p><ul><li><p>确定需要开展的质量保证活动。</p></li><li><p>典型的质量保证活动：个人评审、团队评审、单元测试、集成测试、系统测试、验收测试等。</p></li><li><p>需要解决的关键问题：该开展哪些活动，以及这些活动开展的程度，如时间、人数和目标。</p></li></ul></li><li><p>风险计划</p><ul><li>目的：在风险发生前，识别出潜在的问题，以便在产品或项目的生命周期中规划和实施风险管理活动，以消除潜在问题对项目产生的负面影响。</li><li>风险管理：<ul><li>风险识别<ul><li>识别与成本、进度及绩效相关的风险，审查可能影响项目的环境因素、工作分解结构的所有组件、项目计划的所有组件</li><li>记录风险的内容、条件及可能的结果，识别每一风险相关的干系人</li><li>利用已定义的风险参数，评估已识别的风险，依照定义的风险类别，将风险分类并分组，排列降低风险的优先级</li></ul></li><li>风险应对：制定相应的风险管理策略。<ul><li>风险转嫁</li><li>风险解决</li><li>风险缓解</li></ul></li></ul></li></ul></li></ol><h3 id="跟踪">2.2.3 跟踪</h3><p>目的：了解项目进度。</p><ul><li><p>在项目实际进展与计划产生严重偏离时，可采取适当的纠正措施。</p></li><li><p>项目进度滞后与否需要参照物，即项目计划。</p></li><li><p>项目跟踪需要管理针对偏差而采取的纠偏措施。</p></li></ul><h4 id="挣值管理方法">挣值管理方法</h4><p>Earned Value Management，简称EVM。</p><ul><li><p>每项任务实现附以一定价值</p></li><li><p>100%完成该项任务，就获得相应价值</p></li></ul><p>采用与进度计划、成本预算和实际成本相联系的三个独立的变量，进行项目绩效测量。</p><ul><li><p>简单实现：</p><p>仅仅关注进度信息。</p><ol type="1"><li><p>建立 WBS，定义工作范围</p></li><li><p>为 WBS 中每一项工作定义一个价值（PV）</p></li><li><p>最后按照一定的规则将某一数值赋给已经完成的工作或者正在进行的工作。</p><p>常用规则分别为 0-100 规则和 50-50规则，前者只有当某项任务完成时，该任务的 PV 值将转化成 EV值；后者只需要开始某项任务，即可以赋原 PV 值的 50%作为 EV值，完成时，再加上另外的 50%。而实际完成的工作所需成本 AC 不对 EV值产生任何影响。</p></li></ol></li><li><p>中级实现在简单实现的基础上，加入日程偏差的计算。典型计算方式有：</p><ul><li>日程偏差 SV = EV – PV；</li><li>日程偏差指数 SPI = EV/PV；</li></ul></li><li><p>高级实现在中级实现的基础上，还需要考察项目的实际成本。</p></li></ul><h5 id="常用evm度量">常用EVM度量</h5><p>BAC表示按照PV值的曲线，当项目完成的时候所需预算或者时间</p><p>成本差异CV = EV-AC</p><p>成本差异指数CPI = EV/AC</p><p>日程偏差SV = EV – PV</p><p>日程偏差指数SPI = EV/PV</p><p>预计完成成本EAC = AC+(BAC-EV)/CPI = BAC/CPI</p><h5 id="燃尽图">燃尽图</h5><p>纵坐标为总估计时间，横坐标为迭代时间线，估计曲线为估计的剩余任务，实际曲线为实际的剩余任务。</p><h5 id="局限性">局限性</h5><p>EVM 一般不能应用软件项目的质量管理。</p><p>EVM需要定量化的管理机制，这就使其在一些探索型项目以及常用的敏捷开发方法中的应用受到限制</p><p>EVM完全依赖项目的准确估算，然而在项目早期，很难对项目进行非常准确的估算。</p>]]></content>
    
    
    <categories>
      
      <category>软件质量管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件质量管理_概述</title>
    <link href="/2024/06/21/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/1.%20%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/06/21/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/1.%20%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>高堂明镜悲白发，朝如青丝暮成雪。</p><span id="more"></span><h1 id="概述">1. 概述</h1><h2 id="软件危机">1.0 软件危机</h2><p>软件在改变（定义？颠覆？）我们的世界。</p><p>软件自身的变化：规模、比例。</p><h3 id="软件四大本质困难和挑战">软件四大本质困难和挑战</h3><p>复杂性、不可见性、可变性、一致性</p><ul><li>除了不可见性，其他三个本质难题因项目而异</li><li>四大本质难题相互促进</li><li>本质难题变化带动软件方法（过程）演变</li></ul><h3 id="软件危机-1">软件危机</h3><p>软件危机是指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。</p><h3 id="软件工程">软件工程</h3><p>一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。</p><p>软件工程的两大视角</p><ul><li>管理视角——能否复制成功？</li><li>技术视角——是否可以将问题解决得更好？</li></ul><h2 id="软件项目与过程管理">1.1 软件项目与过程管理</h2><p>管理的三大关键要素：</p><ul><li>目标</li><li>状态</li><li>纠偏</li></ul><h3 id="软件项目管理">1.1.1 软件项目管理</h3><p>应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。</p><ul><li>三大目标：成本、质量、工期</li><li>估算、计划、跟踪、风险管理、范围管理、人员管理、沟通管理，等等</li></ul><p>核心问题：复制成功</p><h4 id="软件过程">软件过程</h4><p>为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合</p><ul><li>这组实践间往往有一定先后顺序，作为整体来实现事先定义的一个或者多个目标。</li></ul><h4 id="广义软件过程">广义软件过程</h4><p>理论基石：软件产品和服务的质量，很大程度上取决于生产维护该软件或者服务的过程的质量。</p><p>广义软件过程包括技术、人员以及狭义过程。</p><ul><li>也称软件开发方法、软件开发过程。</li><li>极限编程方法、SCRUM方法、Gate方法</li><li>敏捷软件过程／方法、轻量型过程／方法以及重型过程／方法等</li></ul><h4 id="生命周期模型">生命周期模型</h4><p>对软件过程的一种人为的划分。</p><ul><li>生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分。</li><li>生命周期模型往往不包括技术实践。</li><li>瀑布模型、迭代式模型、增量模型、螺旋模型、原型法等等</li></ul><h3 id="软件过程管理">1.1.2 软件过程管理</h3><p>管理对象：软件过程</p><p>目的：让软件过程在开发效率、质量等方面有着更好性能绩效</p><ul><li>软件项目管理：产品生产管理（SCRUM、Kanban）</li><li>软件过程管理：流水线的设计、建设、维护、优化（CMMI、SPICE）</li></ul><h4 id="软件过程改进">软件过程改进</h4><ul><li>管理参考模型：CMM/CMMI、SPICE</li><li>改进参考元模型：PDCA、IDEAL</li></ul><h2 id="软件发展三大阶段">1.2 软件发展三大阶段</h2><ol type="1"><li>软硬件一体化阶段（50年代~70年代）</li></ol><ul><li>软件完全依附于硬件</li><li>软件作坊</li></ul><ol start="2" type="1"><li>软件成为独立的产品（70年代~90年代）</li><li>网络化和服务化（90年代中期迄今）</li></ol><h3 id="软硬件一体化">1.2.1 软硬件一体化</h3><h4 id="软件完全依附于硬件">软件完全依附于硬件</h4><p>软件应用典型特征：</p><ul><li><p>软件支持硬件完成计算任务</p></li><li><p>功能单一</p></li><li><p>复杂度有限</p></li><li><p>几乎不需要需求变更</p></li></ul><p>软件开发典型特征</p><ul><li>硬件太贵</li><li>团队以硬件工程师和数学家为主</li></ul><p>实践：Measure twice, cut once</p><h4 id="软件作坊">软件作坊</h4><p>软件应用典型特征</p><ul><li>功能简单</li><li>规模小</li></ul><p>软件开发典型特征</p><ul><li>很多非专业领域的人员涌入软件开发领域</li><li>高级程序语言出现</li><li>质疑权威文化盛行</li></ul><p>实践：Code and fix</p><h3 id="软件成为独立产品">1.2.2 软件成为独立产品</h3><p>软件应用特征</p><ul><li>摆脱了硬件束缚</li><li>功能强大</li><li>规模和复杂度剧增</li><li>个人电脑出现，普通人成为软件用户<ul><li>需求多变</li><li>兼容性要求</li></ul></li><li>来自市场的压力</li></ul><p>实践：</p><ul><li>形式化方法</li><li>结构化程序设计、瀑布模型</li><li>CMM/CMMI</li></ul><h3 id="网格化和服务化">1.2.3 网格化和服务化</h3><p>软件应用特征</p><ul><li>功能更复杂，规模更大</li><li>用户数量急剧增加（这会带来什么问题？）</li><li>快速演化和需求不确定</li><li>分发方式的变化（SaaS）</li></ul><p>典型软件过程和实践</p><ul><li><p>迭代式</p></li><li><p>敏捷宣言</p><ul><li>个体和互动胜过流程和工具</li><li>可以工作的软件胜过详尽的文档</li><li>客户合作胜过合同谈判</li><li>响应变化胜过遵循计划</li></ul></li><li><p>XP、SCRUM、Kanban</p></li><li><p>开源软件开发方法</p></li></ul><h3 id="软件发展现状">1.2.4 软件发展现状</h3><p>软件应用典型特征</p><ul><li><p>进一步服务化和网络化（移动是主流）</p></li><li><p>用户需求多样性进一步凸显</p></li><li><p>软件产品和服务的地位变化</p></li><li><p>错综复杂的部署环境</p></li><li><p>近乎苛刻的用户期望</p><ul><li>多：功能丰富，个性化</li><li>快：快速使用，及时更新，快速解决问题</li><li>好：稳定，可靠，安全，可信</li><li>省：用户的获得成本低，最好免费</li></ul></li></ul><p>软件开发典型特征</p><ul><li>空前强大的开发和部署环境——XaaS<ul><li>IaaS</li><li>PaaS</li><li>SaaS, FaaS</li></ul></li><li>盛行共享和开源</li><li>潜在支撑获得了长足进步（AI，Bigdata， Cloud，etc.）</li></ul><p>典型DevOps实践和方法</p><ul><li>方法论基础：敏捷软件开发、精益思想以及Kanban方法。</li><li>以领域驱动设计为指导的微服务架构方式</li><li>大量虚拟化技术的使用</li><li>一切皆服务的理念指导</li><li>构建了强大的工具链，支持高水平自动化</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件质量管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件系统设计_软件架构复习</title>
    <link href="/2024/06/14/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/06/14/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="软件架构复习">软件架构复习</h1><h2 id="总览">0. 总览</h2><ol type="1"><li>软件架构</li><li>质量属性</li><li>架构模式</li><li>架构设计</li><li>架构文档化</li><li>架构评价</li><li>微服务</li></ol><h2 id="软件架构">1. 软件架构</h2><h3 id="什么是软件架构">1.1 什么是软件架构？</h3><p>程序或计算系统的结构，由软件元素、这些元素外部可⻅的属性、这些元素的关系组成。</p><h3 id="软件架构师做什么">1.2 软件架构师做什么？</h3><p>联络：客户、技术团队和业务需求分析师</p><p>软件工程</p><p>技术知识</p><p>风险管理。</p><h3 id="架构来自哪里">1.3 架构来自哪里？</h3><p>NFRs、ASRs、质量要求、涉众、组织、技术环境、业务目标</p><h3 id="架构41视图">1.4 架构4+1视图</h3><p>逻辑视图：描述架构中重要的元素及其之间的关系</p><p>进程视图：描述架构的并发和通信元素</p><p>物理视图：描述主要过程和元素是如何被映射到应⽤程序硬件</p><p>开发视图：捕获软件组件的内部组织</p><p>架构⽤例：捕获架构的需求；与多个特定视图关联</p><h3 id="架构活动和过程">1.5 架构活动和过程</h3><h4 id="架构活动">架构活动</h4><ul><li><p>创造系统的商业案例</p></li><li><p>理解需求</p></li><li><p>创造和选择架构</p></li><li><p>与包括开发者在内的涉众沟通架构</p></li><li><p>分析或评估架构</p><ul><li><p>总的⽅法</p></li><li><p>质量特定技术</p></li></ul></li><li><p>实现架构</p></li><li><p>确保架构符合要求</p></li></ul><h4 id="架构过程">架构过程</h4><ol type="1"><li>确定ASRs</li><li>架构设计</li><li>文档化</li><li>架构评估</li></ol><h3 id="软件架构知识领域">1.6 软件架构知识领域</h3><p>软件设计基本概念</p><ul><li><p>总体设计概念</p></li><li><p>上下⽂：软件开发⽣命周期——需求、设计、构建和测试</p></li><li><p>设计过程（⻆⾊、活动、⼯作产品）</p></li><li><p>软件设计的可⽤⼯具</p></li></ul><p>关键技术问题：并⾏性、事件控制和处理、分布式、异常处理、交互式系统、持久化</p><p>软件结构和架构</p><ul><li><p>架构结构和视点</p></li><li><p>架构样式和模式（宏观架构）</p></li><li><p>设计模式（微观架构）</p></li></ul><p>软件设计⽅法</p><ul><li><p>架构⽅法（如属性驱动设计）</p></li><li><p>设计⽅法（如动态系统开发⽅法）</p></li></ul><p>软件设计质量分析和评估</p><ul><li><p>质量属性</p></li><li><p>质量分析和评估⽅法、技术、⼯具</p><ul><li><p>设计审查（如 SEI 的架构权衡分析⽅法）</p></li><li><p>静态分析和动态分析</p></li><li><p>模拟和原型</p></li></ul></li><li><p>度量</p><ul><li><p>指标：架构层次</p></li><li><p>与技术有关的度量</p></li></ul></li></ul><p>设计建模和表示</p><ul><li><p>架构和设计标记（架构描述语⾔ ADL Architecture DescriptionLanguages）</p></li><li><p>统⼀建模语⾔（UML）</p></li><li><p>设计⽂档（视图和超越视图）</p></li><li><p>其他：视能⼒、关注点和领域⽽定</p></li></ul><h2 id="质量属性">2. 质量属性</h2><h3 id="软件需求">2.1 软件需求</h3><h4 id="功能需求">功能需求</h4><p>系统必须完成的、为涉众提供价值的内容。</p><ul><li>功能的实现可能⽤了很多的结构，但功能是与结构⽆关的。</li></ul><h4 id="质量需求nfrs">质量需求（NFRs）</h4><p>整个系统的期望特征，在功能需求之上。</p><ul><li>如果质量属性很重要，软件架构将约束功能的分配到不同的结构。</li></ul><h4 id="约束">约束</h4><p>0 ⾃由度、预定义的设计决定</p><ul><li>接受设计决定、协调其他受影响的设计决定，如此来满⾜约束</li></ul><h3 id="质量属性-1">2.2 质量属性</h3><p>内部/外部属性</p><h4 id="建模质量属性场景">建模质量属性场景</h4><p>源、刺激、制品、环境、响应、度量</p><h4 id="举例">举例</h4><p>可用性、互操作性、可修改性、性能、安全性、可测试性、其他</p><h4 id="质量属性战术">质量属性战术</h4><p>战术是影响质量属性响应控制的设计决定。</p><ul><li>战术的集合被称为架构策略。</li></ul><h4 id="架构设计决策检查列表">架构设计决策检查列表</h4><h3 id="架构重要需求">2.3 架构重要需求</h3><p>在架构上有深刻影响的需求。</p><p>如何收集、确认ASRs：</p><ol type="1"><li>从需求文档收集</li><li>采访涉众</li><li>理解业务目标</li><li>质量属性效用树</li></ol><h2 id="架构模式">3. 架构模式</h2><h3 id="架构模式-1">3.1 架构模式</h3><p>⼀系列在实践中能反复地看到的设计决定。</p><ul><li>上下文：经常出现的、普遍的、引起问题的情形</li><li>问题：适当地概括的，在给定上下⽂中出现</li><li>解决方案：成功的、适当抽象的架构解决⽅案</li></ul><h3 id="模块模式">3.2 模块模式</h3><p>分层模式（微内核模式）</p><h3 id="组件-连接件模式">3.3 组件-连接件模式</h3><p>代理人模式、MVC模式、管道、过滤器模式、C/S模式、P2P模式、SO模式、发布-订阅模式、数据共享模式</p><h3 id="分配模式">3.4 分配模式</h3><p>Map-Reduce模式、Multi-Tier模式</p><h3 id="模式与战术">3.5 模式与战术</h3><ol type="1"><li><p>战术⽐模式简单：使⽤单⼀的结构或机制来处理单⼀的架构要求</p></li><li><p>模式通常将多个设计决定合并到⼀个包</p></li><li><p>模式和战术⼀起构成了软件架构师的主要⼯具</p></li><li><p>战术是设计的建造⽅块，⽤来创建架构模式</p></li><li><p>⼤多数模式由⼏个不同的战术组成</p><ul><li><p>所有战术为了⼀个共同⽬的</p></li><li><p>经常被选择来保证不同的质量属性</p></li></ul></li></ol><h2 id="架构设计">4. 架构设计</h2><h3 id="通用设计策略">4.1 通用设计策略</h3><p>抽象、分解、迭代、重用</p><h3 id="设计决策分类">4.2 设计决策分类</h3><p>职责、协调、数据、资源、元素映射、技术</p><h3 id="属性驱动设计add">4.3 属性驱动设计（ADD）</h3><p>输⼊：需求</p><p>输出：软件元素、⻆⾊、职责、属性、关系</p><p>步骤：</p><ol type="1"><li>确认需求</li><li>选择并分解元素</li><li>识别ASR</li><li>选择满足ASR的设计<ul><li>确认关注点</li><li>列出可选项（模式/战术）</li><li>选择模式/战术</li><li>决定模式/战术和ASR间关系</li><li>捕捉初步架构视图</li><li>解决不一致</li></ul></li><li>实例化元素，分配职责</li><li>定义元素接口</li><li>验证、细化需求</li><li>重复2-7直到所有架构重要需求被满足</li></ol><h2 id="架构文档化">5. 架构文档化</h2><h3 id="视图">5.1 视图</h3><h4 id="样式模式和视图">样式、模式和视图</h4><p>架构样式：元素和关系类型的专⻔化，以及如何使⽤它们的⼀组约束。</p><p>架构模式：软件系统中的基础结构组织⽅法的表达。</p><ul><li>架构模式关注问题和上下午，样式侧重方法。</li></ul><p>样式的三个分类：</p><ul><li>一组样式单元：模块样式</li><li>一组有运行时行为和交互的元素：组件-连接件样式</li><li>与环境中的非软件结构关联：分配样式</li></ul><p>架构视图：⼀组系统元素及其关系的表示。</p><ul><li>视图让我们将系统实体划分成感兴趣和易于管理的系统表示。</li><li>不同的视图⽀持不同的⽬标和⽤户，凸显出不同系统元素和关系</li><li>不同视图在不同程度上展现不同的质量属性</li></ul><h4 id="结构性视图">结构性视图</h4><h5 id="模块视图">模块视图</h5><p>模块是提供⼀套连贯的职责的实现单元。</p><p>包含：</p><ul><li>分解视图 Decomposition view</li><li>使⽤视图 Uses view</li><li>概括视图 Generalization view</li><li>分层视图 Layered view</li><li>⽅⾯视图 Aspects view</li><li>数据模型视图 Data model view</li></ul><p>元素：模块，提供⼀套连贯职责的实现单元</p><p>关系：</p><ul><li><p>“⼀部分”：部分⼦模块和整体聚合模块之间的部分、整体关系</p></li><li><p>“依赖于”：两个模块之间的依赖关系。特定的模块视图详细说明了依赖关系的含义</p></li><li><p>“是”：更具体的⼦模块和更⼀般的⽗模块之间的泛化、专⻔化关系</p></li></ul><p>约束：不同模块视图可能会施加特定的拓扑约束，例如限制模块之间的可⻅性。</p><p>⽤途</p><ul><li><p>代码构建蓝图</p></li><li><p>变更影响分析</p></li><li><p>规划增量开发</p></li><li><p>需求追踪分析</p></li></ul><h5 id="组件-连接件视图">组件-连接件视图</h5><p>显示运行时组件。</p><ul><li><p>例如进程、对象、客户机、服务器和数据存储</p></li><li><p>“连接”指明了哪些连接器连接到哪些组件。</p></li></ul><p>包含：</p><ul><li>管道-过滤器视图 Pipe-and-filter view</li><li>客户机-服务端视图 Client-server view</li><li>点对点视图 Peer-to-peer view</li><li>⾯向服务架构视图 Service-oriented view</li><li>发布-订阅视图 Publish-subscribe view</li><li>共享数据视图 Shared-data view</li><li>多层视图 Multi-tier view</li></ul><p>元素：</p><ul><li><p>组件。主要处理单元和数据存储。组件有⼀组端⼝，通过这些端⼝与其他组件进⾏交互（通过连接器）</p></li><li><p>连接器。组件间交互的途径。连接器有⼀组⻆⾊（接⼝），指示组件如何在交互中使⽤连接器</p></li></ul><p>约束：</p><ul><li><p>组件只能连接到连接器，⽽不是直连其他组件</p></li><li><p>连接器只能连接到组件，⽽不是直连其他连接器</p></li><li><p>连接只能在相容的端⼝和⻆⾊上建⽴</p></li><li><p>接⼝委托只能在两个相容端⼝或⻆⾊上定义</p></li><li><p>连接器不能孤⽴出现，必须连接到组件</p></li></ul><p>⽤途</p><ul><li><p>演示系统如何⼯作</p></li><li><p>通过指定运⾏时元素的结构和⾏为来指导开发</p></li><li><p>帮助解释运⾏时系统质量属性，如性能和可⽤性</p></li></ul><h5 id="分配视图">分配视图</h5><p>描述了软件单元到软件开发或执⾏环境元素的映射。</p><p>包含：</p><ul><li>部署视图 Deployment view</li><li>安装视图 Install view</li><li>⼯作安排视图 Work assignment view</li><li>其他分配视图 Other allocation view</li></ul><p>元素</p><ul><li><p>软件元素。软件元素具有环境所需的属性</p></li><li><p>环境元素。环境元素具有提供给软件的属性</p></li></ul><p>关系：被分配。软件元素被分配到环境元素，属性取决于特定视图。</p><p>⽤途：</p><ul><li><p>⽤于对性能、可⽤性、安全性 security 和安全性 safety进⾏解释</p></li><li><p>⽤于解释分布式开发和将⼯作分配给团队</p></li><li><p>⽤于解释软件版本的并⾏访问</p></li><li><p>⽤于解释系统安装的形式和机制</p></li></ul><h4 id="质量视图">质量视图</h4><p>包含</p><ul><li><p>安全视图 Security view</p></li><li><p>性能视图 Performance view</p></li><li><p>可靠性视图 Reliability view</p></li><li><p>通信视图 Communication view</p></li><li><p>异常视图 Exception view（错误处理视图 error- handlingview）</p></li></ul><h3 id="视图文档化">5.2 视图文档化</h3><h3 id="选择视图">选择视图</h3><h4 id="选择视图-1">选择视图</h4><ol type="1"><li><p>构建涉众-视图表</p></li><li><p>组合视图</p><ol type="1"><li>确定上表中的边缘视图</li><li>通过将⼀个视图的元素与另⼀个视图中的元素相关联，将每个边缘视图与另⼀个更具⽀持性的视图相结合</li></ol></li><li><p>确定优先级和阶段</p><ul><li><p>分解视图</p></li><li><p>⼋⼆开原则</p></li><li><p>按顺序完成所有视图</p></li></ul></li></ol><h4 id="涉众文档">涉众文档</h4><p>左列是涉众的类别，右列是对应涉众如何使⽤这个⽂档。</p><h4 id="涉众-视图表">涉众-视图表</h4><p>左边是涉众，右边每⼀列都是⼀个视图，值分别表示：</p><ul><li>d 详细信息</li><li>s ⼀些细节</li><li>o ⼤概信息</li><li>x ⽆所谓。</li></ul><h3 id="超越视图">5.3 超越视图</h3><p>文档信息、架构信息、视图间映射。</p><h2 id="架构评价">6. 架构评价</h2><h3 id="架构分析评价方法">6.1 架构分析+评价方法</h3><p>软件架构分析⽅法 SAAM，Software Architecture Analysis Method</p><p>架构层级可修改性分析 ALMA，Architecture Level ModifiabilityAnalysis</p><p>软件架构性能评估 PASA，Performance Assessment of SoftwareArchitecture</p><p>架构权衡分析⽅法 ATAM，Architecture Trade-off Analysis Method</p><h3 id="atam">6.2 ATAM</h3><p>架构权衡分析⽅法，Architecture Tradeoff Analysis Method</p><ol start="0" type="1"><li><p>合作与准备</p><p>参与者：团队领导和主要项目决策者</p><p>输入：架构文档</p><p>输出：评价计划</p></li><li><p>评估1</p><p>参与者：评估团队和项目决策者</p><p>输出：架构展示、业务驱动因素、质量属性需求优先级列表、效用树、风险、敏感点和权衡点</p><ol type="1"><li>展示 ATAM</li><li>展示业务驱动因素</li><li>展示架构</li><li>识别架构⽅法</li><li>⽣成效⽤树</li><li>分析架构⽅法</li></ol></li><li><p>评估2</p><p>参与者：评估团队、项目决策者、架构涉众</p><p>输出：涉众社区的优先级场景列表、风险主题和受威胁的业务驱动因素</p><ol type="1"><li>展示 ATAM 和结果</li><li>头脑⻛暴和定优先级</li><li>分析架构⽅法</li><li>展示结果</li></ol></li><li><p>后续⾏动</p><p>参与者：评估团队和主要涉众</p><p>输出：最终评估报告</p></li></ol><h4 id="atam输出">ATAM输出</h4><ul><li>架构的简短展示</li><li>业务⽬标的表达</li><li>由质量属性场景表达的定优先级的质量属性需求</li><li>效⽤树</li><li>⼀组⻛险和⾮⻛险</li><li>⼀组⻛险主题</li><li>从架构决定到质量需求的映射</li><li>⼀组确定的敏感点和权衡点</li><li>最终评估报告</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件系统设计_详细设计复习</title>
    <link href="/2024/06/13/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/06/13/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="详细设计复习">详细设计复习</h1><h2 id="软件模式">1. 软件模式</h2><p>软件开发的总体指导思路或参照样板。</p><ul><li>软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等。</li><li>在软件生存期的每一个阶段都存在着一些被认同的模式。</li></ul><h3 id="组成">组成</h3><ul><li>问题描述</li><li>前提条件(环境或约束条件)</li><li>解法</li><li>效果。</li></ul><h3 id="大三律">大三律</h3><p>只有经过三个以上不同类型(或不同领域)系统的校验，一个解决方案才能从候选模式升格为模式。</p><h2 id="设计模式">2.设计模式</h2><p>被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><h3 id="基本要素">基本要素</h3><ul><li>模式名称 (Pattern name)</li><li>问题 (Problem)</li><li>解决方案 (Solution)</li><li>效果 (Consequences)</li></ul><h3 id="分类">分类</h3><p>根据其目的分为</p><ul><li>创建型（Creational）：创建对象</li><li>结构型（Structural）：处理类或对象的组合</li><li>行为型（Bahavioral）：描述对类或对象怎样交互和分配职责</li></ul><p>根据范围，即模式主要用于处理类/对象之间关系分为</p><ul><li>类模式：处理类和子类的关系，这些关系在编译时确定，是静态的</li><li>对象模式：处理对象间关系，这些关系在运行时变化，是动态的</li></ul><h3 id="考察内容">考察内容</h3><table><thead><tr class="header"><th>范围/目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr class="odd"><td>类模式</td><td>工厂方法模式</td><td>（类）适配器模式</td><td>模板方法模式</td></tr><tr class="even"><td>对象模式</td><td>抽象工厂模式<br />原型模式</td><td>（对象）适配器模式<br />组合模式<br />装饰模式<br />外观模式</td><td>命令模式<br />中介者模式<br />观察者模式<br />状态模式<br />策略模式</td></tr></tbody></table><h3 id="设计模式与类库框架">设计模式与类库框架</h3><ol type="1"><li><p>设计模式比库的层次更高。设计模式告诉我们如何构建类和对象以解决特定问题。</p></li><li><p>框架和库不是设计模式；它们提供了具体的实现，我们将这些实现链接到我们的代码中。</p></li></ol><h2 id="设计原则">3. 设计原则</h2><p>对于面向对象的软件系统设计来说，在支持可维护性的同时，需要提高系统的可复用性。</p><ul><li>软件的复用可以提高软件的开发效率和软件质量，节约开发成本。</li><li>恰当的复用还可以改善系统的可维护性。</li></ul><p>目标：开闭原则</p><p>指导：最小知识原则</p><p>基础：单一职责原则、可变性封装原则</p><p>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</p><ol type="1"><li><p>开闭原则：一个软件实体应当对扩展开放，对修改关闭。</p></li><li><p>单一职责原则：一个类只负责一个功能领域中的相应职责。</p></li><li><p>里氏代换原则：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</p></li><li><p>依赖倒转原则：</p><p>抽象不应该依赖于细节，细节应该依赖于抽象</p><p>针对接口编程，不要针对实现编程。</p></li><li><p>接口隔离原则：客户端不应该依赖那些它不需要的接口。</p><ul><li>将一些大的接口细化成一些小的接口供客户端使用。</li></ul></li><li><p>合成复用原则：复用时尽量使用对象组合，而不使用继承。</p></li><li><p>迪米特法则：一个软件实体应当尽可能少的与其他实体发生相互作用。</p></li></ol><h2 id="表驱动法">4. 表驱动法</h2><h3 id="目标">目标</h3><p>将复杂逻辑从代码中⽴出来，以便于单独维护。</p><h3 id="原理">原理</h3><p>从表⾥⾯查找信息⽽不使⽤逻辑语句。</p><h3 id="查询">查询</h3><h4 id="直接访问">直接访问</h4><p>通过索引值（如下标）直接从表中找到对应的条⽬。</p><h4 id="索引访问">索引访问</h4><p>当⽆法直接从表中查询需要的条⽬时，就需要借助其他⽅法先获取表键值</p><ul><li>⽅法：先⽤⼀个基本类型的数据从索引表中查出⼀个键值，然后再⽤这⼀键值查出主数据。</li></ul><h4 id="阶梯访问">阶梯访问</h4><p>基本思想：通过确定每项命中的阶梯层次确定其归类。</p><ul><li>⽐索引访问⽅法节省空间，当阶梯多了⽐较次数就多。</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件系统设计_设计模式</title>
    <link href="/2024/06/12/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/06/12/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="设计模式">设计模式</h1><p>被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><h2 id="概念">0. 概念</h2><h3 id="基本要素">基本要素</h3><ul><li>模式名称 (Pattern name)</li><li>问题 (Problem)</li><li>解决方案 (Solution)</li><li>效果 (Consequences)</li></ul><h3 id="分类">分类</h3><p>根据其目的分为</p><ul><li>创建型（Creational）：创建对象</li><li>结构型（Structural）：处理类或对象的组合</li><li>行为型（Bahavioral）：描述对类或对象怎样交互和分配职责</li></ul><p>根据范围，即模式主要用于处理类/对象之间关系分为</p><ul><li>类模式：处理类和子类的关系，这些关系在编译时确定，是静态的</li><li>对象模式：处理对象间关系，这些关系在运行时变化，是动态的</li></ul><h3 id="设计模式与类库框架">设计模式与类库框架</h3><ol type="1"><li><p>设计模式比库的层次更高。设计模式告诉我们如何构建类和对象以解决特定问题。</p></li><li><p>框架和库不是设计模式；它们提供了具体的实现，我们将这些实现链接到我们的代码中。</p></li></ol><h3 id="考察内容">考察内容</h3><table><thead><tr class="header"><th>范围/目的</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr class="odd"><td>类模式</td><td>工厂方法模式</td><td>（类）适配器模式</td><td>模板方法模式</td></tr><tr class="even"><td>对象模式</td><td>抽象工厂模式<br />原型模式</td><td>（对象）适配器模式<br />组合模式<br />装饰模式<br />外观模式</td><td>命令模式<br />中介者模式<br />观察者模式<br />状态模式<br />策略模式</td></tr></tbody></table><h2 id="工厂模式">1. 工厂模式</h2><h3 id="简单工厂模式">简单工厂模式</h3><p>专门定义一个类来负责创建其他类的实例，根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</p><ul><li><p>又称静态工厂模式。</p></li><li><p>将对象的创建和对象本身业务处理分离可以降低系统的耦合度。</p></li></ul><h3 id="工厂方法模式">工厂方法模式</h3><p>简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这违背了开闭原则。</p><h4 id="概念-1">概念</h4><p>工厂方法模式（Factory Method Pattern）又称为工厂模式。</p><ul><li>也叫虚拟构造器（Virtual Constructor）模式、多态工厂（PolymorphicFactory）模式。</li></ul><ol type="1"><li>工厂父类负责定义创建产品对象的公共接口</li><li>工厂子类则负责生成具体的产品对象</li></ol><p>通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><ul><li>允许系统在不修改工厂角色的情况下引进新产品。</li></ul><h4 id="优缺点">优缺点</h4><p>优点：</p><ol type="1"><li>用户只需要关心所需产品对应的工厂，无须关心创建细节、具体产品类名。</li><li>工厂可以自主确定创建何种对象、如何创建对象。</li><li>在系统中加入新产品时，只要添加具体工厂和具体产品。</li></ol><p>缺点：</p><ol type="1"><li>添加新产品时系统中类的个数成对增加，提高了系统复杂度。</li><li>系统中加入抽象层，提高了系统理解难度和实现难度。</li></ol><h4 id="适用环境">适用环境</h4><ol type="1"><li>一个类不知道它所需要的对象的类。</li><li>一个类通过其子类来指定创建哪个对象。</li><li>客户端不需要关心是哪一个工厂子类，需要时动态指定。<ul><li>可将具体工厂类名存储在数据库或配置文件中。</li></ul></li></ol><h4 id="配置文件实例化具体工厂">配置文件实例化具体工厂</h4><p>将具体类的类名写入配置文件中，再通过Java的反射机制，读取XML格式的配置文件，根据存储在XML文件中的类名字符串生成对象。</p><h3 id="抽象工厂模式">抽象工厂模式</h3><p>有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。</p><ul><li>产品等级结构：产品的继承结构</li><li>产品族：由同一个工厂生产的 ，位于不同产品等级结构中的一组产品</li></ul><h4 id="问题">问题</h4><p>系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品。</p><h4 id="概念-2">概念</h4><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</p><ul><li><p>又称为Kit模式。</p></li><li><p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p></li><li><p>工厂方法模式针对一个产品等级结构，而抽象工厂模式需要面对多个。</p></li></ul><h4 id="优缺点-1">优缺点</h4><p>优点：</p><ol type="1"><li>隔离了具体类的生成，只需改变具体工厂的实例，就在某种程度上改变整个软件系统的行为。</li><li>实现高内聚低耦合的设计目的。</li><li>保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的具体工厂和产品族修改已有系统，符合开闭原则。</li></ol><p>缺点：</p><p>添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品。</p><ul><li>即：增加新的工厂和产品族容易，增加新的产品等级结构麻烦。</li></ul><h4 id="和工厂方法模式区别">和工厂方法模式区别</h4><p>工厂模式创建同一个产品的不同类型，抽象工厂模式创建不同类的产品。</p><ul><li>产品种类单一，适合用工厂模式。</li><li>有多个种类，各种类型时，适合抽象工厂模式。</li></ul><h4 id="适用环境-1">适用环境</h4><p>对所有的工厂模式：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节。</p><ol type="1"><li>系统中有多于一个的产品族，属于同一个产品族的产品将在一起使用。</li><li>所有的产品以同样的接口出 现，从而使客户端不依赖于具体实现。</li></ol><h3 id="模式扩展">模式扩展</h3><h4 id="开闭原则的倾斜性">开闭原则的倾斜性</h4><ol type="1"><li><p>增加产品族：对于增加新的产品族，工厂模式很好的支持了开闭原则，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</p></li><li><p>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持开闭原则。</p></li></ol><h4 id="工厂模式的退化">工厂模式的退化</h4><ol type="1"><li>只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式。</li><li>工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li></ol><h2 id="原型模式">2. 原型模式</h2><h3 id="概念-3">概念</h3><p>用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><ul><li><p>基本工作原理：</p><p>将一个原型对象传给要发动创建的对象，该对象请求原型对象拷贝原型自身来实现创建。</p></li><li><p>包含角色：抽象原型类、具体原型类、客户类</p></li><li><p>类包含一些成员对象，在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为深克隆和浅克隆。</p></li><li><p>clone()满足：</p><ol type="1"><li>对任何的对象x，都有x.clone() !=x，即克隆对象与原对象不是同一个对象。</li><li>对任何的对象x，都有x.clone().getClass()==x.getClass()，克隆对象与原对象类型一样。</li><li>如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</li></ol></li></ul><h3 id="优缺点-2">优缺点</h3><p>优点：</p><ol type="1"><li>简化对象的创建过程，通过已有实例提高新实例的创建效率。</li><li>动态增加或减少产品类。</li><li>可以使用深克隆保存对象的状态。</li></ol><p>缺点：</p><ol type="1"><li>需要为每一个类配备一个克隆方法。</li><li>实现深克隆的代码较为复杂。</li></ol><h3 id="适用环境-2">适用环境</h3><ol type="1"><li>创建新对象成本较大。</li><li>系统要保存对象的状态。</li><li>避免使用分层次的工厂类来创建分层次的对象。</li></ol><h3 id="模式扩展-1">模式扩展</h3><p>相似对象复制：通过原型模式获得相同对象后再对其属性进行修改，从而获取所需对象。</p><h2 id="适配器模式">3. 适配器模式</h2><h3 id="概念-4">概念</h3><p>将一个接口转换成客户希望的另一个接口。</p><ul><li>也称包装器（Wrapper）。</li><li>既可以作为类结构型模式，也可以作为对象结构型模式。</li><li>包含角色：目标抽象类、适配器类、适配者类、客户类</li></ul><h3 id="优缺点-3">优缺点</h3><p>适配器模式优点：</p><ol type="1"><li>将目标类和适配者类解耦。<ul><li>通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li></ul></li><li>增加了类的透明性和复用性。</li><li>灵活性和扩展性好。<ul><li>通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合开闭原则。</li></ul></li></ol><p>类适配器：</p><p>优点：适配器类是适配者类的子类，可以置换一些适配者的方法，灵活性强。</p><p>缺点：在很多编程语言中适配器类不能同时适配多个适配者类。</p><p>对象适配器：</p><p>优点：同一个适配器可以把适配者类和它的子类都适配到目标接口。</p><p>缺点：不容易置换适配者类的方法。</p><h3 id="适用环境-3">适用环境</h3><ol type="1"><li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li><li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ol><h3 id="模式扩展-2">模式扩展</h3><h4 id="默认适配器模式">默认适配器模式</h4><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式。</p><h4 id="双向适配器">双向适配器</h4><p>如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器。</p><h2 id="组合模式">4. 组合模式</h2><h3 id="概念-5">概念</h3><p>组合多个对象形成树形结构以表示“整体-部分”的结构层次。</p><ul><li><p>对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。</p></li><li><p>又称“整体-部分”（Part-Whole）模式</p></li><li><p>包含角色：抽象构件、叶子构件、容器构件、客户类</p></li><li><p>关键：</p><p>定义一个抽象构件类，既可以代表叶子，又可以代表容器，递归组合成树形结构。</p><p>而客户端针对该抽象构件类进行编程。</p></li></ul><h3 id="优缺点-4">优缺点</h3><p>优点：</p><ol type="1"><li>清楚地定义分层次的复杂对象。</li><li>客户端可以一致的使用组合结构或其中单个对象。</li><li>定义了包含叶子对象和容器对象的类层次结构，递归组合成树形结构。</li><li>更容易在组合体内加入对象构件。</li></ol><p>缺点：</p><ol type="1"><li>设计更加抽象困难。</li><li>很难对容器中的构件类型进行限制。</li></ol><h3 id="适用环境-4">适用环境</h3><ol type="1"><li>需要表示一个对象整体或部分层次。</li><li>客户端可以针对抽象构件编程，无须关心对象层次结构的细节。</li><li>对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们。</li></ol><h2 id="装饰模式">5. 装饰模式</h2><h3 id="概念-6">概念</h3><p>动态地给一个对象增加一些额外的职责。</p><ul><li><p>又称包装器（Wrapper），和适配器别名相同，但使用场合不同。</p></li><li><p>包含角色：抽象构件、具体构件、抽象装饰类、具体装饰类</p></li><li><p>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性。</p><ul><li>继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。</li><li>关联关系使系统具有较好的松耦合性， 因此使得系统更加容易维护。</li><li>关联关系的缺点是比继承关系要创建更多的对象。</li></ul></li></ul><h3 id="优缺点-5">优缺点</h3><p>优点：</p><ol type="1"><li>提供比继承更多的灵活性。</li><li>通过一种动态的方式来扩展一个对象的功能。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。</li><li>具体构件类与具体装饰类可以独立变化。</li></ol><p>缺点：</p><ol type="1"><li>产生很多小对象。</li><li>装饰模式比继承更加易于出错，排错也很困难。<ul><li>对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul></li></ol><h3 id="适用环境-5">适用环境</h3><ol type="1"><li>以动态、透明的方式给单个对象添加职责。</li><li>动态地给一个对象增加、撤销功能。</li><li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。<ul><li>系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长</li><li>类定义不能继承（final类）。</li></ul></li></ol><h3 id="模式扩展-3">模式扩展</h3><h4 id="装饰模式简化">装饰模式简化</h4><ol type="1"><li>一个装饰类的接口必须与被装饰类的接口保持相同。</li><li>不要把太多的逻辑和状态放在具体构件类中。</li><li>如果只有一个具体构件类而没有抽象构件类，抽象装饰类可以作为具体构件类的直接子类。</li></ol><h4 id="透明装饰模式和半透明装饰模式">透明装饰模式和半透明装饰模式</h4><ul><li>透明装饰模式：完全针对抽象编程，不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型。</li><li>半透明装饰模式：允许声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li></ul><h2 id="外观模式">6. 外观模式</h2><h3 id="概念-7">概念</h3><p>外部与一个子系统的通信通过统一的外观对象进行，为子系统中的一组接口提供一致的界面。</p><ul><li><p>Facade Pattern</p></li><li><p>包含角色：外观、子系统</p></li><li><p>在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性。</p></li><li><p>通过引入一个新的外观类降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p></li></ul><h3 id="优缺点-6">优缺点</h3><p>优点：</p><ol type="1"><li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。</li><li>实现了子系统与客户之间的松耦合关系。</li><li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程。</li><li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li></ol><p>缺点：</p><ol type="1"><li>不能很好地限制客户使用子系统类。</li><li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了开闭原则。</li></ol><h3 id="适用环境-6">适用环境</h3><ol type="1"><li>为一个复杂子系统提供一个简单接口。</li><li>客户程序与多个子系统之间存在很大的依赖性。</li><li>使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ol><h3 id="模式扩展-4">模式扩展</h3><ol type="1"><li>在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互。</li><li>不要试图通过外观类为子系统增加新行为。</li><li>抽象外观类。</li></ol><h2 id="模板方法模式">7. 模板方法模式</h2><h3 id="概念-8">概念</h3><p>定义一个操作中算法的骨架，而将一些步骤延迟到子类中。</p><ul><li><p>使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></li><li><p>包含角色：抽象类、具体子类</p></li><li><p>只有类之间的继承关系，没有对象关联关系</p></li><li><p>模板方法：</p><p>定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。</p></li></ul><h3 id="优缺点-7">优缺点</h3><p>优点：</p><ol type="1"><li>在一个类中抽象地定义算法，而由它的子类实现细节的处理。</li><li>是代码复用的一项基本技术。</li><li>导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合开闭原则。</li></ol><p>缺点：</p><p>导致类的个数增加。</p><h3 id="适用环境-7">适用环境</h3><ol type="1"><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类。</li><li>对一些复杂的算法进行分割。</li><li>控制子类的扩展。</li></ol><h3 id="模式扩展-5">模式扩展</h3><h4 id="好莱坞原则">好莱坞原则</h4><p>子类不显式调用父类的方法，而是通过覆盖父类的方法来实现某些具体的业务逻辑，父类控制对子类的调用。</p><h4 id="钩子方法的使用">钩子方法的使用</h4><p>使得子类可以控制父类的行为。</p><ol type="1"><li><p>最简单的钩子方法就是空方法，也可以在钩子方法中定义一个默认的实现，如果子类不覆盖钩子方法，则执行父类的默认实现代码。</p></li><li><p>比较复杂一点的钩子方法可以对其他方法进行约束，这种钩子方法通常返回一个boolean类型，即返回true或false，用来判断是否执行某一个基本方法。</p></li></ol><h2 id="命令模式">8. 命令模式</h2><p>动机：对发送者和接收者完全解耦，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p><h3 id="概念-9">概念</h3><p>将请求封装为对象，从而使我们可用不同的请求对客户进行参数化。</p><ul><li><p>对请求排队或者记录请求日志，以及支持可撤销的操作。</p></li><li><p>包含如下角色：抽象命令类、具体命令类、调用者、接收者、客户类</p></li><li><p>本质：对命令进行封装，将发出命令的责任和执行命令的责任分割开。</p></li><li><p>允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口。</p></li><li><p>关键：引入了抽象命令接口，发送者针对抽象命令接口编程。</p></li></ul><h3 id="优缺点-8">优缺点</h3><p>优点：</p><ol type="1"><li>降低系统的耦合度。</li><li>新的命令可以很容易地加入到系统中。</li><li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li><li>可以方便地实现对请求的Undo和Redo。</li></ol><p>缺点：</p><p>可能会导致某些系统有过多的具体命令类。</p><h3 id="适用环境-8">适用环境</h3><ol type="1"><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销操作和恢复操作。</li><li>系统需要将一组操作组合在一起，即支持宏命令。</li></ol><h2 id="中介者模式">9. 中介者模式</h2><p>动机：</p><p>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式。</p><h3 id="概念-10">概念</h3><p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><ul><li><p>Mediator Pattern</p></li><li><p>又称调停者模式</p></li><li><p>包含如下角色：抽象中介者、具体中介者、抽象同事类、具体同事类</p></li><li><p>职责：中转与协调</p></li></ul><h3 id="优缺点-9">优缺点</h3><p>优点：</p><ol type="1"><li>简化对象之间交互。</li><li>将各同事解耦。</li><li>减少子类生成。</li><li>可以简化各同事类的设计和实现。</li></ol><p>缺点：</p><p>具体中介者类非常复杂，使得系统难以维护。</p><h3 id="适用环境-9">适用环境</h3><ol type="1"><li><p>系统中对象间存在复杂引用关系。</p></li><li><p>一个对象由于引用了其他很多对象并且直接和这些对象通信而难以复用。</p></li><li><p>通过一个中间类来封装多个类中的行为。</p></li></ol><h2 id="观察者模式">10. 观察者模式</h2><p>动机：</p><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系。</p><h3 id="概念-11">概念</h3><p>定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。</p><ul><li><p>又称发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。</p></li><li><p>让主题和观察者之间松耦合。</p></li></ul><h3 id="优缺点-10">优缺点</h3><p>优点：</p><ol type="1"><li>实现表示层和数据逻辑层的分离。<ul><li>定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li></ul></li><li>在观察目标和观察者之间建立一个抽象的耦合。</li><li>支持广播通信。</li><li>符合开闭原则的要求。</li></ol><p>缺点：</p><ol type="1"><li>如果观察者太多，将所有的观察者都通知到会花费很多时间。</li><li>观察者和观察目标之间的循环依赖会导致系统崩溃。</li><li>没有相应的机制让观察者知道所观察的目标对象如何发生变化。</li></ol><h3 id="适用环境-10">适用环境</h3><ol type="1"><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li></ol><h2 id="状态模式">11. 状态模式</h2><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的（stateful）对象。</p><h3 id="概念-12">概念</h3><p>一个对象在其内部状态改变时改变它的行为。</p><ul><li><p>包含角色：环境类、抽象状态类、具体状态类。</p></li><li><p>关键：引入抽象状态类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</p></li><li><p>环境类与抽象状态类：</p><ul><li><p>环境类：拥有状态的对象</p></li><li><p>环境类有时候可以充当状态管理器(StateManager)的角色，可以在环境类中对状态进行切换操作。</p></li><li><p>状态类的产生是由于环境类存在多个状态，并且</p><ul><li>这些状态经常需要切换， 在不同的状态下对象的行为不同</li></ul><p>因此将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为。</p></li></ul></li></ul><h3 id="优缺点-11">优缺点</h3><p>优点：</p><ol type="1"><li>封装了转换规则。</li><li>枚举可能的状态，可以方便地增加新的状态。</li><li>状态转换逻辑与状态对象合成一体。</li><li>让多个环境对象共享一个状态对象。</li></ol><p>缺点：</p><ol type="1"><li>增加系统类和对象的个数</li><li>使用不当将导致程序结构和代码的混乱。</li><li>对开闭原则的支持并不太好<ul><li>增加新的状态类需要修改那些负责状态转换的源代码。</li></ul></li></ol><h3 id="适用环境-11">适用环境</h3><ol type="1"><li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li><li>代码中包含大量与对象状态有关的条件语句。</li></ol><h3 id="模式扩展-6">模式扩展</h3><ol type="1"><li>共享状态</li><li>简单状态模式（状态不变）</li><li>可切换状态的状态模式</li></ol><h2 id="策略模式">12. 策略模式</h2><h3 id="概念-13">概念</h3><p>一组各自封装的算法族，可以相互替换。策略让算法可以独立于使用它的用户而变化。</p><h3 id="适用环境-12">适用环境</h3><ol type="1"><li>当许多相关类仅在其行为上有所不同时。</li><li>算法的不同变体。</li><li>算法使用用户不应知道的数据。</li><li>一个类定义了许多行为，而这些行为在它的操作中表现为多个条件语句。</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件系统设计_面向对象设计原则</title>
    <link href="/2024/06/11/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2024/06/11/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>天生我材必有用，千金散尽还复来。</p><span id="more"></span><h1 id="面向对象设计原则">面向对象设计原则</h1><p>需求：系统需要满足的目标</p><p>规约：系统的外部可观察到的行为</p><p>架构：</p><ul><li><p>系统一级的主要组成部分</p></li><li><p>各部分的交互方法</p></li><li><p>使用的技术</p></li></ul><p>设计：</p><ul><li>如何完成任务</li><li>需要写的代码<ul><li>可维护、可复用</li></ul></li></ul><p>面向对象软件设计：将实现的约束条件应用到面向对象分析所产生的概念模型的过程。</p><ul><li><p>用方法和属性来描述用于构成系统的类</p></li><li><p>添加不明显属于领域的类，比如接口</p></li><li><p>描述类是如何构成组件的</p></li></ul><p>难点：将一个系统分解成对象</p><h2 id="面向对象设计原则概述">0. 面向对象设计原则概述</h2><p>目标：提高软件的可维护性和可复用性</p><p>Robert C.Martin认为一个软件设计可维护性较低通常的4个原因：</p><ul><li><p>过于僵硬（Rigidity）</p></li><li><p>过于脆弱（Fragility）</p></li><li><p>复用率低（Immobility）</p></li><li><p>黏度过高（Viscosity）</p></li></ul><p>Peter Coad认为，一个好的系统设计具备的三个性质:</p><ul><li>可扩展性（Extensibility）</li><li>灵活性（Flexibility）</li><li>可插入性（Pluggability）</li></ul><p>软件的复用拥有众多优点，如可以提高软件的开发效率，提高软件质量，节约开发成本。</p><p>恰当的复用还可以改善系统的可维护性。</p><p>面向对象设计复用的目标在于实现支持可维护性的复用。</p><p>在面向对象的设计里面，可维护性复用都是以面向对象设计原则为基础的，这些设计原则首先都是复用的原则，遵循这些设计原则可以有效地提高系统的复用性，同时提高系统的可维护性。</p><p>面向对象设计原则也是对系统进行合理重构的指南针，重构是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。</p><p>常用的7个面向对象设计原则：</p><ul><li>单一职责原则</li><li>开闭原则</li><li>里氏代换原则</li><li>依赖倒转原则</li><li>接口隔离原则</li><li>合成复用原则</li><li>迪米特法则</li></ul><p>这些原则并不是孤立存在的，它们相互依赖，相互补充。</p><h2 id="单一职责原则">1. 单一职责原则</h2><p>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类里。</p><ul><li>对一个类而言，应该仅有一个引起它变化的原因。</li></ul><p>一个类承担的职责越多，它被复用的可能性越小。让一个类承担过多的职责相当于将这些职责耦合，当其中一个职责变化时，可能会影响其他职责的运作。</p><p>数据职责（属性）和行为职责（方法）。</p><h2 id="开闭原则">2. 开闭原则</h2><p>一个软件实体应当对扩展开放，对修改关闭。</p><ul><li><p>在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。</p></li><li><p>软件实体可以指一个软件模块，一个由多个类组成的局部结构或一个独立的类。</p></li></ul><p>抽象化是开闭原则的关键。</p><p>对可变性封装原则：找到系统的可变因素并将其封装起来。</p><h2 id="里氏代换原则">3. 里氏代换原则</h2><p>如果对每一个类型为<span class="math inline">\(S\)</span>的对象<spanclass="math inline">\(o_1\)</span>，都有类型为<spanclass="math inline">\(T\)</span>的对象<spanclass="math inline">\(o_2\)</span>，使得以<spanclass="math inline">\(T\)</span>定义的所有程序<spanclass="math inline">\(P\)</span>在所有的对象<spanclass="math inline">\(o_2\)</span>都代换成<spanclass="math inline">\(o_1\)</span>时，程序<spanclass="math inline">\(P\)</span>的行为没有变化，那么类型<spanclass="math inline">\(S\)</span>是类型<spanclass="math inline">\(T\)</span>的子类型。</p><ul><li>所有引用基类的地方必须能透明地使用其子类的对象。</li></ul><p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><h2 id="依赖倒转原则">4. 依赖倒转原则</h2><p>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><ul><li><p>要针对接口编程，不要针对实现编程。</p></li><li><p>代码要依赖于抽象的类，而不要依赖于具体的类；要针对接口或抽象类编程，而不是针对具体类编程。</p></li></ul><p>如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。</p><p>依赖倒转原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件中。</p><p>类之间的耦合：</p><ul><li>零耦合关系</li><li>具体耦合关系</li><li>抽象耦合关系</li></ul><p>依赖倒转原则要求客户端依赖于抽象耦合，以抽象方式耦合是依赖倒转原则的关键。</p><h2 id="接口隔离原则">5. 接口隔离原则</h2><p>客户端不应该依赖那些它不需要的接口。</p><ul><li>一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。</li></ul><p>使用多个专门的接口，而不使用单一的总接口。每一个接口应该承担一种相对独立的角色。</p><p>使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</p><ul><li>只提供用户需要的行为，而隐藏用户不需要的行为。</li></ul><h2 id="合成复用原则">6. 合成复用原则</h2><p>尽量使用对象组合，而不是继承来达到复用的目的。</p><p>合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。</p><h2 id="迪米特法则">7. 迪米特法则</h2><p>也称最小知识原则。几种典型定义：</p><ol type="1"><li><p>不和“陌生人”说话。</p></li><li><p>只与你的直接朋友通信。</p></li><li><p>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。</p></li></ol><ul><li>一个软件实体应当尽可能少的与其他实体发生相互作用。</li></ul><p>对于一个对象，其朋友包括以下几类:</p><ul><li>当前对象本身</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象</li></ul><p>狭义迪米特法则：</p><p>如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p><p>广义的迪米特法则：</p><p>指对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制。</p><p>迪米特法则的主要用途在于控制信息的过载：</p><ol type="1"><li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及;</li><li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限;</li><li>在类的设计上，只要有可能，一个类型应当设计成不变类;</li><li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ol><h2 id="小结">8. 小结</h2><ol start="0" type="1"><li><p>对于面向对象的软件系统设计来说，在支持可维护性的同时，需要提高系统的可复用性。</p></li><li><p>软件的复用可以提高软件的开发效率，提高软件质量，节约开发成本，恰当的复用还可以改善系统的可维护性。</p></li><li><p>单一职责原则要求在软件系统中，一个类只负责一个功能领域中的相应职责。</p></li><li><p>开闭原则要求一个软件实体应当对扩展开放，对修改关闭，即在不修改源代码的基础上扩展一个系统的行为。</p></li><li><p>里氏代换原则可以通俗表述为在软件中如果能够使用基类对象，那么一定能够使用其子类对象。</p></li><li><p>依赖倒转原则要求抽象不应该依赖于细节，细节应该依赖于抽象;要针对接口编程，不要针对实现编程。</p></li><li><p>接口隔离原则要求客户端不应该依赖那些它不需要的接口，即将一些大的接口细化成一些小的接口供客户端使用。</p></li><li><p>合成复用原则要求复用时尽量使用对象组合，而不使用继承。</p></li><li><p>迪米特法则要求一个软件实体应当尽可能少的与其他实体发生相互作用。</p></li></ol><p>目标：开闭原则</p><p>指导：最小知识原则</p><p>基础：单一职责原则、可变性封装原则</p><p>实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则</p>]]></content>
    
    
    <categories>
      
      <category>软件系统设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程_4_内核驱动</title>
    <link href="/2024/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E7%AB%A0%20%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/"/>
    <url>/2024/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E7%AB%A0%20%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第4章-内核驱动">第4章 内核驱动</h1><h2 id="什么是内核">0. 什么是内核？</h2><p>操作系统是一系列程序的集合，其中最重要的部分构成了内核。</p><p>单内核/微内核</p><ul><li>单内核是一个很大的进程，内部可以分为若干模块，运行时是一个独立的二进制文件，模块间通讯通过直接调用函数实现</li><li>微内核中大部分内核作为独立的进程在特权下运行，通过消息传递进行通讯</li></ul><p>Linux内核的能力</p><ul><li>内存管理，文件系统，进程管理，多线程支持，抢占式，多处理支持</li></ul><p>Linux内核区别于其他UNIX商业内核的优点</p><ul><li>单内核，模块支持</li><li>免费/开源</li><li>支持多种CPU，硬件支持能力非常强大</li><li>Linux开发者都是非常出色的程序员</li><li>通过学习Linux内核的源码可以了解现代操作系统的实现原理</li></ul><h3 id="配置内核">配置内核</h3><p>下载源码、解压、make clean、<strong>make menuconfig</strong></p><figure><img src="/image/Linux系统编程/menu.png" alt="menu" /><figcaption aria-hidden="true">menu</figcaption></figure><p>编译内核：</p><ul><li>make</li><li>make zImage、make bzImage：生成压缩内核镜像</li><li>make modules：编译模块</li></ul><p>make install：将编译好的内核copy到/boot</p><h2 id="驱动">1. 驱动</h2><p>许多常见驱动的源代码集成在内核源码里，也有第三方开发的驱动，可以单独编译成模块.ko。编译需要内核头文件的支持。</p><p>驱动运行在内核态。</p><h3 id="加载模块">加载模块</h3><p>底层命令：</p><p>insmod：<code>insmod [options] module_file</code></p><ul><li><code>-f</code>: 强制加载模块，即使模块已被其他进程使用。</li><li><code>-o</code>: 指定模块的参数。</li><li><code>-v</code>: 显示详细信息。</li></ul><p>rmmod：<code>rmmod [options] module_name</code></p><ul><li><code>-f</code>: 强制卸载模块，即使模块已被其他进程使用。</li><li><code>-s</code>: 模块卸载后，不更新/proc/modules文件。</li><li><code>-w</code>: 在卸载模块之前，等待其关闭所有文件描述符。</li></ul><p>高层命令：</p><p>modprobe：<code>modprobe [options] module_name</code></p><ul><li><code>-a</code>: 自动加载所有依赖的模块。</li><li><code>-c</code>: 从 /etc/modprobe.conf 中读取配置。</li><li><code>-d</code>: 检测模块依赖，但不加载它们。</li><li><code>-e</code>: 禁止使用某些内核特性（如 SMP）。</li><li><code>-k</code>: 保留内核符号表。</li><li><code>-l</code>: 列出可以加载的模块，而不实际加载它们。</li><li><code>-n</code>: 禁止自动插入已指定名字的模块。</li><li><code>-p</code>: 使用预设的模块参数。</li><li><code>-r</code>: 删除模块及其依赖的模块。</li><li><code>-s</code>: 使模块静默加载，不输出信息。</li><li><code>-v</code>: 输出更多的信息。</li></ul><p>模块依赖</p><p>自动按需加载/卸载</p><p>moddep：列出指定内核模块所依赖的其他模块</p><p>lsmod：列出当前内核加载的所有模块及其各种信息</p><p>modinfo：显示关于内核模块的详细信息</p><h3 id="模块编写">模块编写</h3><p>不能使用c库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/moduleparam.h&gt;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> test;<br><span class="hljs-built_in">module_param</span>(test, <span class="hljs-type">int</span>, <span class="hljs-number">0644</span>);<span class="hljs-comment">//module_param(变量名称，类型, 访问许可掩码)</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">hello_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(KERN_INFO “Hello world test=%d \n” , test);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">hello_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(KERN_INFO <span class="hljs-string">&quot;Goodbye world\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-built_in">MODULE_DESCRIPTION</span>(<span class="hljs-string">&quot;Test&quot;</span>);<br><span class="hljs-built_in">MODULE_AUTHOR</span>(<span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-built_in">module_init</span>(hello_init);<br><span class="hljs-built_in">module_exit</span>(hello_exit);<br></code></pre></td></tr></table></figure><h4 id="导出符号">导出符号</h4><p>如果一个模块需要向其他模块导出符号（方法或全局变量），需要使用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">EXPORT_SYMBOL(<span class="hljs-params">name</span>)</span>;<br><span class="hljs-constructor">EXPORT_SYMBOL_GPL(<span class="hljs-params">name</span>)</span>;<br></code></pre></td></tr></table></figure><p>符号必须在模块文件的全局部分导出。</p><p>/proc/kallsyms 可以显示所有导出的符号。</p><h3 id="字符设备">字符设备</h3><h4 id="设备号">设备号</h4><p>一个字符设备或者块设备都有一个主设备号和次设备号。</p><ul><li>主设备号和次设备号统称为设备号。<ul><li>主设备号用来表示一个特定的驱动程序。</li><li>次设备号用来表示使用该驱动程序的各设备。</li></ul></li></ul><h4 id="cdev">cdev</h4><p>linux内核中使用cdev结构体来描述字符设备。该结构体是所有字符设备的抽象，其包含了大量字符设备所共有的特性。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> cdev *my_cdev = cdev<span class="hljs-constructor">_alloc()</span>;<br>my_cdev-&gt;ops = &amp;my_fops;<br>void cdev<span class="hljs-constructor">_init(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">cdev</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file_operations</span> <span class="hljs-operator">*</span><span class="hljs-params">fops</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="初始化加载过程">初始化加载过程</h4><ol type="1"><li>申请设备号</li><li>定义文件操作结构体 file_operations</li><li>创建并初始化定义结构体 cdev</li><li>将cdev注册到系统，并和对应的设备号绑定</li><li>在/dev文件系统中用mknod创建设备文件，并将该文件绑定到设备号上</li></ol><p>申请释放设备号：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">first</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>;<br><span class="hljs-built_in">int</span> alloc<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">firstminor</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>;<br>void unregister<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">first</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span>;<br></code></pre></td></tr></table></figure><p>设备注册与释放</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> cdev<span class="hljs-constructor">_add(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">dev_t</span> <span class="hljs-params">num</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">count</span>)</span>;<br>void cdev<span class="hljs-constructor">_del(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux系统编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程_3_编程</title>
    <link href="/2024/05/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0%20Linux%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC3%E7%AB%A0%20Linux%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第3章-linux编程">第3章 Linux编程</h1><h2 id="编程前的准备">0. 编程前的准备</h2><h3 id="编译命令">0.1 编译命令</h3><p>gcc -c（编译）</p><p>gcc（链接 或者 编译 + 链接）</p><p>g++（C++对应的命令，其实就是换了前端）</p><p>gcc [options] [filename]</p><p>基础可选项:</p><ul><li>-E: 只对源程序进行预处理(调用cpp预处理器)</li><li>-S: 只对源程序进行预处理、编译</li><li>-c: 执行预处理、编译、汇编而不链接</li><li>-o output_file: 指定输出文件名</li><li>-g: 产生调试工具必需的符号信息</li><li>-O/On: 在程序编译、链接过程中进行优化处理</li><li>-Wall: 显示所有的警告信息</li><li>-Idir: 指定额外的头文件搜索路径</li><li>-Ldir: 指定额外的库文件搜索路径</li><li>-lname: 链接时搜索指定的库文件</li><li>-DMACRO[=DEFN]: 定义MACRO宏</li></ul><h3 id="make">0.2 make</h3><p>make [-f Makefile] [option] [target]</p><p>makefile描述模块间的依赖关系，make命令根据makefile对程序进行管理和维护；make判断被维护文件的时序关系。</p><h4 id="make执行顺序">make执行顺序</h4><ol type="1"><li>make会在当前目录下找名字叫“Makefile” 或“makefile” 的文件。</li><li>查找文件中的第一个目标文件（target），举例中的hello</li><li>如果hello文件不存在，或是hello所依赖的文件修改时间要比hello新，就会执行后面所定义的命令来生成hello文件。</li><li>如果hello所依赖的.o文件不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（类似一个堆栈的过程）</li><li>make根据.o文件的规则生成 .o 文件，然后再用 .o文件生成hello文件。</li></ol><h4 id="makefile规则结构">Makefile规则结构</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">target <span class="hljs-string">...</span> : prerequisites <span class="hljs-string">...</span><br><span class="hljs-keyword">command</span>```<br></code></pre></td></tr></table></figure><ul><li>target是一个目标文件，可以是Object File，也可以是执行文件</li><li>prerequisites是要生成target所需要的文件或是目标</li><li>command是make需要执行的命令。（可以是任意的Shell命令）</li></ul><p>例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hello : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span><br>gcc -o hello <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span><br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> defs<span class="hljs-selector-class">.h</span><br>cc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br><span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.o</span> : <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.c</span> defs<span class="hljs-selector-class">.h</span> command<span class="hljs-selector-class">.h</span><br>cc -c <span class="hljs-selector-tag">kbd</span><span class="hljs-selector-class">.c</span><br>clean :<br>rm edit <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">kbd</span>.o<br></code></pre></td></tr></table></figure><p>伪目标：clean</p><p>取名不能和文件名重名，可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”。</p><ul><li><p>一般没有依赖的文件，但也可以为伪目标指定所依赖的文件。</p></li><li><p>伪目标同样可以作为“默认目标”，只要将其放在第一个。</p></li></ul><h4 id="预定义变量">预定义变量</h4><ul><li>$&lt; 第一个依赖文件的名称</li><li>$?所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚</li><li>$+所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件</li><li>$^ 所有的依赖文件，以空格分开，不包含重复的依赖文件</li><li>$* 不包括扩展名的目标文件名称</li><li>$@ 目标的完整名称</li><li>$% 如果目标是归档成员，则该变量表示目标的归档成员名称</li></ul><h4 id="多目标扩展">多目标扩展</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">targets</span> <span class="hljs-attr">...</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">target-pattern</span>&gt;</span>: <span class="hljs-tag">&lt;<span class="hljs-name">prereq-patterns</span> <span class="hljs-attr">...</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">commands</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objects = foo.o bar.o<br><span class="hljs-section">all: <span class="hljs-variable">$(objects)</span></span><br><span class="hljs-variable">$(objects)</span>: %.o: %.c<br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><ul><li>目标从$object中获取</li><li>“%.o”表明要所有以“.o”结尾的目标，即“foo.obar.o”，就是变量$object集合的模式</li><li>依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是依赖的目标就是“foo.c bar.c”</li></ul><h4 id="函数">函数</h4><p>调用语法：</p><ul><li><p><code>$(&lt;function&gt; &lt;arguments&gt;)</code></p></li><li><p><code>$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</code></p></li><li><p>字符串处理函数</p><ul><li><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></li><li><code>$(strip &lt;string&gt;)</code></li></ul></li><li><p>文件名操作函数</p><ul><li><code>$(dir &lt;names...&gt;)</code></li><li><code>$(basename &lt;names...&gt;)</code></li></ul></li><li><p>foreach函数：<code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></p></li><li><p>if函数：<code>$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code></p></li><li><p>call函数：<code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</code></p></li></ul><h2 id="文件系统">1. 文件系统</h2><p>文件：可以被读写的对象。</p><ul><li>文件的属性包含访问权限、文件类型。</li></ul><p>文件系统：文件及其属性的集合。</p><h3 id="文件类型和结构">1.1 文件类型和结构</h3><p>文件类型：</p><ul><li>-：常规文件</li><li>d：目录</li><li>l：链接</li><li>c：字符设备文件</li><li>b：块设备文件</li><li>p：管道</li><li>s：套接字</li></ul><p>文件结构：字节流</p><h3 id="vfsvirtual-file-system-switch">1.2 VFS：Virtual File SystemSwitch</h3><p>用户程序系统调用的统一接口，连接Ext2、FAT等多种不同的文件系统。</p><p>虚拟、只存在于内存。</p><p>组件：</p><ul><li>超级块：文件系统的元数据，它包含了文件系统的全局信息，如块大小、inode和数据块的数量、分配策略等。</li><li>i-node：文件的元数据，如文件的大小、创建时间、最后访问时间、最后修改时间、文件权限等，但不包括文件名和文件数据本身。</li><li>文件：打开的文件，包含了读写文件的当前位置、文件的状态等。</li><li>dentry：文件系统中的一个目录入口，即一个路径名与一个i-node的映射。</li></ul><h3 id="硬链接和符号链接">1.3 硬链接和符号链接</h3><p>硬链接：</p><ul><li>不同的文件名对应同一个inode</li><li>不能跨越文件系统</li><li>对应系统调用link</li></ul><p>符号链接</p><ul><li>存储被链接文件的文件名(而不是inode)实现链接</li><li>可跨越文件系统</li><li>对应系统调用symlink</li></ul><h3 id="系统调用和库函数">1.4 系统调用和库函数</h3><p>都是C函数。</p><p>系统调用：Linux内核的对外接口；用户程序和内核之间唯一的接口。</p><p>库函数：依赖于系统调用，提供较复杂功能。</p><h4 id="基础io系统调用">基础I/O系统调用</h4><ul><li>文件描述符：非负整数<ul><li>STDIN_FILENO (0)、STDOUT_FILENO (1)、STDERR_FILENO (2)</li></ul></li><li>基础I/O函数<ul><li>open/creat、close、read、write、lseek</li><li>dup/dup2</li><li>fcntl</li><li>ioctl</li></ul></li></ul><h5 id="opencreat">open/creat</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br>(Return: a <span class="hljs-keyword">new</span> file descriptor <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>flags：文件访问模式。</p><ul><li>O_RDONLY：只读</li><li>O_WRONLY：只写</li><li>O_RDWR：读写</li><li>O_APPEND：追加</li><li>O_TRUNC：如果文件存在，截断到0字节</li><li>O_CREAT：文件不存在则创建</li><li>O_EXCL：与 <code>O_CREAT</code>标志结合使用。如果文件已存在则报错。</li></ul><p>mode：八进制数，文件权限。</p><figure><img src="/image/Linux系统编程/权限.png" alt="权限" /><figcaption aria-hidden="true">权限</figcaption></figure><p>umask：一个环境变量，决定了文件创建时的权限掩码。</p><ul><li>mode &amp; ~umask，得到最终创建的文件权限。</li></ul><h5 id="close">close</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h5 id="readwrite">read/write</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br>(返回值: 读到的字节数，若已到文件尾为<span class="hljs-number">0</span>，若出错为<span class="hljs-number">-1</span>)<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br>(返回值: 若成功为已写的字节数，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h5 id="lseek">lseek</h5><p>改变文件读写位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br>(Return: the resulting offset location <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>whence（出发点）：</p><ul><li>SEEK_SET</li><li>SEEK_CUR</li><li>SEEK_END</li></ul><h5 id="dupdup2">dup/dup2</h5><p>复制文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span></span>;<br>(Return: the <span class="hljs-keyword">new</span> file descriptor <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h5 id="fcntl">fcntl</h5><p>管理文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">long</span> arg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> flock *lock)</span></span>;<br>(返回值: 若成功则依赖于cmd，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><p>cmd：</p><ul><li>F_DUPFD：复制文件描述符</li><li>F_GETFD/F_SETFD：获取设置文件描述符控制标志</li><li>F_GETFL/F_SETFL：获取设置文件描述符状态标志</li><li>F_GETOWN/F_SETOWN：获取设置I/O可用性标志</li><li>F_GETLK/F_SETLK/F_SETLKW：获取设置文件锁</li></ul><h5 id="ioctl">ioctl</h5><p>控制设备。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> request, ...)</span></span>;<br></code></pre></td></tr></table></figure><p>重定向用到了哪些系统调用？</p><h4 id="标准io库">标准I/O库</h4><p>主要考察缓冲。</p><p>文件流</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs julia">FILE* fp;<br>// <span class="hljs-literal">stdin</span> <span class="hljs-literal">stdout</span> <span class="hljs-literal">stderr</span><br></code></pre></td></tr></table></figure><p>三种缓冲：</p><ul><li>块缓冲</li><li>线性缓冲</li><li>无缓冲</li></ul><p>setbuf、setvbuf</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setvbuf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> mode, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>mode：_IOFBF（满缓冲）、_IOLBF（行缓冲）、_IONBF（无缓冲）</p><p>流式I/O函数：</p><ul><li><p>open/close</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FILE *<span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fclose</span><span class="hljs-params">(FILE *stream)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>mode：r w a r+(读写) w+(读写，无则新建，有则清空)a+(读与追加，无则新建)</p></li><li><p>read/write</p><ul><li><p>每次一个字符的I/O</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getc</span>(<span class="hljs-params">FILE *fp</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fgetc</span>(<span class="hljs-params">FILE *fp</span>)</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getchar</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)</span>;<br>（Result: Reads the next character <span class="hljs-keyword">from</span> a stream <span class="hljs-keyword">and</span> returns it <span class="hljs-keyword">as</span> an unsigned <span class="hljs-built_in">char</span> cast to an <span class="hljs-built_in">int</span>, <span class="hljs-keyword">or</span> EOF <span class="hljs-keyword">on</span> end of file <span class="hljs-keyword">or</span> error.）<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">ungetc</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> c, FILE *stream</span>)</span>; <span class="hljs-comment">// 将字符插回流中</span><br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-built_in">int</span> putc(<span class="hljs-built_in">int</span> c, <span class="hljs-keyword">FILE</span> *fp);<br><span class="hljs-built_in">int</span> fputc(<span class="hljs-built_in">int</span> c, <span class="hljs-keyword">FILE</span> *fp);<br><span class="hljs-built_in">int</span> putchar(<span class="hljs-built_in">int</span> c);<br>(<span class="hljs-keyword">Return</span>: the <span class="hljs-keyword">character</span> <span class="hljs-keyword">if</span> success; -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure></li><li><p>每次一行的I/O</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span>; <span class="hljs-comment">//not recommended.</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>直接I/O(二进制I/O)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span></span>;<br>(Return: the number of a items successfully read <span class="hljs-keyword">or</span> written.)<br></code></pre></td></tr></table></figure></li><li><p>格式化I/O</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">scanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sscanf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span></span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>reposition</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">ftell</span><span class="hljs-params">(FILE *stream)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rewind</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fgetpos</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">fpos_t</span> *pos)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fsetpos</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">fpos_t</span> *pos)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>flush</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fflush</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>流与文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fileno</span><span class="hljs-params">(FILE *fp)</span></span>;<br><span class="hljs-function">FILE *<span class="hljs-title">fdopen</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>临时文件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">char *<span class="hljs-built_in">tmpnam</span>(char *s);<br>(返回值: 指向唯一路径名的指针)<br>FILE *<span class="hljs-built_in">tmpfile</span>(void);<br>(返回值: 若成功为文件指针，若出错为NULL)<br></code></pre></td></tr></table></figure></li></ul><h4 id="高级系统调用">高级系统调用</h4><p>stat、fstat：返回文件状态信息，存储在buf中</p><p>lstat：获取符号链接本身的状态信息，存储在buf中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> filedes, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file_name, <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> &#123;<br><span class="hljs-type">mode_t</span> st_mode; <span class="hljs-comment">/*file type &amp; mode*/</span><br><span class="hljs-type">ino_t</span> st_ino; <span class="hljs-comment">/*inode number (serial number)*/</span><br><span class="hljs-type">dev_t</span> st_rdev; <span class="hljs-comment">/*device number (file system)*/</span><br><span class="hljs-type">nlink_t</span> st_nlink; <span class="hljs-comment">/*link count*/</span><br><span class="hljs-type">uid_t</span> st_uid; <span class="hljs-comment">/*user ID of owner*/</span><br><span class="hljs-type">gid_t</span> st_gid; <span class="hljs-comment">/*group ID of owner*/</span><br><span class="hljs-type">off_t</span> st_size; <span class="hljs-comment">/*size of file, in bytes*/</span><br><span class="hljs-type">time_t</span> st_atime; <span class="hljs-comment">/*time of last access*/</span><br><span class="hljs-type">time_t</span> st_mtime; <span class="hljs-comment">/*time of last modification*/</span><br><span class="hljs-type">time_t</span> st_ctime; <span class="hljs-comment">/*time of last file status change*/</span><br><span class="hljs-type">long</span> st_blksize; <span class="hljs-comment">/*Optimal block size for I/O*/</span><br><span class="hljs-type">long</span> st_blocks; <span class="hljs-comment">/*number 512-byte blocks allocated*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>测试文件类型：sys/stat.h</p><ul><li>S_ISREG()</li><li>S_ISDIR()</li><li>S_ISCHAR()</li><li>S_ISBLK()</li><li>S_ISFIFO()</li><li>S_ISLNK()</li><li>S_ISSOCK()</li></ul><p>文件权限</p><ul><li><p>rwx</p></li><li><p>SUID：需要有效uid</p></li><li><p>SGID：需要有效gid</p></li><li><p>Sticky bit：只有owner</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchmod</span><span class="hljs-params">(<span class="hljs-type">int</span> fildes, <span class="hljs-type">mode_t</span> mode)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchown</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lchown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">mode_t</span> <span class="hljs-title">umask</span><span class="hljs-params">(<span class="hljs-type">mode_t</span> mask)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">symlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br>(Return: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success; <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">readlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> bufsiz)</span></span>;<br>(Return: the count of characters placed in the buffer <span class="hljs-keyword">if</span> success;<span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><p>目录</p><ul><li>mkdir/rmdir</li><li>chdir/fchdir, getcwd</li><li>读取目录：DIR数据结构<ul><li>opendir/closedir</li><li>readdir</li><li>telldir</li><li>seekdir</li></ul></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rmdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fchdir</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dir)</span></span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *<span class="hljs-built_in">readdir</span>(DIR *dir);<br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">telldir</span><span class="hljs-params">(DIR *dir)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">seekdir</span><span class="hljs-params">(DIR *dir, <span class="hljs-type">off_t</span> offset)</span></span>;<br></code></pre></td></tr></table></figure><p>文件锁 important</p><ul><li><p>记录锁</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fcntl</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> fd, <span class="hljs-built_in">int</span> cmd, <span class="hljs-keyword">struct</span> flock *<span class="hljs-keyword">lock</span></span>)</span>;<br>(返回值: 若成功则依赖于cmd，若出错为<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure></li><li><p>劝告锁</p><ul><li>检查，加锁有应用程序自己控制</li></ul></li><li><p>强制锁</p><ul><li>检查，加锁由内核控制</li><li>影响[open() read() write()]等</li></ul></li><li><p>共享锁</p></li><li><p>排他锁</p></li><li><p>共享模式强制锁</p></li><li><p>租借锁</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">flock</span>&#123;<br>...<br><span class="hljs-type">short</span> l_type; <span class="hljs-comment">/* Type of lock: F_RDLCK, F_WRLCK, F_UNLCK */</span><br><span class="hljs-type">short</span> l_whence; <span class="hljs-comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR,</span><br><span class="hljs-comment">SEEK_END */</span><br><span class="hljs-type">off_t</span> l_start; <span class="hljs-comment">/* Starting offset for lock */</span><br><span class="hljs-type">off_t</span> l_len; <span class="hljs-comment">/* Number of bytes to lock */</span><br><span class="hljs-type">pid_t</span> l_pid; <span class="hljs-comment">/* PID of process blocking our lock (F_GETLK only) */</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>cmd</p><ul><li>F_GETLK：获得文件的封锁信息</li><li>F_SETLK：对文件的某个区域封锁或解除封锁</li><li>F_SETLKW：功能同F_SETLK，wait方式。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/file.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lockf</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, <span class="hljs-type">off_t</span> len)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="多核编程">2. 多核编程</h2><h3 id="exec">exec</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg0, ..., (<span class="hljs-type">char</span> *)<span class="hljs-number">0</span>, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>execl</code>、<code>execlp</code>和<code>execle</code>：可变参数为逐个列举。<code>execl</code>和<code>execle</code>带有环境变量，而<code>execlp</code>不带环境变量。实际上会调用对应的v系列函数。</p></li><li><p><code>execv</code>、<code>execvp</code>和<code>execve</code>：可变参数为NULL结尾的指针数组。<code>execv</code>和<code>execvp</code>不带环境变量，而<code>execve</code>可以传递环境变量。前两者最终会调用execve函数。</p></li></ul><h3 id="fork">fork</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)<br>&#123;子进程执行的代码段；&#125;<br><span class="hljs-keyword">else</span><br>&#123;父进程执行的代码段；&#125;<br></code></pre></td></tr></table></figure><h3 id="wait-waitpid">wait &amp; waitpid</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *status)</span></span>;<br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *status, <span class="hljs-type">int</span> options)</span></span>;<br></code></pre></td></tr></table></figure><p>wait：调用wait函数的进程会被挂起，等待任意一个子进程结束，如果该子进程结束了，此函数会回收子进程的资源。</p><ul><li>如果成功，wait会返回被收集的子进程的进程ID；</li><li>如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。</li></ul><p>waitpid：回收指定进程号的子进程，可以设置是否阻塞。</p><ul><li><p>pid=0，等待任意子进程。</p></li><li><p>pid=-1，回收所有子进程。</p></li><li><p>pid&lt;-1，其绝对值为某个进程组的组id，回收该进程组的所有进程。</p></li><li><p>status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。</p></li><li><p>options：WNOHANG，非阻塞。</p></li></ul><ol type="1"><li><p>当正常返回的时候，waitpid返回收集到的子进程的进程ID；</p></li><li><p>如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0；　　</p></li><li><p>如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在；</p><p>当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD。</p></li></ol><h3 id="signal">Signal</h3><p>信号处理</p><ul><li><p>忽略信号</p></li><li><p>不能忽略的信号： SIGKILL, SIGSTOP、一些硬件异常信号</p></li><li><p>执行系统默认动作</p></li><li><p>捕捉信号</p></li></ul><p>signal函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span></span>;<br>(Returned Value: the previous handler <span class="hljs-keyword">if</span> success, SIG_ERR <span class="hljs-keyword">if</span> error)<br></code></pre></td></tr></table></figure><p>handler为用户定义的函数。</p><h4 id="kill和raise">kill和raise</h4><p>kill向进程发送信号，raise向当前进程发送信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span></span>;<br>(Returned Value: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success, <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">raise</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>;<br>(Returned Value: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> success, <span class="hljs-number">-1</span> <span class="hljs-keyword">if</span> failure)<br></code></pre></td></tr></table></figure><h4 id="alarm和pause">alarm和pause</h4><p>alarm：一定时间后发送SIGALRM信号。</p><p>pause：挂起等待信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seconds)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pause</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>组合两者可以让进程等待一段时间后执行。</p><h4 id="可靠信号机制">可靠信号机制</h4><h3 id="可重入函数">可重入函数</h3><p>可以被中断的函数。</p><p>不可重入函数：</p><ul><li>系统资源</li><li>全局变量</li><li>使用静态数据结构</li><li>malloc、free</li><li>标准IO函数</li></ul><h3 id="posix-thread">POSIX Thread</h3><p>编译：gcc thread.c –o thread –lpthread</p><h4 id="创建和终止">创建和终止</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_t</span> *thread,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_attr_t</span> *attr,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *),</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">void</span> *arg)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="等待和分离">等待和分离</h4><p>Joinable Thread：可连接线程</p><ul><li>可以被其他线程等待（join）的线程。</li></ul><p>Detached Thread：分离线程</p><ul><li>启动后独立运行的线程。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;pthread.h&gt;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_join(<span class="hljs-params">pthread_t</span> <span class="hljs-params">th</span>, <span class="hljs-params">void</span> <span class="hljs-operator">**</span><span class="hljs-params">thread_return</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_detach(<span class="hljs-params">pthread_t</span> <span class="hljs-params">th</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="线程同步">线程同步</h4><h5 id="信号量">信号量</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_init(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-params">pshared</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">value</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_wait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_post(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_destroy(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_trywait(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>)</span>;<br><span class="hljs-built_in">int</span> sem<span class="hljs-constructor">_getvalue(<span class="hljs-params">sem_t</span> <span class="hljs-operator">*</span><span class="hljs-params">sem</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">sval</span>)</span>;<br></code></pre></td></tr></table></figure><p>生产者-消费者问题：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/wait.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;fcntl.h&gt;</span><br><span class="hljs-comment">#include &lt;semaphore.h&gt;</span><br><br><span class="hljs-comment">#define BUFFER_SIZE 10</span><br><span class="hljs-comment">#define PRODUCER_COUNT 3</span><br><span class="hljs-comment">#define CONSUMER_COUNT 2</span><br><br>sem_t empty, full, mutex;<br>int buffer[BUFFER_SIZE];<br>int <span class="hljs-keyword">in</span> = <span class="hljs-number">0</span>;<br>int out = <span class="hljs-number">0</span>;<br><br>void produce(int index) &#123;<br>    sem_wait(&amp;empty);<br>    sem_wait(&amp;mutex);<br><br>    printf(<span class="hljs-string">&quot;生产者%d生产了一个产品\n&quot;</span>, index);<br>    buffer[<span class="hljs-keyword">in</span>] = index;<br>    <span class="hljs-keyword">in</span> = (<span class="hljs-keyword">in</span> + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br><br>    sem_post(&amp;mutex);<br>    sem_post(&amp;full);<br>&#125;<br><br>void consume(int index) &#123;<br>    sem_wait(&amp;full);<br>    sem_wait(&amp;mutex);<br><br>    printf(<span class="hljs-string">&quot;消费者%d消费了一个产品\n&quot;</span>, index);<br>    buffer[out] = -<span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 或者可以用某种方式标记为已消费<br>    out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br><br>    sem_post(&amp;mutex);<br>    sem_post(&amp;empty);<br>&#125;<br><br>int main() &#123;<br>    <span class="hljs-regexp">//</span> 初始化信号量<br>    <span class="hljs-keyword">if</span> (sem_init(&amp;empty, <span class="hljs-number">1</span>, BUFFER_SIZE) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sem_init(&amp;full, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sem_init(&amp;mutex, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == -<span class="hljs-number">1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;sem_init&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    pid_t pid;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; PRODUCER_COUNT; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 子进程，生产者<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                produce(i);<br>                sleep(rand() % <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 随机睡眠以模拟不同生产者生产速度<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; CONSUMER_COUNT; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>            <span class="hljs-keyword">exit</span>(EXIT_FAILURE);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-regexp">//</span> 子进程，消费者<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>                consume(i);<br>                sleep(rand() % <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 随机睡眠以模拟不同消费者消费速度<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-regexp">//</span> 等待所有生产者和消费者结束<br>    <span class="hljs-keyword">while</span> (wait(NULL) &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-regexp">//</span> 销毁信号量<br>    sem_destroy(&amp;empty);<br>    sem_destroy(&amp;full);<br>    sem_destroy(&amp;mutex);<br><br>    <span class="hljs-keyword">exit</span>(EXIT_SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="互斥量">互斥量</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex, <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *mutexattr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><br><span class="hljs-type">int</span> buffer[BUFFER_SIZE];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> out = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 互斥量初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex, empty, full;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        <span class="hljs-keyword">while</span> (in == BUFFER_SIZE) &#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>); <span class="hljs-comment">// 生产者等待</span><br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        &#125;<br><br>        <span class="hljs-comment">// 生产产品</span><br>        buffer[in] = *(<span class="hljs-type">int</span>*)arg;<br>        in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产了产品 %d\n&quot;</span>, *(<span class="hljs-type">int</span>*)arg);<br><br>        <span class="hljs-comment">// 通知消费者有新产品</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        full++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有产品</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        <span class="hljs-keyword">while</span> (out == in) &#123;<br>            <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>); <span class="hljs-comment">// 消费者等待</span><br>            <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;full);<br>        &#125;<br><br>        <span class="hljs-comment">// 消费产品</span><br>        <span class="hljs-type">int</span> product = buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费了产品 %d\n&quot;</span>, product);<br><br>        <span class="hljs-comment">// 通知生产者有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;full);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;empty);<br>        empty++;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;empty);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; mutex init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;empty, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; empty init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;full, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; full init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_t</span> pid, cid;<br>    <span class="hljs-type">int</span> producer_arg = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> consumer_arg = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建生产者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, producer, &amp;producer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建消费者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;cid, <span class="hljs-literal">NULL</span>, consumer, &amp;consumer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(cid, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 销毁互斥量</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;empty);<br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;full);<br></code></pre></td></tr></table></figure><h5 id="条件变量">条件变量</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_init(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>, <span class="hljs-params">pthread_condattr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond_attr</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_destory(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_wait(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>, <span class="hljs-params">pthread_mutex_t</span> <span class="hljs-params">mutex</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_signal(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-params">cond</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_broadcast(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-params">cond</span>)</span>;<br></code></pre></td></tr></table></figure><p>条件变量使用：与互斥量结合</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><br><span class="hljs-type">int</span> buffer[BUFFER_SIZE];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> out = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 互斥量初始化</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-comment">// 条件变量初始化</span><br><span class="hljs-type">pthread_cond_t</span> empty, full;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有空余位置</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">while</span> (in == BUFFER_SIZE) &#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;empty, &amp;mutex);<br>        &#125;<br><br>        <span class="hljs-comment">// 生产产品</span><br>        buffer[in] = *(<span class="hljs-type">int</span>*)arg;<br>        in = (in + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产了产品 %d\n&quot;</span>, *(<span class="hljs-type">int</span>*)arg);<br><br>        <span class="hljs-comment">// 通知消费者有新产品</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;full);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 等待有产品</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-keyword">while</span> (out == in) &#123;<br>            <span class="hljs-built_in">pthread_cond_wait</span>(&amp;full, &amp;mutex);<br>        &#125;<br><br>        <span class="hljs-comment">// 消费产品</span><br>        <span class="hljs-type">int</span> product = buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) % BUFFER_SIZE;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费了产品 %d\n&quot;</span>, product);<br><br>        <span class="hljs-comment">// 通知生产者有空余位置</span><br>        <span class="hljs-built_in">pthread_cond_signal</span>(&amp;empty);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; mutex init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化条件变量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_cond_init</span>(&amp;empty, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; empty init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_cond_init</span>(&amp;full, <span class="hljs-literal">NULL</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; full init failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">pthread_t</span> pid, cid;<br>    <span class="hljs-type">int</span> producer_arg = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> consumer_arg = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建生产者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;pid, <span class="hljs-literal">NULL</span>, producer, &amp;producer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建消费者线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;cid, <span class="hljs-literal">NULL</span>, consumer, &amp;consumer_arg)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(pid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(cid, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 销毁互斥量</span><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;empty);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;full);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程取消">线程取消</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cancel(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcancelstate(<span class="hljs-params">int</span> <span class="hljs-params">state</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldstate</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setcanceltype(<span class="hljs-params">int</span> <span class="hljs-params">type</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">oldtype</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="线程局部存储-tls">线程局部存储 TLS</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_key_create(<span class="hljs-params">pthread_key_t</span> <span class="hljs-operator">*</span><span class="hljs-params">key</span>, <span class="hljs-params">void</span> (<span class="hljs-operator">*</span><span class="hljs-params">destructor</span>)</span>(void*));<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_key_delete(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>)</span>;<br>void *pthread<span class="hljs-constructor">_getspecific(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setspecific(<span class="hljs-params">pthread_key_t</span> <span class="hljs-params">key</span>, <span class="hljs-params">const</span> <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">value</span>)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux系统编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程_2_Shell</title>
    <link href="/2024/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E7%AB%A0%20Shell%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC2%E7%AB%A0%20Shell%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第2章-shell编程">第2章 Shell编程</h1><p>Shell：指令解释器和编程环境。</p><p>用户和操作系统之间的接口，作为核外程序存在。</p><p>Shell的双重角色：</p><ul><li>命令解释程序<ul><li>Linux的开机启动过程；进程树</li><li>Shell的工作步骤</li><li>打印提示符；得到命令行；解析命令；查找文件；准备参数；执行命令</li></ul></li><li>独立的程序设计语言解释器</li></ul><p>Shell列举：ash、bsh、bash、sh、csh、zsh</p><h2 id="脚本文件">脚本文件</h2><p>注释：#</p><p>退出码：</p><ul><li>0：正常返回</li><li>1~128：错误码</li><li>129+：信号量</li></ul><h3 id="执行脚本文件">执行脚本文件</h3><ol type="1"><li><p>$ sh script_file</p></li><li><p>chmod +x script_file</p><p>./script_file</p></li><li><p>source script_file或 . script_file</p></li></ol><h3 id="用户环境">用户环境</h3><ol type="1"><li>.bash_profile，.bash_logout，.bashrc<ul><li>.bash_profile：用户登录时被读取，其中命令被bash执行</li><li>.bashrc：启动一个新的shell时被读取并执行</li><li>.bash_logout：登录退出时读取执行</li></ul></li><li>Alias：alias/unalias</li><li>环境变量<ul><li>export/env/set</li></ul></li></ol><h3 id="变量">变量</h3><ul><li>用户变量</li><li>环境变量</li><li>参数变量和内部变量</li></ul><h4 id="用户变量">用户变量</h4><p>用户在shell脚本里定义的变量。</p><ul><li><p>变量的赋值与使用：var=value echo $var</p></li><li><p>read命令：read var（读取用户输入并赋值给var）</p><ul><li>-p：在提示符后添加文本</li><li>-s：不显示用户输入</li><li>-r：用户输入不能修改</li><li>-n[字符数]：指定读取字符数，例如-n1</li></ul></li><li><p>引号</p><ul><li>单引号内的所有字符保持本身字符的意思，不被bash解释</li><li>除了$、``（不是单引号）、，双引号内的所有字符将保持字符本身含义，不被bash解释</li></ul></li></ul><h4 id="环境变量">环境变量</h4><p>Shell环境提供的变量，通常使用大写字母做名称。</p><table><thead><tr class="header"><th>环境变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$HOME</td><td>当前用户登录目录</td></tr><tr class="even"><td>$PATH</td><td>以冒号分隔的用来搜索命令的目录清单</td></tr><tr class="odd"><td><span class="math inline">\(PS1 |命令行提示符，通常是”\)</span>”字符</td><td></td></tr><tr class="even"><td>$PS2</td><td>辅助提示符，用来提示后续输入，通常是”&gt;”字符</td></tr><tr class="odd"><td>$IFS</td><td>输入区分隔符。当shell读取输入数据时会把一组字符看成是单词之间的分隔符，通常是空格、制表符、换行符等。</td></tr></tbody></table><h4 id="参数变量和内部变量">参数变量和内部变量</h4><p>调用脚本程序时如果带有参数，对应的参数和额外产生的一些变量。</p><table><thead><tr class="header"><th>环境变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>$#</td><td>传递到脚本程序的参数个数</td></tr><tr class="even"><td>$0</td><td>脚本程序的名字</td></tr><tr class="odd"><td>$1</td><td>脚本程序的参数</td></tr><tr class="even"><td>$*</td><td>一个全体参数组成的清单，它是一个独立的变量，各个参数之间用环境变量IFS中的第一个字符分隔开</td></tr><tr class="odd"><td><span class="math inline">\(@ |“\)</span>*”的一种变体，它不使用IFS环境变量。</td><td></td></tr></tbody></table><h3 id="条件测试">条件测试</h3><p>test expression 或 [ expression ]</p><ul><li>字符串比较</li><li>算术比较</li><li>文件相关测试</li><li>逻辑操作</li></ul><table><thead><tr class="header"><th>字符串比较</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>str1 = str2</td><td>相同则为真</td></tr><tr class="even"><td>str1!=str2</td><td>不同则为真</td></tr><tr class="odd"><td>-z str</td><td>字符串为空则结果为真</td></tr><tr class="even"><td>-n str</td><td>字符串不为空则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>算术比较</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>expr1 –eq expr2</td><td>两个表达式相等则结果为真</td></tr><tr class="even"><td>expr1 –ne expr2</td><td>两个表达式不等则结果为真</td></tr><tr class="odd"><td>expr1 –gt expr2</td><td>expr1 大于 expr2 则结果为真</td></tr><tr class="even"><td>expr1 –ge expr2</td><td>expr1 大于或等于 expr2 则结果为真</td></tr><tr class="odd"><td>expr1 –lt expr2</td><td>expr1 小于 expr2 则结果为真</td></tr><tr class="even"><td>expr1 –le expr2</td><td>expr1 小于或等于 expr2 则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>文件条件测试</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>-e file</td><td>文件存在则结果为真</td></tr><tr class="even"><td>-d file</td><td>文件是一个子目录则结果为真</td></tr><tr class="odd"><td>-f file</td><td>文件是一个普通文件则结果为真</td></tr><tr class="even"><td>-s file</td><td>文件的长度不为零则结果为真</td></tr><tr class="odd"><td>-r file</td><td>文件可读则结果为真</td></tr><tr class="even"><td>-w file</td><td>文件可写则结果为真</td></tr><tr class="odd"><td>-x file</td><td>文件可执行则结果为真</td></tr></tbody></table><table><thead><tr class="header"><th>逻辑操作</th><th>结果</th></tr></thead><tbody><tr class="odd"><td>! expr</td><td>逻辑表达式求反</td></tr><tr class="even"><td>expr1 –a expr2</td><td>两个逻辑表达式“And”（“与”）</td></tr><tr class="odd"><td>expr1 –o expr2</td><td>两个逻辑表达式“Or”（“或”）</td></tr></tbody></table><h3 id="条件语句">条件语句</h3><h4 id="if语句">if语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ expression ]<br><span class="hljs-keyword">then</span><br>statements<br><span class="hljs-keyword">elif</span> [ expression ]<br><span class="hljs-keyword">then</span><br>statements<br><span class="hljs-keyword">elif</span> …<br><span class="hljs-keyword">else</span><br>statements<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h4 id="case语句">case语句</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">case</span> str <span class="hljs-built_in">in</span><br>str1 | <span class="hljs-type">str2</span>) statements;;<br>str3 | <span class="hljs-type">str4</span>) statements;;<br>*) statements;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="重复语句">重复语句</h3><h4 id="for语句">for语句</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">for</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">in</span> list<br><span class="hljs-keyword">do</span><br>statements<br>done<br></code></pre></td></tr></table></figure><h4 id="while语句">while语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span><br>statements<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="until语句">until语句</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">until</span> condition<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">statements</span><br>done<br></code></pre></td></tr></table></figure><h4 id="select语句">select语句</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">select</span> item in itemlist<br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">statements</span><br>done<br></code></pre></td></tr></table></figure><p>生成菜单列表</p><h3 id="命令表">命令表</h3><p>命令的组合。</p><ul><li><p>分号串联：command1 ; command2 ; …</p></li><li><p>条件组合，AND和OR：</p><p><code>statement1 &amp;&amp; statement2 &amp;&amp; …</code>和<code>statement1 || statement2 || …</code></p></li></ul><h3 id="语句块">语句块</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">&#123;<br>stateme<span class="hljs-symbol">nt1</span><br>stateme<span class="hljs-symbol">nt2</span><br>…<br>&#125;<br>&#123; stateme<span class="hljs-symbol">nt1</span>; stateme<span class="hljs-symbol">nt2</span> ; … ; &#125;<br></code></pre></td></tr></table></figure><h3 id="函数">函数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">func</span><span class="hljs-params">()</span></span><br>&#123;<br>statements<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量：local关键字</p><p>函数调用：func para1 para2 ...</p><p>返回值：return</p><h3 id="杂项命令">杂项命令</h3><ul><li>break：从for/while/until循环退出</li><li>continue：跳到下一个循环继续执行</li><li>exit n：以退出码”n”退出脚本运行</li><li>return：函数返回</li><li>export：将变量导出到shell，使之成为shell的环境变量</li><li>set：为shell设置参数变量</li><li>unset：从环境中删除变量或函数</li><li>trap：指定在收到操作系统信号后执行的动作</li><li>“:”(冒号命令)：空命令</li><li>“.”(句点命令)或source在当前shell中执行命令</li></ul><h3 id="捕获命令输出">捕获命令输出</h3><p><code>$(command)</code>和<code>`(command)`</code></p><h3 id="算术扩展">算术扩展</h3><p><code>$((...))</code></p><h3 id="参数扩展">参数扩展</h3><p>批处理 1_tmp, 2_tmp, …</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>i=1<br><span class="hljs-keyword">while</span> [ “<span class="hljs-variable">$i</span>” –ne 10 ]; <span class="hljs-keyword">do</span><br><span class="hljs-built_in">touch</span> “<span class="hljs-variable">$&#123;i&#125;</span>_tmp”<br>i=$((<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>))<br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure><p>更复杂形式：</p><figure><img src="/image/Linux系统编程/参数.png" alt="参数扩展" /><figcaption aria-hidden="true">参数扩展</figcaption></figure><h3 id="即时文档">即时文档</h3><p>在shell脚本中向一条命令传送输入数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">cat</span> &gt;&gt; file.txt &lt;&lt; !CATINPUT!<br>Hello, this is a here document.<br>!CATINPUT!<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux系统编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程_1_基础</title>
    <link href="/2024/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E7%AB%A0%20Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%AC%AC1%E7%AB%A0%20Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="第1章-linux系统基础">第1章 Linux系统基础</h1><h2 id="linux概念与使用">1. Linux概念与使用</h2><p>基于GNU通用公共协议的类Unix操作系统。</p><ul><li>开源、流行、支持大多数平台</li></ul><h3 id="gnulinux系统">GNU/Linux系统</h3><p>GNU软件/库+Linux内核</p><p>版本：Ubuntu、Debian、Mint、Red Hat、Fodore、SuSe</p><h3 id="boot-loader">Boot loader</h3><p>Boot loader加载并启动Linux内核。</p><p>常见的Boot loader：</p><ul><li>LILO：Linux Loader</li><li>GRUB：Grand Unified Boot Loader<ul><li>配置文件：<code>/boot/grub/grub.conf</code>（旧版）</li><li>不需要和LILO一样进行配置激活（自动识别加载系统内核和initrd文件）</li><li>使用grub-install安装在MBR中</li></ul></li></ul><p>GRUB引导过程：</p><ol type="1"><li>MBR上的引导程序，负责加载GRUB的第二阶段</li><li>完整的内核加载在/boot/grub目录下</li></ol><p>要能读懂GRUB配置文件</p><p>基本结构：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">default</span>=<span class="hljs-number">0</span>  # 默认启动第一个系统<br><span class="hljs-attribute">timeout</span>=<span class="hljs-number">5</span>  # 等待超时时间<span class="hljs-number">5</span>秒<br><span class="hljs-attribute">splashimage</span>=(hd0,<span class="hljs-number">0</span>)/grub/splash.xpm.gz  # 背景图片<br><span class="hljs-attribute">hiddenmenu</span>  # 隐藏菜单，若要显式，在启动时按下ESC<br><span class="hljs-attribute">title</span> Red Hat Enterprise Linux AS (<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5)  # 定义操作系统的说明信息<br>    <span class="hljs-attribute">root</span> (hd0,<span class="hljs-number">0</span>) <br>    <span class="hljs-attribute">kernel</span> /vmlinuz-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5 ro root＝/dev/sda2 rhgb quiet<br>    <span class="hljs-attribute">initrd</span> /initrd-<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span>-<span class="hljs-number">92</span>.el5.img<br></code></pre></td></tr></table></figure><p>GRUB2：<code>/boot/grub/grub.cfg</code></p><h3 id="虚拟终端">虚拟终端</h3><p>控制台模拟了一个或多个虚拟终端。</p><p>每个虚拟终端是独立的控制台，不同用户可以使用不同的虚拟终端。</p><p>切换方式：Ctrl+Alt+Fn / Alt+Fn</p><h2 id="linux基础命令">2. Linux基础命令</h2><p>命令行：$ 和 #（root）</p><p>$ command option(s) argument(s)</p><p>主要命令都需要掌握。</p><h3 id="基础命令">0. 基础命令</h3><ul><li>passwd：修改密码</li><li>mkpasswd：生成随机密码</li><li>date, cal：打印日期/日历</li><li>who, finger：查看系统上在线的用户信息</li><li>clear：清空屏幕</li><li>echo：打印信息</li><li>write, wall, talk：与其他用户信息通信。<ul><li><code>write username</code>：提示输入消息内容，然后将消息发送给<code>username</code>。</li><li><code>wall</code>：即write all，发送给所有用户</li><li><code>talk username</code>：连接目标用户，启动聊天会话</li></ul></li></ul><h3 id="目录命令">1. 目录命令</h3><ul><li><p>pwd：打印工作目录</p></li><li><p>cd</p></li><li><p>mkdir</p></li><li><p>rmdir</p></li><li><p>ls：列出目录中的内容</p><ul><li><p>-l：以长格式显示文件和目录的信息。</p><p>包括文件或目录的权限模式、所有者、群组、大小和最后修改日期。</p></li><li><p>-a：显示所有文件，包括以.开头的隐藏文件。</p></li><li><p>-R：递归列出所有子目录中的内容。</p></li></ul></li><li><p>mknod：创建字符设备或块设备<code>mknod [options] [name] [type] [major minor]</code></p><ul><li><code>[options]</code>：可选的标志，如 <code>-m</code>用来设置文件的权限模式。</li><li><code>[major minor]</code>：设备的节点号。主节点号和次节点号用于识别设备类型。对于字符设备，主节点号通常表示设备类，而次节点号表示特定的设备。</li></ul></li></ul><h3 id="文件命令">2. 文件命令</h3><ul><li><p>touch：创建新文件、更新文件修改时间</p></li><li><p>cp</p></li><li><p>mv：移动并重命名文件</p></li><li><p>ln：链接文件</p><ul><li>硬链接：<code>ln source_file link_name</code></li><li>符号链接：<code>ln -s /full/path/to/source source_directory/link_name</code></li></ul></li><li><p>rm</p></li><li><p>cat</p></li><li><p>chown：改变文件或目录的所有者。<code>chown [options] [user:group] [file...]</code></p><ul><li><p><code>[options]</code>：</p><p><code>-R</code> 用于递归改变所有子目录和文件的所有者；</p><p><code>-h</code>：对于符号链接，改变链接本身的所有者，而不是链接指向的文件。</p></li><li><p><code>[user:group]</code>：指定新的所有者和组。用户名可以单独指定，或者与组名一起指定。如果只指定用户名，则默认组为用户所属的默认组。</p></li><li><p><code>[file...]</code>：要改变所有者的文件或目录列表。</p></li></ul></li><li><p>chgrp：改变文件或目录的组所有权。<code>chgrp [options] [group] [file...]</code></p></li><li><p>more/less：分页查看文件内容</p><ul><li>more：逐页显示文件，空格下一页，<code>b</code>上一页，<code>q</code>退出</li><li>less：滚动显示文件，功能更多。<ul><li>按 <code>/</code> ，输入搜索词搜索文件内容，按 <code>n</code>查找下一个匹配项，按 <code>p</code> 查找上一个匹配项。</li></ul></li></ul></li></ul><h4 id="文件权限">文件权限</h4><p>三个访问等级：</p><ul><li>用户</li><li>群组</li><li>其他</li></ul><p>三个权限：</p><ul><li>读 r</li><li>写 w</li><li>执行 x</li></ul><p>ls -l会展示文件权限</p><p>默认文件权限</p><p>file：-rw-r--r--</p><p>Directory：drwxr-xr-x</p><p>第一个字符表示文件类型，后续9个字符分别为u、g、o的rwx。</p><p>文件类型：</p><ul><li>-：常规文件</li><li>d：目录</li><li>l：链接</li><li>c：字符设备文件</li><li>b：块设备文件</li><li>p：管道</li><li>s：套接字</li></ul><p>修改权限：<code>chmod who operator what filename</code></p><ul><li>who:<ul><li>u：文件所有者</li><li>g：群组</li><li>o：系统其他用户</li><li>a：all</li></ul></li><li>operator:<ul><li>+：添加权限</li><li>-：删除权限</li><li>=: 设置明确权限</li></ul></li><li>what: rwx</li></ul><p>将u、g、o各自的rwx权限看为一个二进制数，可以用数字为它们赋予权限。</p><ul><li><p>r=4,w=2,x=1</p></li><li><p>chmod 765 file：u=rwx,g=rw,o=rx</p></li></ul><h4 id="文件编辑">文件编辑</h4><p>vi、emacs、gedit</p><h3 id="进程">3. 进程</h3><p>进程是一个正在执行的程序实例。由执行程序、它的当前值、状态信息以及通过操作系统管理此进程执行情况的资源组成。</p><ul><li><p>ps：报告进程状态</p></li><li><p>pstree：展示进程树</p></li><li><p>jobs, fg, bg, ctrl-z：任务控制</p><ul><li><p>jobs：查看当前 shell环境中所有在后台运行的任务列表，会给出每个任务的唯一编号。</p></li><li><p>fg %1：将一个后台任务调至前台执行，用%指定任务编号。</p></li><li><p>bg %1：将一个在后台暂停的任务继续运行在后台。</p></li><li><p>Ctrl+Z：将当前前台执行的任务挂起到后台。</p></li></ul></li><li><p>kill：杀死进程<code>kill [PID]</code>、发送信号给进程<code>kill [signal] [PID]</code></p></li><li><p>nohup：无视挂起信号运行指令</p></li><li><p>nice, renice：调整进程优先级</p><p>nice介于-20～19，影响调度优先级，nice越低优先级越高</p><ul><li><p>nice：启动一个新进程，并为其设置一个nice值。</p></li><li><p>renice：改变正在运行的进程的nice值。</p></li></ul></li><li><p>top：展示占用CPU最高的进程列表</p></li></ul><h3 id="寻找帮助">4. 寻找帮助</h3><p>man、info、--help</p><h3 id="重定向">5. 重定向</h3><p>标准输入、标准输出、标准错误</p><ul><li>对应的文件描述符：0, 1, 2</li></ul><p><code>&lt;、&gt;</code>：覆盖文件</p><p><code>&gt;&gt;</code>：追加到末尾</p><p><code>2&gt;</code>：将标准错误输出到文件，而标准输出仍然会输出到命令行</p><p><code>&gt;&amp;</code>：将标准输出和错误都输出到文件</p><p><code>2&gt;&amp;1</code>：将标准错误输出重定向到标准输出，与上个选项的区别是会打印到命令行</p><h3 id="管道">6. 管道</h3><p>一个进程的输出作为另一个进程的输入。</p><p><code>命令1|命令2</code>：命令1的输出会直接传递给命令2作为输入。</p><h3 id="高级命令">7. 高级命令</h3><ul><li><p>find：查找文件。<code>find [options] [path...] [-exec [command] &#123;&#125; +]</code></p><ul><li><code>[options]</code>：find命令的行为选项，如<code>-name</code>、<code>-type</code>、<code>-mtime</code> 等。<ul><li><code>-print</code>：打印找到的文件名。</li><li><code>-delete</code>：删除找到的文件。</li></ul></li><li><code>[path...]</code>：要搜索的目录路径。如果省略，默认在当前目录搜索。</li></ul></li><li><p>sed：通过模式匹配对文本进行处理。</p></li><li><p>grep：在文本文件中搜索指定的文本字符串。<code>grep [options] [pattern] [file...]</code></p><ul><li>选项：<ul><li><code>-i</code>：忽略大小写。</li><li><code>-v</code>：反转匹配，只显示不匹配的行。</li><li><code>-c</code>：计数，只输出匹配行的数量。</li><li><code>-n</code>：显示匹配行及其行号。</li><li><code>-l</code>：只输出包含匹配字符串的文件名。</li><li><code>-L</code>：只输出不包含匹配字符串的文件名。</li><li><code>-r</code> 或 <code>-R</code>：递归搜索目录中的所有文件。</li><li><code>-E</code>：使用扩展正则表达式。</li><li><code>-o</code>：只输出匹配到的部分，而不是整行内容。</li></ul></li></ul></li></ul><p>基本正则表达式：</p><ul><li><code>.</code>：匹配任意单个字符。<ul><li>例子：<code>grep '.$' file.txt</code> 将匹配 file.txt中以任意字符结尾的行。</li></ul></li><li><code>*</code>：匹配前一个字符出现零次或多次。<ul><li>例子：<code>grep 'o*' file.txt</code> 将匹配 file.txt中包含零个或多个 “o” 的行。</li></ul></li><li><code>^</code>：匹配行的开始。<ul><li>例子：<code>grep '^A' file.txt</code> 将匹配 file.txt 中以 “A”开头的行。</li></ul></li><li><code>$</code>：匹配行的结束。<ul><li>例子：<code>grep 'B$' file.txt</code> 将匹配 file.txt 中以 “B”结尾的行。</li></ul></li><li><code>[abc]</code>：匹配方括号内的任意一个字符。<ul><li>例子：<code>grep '[abc]' file.txt</code> 将匹配 file.txt 中包含“a”、“b” 或 “c” 的行。</li></ul></li><li><code>[^abc]</code>：匹配不在方括号内的任意一个字符。<ul><li>例子：<code>grep '[^abc]' file.txt</code> 将匹配 file.txt 中不包含“a”、“b” 或 “c” 的行。</li></ul></li><li><code>\</code>：转义字符，用于匹配特殊字符。<ul><li>例子：<code>grep '\\.' file.txt</code> 将匹配 file.txt中包含一个反斜杠后跟一个点（<code>.</code>）的行。</li></ul></li><li><code>()</code>：标记子表达式的开始和结束。<ul><li>例子：<code>grep '(abc|def)' file.txt</code> 将匹配 file.txt 中包含“abc” 或 “def” 的行。</li></ul></li><li><code>|</code>：逻辑或操作符。<ul><li>例子：<code>grep 'A|B' file.txt</code> 将匹配 file.txt 中包含 “A” 或“B” 的行。</li></ul></li><li><code>\&lt;</code>：匹配单词的开始（前面必须有一个单词边界）。<ul><li>例子：<code>grep '\&lt;word' file.txt</code> 将匹配 file.txt 中以“word” 开头的行，其中 “word” 是一个单词。</li></ul></li><li><code>\&gt;</code>：匹配单词的结束（后面必须有一个单词边界）。<ul><li>例子：<code>grep '\&gt;word' file.txt</code> 将匹配 file.txt 中以“word” 结尾的行，其中 “word” 是一个单词。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux系统编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云计算_5_云数据中心</title>
    <link href="/2024/04/05/%E4%BA%91%E8%AE%A1%E7%AE%97/5-%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2024/04/05/%E4%BA%91%E8%AE%A1%E7%AE%97/5-%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云数据中心">5-云数据中心</h1><h2 id="基本设计">1. 基本设计</h2><p>外部：不间断的电源、足够带宽的网络</p><p>内部：散热（保证设备安全）</p><h2 id="云数据中心特征">2. 云数据中心特征</h2><h3 id="特征">2.0 特征</h3><ol type="1"><li><p>高设备利用率</p><ul><li><p>通过虚拟化整合云平台系统与数据中心硬件资源，减少物理服务器数量</p></li><li><p>优化资源利用率、简化管理，降低成本、快速响应业务需求的变化等</p></li><li><p>较大的数据中心有更低的单位运营成本：网络、存储、管理</p></li></ul></li><li><p>绿色节能</p><ul><li><p>能源</p></li><li><p>功耗：服务器、空调</p></li></ul></li><li><p>自动化管理</p><ul><li><p>人力成本是大多数管理数据中心站点最大成本因素</p></li><li><p>无人值守，远程管理</p></li><li><p>门禁、通风、温度、湿度、电力均可远程调度与控制</p></li></ul></li><li><p>高可用性</p><ul><li><p>各个部分的冗余、容错、容灾设计</p></li><li><p>扩展和升级时，保持正常运行</p></li></ul></li></ol><h3 id="绿色节能技术">2.1 绿色节能技术</h3><h4 id="耗电原因">耗电原因</h4><ul><li>技术因素<ul><li>云计算中心规模不断扩大，硬件设备数量激增，导致总体耗电量大幅上升。</li><li>为了保证高可用性和稳定性，通常采用功耗相对较高的高性能处理器、内存和存储设备。</li><li>虚拟化技术的广泛应用也带来了额外的能耗。</li></ul></li><li>商业因素<ul><li>客户需求不断增长<spanclass="math inline">\(\rightarrow\)</span>数据中心建设、扩容。</li><li>激烈的市场竞争<spanclass="math inline">\(\rightarrow\)</span>不断优化更新技术。</li></ul></li></ul><h4 id="采取措施">采取措施</h4><ol type="1"><li><p>优化技术</p><ul><li>使用更高能效设备、服务器架构和更智能的资源调度策略。</li></ul></li><li><p>节约能源</p><ul><li><p>在数据中心设计和运营中充分考虑节能因素。</p><p>例如，采用更为合理的布局和散热系统设计，减少冷却能耗；</p><p>合理安排数据中心工作时间，充分利用自然冷却等方式降低能耗。</p></li></ul></li><li><p>提升硬件使用率</p><ul><li><p>例如，推广容器化技术，实现应用打包和快速部署；</p><p>采用无服务器架构，减少闲置服务器数量等。</p></li></ul></li><li><p>可再生能源</p></li><li><p>绿色云生态系统</p><ul><li>与硬件厂商、政府部门等共同合作，构建一个绿色云生态系统。通过政策引导、技术创新和市场机制等手段，推动整个行业的绿色发展。</li></ul></li></ol><h4 id="具体节能技术">具体节能技术</h4><ul><li>配电系统：高压直流配电、市电直供配电</li><li>空调系统节能：高温回风、精确制冷、自然冷空调</li><li>集装箱数据中心节能技术<ul><li>服务器设备、网络设备、空调设备、供电设备等高密度地装入固定尺寸的集装箱中</li><li>高密度、模块化、按需快速部署、移动便捷</li></ul></li><li>管理系统节能策略和算法：供电管理</li><li>新能源应用</li></ul><h3 id="自动化管理">2.2 自动化管理</h3><p>目标：使得在规模较大的情况下，实现较少人员对数据中心的高度智能管理。</p><p>工作范围：按需分配/收回资源；自动配电、冷却、消防等。</p><p>具体内容：资源的自动化调度和对业务的灵活响应。</p><ul><li>既需要单业务自治，也需要对业务和资源进行全局控制和协调。</li></ul><h4 id="特征和内容">特征和内容</h4><ol type="1"><li><p>全面可视化：多层级运行时视图，全面掌握数据中心资产、配置和各层次依赖关系的现状</p></li><li><p>自动的控制执行：全面自动化流程</p></li><li><p>多层次的无缝集成：流畅地自动执行在不同层次和组成部分之间地各种处理流程，快速的协调数据中心内外的所有变更，实现端到端的流程管理</p></li><li><p>综合与实时的报告：提供全面综合和透视依赖关系的报告提高管理水平</p></li><li><p>全生命周期支持：自动化整个“计划—实施—检查—更正”的IT流程生命周期</p></li></ol><p>实现的三个阶段：</p><ol type="1"><li><p>IT服务操作：监控和管理IT基础设施的广义集合</p><ul><li><p>目标：生成有效的全局IT支撑架构，提高IT服务质量，对活动和过程进行协调和执行</p></li><li><p>活动和过程：事故管理、事件监控和管理、问题管理</p></li></ul></li><li><p>IT服务管理：制定设施间的交互和协作处理，确保IT服务符合标准规范</p><ul><li><p>定义：根据客户需求的层次确保IT服务质量的一系列过程</p></li><li><p>主题：服务管理、服务层管理、IT资产管理、财务管理</p></li></ul></li><li><p>数据中心自动化：维护IT环境，定制、检查和执行服务层协议</p></li></ol><p>采用数据中心自动化工具必须具备如下条件</p><ul><li>管理系统</li><li>定义过程</li><li>认知非自动化过程的成本</li><li>内部流程资源</li></ul><h3 id="容灾备份">2.3 容灾备份</h3><table><thead><tr class="header"><th><strong>对比维度</strong></th><th><strong>备份</strong></th><th><strong>容灾</strong></th></tr></thead><tbody><tr class="odd"><td>使用目的</td><td>避免数据丢失，一般通过快照、备份等技术构建数据的数据备份副本，故障时可以通过数据的历史副本恢复用户数据。</td><td>避免业务中断，一般是通过复制技术（应用层复制、主机I/O层复制、存储层复制）在异地构建业务的备用主机和数据，主站点故障时备用站点可以接管业务。</td></tr><tr class="even"><td>使用场景</td><td>针对病毒入侵、人为误删除、软硬件故障等场景，可将数据恢复到任意备份点。</td><td>针对软硬件故障以及海啸、火灾、地震等重大自然灾害，运行故障切换，尽快恢复业务。源端可用区恢复正常时，可轻松利用故障恢复能力重新切换回到源端可用区。</td></tr><tr class="odd"><td>成本</td><td>通常是生产系统的1~2%。</td><td>通常是生产系统的20%~100%（根据不同的RPO/RTO要求而定），高级别的双活容灾，要求备用站点也要部署一套和主站点相同的业务系统，基础设施成本需要翻倍计算。</td></tr></tbody></table><p>容灾备份：</p><p>异地建立、维护备份存储系统，利用地理分离保证系统和数据对灾难性事件的抵御能力。</p><ul><li>容灾系统的抵抗程度：数据级容灾和应用级容灾。</li></ul><h4 id="关键技术">关键技术</h4><p>技术核心：复制数据</p><ul><li><p>镜像：将符合指定规则的报文复制到目的端口</p></li><li><p>快照：拷贝指定数据集合，用于数据备份恢复、提供额外访问通道。</p></li><li><p>基于IP的SAN的远程数据容灾备份技术：主数据中心复制到备份数据中心。</p></li><li><p>数据库复制。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云计算_4_网络</title>
    <link href="/2024/04/04/%E4%BA%91%E8%AE%A1%E7%AE%97/4-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/04/04/%E4%BA%91%E8%AE%A1%E7%AE%97/4-%E4%BA%91%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算网络">4-云计算网络</h1><h2 id="基本架构">1. 基本架构</h2><p>云数据中心需要基础网络将所有设备组织在本地网络里面——基础网络架构。</p><p>传统树结构：建造方便简单，但不便于拓展与升级</p><ul><li>任意一个核心交换机故障导致上千台服务器失效</li></ul><p>架构需求：低成本、高可扩展性、低配置开销、健壮性、节能</p><h3 id="改进树结构">1.1 改进树结构</h3><h4 id="fattree">FatTree</h4><ol type="1"><li>K叉树，K个Pod(集装器)，每个Pod有K个交换机，其中K/2个为接入交换机，K/2个为汇聚交换机。</li><li>Pod中每个交换机有K个接口。<ul><li>接入交换机的K/2个接口接主机，K/2个接口接汇聚交换机；</li><li>汇聚交换机的K/2个接口接接入交换机，K/2个接核心交换机。</li></ul></li><li>有<spanclass="math inline">\((K/2)^2\)</span>个核心交换机，每个交换机K个端口接K个汇聚交换机。</li><li>一个Pod内的所有交换机相互连接：完全二分图。</li><li>一个Pod内的每个汇聚交换机与一部分核心交换机连接，但是一个Pod和每一个核心交换机都有连接。</li></ol><p>两级路由表，允许两级前缀查询：Pod间流量尽可能均匀分布于核心交换机</p><p>任意两个不同Pod主机之间存在K条路径</p><ul><li>将流量在这些路径间分散</li><li>任意给定Pod的低层和高层交换机对位于本Pod的任意子网都有终结性表项</li><li>在全负载最坏的情况下实现约87%的聚合带宽</li></ul><p>与传统层次结构相比，FatTree有如下特点：</p><ul><li>消除了树形结构上层链路对吞吐量的限制</li><li>为内部节点间通信提供多条并行链路</li><li>与现有数据中心网络使用的以太网结构和IP 配置的服务器兼容</li><li>但是布线复杂了；扩展时需要重构；受到端口数限制等。</li></ul><p>FatTree的扩展性受限于核心交换机端口数量，目前比较常用的是48端口10G核心交换机，在3层树结构中能够支持27648台主机。</p><h4 id="vl2">VL2</h4><p>若干服务器连接到机架(接入)交换机；</p><p>每台接入交换机与两台汇聚交换机连接；</p><p>每台汇聚交换机与所有核心交换机连接。</p><p>特点：</p><ul><li>扁平寻址，允许服务实例被放置到网络覆盖的任何地方</li><li>负载均衡将流量统一分配到网络路径</li><li>终端系统的地址解析拓展到巨大的服务器池</li></ul><p>核心思想：使用FatTree同样的拓扑结构建立扁平的第二层网络。</p><p>机制：</p><ul><li>IP地址仅仅作为名字使用，没有拓扑含义；将服务器的名字与其位置分开。</li><li>使用可扩展、可靠的目录系统来维持名字和位置间的映射。</li><li>当服务器发送分组时，服务器上的VL2代理开启目录系统以得到实际的目的位置，然后将分组发送到目的地。</li></ul><p>优势：VL2是目前最易用于对现有数据中心网络改造的结构；应用程序使用服务地址通信而底层网络使用位置信息地址进行转发，使得虚拟机能够在网络中任意迁移而不影响服务质量。</p><p>缺点：VL2依赖于中心化的基础设施来实现2层语义和资源整合，面临单点失效和扩展性问题。</p><h3 id="递归层次结构">1.2 递归层次结构</h3><p>每一个高层的网络拓扑，由多个低层的递归单元按照递归规律相互连接构成，同时也是更高层级网络的一个递归单元。</p><ul><li>增加服务器数量<spanclass="math inline">\(\rightarrow\)</span>提高总的递归层次<ul><li>添加服务器更加灵活，可增加的数量增大</li><li>对交换机性能要求低</li></ul></li></ul><p>递归层次结构：DCell、Ficonn、BCube、MDCube</p><h4 id="ficonn">FiConn</h4><p>服务器使用两个网卡端口：主用端口连接低层网络，备用端口连接高层网络</p><p>递归定义的结构</p><ul><li>第0层为基本构建单元，n个服务器连接一个具有n个端口的交换机</li><li>每个低层<strong>FiConn</strong>中备用端口空闲的一半服务器与其他相同层次的FiConn网络中备用端口空闲的服务器连接</li><li>k层服务器、k层端口、k层链路</li></ul><h4 id="bcube">BCube</h4><p>主要使用交换机构建层次化网络</p><p>第0层：n服务器连接1交换机</p><p>第1层：n个0层连接n个交换机</p><p>……</p><p>第k层：n个k-1层连接nk交换机</p><p>交换机n个端口，服务器k+1个端口。</p><h3 id="光交换网络">1.3 光交换网络</h3><p>使用光纤交换机调整网络拓扑。</p><h2 id="软件定义网络">2. 软件定义网络</h2><h3 id="openflow">2.1 OpenFlow</h3><p>使用集中控制器控制OpenFlow Switch的Flow Table。</p><p>Controller 会为特定的工作负载计算最佳路径，从而对 Switch的数据转发定义路径。</p><p>核心理论：控制转发分离架构、可编程性</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云计算_3_虚拟化</title>
    <link href="/2024/04/03/%E4%BA%91%E8%AE%A1%E7%AE%97/3-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/04/03/%E4%BA%91%E8%AE%A1%E7%AE%97/3-%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="虚拟化技术">3-虚拟化技术</h1><p>问题：云计算涉及到哪些虚拟化技术？需要对哪些资源做虚拟化？对应的虚拟化技术和产品是什么？</p><h2 id="什么是虚拟化">0. 什么是虚拟化</h2><p>虚拟化是云计算的核心技术。</p><p>本质：通过虚拟化层逻辑化原先的物理设备，实现软硬件解耦。</p><p>核心思想：</p><ul><li><p>利用软件或固件管理程序构成虚拟化层，把物理资源映射为虚拟资源。</p></li><li><p>在虚拟资源上可以安装和部署多个虚拟机，实现多用户共享物理资源。</p></li></ul><h2 id="服务器虚拟化">1. 服务器虚拟化</h2><p>硬件级、操作系统级、程序库API、应用程序</p><p>代表产品：</p><p>裸机虚拟化（VMware vSphere）、操作系统级虚拟化（VMwareWorkstation、Docker）</p><h3 id="硬件级虚拟化">1.1 硬件级虚拟化</h3><p>使用作为虚拟化层的软件管理客户操作系统，使其独立于主机操作系统，同时运行在同硬件上。</p><ul><li>Hypervisor、Virtual Machine Monitor（VMM）</li></ul><p>要求：高效、隔离、复制</p><p>类别：裸机虚拟化、寄居虚拟化</p><h4 id="优势">优势</h4><ol type="1"><li>封装性：虚拟机快照、克隆、挂起和恢复非常便捷</li><li>多实例：降低计算机资源损耗</li><li>隔离</li><li>硬件无关性</li><li>特权功能</li></ol><h4 id="可虚拟化架构">可虚拟化架构</h4><p>使用特权级分隔应用软件和系统软件的架构。</p><p>原因：提高虚拟机控制软件直接访问硬件的效率、低特权级的虚拟机之间更易实现资源隔离。</p><h4 id="虚拟化硬件对象">虚拟化硬件对象</h4><p>CPU、内存、I/O设备</p><h5 id="cpu虚拟化">CPU虚拟化</h5><ul><li>任意时刻一个物理CPU只能运行一个虚拟CPU</li><li>每个客户操作系统可以使用一个或多个虚拟CPU</li><li>各个操作系统之间虚拟CPU运行相互隔离，互不影响</li></ul><p>调度：VMM决定哪个虚拟CPU在哪个物理CPU上运行，保证隔离、公平和性能</p><p>执行：虚拟CPU保证虚拟机的指令正确运行。</p><ul><li>实现技术：模拟执行、监控执行</li></ul><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：解释、扫描、翻译</li><li>基于硬件辅助的虚拟化：硬件针对虚拟化作出支持</li><li>修改操作系统的类虚拟化：修改客户机操作系统，配合VMM进行虚拟化</li></ol><h5 id="内存虚拟化">内存虚拟化</h5><p>把物理内存统一管理，包装成多个虚拟的物理内存提供给虚拟机使用。</p><p>每个虚拟机拥有各自独立的内存空间。</p><p>VMM的工作：</p><ol type="1"><li>维护客户机物理地址和宿主机器的机器地址之间的映射</li><li>截获虚拟机对客户机物理地址的访问，并根据所记录的映射关系，转换成机器地址</li></ol><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：影子页表，直接把客户机虚拟地址翻译为物理地址</li><li>基于硬件辅助的虚拟化：硬件辅助地址转换</li><li>修改操作系统的类虚拟化：客户机直接使用VMM的机器地址到物理地址的翻译表</li></ol><h5 id="io虚拟化">I/O虚拟化</h5><p>实现方式：</p><ol type="1"><li>基于软件的完全虚拟化：VMM进行设备模拟并处理所有设备请求与响应</li><li>基于硬件辅助的虚拟化：DMA地址重映射</li><li>修改操作系统的类虚拟化：修改客户机操作系统，客户机直接与物理设备交互</li></ol><h3 id="操作系统级虚拟化">1.2 操作系统级虚拟化</h3><p>在主机操作系统中插入一个虚拟化层。</p><p>在同一个操作系统内核内，运行多个虚拟机；虚拟机可以访问内核。</p><p>虚拟机/容器</p><p>容器的优缺点：</p><ul><li>启动/停止开销最小，资源需求低，可扩展性强</li><li>可同步虚拟机与宿主操作系统环境状态的变化</li><li>允许虚拟机中进程访问尽可能多的主机资源</li><li>同一个容器中的操作系统级虚拟机必须使用相同的客户操作系统</li><li>资源隔离性较差</li></ul><h2 id="云数据中心虚拟化">2. 云数据中心虚拟化</h2><p>为什么要虚拟化？</p><ul><li>一台物理设备一个用户 vs.一台物理设备多个用户：提升资源共享与复用的效率，降低成本</li><li>固定大小与位置的存储空间 vs.灵活扩展和空间分布的空间：提升可扩展性，提升存储资源使用效率</li><li>为了实现服务器、存储虚拟化，要求网络也要能够方便、灵活地调整：随着虚拟机的迁移一起迁移</li></ul><h3 id="服务器虚拟化-1">服务器虚拟化</h3><p>将一个或多个物理服务器虚拟成多个逻辑上的服务器。</p><p>虚拟机、容器。</p><h3 id="存储虚拟化">存储虚拟化</h3><p>把分布的异构存储设备统一为一个或几个大的存储池。</p><p>存储虚拟化将系统中分散且异构的存储资源整合起来，形成一个统一连续编址的逻辑存储空间。</p><h3 id="网络虚拟化">网络虚拟化</h3><p>在底层物理网络和网络用户之间增加一个抽象层。</p><p>云数据中心对网络的需求</p><ul><li>提高数据传输效率：应对数据同步、备份、虚拟机迁移等的大流量</li><li>提高管理效率：采用统一的交换网络减少布线、维护和扩容的成本</li></ul><p>网络虚拟化技术：</p><ul><li><p>核心层网络虚拟化</p></li><li><p>虚拟机网络虚拟化</p></li><li><p>接入层网络虚拟化</p></li></ul><h2 id="虚拟机迁移">3. 虚拟机迁移</h2><h3 id="需求">需求</h3><ol type="1"><li><p>负载平衡需要</p></li><li><p>物理服务器定期升级的需要</p></li></ol><p>关注重点：实时迁移</p><ul><li>保持虚拟机运行的同时，将其从一个计算机迁移到另一个计算机，并在目的计算机恢复运行</li></ul><h3 id="迁移内容">迁移内容</h3><ul><li>内存迁移：最困难</li><li>网络迁移：迁移网络设备、协议状态和配置</li><li>存储设备迁移：使用NAS作为存储设备共享数据</li></ul><p>分类：</p><ul><li>物理机到虚拟机 P2V</li><li>虚拟机到虚拟机 V2V</li><li>虚拟机到物理机 V2P</li></ul><h3 id="内存迁移方案">内存迁移方案</h3><table><thead><tr class="header"><th>迁移方案</th><th>具体描述</th><th>优势与劣势</th></tr></thead><tbody><tr class="odd"><td>Stop and Copy</td><td>A停机，将对应内存全部复制到B，启动B</td><td>方法简单，总迁移时间最短，但停机时间无法接受</td></tr><tr class="even"><td>Stop and Copy和Pull阶段结合</td><td>A停机，将部分内存复制到B，启动B，B运行中遇到缺失内存，再到A内存中复制</td><td>停机时间很短，总迁移时间很长。Pull阶段复制造成的性能下降，用户体验差</td></tr><tr class="odd"><td>Push和Stop and Copy阶段结合</td><td>A不停机，保持对外服务，将变化的内存迭代地复制到B，直到最后剩余很少要复制的再停止A，复制最后变动到B，启动B</td><td>平衡了停机时间和总迁移时间之间的矛盾。需要有一种算法能够测定工作集，以避免反复重传。可能会占用大量的网络带宽，对其他服务造成影响</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云计算_2_架构</title>
    <link href="/2024/04/02/%E4%BA%91%E8%AE%A1%E7%AE%97/2-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/04/02/%E4%BA%91%E8%AE%A1%E7%AE%97/2-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算架构">2-云计算架构</h1><h2 id="计算架构的演化">1. 计算架构的演化</h2><h3 id="发展历程">1.1 发展历程</h3><ol type="1"><li>中央集权架构：所有计算、计算资源、业务逻辑都集中于一台主机</li><li>客户机/服务机架构（C/S架构）<ul><li>客户端：承载少量计算任务和所有IO任务</li><li>服务器：承载主要计算任务</li><li>优点：充分利用客户端计算能力；关注点分离，简化软件复杂度、编程模式</li><li>缺点：持久链接，系统伸缩能力受限；客户端开发维护成本高；平台相关，升级换代麻烦</li></ul></li><li>中间层架构：将业务逻辑和数据服务分别放在两个服务器上（还是C/S架构）<ul><li>客户机到中间件为无状态的非持久链接：提升架构弹性</li></ul></li><li>浏览器/服务器架构（B/S架构）<ul><li>对客户机、中间层架构的扩展——客户端开发、维护成本降低，升级改动小</li><li>客户端：负载进一步缩减，仅显示和运行基于浏览器的脚本程序</li><li>服务器：Web服务器层屏蔽各中间件的差异，提供通用的用户访问界面</li><li>扩展性高：对客户机性能无要求</li><li>对网络性能要求高</li></ul></li><li>C/S和B/S混合架构<ul><li>没有一种架构能够适用于所有场景</li><li>有些服务需要持久的链接（内部用户）</li><li>有些仅通过非持久链接即可（外部用户）</li></ul></li><li>面向服务的架构（SOA）</li><li>微服务架构：在SOA思想上对系统业务做彻底的组件化、服务化。</li></ol><h3 id="面向服务的架构soa">1.2 面向服务的架构（SOA）</h3><p>通过定义良好的接口，联系应用程序的不同服务的组件模型。</p><p>接口：中立定义，独立于硬件平台、操作系统和编程语言。</p><ul><li><p>服务交互方式统一、通用。</p></li><li><p>服务只做本职工作，暴露接口。</p></li><li><p>通过统一的界面协调多个服务：控制复杂性，更容易管理。</p></li></ul><p>SOA的目标：系统更有弹性，更灵活、更快地响应不断改变的企业业务需求，解决软件重用问题。</p><p>具体通过：</p><ul><li>简单的服务间接口</li><li>粗粒度：调用者和服务层只需一次交互</li><li>松耦合：服务间相对独立无依赖</li><li>位置透明</li><li>协议无关</li></ul><p>SOA架构角色：</p><ul><li>服务请求者</li><li>服务提供者</li><li>服务注册中心</li></ul><p>操作：</p><ul><li>发布</li><li>查询</li><li>绑定和调用</li></ul><h2 id="云计算架构二维视角">2. 云计算架构二维视角</h2><p>基础架构 + 应用程序（后端+前端）</p><h3 id="基础架构">2.1 基础架构</h3><p>虚拟化层</p><ul><li><p>将硬件转换为统一的IT资源（可灵活拆分、统一计量、统一管理、软件定义的）</p></li><li><p>可以在不同的抽象层实现：应用层、操作系统层、体系结构层、硬件层等</p></li></ul><p>Web服务层</p><ul><li><p>将云资源提供给客户的一种最方便的方式，解决大部分客户无法直接使用虚拟机的问题；</p></li><li><p>支持面广、对客户端要求低，只需要浏览器就可以访问。</p></li></ul><p>服务总线层</p><ul><li>中间件层，封装计算服务、数据存储、消息传递</li><li>分离用户与虚拟化层、连接用户与Web服务层。</li></ul><p>客户机用户界面</p><ul><li><p>Web门户，将各种服务混搭集成在一个页面。</p></li><li><p>基于Ajax，Javascript，趋势是使用功能完善的组件</p><ul><li>如JavaBeans/Applets，Silvedight/.NET等</li><li>可下载和安装在客户机上</li></ul></li></ul><p>###　2.2 云应用程序结构</p><p>传统操作系统上的应用程序：进程、线程、服务、shell（应用程序的控制接口）</p><ul><li>进程就是最终产品，每一个进程可运行多个指令序列（线程），一个线程对应一种服务。</li></ul><p>云环境中的应用程序：应用程序、应用实例、服务、云命令行界面（控制端）</p><ul><li><p>应用程序由多个同时运行的实例支撑</p></li><li><p>不同的应用实例运行在不同的服务器上，每一个应用实例提供一种或多种服务</p></li><li><p>服务间相互独立</p></li></ul><h2 id="云计算逻辑架构">3. 云计算逻辑架构</h2><h3 id="云体">3.1 云体</h3><p>云计算的物质基础，使用的资源集合，构成云计算的软硬件环境。</p><ul><li><p>例如网络、服务器、存储器、交换机等。</p><p>广义的云体包括数据中心机器辅助设施如电力、空调、机架、冷却等系统。</p></li></ul><p>目前，云体就是数据中心。</p><p>云计算的横向架构。</p><p>传统系统环境：进程/线程/内存管理 + 文件系统 + 进程间通信/网络。</p><p>云运行时环境：计算资源+持久存储+通信</p><h4 id="云数据中心">云数据中心</h4><p>数据集中存储、计算、交换的中心。</p><p>传统数据中心的问题</p><ul><li>机器过多、利用率过低</li><li>应用迁移太困难</li><li>存储需求增长太快</li></ul><p>云数据中心：重视虚拟化，以提高资源利用率</p><p>软件定义数据中心：</p><ul><li>软件定义计算：计算节点虚拟化。</li><li>软件定义存储：分离管理接口与数据读写。管理接口统一，数据读写可以兼容各种方式。</li><li>软件定义网络：数据平面（数据转发）和控制平面（转发表的设置等）分离；集中控制，分布式转发。</li></ul><h3 id="云栈">3.2 云栈</h3><p>又称云平台，是在云上建造的运行环境。</p><ul><li><p>支持应用程序的发布、运行、监控、调度、伸缩，</p><p>并为应用程序提供辅助服务机制，如访问控制、权限管理等。</p></li></ul><h4 id="云栈的三层模式">云栈的三层模式</h4><ol type="1"><li>基础设施即服务层：硬件+虚拟化</li><li>平台即服务层：应用程序的运行环境</li><li>软件即服务层：Web应用服务</li></ol><h4 id="云计算技术架构">云计算技术架构</h4><p>SOA构建层+管理中间件层+资源池层+物理资源层</p><p>管理中间件层和资源池层是云计算技术的最关键部分。</p><h4 id="iaas实现机制">IaaS实现机制</h4><ol type="1"><li>配置工具：在分配的节点上准备任务运行环境。</li><li>系统管理模块：管理和分配所有可用的资源，其核心是负载均衡。</li><li>服务目录：用户可以访问的服务清单。</li><li>用户交互接口：Web用户访问接口。</li><li>监视统计模块：监视节点运行状态，统计节点使用情况。</li></ol><h3 id="云计算">3.3 云计算</h3><p>利用云体和云平台所进行的计算或处理。</p><p>无论在哪个层面开展，只要符合“按量计费、资源可伸缩”就是云计算。</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云计算_1_概念</title>
    <link href="/2024/04/01/%E4%BA%91%E8%AE%A1%E7%AE%97/1-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/04/01/%E4%BA%91%E8%AE%A1%E7%AE%97/1-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>飞萤扑火，向死而生。</p><span id="more"></span><h1 id="云计算概念">1-云计算概念</h1><p>大规模分布式计算模式，通过一系列技术实现按需交付。</p><h2 id="计算模式的发展历程">1. 计算模式的发展历程</h2><p>主机系统与集中计算<spanclass="math inline">\(\rightarrow\)</span>集群计算<spanclass="math inline">\(\rightarrow\)</span>个人计算机与桌面计算<spanclass="math inline">\(\rightarrow\)</span>分布式计算<spanclass="math inline">\(\rightarrow\)</span>网格计算<spanclass="math inline">\(\rightarrow\)</span>​云计算</p><ul><li><strong>效用计算</strong>：将IT资源包装成可以度量的服务提供给用户。</li><li><strong>服务计算</strong>（软件即服务SaaS）：将应用程序作为服务提供。</li></ul><p>云计算：效用计算+服务计算</p><h3 id="对计算的追求">对计算的追求</h3><p>自动化、高性能、易使用</p><h3 id="云计算持续优化的动力">云计算持续优化的动力</h3><ol type="1"><li>节能</li><li>降低成本</li><li>提升资产安全</li><li>提升信息系统容灾备份能力</li></ol><h2 id="云计算的特征与分类">2. 云计算的特征与分类</h2><h3 id="特征">2.1 特征</h3><ul><li><p>物理特征：大规模</p></li><li><p>技术特征：虚拟化</p></li><li><p>商业特征：按需服务</p></li><li><p>使用特征：通用、高可伸缩</p></li><li><p>目标：高可靠</p></li></ul><h3 id="云部署模型">2.2 云部署模型</h3><p>公有云：由第三方云提供者拥有的可公共访问的云环境</p><p>私有云：由一家组织单独拥有，利用云计算技术来访问组织内部的IT资源</p><p>混合云：由两种或者更多不同云部署模型组成的云环境</p><h3 id="云服务模型">2.3 云服务模型</h3><ul><li>软件作为服务：Software as a Service，SaaS</li><li>平台作为服务：PaaS</li><li>基础设施作为服务：IaaS</li></ul><h4 id="iaas">IaaS</h4><p>通过虚拟机方式对外提供计算、存储和网络能力</p><ul><li>虚拟机安装操作系统，享有公网IP，使用公网访问虚拟机</li><li>额外租用存储设备挂载到虚拟机</li><li>多个虚拟机之间通过公用网络、私有网络进行通信</li></ul><p>类似租用独立的计算机，用户自行解决多台机器之间的协同问题</p><p>优势</p><ul><li>允许用户动态申请和释放资源</li><li>按使用量计费</li><li>更高的资源使用效率（节能环保）</li></ul><h4 id="paas">PaaS</h4><p>提供用户应用程序的开发和运行环境，包括应用编程接口和运行平台等，支持应用从创建到运行整个生命周期需要的各种软硬件资源和工具。</p><ul><li>经过封装的IT能力，或逻辑资源：数据库、文件系统和应用运行环境</li><li>主要面向软件开发者（包括应用服务上）</li></ul><p>PaaS自身负责资源的动态扩展和容错管理，用户无需考虑节点间的配合问题。</p><p>用户自主权降低，需按照给定的编程环境和编程模型构建应用。</p><h4 id="saas">SaaS</h4><p>通过标准的Web浏览器或软件客户端访问云上的应用。</p><h3 id="相关技术">2.4 相关技术</h3><p>虚拟化技术、容器技术、数据加密、分布式计算与分布式存储等。</p><h4 id="分布式计算">分布式计算</h4><p>多个通过网络互联的计算机相互之间传递数据，实现信息共享，协作共同完成处理任务。</p><p>优势：</p><ul><li>资源共享</li><li>多设备负载均衡</li><li>将程序放在最适合的计算机上运行</li></ul><h2 id="云计算三元认知">3. 云计算三元认知</h2><h3 id="商业模式">3.1 商业模式</h3><p>一种全新的商业模式、服务类型。</p><ul><li>在软件服务基础上提供平台和基础设施服务</li><li>具体实现：云平台，包括计算范式和实现方式</li></ul><h3 id="计算范式">3.2 计算范式</h3><p>理论实现，针对商业模式的架构设计。</p><ul><li>云体逻辑结构：具体落地的云平台逻辑结构。<ul><li>物理结构：云数据中心</li><li>计算+存储+通信</li></ul></li><li>云栈逻辑结构：面向服务的云平台逻辑结构。<ul><li>物理结构：管理系统的结构</li><li>基础设施即服务，平台即服务，软件即服务</li></ul></li></ul><h3 id="实现方式">3.3 实现方式</h3><p>数据中心+云平台管理系统</p><ul><li>软件定义数据中心：软件定义计算，软件定义存储，软件定义网络，软件定义安全。</li></ul><h2 id="云计算的开源方法论">4. 云计算的开源方法论</h2><h3 id="什么是开源">4.1 什么是开源</h3><p>开源是一种方法论、一种构造大规模复杂软件的协作方式。</p><p>开源软件：</p><p>一种版权持有人为任何人和任何目的提供学习、修改和分发权力，并公布源代码的计算机软件。</p><ol type="1"><li><p>许可证不应限制任何个人或团体将包含该开源软件的广义作品进行销售或赠予</p></li><li><p>开源软件的程序必须包含源代码，必须允许发布源代码及以后的程序</p></li><li><p>开源软件许可证必须允许修改和派生作品，并允许使用原有软件的许可条款发布他们</p></li></ol><p>开源不一定自由，开源不一定免费；自由不一定免费；免费不一定开源，不一定自由。</p><h3 id="开源的价值与意义">4.2 开源的价值与意义</h3><ol type="1"><li>开源促进国家信息技术创新，带动经济发展</li><li>软件厂商依托开源提升研发能力</li><li>用户使用开源技术改变信息化路线</li><li>企业自主开源，引领技术发展路径</li></ol><h2 id="云计算技术的挑战与未来">5. 云计算技术的挑战与未来</h2><h3 id="难点">5.1 难点</h3><ol type="1"><li><p>数据中心安全控制</p></li><li><p>构建高度同构化的虚拟资源</p></li><li><p>高可用性的实现——资源管理</p></li><li><p>容错的实现——任务管理</p><p>当集群中的服务出现故障时，服务器集群上的程序执行不会被中端或挂起。</p></li><li><p>节能（负载均衡）——任务管理</p><p>任务调度；虚拟机调度。</p></li><li><p>云安全与隐私保护——安全管理</p><p>基础设施安全，平台安全，软件安全；数据完整性和隐私保护等。</p></li></ol><p><span class="math inline">\(集群可用性=\frac{MTTF(两个相邻故障之间的系统平均正常运行时间)}{MTTF+MTTR(发生故障后修复及还原工作状态的平均时间)}\)</span></p><h3 id="风险与挑战">5.2 风险与挑战</h3><ol type="1"><li><p>增加了安全漏洞</p><ul><li>远程使用IT资源需要云用户将信任边界扩展到外部的云，建立这样的安全架构同时又不引入安全漏洞是非常困难的</li><li>重叠的信任边界和不断增加的数据曝光为恶意的云用户提供了更多的攻击IT资源、窃取或破坏企业数据的机会</li></ul></li><li><p>降低了运营管理控制能力</p><ul><li>云用户对云资源的管理控制低于对企业内部IT资源的管理控制<ul><li>云提供者可能不遵守它发布的云服务保证</li><li>云用户和云提供者之间较长的地理距离可能需要更多的网络跳数，会带来延迟波动和带宽受限</li></ul></li></ul></li><li><p>云提供者之间有限的可移植性</p><ul><li>由于缺乏行业标准，不同的云提供者提供的服务存在较大差异</li></ul></li><li><p>法规和法律问题</p><ul><li><p>第三方云提供者通常选择造价较低、方便的地理位置建立数据中心，而云用户通常不会意识到所使用IT资源和自身数据所存放的位置</p></li><li><p>某些云用户可能会遇到严重的法律问题</p><p>例如：英国法律规定，英国公民的个人数据只能留在英国境内</p></li><li><p>潜在的数据获得和公开</p><p>例如：某些国家的法律规定，某些类型的数据必须向某些政府机构或数据主体公开</p></li></ul></li></ol><h3 id="缺陷与未来">5.3 缺陷与未来</h3><ul><li>从平台角度看——没有统一的标准</li><li>从计算角度看——针对松耦合的数据处理</li><li>从数据角度看——管理和分析商业数据</li><li>从资源集成角度看——必须集中到云中</li><li>从信息安全角度看——暴露、丢失的风险</li></ul><p>这也恰是网格的优势。</p><p>未来：云格计算</p>]]></content>
    
    
    <categories>
      
      <category>云计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_07_演化学习</title>
    <link href="/2023/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07_%E6%BC%94%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/12/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/07_%E6%BC%94%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="演化学习">演化学习</h1><h2 id="动机">1. 动机</h2><p>人工神经网络：从生物神经系统中得到灵感</p><p>涌现学习模型：模仿生物的声明演化形式</p><p>遗传算法：学习是问题候选假设在进化中的一种竞争，较好的候选假设在自然选择中不断演化。</p><p>进化论：（个体）适应+（自然）选择+（种群）进化</p><h2 id="遗传算法">2. 遗传算法</h2><p>genetic algorithms</p><p>通过对当前最好的假设模型重组来产生后续假设模型。</p><ul><li>生成并测试的柱状搜索</li><li>假设的各个部分相互作用，每一部分对总体的影响难以建模</li></ul><p>算法的一般形式：</p><ol type="1"><li><span class="math inline">\(t:=0\)</span>，初始化种群<spanclass="math inline">\(P(t)\)</span></li><li>循环至终止条件<ul><li>评估<span class="math inline">\(P(t)\)</span>每个染色体的适应度</li><li>根据适应度函数选择部分染色体</li><li>根据所选择的染色体产生后代</li><li>根据<spanclass="math inline">\(P(t)\)</span>中染色体的适应度，选择被替换的染色体，以后代替换</li><li><span class="math inline">\(t:=t+1\)</span></li></ul></li></ol><p>四个问题：</p><ul><li><p>染色体<spanclass="math inline">\(\rightarrow\)</span>模式，每个<属性-值>对用二进制的一位表示：1、0、#（表示1and0）</p><ul><li>模式：0、1、#组成的任意串</li></ul></li><li><p>适应度函数</p></li><li><p>染色体选择：基于适应度函数，与适应度成比例选择</p></li><li><p>后代产生</p><ul><li><p>选择父母：</p><ul><li><p>锦标赛选择：</p><p>每次有放回地取出一定数量个体，选择其中最好个体进入子代种群，重复至新种群与原种群规模相同</p></li><li><p>截断选择：</p><p>适应度前f个染色体进入下一代种群，复制染色体填充种群规模到原种群规模</p></li></ul></li></ul></li></ul><p>遗传算子：对从当前群体中选择的染色体进行重组以产生后代</p><ul><li><p>两个染色体单点/多点交叉替换形成两个新的候选个体</p></li><li><p>变异，随机选择候选个体，以小概率<spanclass="math inline">\(p=1/L\)</span>（L为染色体长度）选位取反</p><ul><li>避免局部收敛，保证种群多样性</li></ul></li></ul><p>后代种群的演化</p><ul><li><p>简易方案：后代染色体直接替代父代染色体</p><ul><li>易丢失优解</li></ul></li><li><p>精英法：每代保留上代最优染色体，丢弃最差个体</p><ul><li>往往与选择算子混用</li></ul></li><li><p>锦标赛法：父母染色体与后代染色体竞争，胜者放入下一代种群</p></li><li><p>小生境法：</p><p>每代个体划分为若干类，每个类中选择若干适应度较大的个体作为一个类的优秀代表组成一个群；</p><p>种群中，以及不同种群之间杂交、变异产生新一代个体群。</p><ul><li>预选择机制：只用高适应度子代替换父代</li><li>排挤机制：预定义原型。所产生的子代要保持和原型的模式不一致，模式相似的个体被替换</li><li>共享机制：计算适应度和模式的关联关系，共享这种模式</li></ul></li></ul><p>优点：</p><ul><li>无需理解问题内部相关性和因果性</li><li>以一个随机的群体开始，以适应度作为某种启发式</li><li>保证整个种群的演化</li></ul><p>问题：</p><ul><li>表示：编码不规范以及编码存在表示的不准确性</li><li>约束：单一遗传算法编码不能全面地将优化问题的约束表示出来</li><li>效率：效率比传统方法低，容易出现过早收敛</li><li>理论保证：对遗传算法的精度、可行性、计算复杂性等方面还没有有效的定量分析方法</li></ul><p>模式定理：高适应度的短模式会在演化的过程中增加占比。</p><h2 id="其他">3. 其他</h2><p>自然计算：模仿自然界特点，具有自适应、自组织、自学习能力的模型和算法</p><ul><li>遗传算法、蚁群算法、粒子群算法、免疫算法</li><li>往往用来解决非凸优化问题</li></ul><p>蚁群优化：模拟蚂蚁觅食，更新信息素</p><p>粒子群优化：模拟鸟群觅食，更新移动位置</p><p>学习分类器系统</p><p>课件没有文字介绍</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_06_神经元</title>
    <link href="/2023/11/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06_%E7%A5%9E%E7%BB%8F%E5%85%83/"/>
    <url>/2023/11/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/06_%E7%A5%9E%E7%BB%8F%E5%85%83/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="神经元">神经元</h1><h2 id="脑和神经元">1. 脑和神经元</h2><h3 id="生物学基础">生物学基础</h3><ol type="1"><li><p>神经元内化学物质调节内部电位。</p></li><li><p>跨膜电位达到一个阈值时，则激活或放电。</p></li><li><p>（固定）时间和强度的脉冲传递给轴突</p></li><li><p>轴突像树枝状，连接到突触</p></li></ol><p>人脑有<spanclass="math inline">\(10^{11}\)</span>个神经元，每个神经元处理速度<spanclass="math inline">\(10^{-3}s\)</span>。</p><p>赫布理论：连接强度调整量与输入输出的乘积成正比。</p><ul><li>又称为长程增强机制或神经可塑。</li></ul><h3 id="mp神经元">MP神经元</h3><p>输入<span class="math inline">\(X=[x_1,x_2,...]\)</span></p><p>权值<span class="math inline">\(W=[w_1,w_2,...]\)</span></p><p>激活函数<spanclass="math inline">\(f(net)=f(\Sigma(w_i*x_i))\)</span></p><p>偏置单元<span class="math inline">\(x_0\)</span>，对应权值<spanclass="math inline">\(w_0\)</span></p><ul><li>输入<span class="math inline">\(X\)</span>，输出<spanclass="math inline">\(f(net)\)</span></li></ul><p>局限性：</p><ul><li>输入方面：线性求和</li><li>输出方面：单一输出值</li><li>更新机制：时钟同步更新</li><li>权值的物理意义：兴奋性连接与抑制性连接；不存在由正到负/由负到正的连接</li></ul><p>激活函数</p><ul><li>单位阶跃函数：<span class="math inline">\(f(x):= \begin{cases}1,\quad x\ge 0 \\[2ex] 0, \quad x\lt0 \end{cases}\)</span><ul><li>不连续，对变化敏感，在x=0处不可微</li><li>一般适合单层感知机</li></ul></li><li>Sigmoid函数：<spanclass="math inline">\(f(x):=\frac{1}{1+e^{-x}}\)</span><ul><li>连续、光滑、严格单调，范围在(0,1)，S形非线性</li><li>导数始终小于1且不以0为对称轴</li><li>饱和类激活函数</li></ul></li><li>ReLU：<span class="math inline">\(f(x):=max(0,x)\)</span></li><li>Leaky ReLU：<span class="math inline">\(f(x):=\begin{cases}x,\quadx\ge0\\ax,\quad x\lt 0 \end{cases}\)</span><ul><li>若a遵循均匀分布随机采样，则为Randomized Leaky ReLU</li></ul></li></ul><p>ReLU都是非饱和类激活函数。</p><h2 id="感知机学习">2. 感知机学习</h2><p>最简单形式的前馈式人工神经网络。</p><p>二元线性分类器，使用特征向量作为输入，把矩阵上的输入x映射到输出值f(x)上（二元值）。</p><p>感知机学习算法</p><ol type="1"><li>权值初始化</li><li>输入样本对</li><li>计算输出</li><li>根据学习规则调整权重</li><li>继续输入下一对样本，循环至对所有样本的实际输出与期望输出相等</li></ol><p>学习规则：<span class="math inline">\(\Delta w_i=c(d-sign(\Sigmaw_i·x_i))x_i\)</span></p><ul><li>c是常数，表示学习率</li><li>d是期望的输出，值为1或-1</li><li>sign是感知机的输出，值为1或-1</li></ul><h2 id="线性可分性">3.线性可分性</h2><p>决策边界：</p><p>即不同决策的输入间的边界。</p><ul><li>鉴别函数</li><li>神经元激活阈值</li></ul><p>多分类决策边界：每个输出神经元定义一条决策边界。</p><p>感知机收敛理论：给定一个线性可分数据集，感知机将在有限次迭代中收敛到一个决策边界。</p><ul><li><p>设<spanclass="math inline">\(\gamma\)</span>是分离超平面与最接近的数据点之间的距离，则迭代次数的界是<spanclass="math inline">\(1/\gamma^2\)</span>。</p></li><li><p>感知机学习可以收敛的前提是训练样例必须线性可分，否则只能收敛到近似目标概念。</p></li></ul><p>感知机学习缺点：单层神经网络，不能解决非线性可分问题。</p><ul><li>异或</li></ul><p>感知机表达能力：n维实例空间的超平面决策。</p><ul><li>候选假设空间：所有可能的权向量的集合</li></ul><p>二层神经网络可以表达所有布尔函数</p><ul><li>广义布尔函数m-of-n：n个输入值至少有m个为真，则输出为真</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_05_支持向量机</title>
    <link href="/2023/11/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05_%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2023/11/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/05_%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="支持向量机">支持向量机</h1><p>20231031</p><p>18:30-21:20</p><p>20231107</p><p>18:30-21:20</p><p>从统计学的观点来看，机器学习的目的是得到映射：<spanclass="math inline">\(X\rightarrow Y\)</span></p><ul><li>类的先验概率：<span class="math inline">\(p(y=i)\)</span></li><li>样本的先验概率：<span class="math inline">\(p(x)\)</span></li><li>类的条件概率：<span class="math inline">\(p(x|y=i)\)</span></li><li>后验概率：<span class="math inline">\(p(y=i|x)\)</span></li></ul><p>统计机器学习方法从概率框架的角度粗略分类：</p><ul><li>生成式模型：估计<span class="math inline">\(p(x|y=i)\)</span>和<spanclass="math inline">\(p(y=i)\)</span>，用贝叶斯定理求<spanclass="math inline">\(p(y=i|x)\)</span></li><li>判别式模型：直接估计<span class="math inline">\(p(y=i|x)\)</span><ul><li>判别函数：不假设概率模型，直接求一个把各类分开的边界</li></ul></li></ul><h2 id="感知机">感知机</h2><h3 id="二分类">二分类</h3><p>二分类问题可以看作是在特征空间上对类别进行划分的任务。</p><p>线性超平面、线性可分</p><ul><li><p><spanclass="math inline">\(w^Tx+b=0\)</span>：划分超平面的线性方程</p><p><spanclass="math inline">\(w\)</span>为法向量，决定了超平面的方向；<spanclass="math inline">\(b\)</span>为位移量，决定了超平面和原点之间的距离</p><p><span class="math inline">\(f(x)=sign(w^Tx+b)\)</span></p></li></ul><h2 id="线性支持向量机">线性支持向量机</h2><h3 id="间隔与支持向量">间隔与支持向量</h3><p>一个点到分界超平面的垂直距离称为这个点对应的间隔（margin）：<spanclass="math inline">\(\frac{|f(x)|}{||w||}=\frac{|w^Tx+b|}{||w||}\)</span>。</p><p>具有最小间隔的点称为支持向量（supported vectors）。</p><p>支持向量机（supported vectormachine，SVM）最大化（所有训练样本的）最小间隔。</p><h3 id="分类与评价">分类与评价</h3><p><span class="math inline">\(f(\vec x)\gt0\)</span>则为正类，<spanclass="math inline">\(f(\vec x)\lt0\)</span>则为负类。</p><p><span class="math inline">\(y_i=\{-1,1\}\)</span>，<spanclass="math inline">\(y_if(\vec x_i)\gt0\)</span>为正确，<spanclass="math inline">\(y_if(\vec x_i)\lt0\)</span>为错误。</p><ul><li>假设能完全分开，且<spanclass="math inline">\(|y_i|=1\)</span>，那么<spanclass="math inline">\(y_if(\vec x_i)=|f(x_i)|\)</span></li></ul><h2 id="非线性支持向量机">非线性支持向量机</h2><p>将样本从原始空间映射到一个更高维的特征空间，使样本在这个特征空间内线性可分。</p><p>非线性核：RBF/高斯核、多项式核</p><h2 id="多类支持向量机">多类支持向量机</h2><p>1vs rest/1v1</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_04_集成学习</title>
    <link href="/2023/10/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/04_%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="集成学习">集成学习</h1><h2 id="集成学习原理">集成学习原理</h2><h3 id="特点分类">特点（分类）</h3><p>多个分类器集成在一起，以提高分类准确率；</p><p>由训练数据构建基分类器，然后根据预测结果投票。</p><ul><li><p>集成学习本身不是一种分类器，而是一种分类器结合方法。</p></li><li><p>通常集成分类器性能会好于单个分类器。</p></li></ul><h4 id="例多数投票法结合">例：多数投票法结合</h4><p>每个二分类器的分类精度为p，则集成T个分类器的分类精度为<spanclass="math inline">\(\Sigma_{k=\frac{T}{2}+1}^T(_k^T)p^k(1-p)^{T-k}\)</span></p><ul><li>当<span class="math inline">\(p\gt0.5\)</span>且<spanclass="math inline">\(T\rightarrow\infty\)</span>时，上式<spanclass="math inline">\(\rightarrow 1\)</span></li></ul><h3 id="bias-variance-tradeoff问题">Bias-Variance tradeoff问题</h3><p>Bias：学习结果的期望和真实规律的差距</p><p><span class="math inline">\(Bias=E[\hat f(x)]-f(x)\)</span></p><p>Variance：学习结果自身的不稳定性</p><p><span class="math inline">\(Variance=E[(\hat f(x)-E[\hatf(x)])^2]\)</span></p><p>Total Error：以均方误差为例</p><p><spanclass="math inline">\(Err(x)=Bias^2+Variance+Random\,Error\)</span></p><h4 id="核心问题">核心问题</h4><p>序列集成（基学习器）法</p><ul><li>利用基学习器之间的依赖关系依次生成</li><li>减少偏差bias</li></ul><p>并行集成（基学习器）法</p><ul><li>利用基学习器之间的独立关系并行生成</li><li>减少方差variance</li></ul><p>问题：如何训练和结合每个学习器</p><h3 id="结合策略">结合策略</h3><p>平均法（回归问题）</p><ul><li>简单平均</li><li>加权平均</li></ul><p>投票法（分类问题）</p><ul><li>绝对多数</li><li>相对多数</li><li>加权投票</li></ul><p>学习法（Stacking）</p><h3 id="多样性策略学习基学习器">多样性策略（学习基学习器）</h3><p>数据层面</p><ul><li>输入样本的扰动，构建基学习器</li><li>输出样本的扰动，构建基学习器</li></ul><p>属性层面</p><ul><li>随机选择部分属性，构建基学习器</li></ul><p>参数层面</p><ul><li>算法模型参数的扰动，构建基学习器</li></ul><h2 id="bagging和随机森林">Bagging和随机森林</h2><h3 id="bagging">Bagging</h3><p>Bagging（Boosting aggregating）基本原理：</p><p>有放回采样方法。统计上的目的是得到统计量分布以及置信区间。</p><h4 id="bagging-算法流程">Bagging 算法流程</h4><p>输入：训练集S，基学习算法I，整数T（训练轮数/自助Bootstrap数）</p><p><span class="math inline">\(for\;i = 1\;to\;T\)</span> <spanclass="math inline">\(\{\)</span> <spanclass="math inline">\(S&#39;=从S中自助采样（有放回的独立采样）\)</span><span class="math inline">\(C_i=I(S&#39;)\)</span> <spanclass="math inline">\(\}\)</span></p><p><span class="math inline">\(C^*(x)=argmax_{y\inY}\Sigma_{i=1}^T(C_i(x)=y)\)</span></p><p>输出：分类器<span class="math inline">\(C^*\)</span></p><p>优点：</p><p>并行式集成学习，降低分类器方差，改善泛化。</p><ul><li>其性能依赖于基分类器的稳定性，若基分类器稳定，则其误差主要由基分类器bias决定</li><li>由于采样概率相同，bagging方法不侧重于任何特定实例</li><li>可以并行化处理，提高效率</li></ul><p>缺点：</p><ul><li>当基学习器具有高bias，集成之后也会具有较高bias</li><li>集成之后的模型会损失可解释性</li><li>依赖数据集，计算可能会比较昂贵</li></ul><p>代表性算法：随机森林（Random Forest，RF）</p><h3 id="随机森林">随机森林</h3><ol type="1"><li>训练用例的个数为N，特征数目为M，输入特征数目m以确定决策树上个结点的决策结果。<ul><li>m应远小于M。</li></ul></li><li>从N个训练样例中以有放回抽样的方式取样N次，形成一个训练集（即bagging取样），并用未抽到的用例作预测，评估其误差。</li><li>对于每一个结点，随机选择m个特征（通常为M的均方根<spanclass="math inline">\(log_2M\)</span>），根据这m个特征，计算其最佳的分裂方式。</li><li>每棵树都会完整成长而不会剪枝，这有可能在建完一棵正常树状分类器后会被采用。</li><li>以上过程做充分多次以产生足够多的随机树。</li></ol><p>特点：</p><ul><li>差异性：每棵树是不同的；每棵树使用的特征是不同的的</li><li>缓解维度灾难：每棵树没有使用全部特征，特征空间被减小了</li><li>可并行化：每棵树使用不同数据、不同特征，可以有效采用并行化技术</li><li>训练-测试划分：训练和测试的划分不是必须的，因为构建每棵决策树时，总有30%的数据没有采样</li><li>稳定性：通过多数投票或者平均，结果较为稳定</li></ul><h2 id="boosting">Boosting</h2><h3 id="概率近似正确pac学习理论">概率近似正确（PAC）学习理论</h3><p>强可学习：在PAC框架中，一个概念，如果存在一个多项式的学习算法能够学习它，并且正确率很高，那么就称这个概念是强可学习的。</p><p>弱可学习：在PAC框架中，一个概念，如果存在一个多项式的学习算法能够学习它，学习的正确率仅比随机猜测略好，那么就称这个概念是弱可学习的。</p><p>PAC学习理论：</p><ul><li>强学习器和弱学习器是等价的</li><li>一个概念是强学习的充分必要条件是这个概念是弱可学习的</li><li>可以通过提升方法（Boosting）将弱学习器转为强学习器</li></ul><h3 id="boosting-1">Boosting</h3><p>代表性算法：Adaptive Boost（AdaBoost）</p><p>从弱学习算法出发，通过改变训练数据的概率（权值）分布，反复学习，得到一系列弱分类器，然后进行组合，构成一个强分类器。</p><p>策略：</p><ul><li>权值分布：提高那些被前一轮弱分类器错误分类样本的权值，降低那些被正确分类样本的权值。</li><li>弱分类器组合：采用加权多数表决策略；增加分类误差率小的弱分类器权重，减小分类误差率大的弱分类器权重。</li></ul><h3 id="adaboost">AdaBoost</h3><p>以分类问题为例：分类器的误差率和权重系数</p><p>AdaBoost采用加权表决。</p><p>AdaBoost算法的另一个解释：</p><ul><li><p>AdaBoost的模型为加法模型</p></li><li><p>AdaBoost的损失函数为指数函数：<spanclass="math inline">\(L(y,f(x))=exp[-yf(x)]\)</span></p></li><li><p>AdaBoost的学习算法为前向分步算法</p></li><li><p>AdaBoost的算法是一个二分类学习算法</p></li><li><p>AdaBoost的最终分类器：<spanclass="math inline">\(f(x)=\Sigma_{k=1}^K\alpha_kG_k(x_i)\)</span></p></li></ul><h4 id="加法模型">加法模型</h4><p><spanclass="math inline">\(f(x)=\Sigma_{m=1}^M\beta_mb(x;\gamma_m)\)</span></p><p>基函数（共M个）：<spanclass="math inline">\(b(x;\gamma_m)\)</span></p><p>基函数参数：<span class="math inline">\(\gamma_m\)</span></p><p>基函数系数：<span class="math inline">\(\beta_m\)</span></p><p>目标函数：<spanclass="math inline">\(min_{(\beta_m,\gamma_m)}\Sigma_{i=1}^NL(y_i,\Sigma_{m=1}^M\beta_mb(x_i;\gamma_m))\)</span></p><h4 id="前向分步算法">前向分步算法</h4><p>学习目标函数为加法模型，如果能够从前到后，每一步只学习一个基函数及其系数，逐步逼近要优化的总目标函数，就可以简化优化的复杂度。</p><p>输入：</p><ul><li>训练数据集<spanclass="math inline">\(T=\{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\}\)</span>；</li><li>损失函数<span class="math inline">\(L(Y,f(x))\)</span>；</li><li>基函数集<span class="math inline">\(\{b(x;\gamma)\}\)</span></li></ul><p>输出：加法模型<span class="math inline">\(f(x)\)</span></p><ol type="1"><li>初始化<span class="math inline">\(f_0(x)=0\)</span></li><li>对<span class="math inline">\(m=1,2,...,M\)</span><ol type="1"><li>极小化损失函数得到<spanclass="math inline">\(\beta_m,\gamma_m\)</span>：<spanclass="math inline">\((\beta_m,\gamma_m)=argmin_{\beta,\gamma}\Sigma_{i=1}^NL(y_i,f_{m-1}(x_i)+\betab(x_i;\gamma))\)</span></li><li>更新：<spanclass="math inline">\(f_m(x)=f_{m-1}(x)+\beta_mb(x;\gamma_m)\)</span></li></ol></li><li>得到加法模型：<spanclass="math inline">\(f(x)=f_M(x)=\Sigma_{m=1}^M\beta_mb(x;\gamma_m)\)</span></li></ol><h3 id="提升树">提升树</h3><p>提升（Boosting）方法主要采用加法模型，即基函数的线性组合，与前向分步算法。</p><p>以决策树为基函数的提升方法称为提升树（boosting tree）。</p><ul><li><spanclass="math inline">\(f_M(x)=\Sigma_{m=1}^Mh_m(x)\)</span>，其中<spanclass="math inline">\(h_m(x)\)</span>表示决策树，<spanclass="math inline">\(M\)</span>为决策树个数</li></ul><h4 id="提升树算法流程">提升树算法流程</h4><p>回归问题</p><ol type="1"><li>初始化<span class="math inline">\(f_0(x)=0\)</span></li><li>对<span class="math inline">\(m=1,2,...,M\)</span><ol type="1"><li>计算<spanclass="math inline">\(argmin\Sigma_{i=1}^NL(y_i,f_{m-1}(x_i)+h_m(x_i))\)</span></li><li>得到<span class="math inline">\(h_m(x)\)</span></li><li>更新<spanclass="math inline">\(f_m(x)=f_{m-1}(x)+h_m(x)\)</span></li></ol></li><li>得到回归问题提升树：<spanclass="math inline">\(f_M(x)=\Sigma_{m=1}^Mh_m(x)\)</span></li></ol><p>当采用平方误差损失函数：<spanclass="math inline">\(L(y,f_{m-1}(x)+h_m(x))=(y-f_{m-1}(x)-h_m(x))^2=(r-h_m(x))^2\)</span></p><p>其中残差<span class="math inline">\(r=y-f_{m-1}(x)\)</span>。</p><p>可以拟合残差<spanclass="math inline">\(r_{m_i}\)</span>学习一个回归树，得到<spanclass="math inline">\(h_m(x)\)</span>。</p><p>推广到一般损失：第m轮第i个样本的负梯度作为残差的近似值：<spanclass="math inline">\(-[\frac{\partial L(y,f(x_i))}{\partialf(x_i)}]_{f=f_{m-1}}\)</span></p><h3 id="gbdt">GBDT</h3><p>Gradient Boosting Decision Tree，梯度提升树</p><h4 id="算法流程">算法流程</h4><ol type="1"><li>初始化弱分类器</li><li>循环<ol type="1"><li>对每个样本计算负梯度</li><li>构建新的样本集合</li><li>根据对树的约束，构建CART树</li><li>计算叶子区域最佳拟合值</li><li>更新得到强学习器</li></ol></li><li>得到最终强学习器</li></ol><p>回归问题</p><ol type="1"><li>初始化<spanclass="math inline">\(f_0(x)=argmin_\gamma\Sigma_{i=1}^NL(y_i,\gamma)\)</span></li><li>对<span class="math inline">\(m=1,2,...,M\)</span><ol type="1"><li>计算残差<span class="math inline">\(r_{mi}=-[\frac{\partialL(y,f(x_i))}{\partial f(x_i)}]_{f=f_{m-1}},i=1,2,...,N\)</span></li><li>残差<spanclass="math inline">\(rmi\)</span>拟合一个回归树，得到第m棵树的叶结点区域<spanclass="math inline">\(R_{mj},j=1,2,...,J\)</span></li><li>对<span class="math inline">\(j=1,2,...,J\)</span>计算<spanclass="math inline">\(Y_{mj}=argmin_c\Sigma_{x_i\inR_{mj}}L(y_i,f_{m-1}(x_i)+\gamma)\)</span></li><li>更新<spanclass="math inline">\(f_m(x)=f_{m-1}(x)+\Sigma_{j=1}^J\gamma_{mj}I(x\inR_{mj})\)</span></li></ol></li><li>得到回归问题提升树：<spanclass="math inline">\(f_M(x)=\Sigma_{m=1}^M\Sigma_{j=1}^J\gamma_{mj}I(x\inR_{mj})\)</span></li></ol><h3 id="xgboost">XGBoost</h3><p>Extreme Gradient Boosting</p><ul><li><p>GBDT的一种高效实现</p></li><li><p>目标函数通过二阶泰勒展开式做近似</p></li><li><p>定义了树的复杂度，并应用到目标函数中</p></li><li><p>分裂结点处通过结构打分和分割损失动态生长</p></li><li><p>分裂结点的候选集合通过一种分布式Quantile Sketch得到</p></li><li><p>可以处理稀疏、缺失数据</p></li><li><p>可以通过特征的列采样防止过拟合</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_03_树学习</title>
    <link href="/2023/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/03_%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="树学习">树学习</h1><p>20230926</p><p>18:30-21:30</p><p>20231010</p><p>18:30-21:30</p><h2 id="符号学习">符号学习</h2><p>推理的角度：</p><ul><li>演绎推理：<span class="math inline">\(P\rightarrowQ\)</span>，P为真则Q为真</li><li>反绎推理：<span class="math inline">\(P\rightarrowQ\)</span>，Q为真则P为真</li><li>归纳推理：P为真，Q未必为真</li></ul><p>符号（概念）学习是一类归纳推理。</p><h3 id="概念学习">概念学习</h3><p>给定样例集合，以及每个样例是否属于某个概念，自动地推断出该概念的一般定义。</p><h4 id="概念学习任务">概念学习任务</h4><ul><li>实例集合X</li><li>目标概念c：定义在实例集X上的布尔函数<spanclass="math inline">\(c:X\rightarrow\{0,1\}\)</span></li><li>训练样例：正例<spanclass="math inline">\((c(x)=1)\)</span>，反例<spanclass="math inline">\((c(x)=0)\)</span></li><li>假设集H：每个假设h表示X上定义的布尔函数<spanclass="math inline">\(h:X\rightarrow\{0,1\}\)</span></li></ul><p>概念学习：寻找一个假设h，使对于X中的所有x，<spanclass="math inline">\(h(x)=c(x)\)</span></p><p>归纳学习假设：任一假设如果在足够大的训练样例集合中能很好地逼近目标概念函数，它也能在未见实例中很好地逼近目标概念。</p><h4 id="作为搜索的概念学习">作为搜索的概念学习</h4><p>当假设的表示确定后，也就确定了概念学习算法所有假设的空间。</p><p>搜索的目标是为了寻找最好的拟合训练样例的假设。</p><p>搜索的操作：</p><ul><li>用逻辑变量替换常量</li><li>合取表达式去掉部分条件</li><li>对表达式增加析取项</li><li>用属性的超类来替换属性</li></ul><h4 id="假设的一般到特殊序">假设的一般到特殊序</h4><ul><li><p>更泛化</p><p><span class="math inline">\(令h_j和h_k是定义在X上的布尔函数，h_j\ge_gh_k即h_j更泛化于h_k\)</span></p><p><span class="math inline">\(当且仅当(\forall x\inX)[(h_k(x)=1)\rightarrow (h_j(x)=1)]\)</span></p></li><li><p>严格泛化：记为<spanclass="math inline">\(h_j\gt_gh_k\)</span></p></li><li><p>更特化：记为<spanclass="math inline">\(h_j\ge_sh_k\)</span></p></li></ul><h3 id="寻找极大特殊假设find-s">寻找极大特殊假设，Find-S</h3><ol type="1"><li><p>将h初始化为H中最特殊的假设</p></li><li><p>对每个正例x：</p><p>对h的每个属性约束，如果x满足，不处理；</p><p>否则将该约束替换为x满足的另一个最一般的约束</p></li><li><p>输出假设h</p></li></ol><p>对以属性合取式表示的假设空间，输出与正例一致的最特殊的假设。</p><h3id="列表消除算法list-then-eliminate">列表消除算法，List-Then-Eliminate</h3><ol type="1"><li>变型空间Version Space：假设空间H中所有假设的列表</li><li>对每个样例<spanclass="math inline">\(&lt;x,c(x)&gt;\)</span>，从变型空间中移除<spanclass="math inline">\(h(x)\neq c(x)\)</span>的假设h</li><li>输出变型空间中的假设列表</li></ol><p>要列出所有假设，在实际中往往不可能。</p><h2 id="变型空间">变型空间</h2><p>一致：一个假设h与训练样例集合D一致，当且仅当<spanclass="math inline">\(Consistent(h,D)\equiv(\forall&lt;x,c(x)&gt;\inD)\quad h(x)=c(x)\)</span>。</p><p>变型空间（Version Space）：</p><p>关于假设空间H和训练样例集合D的变型空间，是H中与训练样例D一致的所有假设构成的子集。<spanclass="math inline">\(VS_{H,D}\equiv\{h\inH|Consistent(h,D)\}\)</span></p><ul><li><p>极大泛化：H中和D一致的极大一般成员的集合</p><p><span class="math inline">\(G\equiv\{g\inH|Consistent(g,D)\and(\neg\exist g&#39;\in H[(g&#39;\gt_g g)\andConsistent(g&#39;,D)])\}\)</span></p></li><li><p>极大特化：H中和D一致的极大特殊成员的集合</p><p><span class="math inline">\(S\equiv\{s\inH|Consistent(s,D)\and(\neg\exist s&#39;\in H[(s\gt_s s&#39;)\andConsistent(s&#39;,D)])\}\)</span></p></li></ul><h3 id="表示定理">表示定理</h3><p>令X为任意的实例集合，H为X上定义的布尔函数集合。令<spanclass="math inline">\(c:X\rightarrow[0,1]\)</span>为X上定义的任一目标概念，并令D为任意训练样例的集合<spanclass="math inline">\(\{&lt;x,c(x)&gt;\}\)</span>。对所有的X，H，c，D以及良好定义的S和G：<spanclass="math inline">\(VS_{H,D}\equiv\{h\in H|(\exist s\in S)(\exist g\inG)[g\gt_g h\gt_s s]\}\)</span></p><ul><li>其中G为极大泛化集合，S为极大特化集合。</li></ul><h3 id="正例和反例的作用">正例和反例的作用</h3><p>正例用于S泛化，搜索S集合；反例用于G特化，缩小G集合。</p><p>反例对于超泛化具有抑制作用。</p><h3 id="候选消除算法">候选消除算法</h3><p>将G集合初始化为H中最一般的假设：<spanclass="math inline">\(G_0=\{&lt;?,...,?&gt;\}\)</span></p><p>将S集合初始化为H中最特殊的假设：<spanclass="math inline">\(S_0=\{&lt;\empty,...,\empty&gt;\}\)</span></p><p>对每个训练样例d，</p><ul><li><p>如果d是正例：</p><ul><li><p>从G中移去所有与d不一致的假设</p></li><li><p>对S中每一个与d不一致的假设s：</p><ul><li><p>从S中移除s</p></li><li><p>把s的所有极小泛化假设h加入到S中</p><p>h满足与D一致，而且G中某个成员比h更一般</p></li><li><p>从S中移去所有比S中另一假设更一般的假设</p></li></ul></li></ul></li><li><p>如果d是反例：</p><ul><li><p>从S中移去所有和d不一致的假设</p></li><li><p>对G中每一个与d不一致的假设g：</p><ul><li><p>从G中移除g</p></li><li><p>把g的所有极小特化假设h加入到G中</p><p>h满足与D一致，而且S中某个成员比h更特殊</p></li><li><p>从G中移去所有比G中另一假设更特殊的假设</p></li></ul></li></ul></li></ul><h3 id="归纳偏置">归纳偏置</h3><p>归纳推理的根本问题：</p><ul><li>目标概念假设不在假设空间怎么办？</li><li>能设计包含所有假设的空间吗？</li><li>假设空间大小对未见实例的泛化能力有什么影响？</li><li>假设空间大小对所需训练样例数量有什么影响？</li></ul><p>假设空间往往是合取的有偏表示，而真实空间是析取的无偏表示。</p><p>无偏学习的无用性：</p><p>无偏学习需要X中所有实例进行训练，无法进行泛化，变型空间和候选消除算法失效。</p><p>因此，归纳学习必须给定某种形式的预先假定，即归纳偏置。</p><ul><li><p>核心：学习器从训练样例中泛化并推断新实例分类过程中所采用的策略</p></li><li><p>精确定义：</p><ul><li><p>给定任意训练数据<spanclass="math inline">\(D_c=\{x,c(x)\}\)</span>，目标概念c，学习算法L</p></li><li><p>推断新实例性<span class="math inline">\(x_i\)</span></p></li><li><p>归纳推理过程为：</p><p><span class="math inline">\((D_c\and x_i)\rightarrowL(x_i,D_c)\)</span></p><p><span class="math inline">\((B\and D_c\and x_i)\vdashL(x_i,D_c)\)</span></p></li></ul><p>学习器的归纳偏置为附加的前提集合B，通过B，则归纳推理可由演绎推理派生</p></li></ul><h4 id="有偏性">有偏性</h4><ul><li>无归纳偏置</li><li><span class="math inline">\(c\in H\)</span></li><li><span class="math inline">\(c\inH\)</span>且任何实例，除非可由其他先验推出，否则为反例</li></ul><p>有偏性越强，则学习器的归纳能力越强。</p><p>有偏程度不同的三种归纳学习算法：</p><ul><li>机械式学习器</li><li>候选消除算法</li><li>Find-S</li></ul><h2 id="决策树学习">决策树学习</h2><ul><li><p>实例：“属性-值”对表示，应用最广的归纳推理算法之一</p></li><li><p>目标函数具有离散的输出值</p></li><li><p>很好的健壮性（样例可以包含错误，也可以处理缺少属性值的实例）</p></li><li><p>能够学习析取表达式</p></li></ul><p>决策树学习算法：</p><ul><li>ID3、Assistant、C4.5</li><li>搜索一个完整表示的假设空间，表示为多个if-then规则</li></ul><p>归纳偏置：优先选择较小的树</p><h3 id="算法框架">算法框架</h3><p>问题设置：</p><ul><li>可能的实例集X</li><li>未知的目标函数<span class="math inline">\(f:X\rightarrowY\)</span></li><li>假设函数集<span class="math inline">\(H=\{h|h:X\rightarrowY\}\)</span></li></ul><p>输入：未知目标函数f的训练样例<spanclass="math inline">\(\{&lt;x_i,y_i&gt;\}\)</span></p><p>输出：最佳近似f的假设<span class="math inline">\(h\in H\)</span></p><p>算法框架：</p><ol type="1"><li>处理基本情况</li><li>寻找最好的分类属性A</li><li>用A建立一个节点划分样例</li><li>递归处理每一个划分作为其子节点/子树</li></ol><h3 id="假设空间搜索">假设空间搜索</h3><p>搜索的假设空间就是可能的决策树的集合。</p><p>从一个假设空间中搜索一个正确拟合训练样例的假设。</p><p>从简单到复杂的爬山算法遍历假设空间。从空的树开始，然后逐步考虑更加复杂的假设。引导爬山搜索的评估函数是信息增益度量。</p><h3 id="如何选择最佳属性">如何选择最佳属性</h3><p>衡量给定的属性区分训练样例的能力：信息增益</p><p>信息的度量：熵，刻画了样例集合的纯度。</p><ul><li><p>目标属性为布尔值的样例集S的熵：</p><p><spanclass="math inline">\(Entropy(S)=-p_+log_2p_+-p_-log_2p_-\)</span></p><p>其中，<span class="math inline">\(p_+\)</span>为正例的概率，<spanclass="math inline">\(p_-\)</span>为反例的概率。</p></li><li><p>熵的一般定义：</p><p><spanclass="math inline">\(Entropy(S)=\Sigma_{i=1}^c(-p_ilog_2p_i)\)</span></p></li></ul><p>信息增益：使用属性分割样例，导致期望熵降低</p><p><span class="math inline">\(Gain(S,A)=Entropy(S)-\Sigma_{v\inValues(A)}\frac{|S_v|}{S}Entropy(S_v)\)</span></p><ul><li><p>其中<spanclass="math inline">\(Values(A)\)</span>是属性A所有可能值的集合</p></li><li><p><spanclass="math inline">\(S_v\)</span>是S中属性A的值为v的子集，即<spanclass="math inline">\(S_v=\{s\in S|A(s)=v\}\)</span></p></li><li><p>第二项是用A分类S后熵的期望值</p></li></ul><h3 id="用于学习布尔函数的id3算法">用于学习布尔函数的ID3算法</h3><p><span class="math inline">\(ID3(Examples,Attributes)\)</span></p><ol type="1"><li><p>创建树的Root结点</p></li><li><p>如果Examples的目标属性均为正，则返回label=+的单结点树Root</p></li><li><p>如果Examples的目标属性均为反，那么返回label=-的单结点树Root</p></li><li><p>如果Attributes为空，那么返回单结点树Root，label设置为Examples中最普遍的目标属性值</p></li><li><p>否则</p><ul><li><p><span class="math inline">\(A\leftarrowAttributes中分类Examples能力最好的属性\)</span></p></li><li><p><span class="math inline">\(Root的决策属性\leftarrowA\)</span></p></li><li><p><span class="math inline">\(对于A的每个可能值v_i\)</span></p><ul><li><p><spanclass="math inline">\(令Examples_{v_i}为Examples中满足A属性值为v_i的子集\)</span></p></li><li><p><span class="math inline">\(如果Examples_{v_i}为空\)</span></p><ul><li><p><spanclass="math inline">\(在这个分支下加一个叶子结点，\)</span></p><p><spanclass="math inline">\(结点的label设置为Examples中最普遍的目标属性值\)</span></p></li></ul></li><li><p><spanclass="math inline">\(否则，在这个分支下加一个子树ID3(Examples_{v_i},Attributes-\{A\})\)</span></p></li></ul></li></ul></li><li><p>结束，返回树Root</p></li></ol><h4 id="id3算法特点">ID3算法特点</h4><p>假设空间：包含所有的决策树</p><p>遍历过程：仅维持单一的当前假设</p><ul><li>变型空间候选消除算法维持满足训练样例的所有假设</li></ul><p>不进行回溯，局部最优</p><p>基于统计，对错误样例不敏感，不适用于增量处理。</p><p>改进算法：C4.5等。</p><h3 id="决策树学习中的归纳偏置">决策树学习中的归纳偏置</h3><p><span class="math display">\[ 搜索策略决定了归纳偏置\begin{cases}近似：优先选择较短的树\\ 有限选择信息增益高的属性更接近根结点的树\end{cases}\]</span></p><h3 id="奥卡姆剃刀原理">奥卡姆剃刀原理</h3><p>如果对于同一现象有两种不同的假说，应该采取比较简单的那一种。</p><ul><li>不是简单的选择最简化的假设，而是推理所依据的是使可证伪的假设的数目更少。</li></ul><h2 id="其他树算法">其他树算法</h2><h3 id="c4.5算法">C4.5算法</h3><p>属性选择指标：</p><p>信息增益率：信息增益/该属性的熵</p><ul><li>信息增益准则对可取值数目较多的属性有所偏好</li><li>避免对取值数目较少的属性有所偏好，采用以下启发式：<ul><li>先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择增益率最高的</li></ul></li></ul><h3 id="cart算法">CART算法</h3><h4 id="属性选择指标分类">属性选择指标（分类）</h4><p>信息增益和增益率准则均需要计算对数。</p><p>基尼指数：模型的纯度，越小纯度越高。</p><ul><li><p>K个分类：<spanclass="math inline">\(Gini(p)=\Sigma_{k=1}^K(1-p_k)p_k=1-\Sigma_{k=1}^Kp_k^2\)</span></p></li><li><p>数据集D：<spanclass="math inline">\(Gini(D)=1-\Sigma_{k=1}^K(\frac{C_k}{D})^2\)</span></p></li><li><p>属性A对数据集的划分：<spanclass="math inline">\(Gini(D,A)=\frac{|D_1|}{D}Gini(D_1)+\frac{|D_2|}{D}Gini(D_2)\)</span></p></li><li><p>基尼指数和熵是正相关的，均可用来表示一个集合的混乱程度，并作为叶子结点的损失</p></li></ul><h4 id="属性选择指标回归">属性选择指标（回归）</h4><p>采用方差和度量。</p><p>度量目标是对于划分特征A，对应划分点s两边的数据集<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>，求出使<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>各自集合的均方差最小，同时<spanclass="math inline">\(D_1\)</span>和<spanclass="math inline">\(D_2\)</span>的均方差之和最小。</p><p><span class="math inline">\(min_{A,s}[min_{c_1}\Sigma_{x_i\inD_1(A,s)}(y_i-c_i)^2+min_{c_2}\Sigma_{x_i\inD_2(A,s)}(y_i-c_2)^2]\)</span></p><p>回归树输出不是类别，采用叶子结点的均值或者中位数来预测输出结果。</p><h4 id="连续值处理">连续值处理</h4><p>连续特征离散化：</p><ul><li>C4.5基于信息增益率离散化，CART基于基尼系数离散化</li><li>m个样本的连续特征A有m个，从小到大排列<spanclass="math inline">\(a_1,...,a_m\)</span>，则CART取相邻两样本值的平均数做划分点，一共取m-1个，其中第i个划分点<spanclass="math inline">\(T_i\)</span>表示为：<spanclass="math inline">\(T_i= (a_i+a_{i+1})/2\)</span>。<ol type="1"><li>分别计算以这m-1个点作为二元分类点时的基尼系数。</li><li>选择基尼系数最小的点为该连续特征的二元离散分类点。</li><li>如取到的基尼系数最小的点为<spanclass="math inline">\(a_t\)</span>，则小于<spanclass="math inline">\(a_t\)</span>的值为类别1；大于<spanclass="math inline">\(a_t\)</span>的值为类别2，这样就做到了连续特征的离散化。</li></ol></li></ul><h4 id="离散值处理">离散值处理</h4><p>CART分类树算法：对离散值的处理，采用不停地二分离散特征。</p><ul><li><p>多叉树：在ID3、C4.5，特征A被选中，如果它有3个取值<spanclass="math inline">\(A_1,A_2,A_3\)</span>，则建立三叉子树</p></li><li><p>二叉树：</p><ul><li>CART将特征A分成<span class="math inline">\(\{A_1\}\)</span>和<spanclass="math inline">\(\{A_2,A_3\}\)</span>、<spanclass="math inline">\(\{A_2\}\)</span>和<spanclass="math inline">\(\{A_1,A_3\}\)</span>、<spanclass="math inline">\(\{A_3\}\)</span>和<spanclass="math inline">\(\{A_1,A_2\}\)</span>三种情况，找到基尼系数最小的组合，比如<spanclass="math inline">\(\{A_2\}\)</span>和<spanclass="math inline">\(\{A_1,A_3\}\)</span>，然后建立二叉树节点。</li><li>由于并没有把特征A的取值完全分开，后面还有机会对子节点继续选择特征A划分<spanclass="math inline">\(A_1\)</span>和<spanclass="math inline">\(A_3\)</span>。</li></ul></li></ul><h4 id="剪枝处理">剪枝处理</h4><p>后剪枝：从完全生长的决策树的底端剪去一些子树，使决策树变小，从而增强泛化能力。</p><ul><li>首先从生成算法产生的决策树<spanclass="math inline">\(T_0\)</span>底端开始不断剪枝，直到<spanclass="math inline">\(T_0\)</span>的根节点，形成一个子序列<spanclass="math inline">\(T_0,...,T_n\)</span></li><li>然后通过交叉验证在独立的验证集上对子树序列进行测试，从中选择最优子树。</li></ul><p>最小化子树的损失函数：<spanclass="math inline">\(C_a(T)=C(T)+a|T|\)</span></p><ul><li>T为任意子树，C(T)为对数据的预测误差（如基尼系数），|T|为子树叶结点个数。超参<spanclass="math inline">\(a\ge0\)</span>，权衡训练数据的拟合程度与模型的复杂度。</li><li>a比较大，则最优子树<span class="math inline">\(T_a\)</span>偏小</li><li>a比较小，则最优子树<span class="math inline">\(T_a\)</span>偏大</li><li>a=0，则最优子树等于未剪枝的<spanclass="math inline">\(T_0\)</span></li><li>a趋近于∞，则最优子树为根结点树</li></ul><h2 id="树学习算法优缺点">树学习算法优缺点</h2><h3 id="优点">优点</h3><ul><li><p>简单直观，可解释性强。</p></li><li><p>基本不需要预处理，也不需要提前归一化和处理缺失值。既可以处理离散值也可以处理连续值。不过很多算法只是专注于离散值或者连续值。</p></li><li><p>可以处理多维度输出的分类问题。</p></li><li><p>使用决策树预测的代价为<spanclass="math inline">\(O(log_2m)\)</span>，m为样本数。</p></li><li><p>可以交叉验证的剪枝来选择模型，从而提高泛化能力。</p></li><li><p>对于异常点的容错能力好，健壮性高。</p></li></ul><h3 id="缺点">缺点</h3><ul><li><p>树算法非常容易过拟合，导致泛化能力不强（设置节点最少样本树、限制树深度）</p></li><li><p>样本的一点变动会导致树结构的剧烈改变（集成学习）</p></li><li><p>寻找最优决策树是NP难题，通过启发式方法容易陷入局部最优（集成学习）</p></li><li><p>比较复杂的关系，决策树很难学习（使用其他学习方法）</p></li><li><p>如果某些特征的样本比例过大，生成决策树比较容易偏向于这些特征（调节样本权重）</p></li></ul><h3 id="延伸">延伸</h3><ul><li><p>BAIR博客地址：https://bair.berkeley.edu/blog/2020/04/23/decisions/</p></li><li><p>论文地址：https://arxiv.org/abs/2004.00221</p></li><li><p>开源项目地址：https://github.com/alvinwan/neu</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_02_无监督学习</title>
    <link href="/2023/09/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/02_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="无监督学习">无监督学习</h1><p>20230912</p><p>20:10-21:10</p><p>20230917</p><p>18:30-21:10</p><p>聚类算法 Clustering Algorithm</p><p>聚类的“好坏”不存在绝对标准。</p><h2 id="大纲">大纲</h2><ul><li>相关概念</li><li>距离度量</li><li>聚类准则</li><li>聚类方法</li><li>聚类评价</li></ul><h2 id="相关概念">相关概念</h2><p>聚类：数据对象的集合</p><ul><li>在同一个类里，数据对象是相似的</li><li>不同类的数据对象是不相似的</li></ul><p>聚类算法：根据给定的相似性评判标准，将一个数据集合划分为几个聚类。</p><ul><li><p>数学形式化：</p><p>样本集合：<span class="math inline">\(D=\{x_1,x_2,...,x_m\},x_i\inR^d\)</span></p><p>聚类成k个簇：<span class="math inline">\(\{C_l|l=1,2,...,k\}\)</span></p></li><li><p>好的聚类算法：聚类内部高相似，聚类之间低相似。</p></li></ul><p>聚类的依据：将整个数据集中每个样本的特征向量看成是分布在特征空间中的一些点，点与点之间的距离即可作为相似性度量依据。</p><p>聚类方法目的：寻找数据中潜在的自然分组结构、感兴趣的关系。</p><p>聚类方法的有效性和数据分布形式有很大关系。</p><h2 id="距离度量">距离度量</h2><p>目的：度量同类样本间的相似性或不同样本间的差异性</p><h3 id="度量函数和度量空间">度量函数和度量空间</h3><h3 id="常用度量函数">常用度量函数</h3><p>闵可夫斯基距离</p><h2 id="聚类准则">聚类准则</h2><h3 id="类的定义">类的定义</h3><h3 id="试探方法">试探方法</h3><p>凭直观感觉或方法，针对实际问题定义一种距离度量的阈值，然后按最近邻规则制定某些样本属于一个聚类类别。</p><h3 id="聚类准则函数方法">聚类准则函数方法</h3><h2 id="聚类方法">聚类方法</h2><ul><li>基于试探的聚类搜索算法</li><li>系统聚类法</li><li>动态聚类法</li></ul><h3 id="基于试探的聚类搜索算法">基于试探的聚类搜索算法</h3><h4 id="按最近邻规则的简单试探法">按最近邻规则的简单试探法</h4><p>选用不同的阈值和起始点来试探。</p><p>依赖于以下因素：</p><ul><li>第一个聚类中心的位置</li><li>待分类样本的排序次序</li><li>距离阈值T的大小</li><li>样本分布的几何性质</li></ul><h4 id="最大最小距离算法">最大最小距离算法</h4><p>基本思想：以试探类间欧式距离为最大作为预选出聚类中心的条件。</p><ol type="1"><li>任选一个样本作为第一个聚类中心</li><li>选距离其最远的样本为第二个聚类中心</li><li>逐个计算各样本与两个聚类中心间距离，并选取其中较小值</li><li>在所有较小值中选出最大距离，若该最大值达到一定阈值，则选取相应样本点为迪桑聚类中心</li><li>重复3、4步，若无新聚类中心，进入下一步</li><li>不同样本按最近距离分到最近的聚类中心</li><li>最后，在每一类中计算各样本均值以得到更具代表性的聚类中心。</li></ol><h3 id="系统聚类法">系统聚类法</h3><p>基本思想：</p><p>将数据样本按距离准则逐步分类，类别有多到少，直到获得合适的分类要求为止。</p><h4 id="距离准则函数">距离准则函数</h4><ul><li>最短距离（两个集合所有距离最小值）</li><li>最长距离（两个集合所有距离最大值）</li><li>类平均距离（两个集合所有距离平均值）</li></ul><h3 id="动态聚类法">动态聚类法</h3><p>基本思想：</p><p>首先选择若干个样本点作为聚类中心，再按某种聚类准则使样本点向各中心聚集，从而得到初始聚类；然后判断初始分类是否合理，若不合理，则修改聚类，如此反复，直至合理。</p><p>代表算法：K-means算法和ISODATA算法（迭代自组织数据分析算法）</p><h4 id="k-means算法">K-means算法</h4><ol type="1"><li>选择一个聚类数量k</li><li>初始化聚类中心<ul><li>随机选择k个样本点，设置这些样本点为中心</li></ul></li><li>对每个样本点，计算样本点到k个聚类中心的距离，将样本点分距离它最近的聚类中心所属的聚类</li><li>重新计算聚类中心，聚类中心为属于这一聚类的所有样本的均值</li><li>如果没有发生样本所属的聚类改变的情况则退出，否则，返回第三步重复</li></ol><p>K-means算法的结果影响因素：</p><ul><li>所选聚类数目</li><li>聚类中心的初始分布</li><li>样本分布的几何性质</li></ul><p>在实际应用中，需要试探不同的K值和选择不同的聚类中心的起始值。</p><p>如果数据样本可以形成若干个相距较远的孤立区域分布，一般都能得到较好的收敛效果。</p><ul><li>K-means算法比较适合于分类数目已知的情况。</li></ul><h5 id="k-means">K-means++</h5><p>基本思想：K个初始聚类中心相互之间应该分得越开越好</p><ol type="1"><li>从数据集中随机选取一个样本作为初始聚类中心</li><li>首先计算每个样本与当前已有聚类中心之间的最短距离（即与最近的一个聚类中心的距离），用D(x)表示；接着计算每个样本被选为下一个聚类中心的概率<spanclass="math inline">\(\frac{D(x)^2}{\Sigma_{x\inX}D(x)^2}\)</span>，最后，按轮盘法选择下一个聚类中心</li><li>重复第2步选择出共K个聚类中心</li><li>K-means中第3步至第5步</li></ol><h4 id="迭代自组织数据分析算法-isodata">迭代自组织数据分析算法ISODATA</h4><p>基本步骤与思路：</p><ol type="1"><li>选择某些初始值，可选不同的参数，也可在迭代过程中人为修改，以将N个样本按指标分配到各个聚类中心去</li><li>计算各类中诸样本的距离指标函数</li><li>按给定的要求，将前一次获得的聚类集合进行分裂和合并处理，从而获得新的聚类中心</li><li>重新进行迭代运算，计算各项指标，判断聚类结果是否符合要求。经过多次迭代后，若结果收敛，则运算结束。</li></ol><p>具体过程（运行中能够根据各个类别的实际情况进行分裂和合并来调整聚类中心数）：</p><ol type="1"><li>从数据集中随机选取<spanclass="math inline">\(K_0\)</span>个样本作为聚类中心<spanclass="math inline">\(C=\{c_1,...,c_{K_0}\}\)</span></li><li>针对数据集中每个样本<spanclass="math inline">\(x_i\)</span>，计算它到<spanclass="math inline">\(K_0\)</span>个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中</li><li>判断上述每个类中的元素数目是否小于<spanclass="math inline">\(N_{min}\)</span>。如果小于<spanclass="math inline">\(N_{min}\)</span>则需要丢弃该类，令<spanclass="math inline">\(K=K-1\)</span>，并将该类中的样本重新分配给剩下类中距离最小的类</li><li>针对每个类别<spanclass="math inline">\(c_i\)</span>，重新计算它的聚类中心$c_i=_{xc_i}x</li><li>如果当前<spanclass="math inline">\(K\le\frac{K_0}{2}\)</span>，说明当前类别太少，前往分裂</li><li>如果当前<span class="math inline">\(K\ge2K_0\)</span>，说明当前类别太多，前往合并</li><li>如果达到最大迭代次数则终止，否则返回第2步继续执行</li></ol><p>合并</p><ol type="1"><li><p>计算当前所有类别聚类中心两两之间的距离，用矩阵D表示，其中<spanclass="math inline">\(D(i,i)=0\)</span></p></li><li><p>对于<span class="math inline">\(D(i,j)\lt d_{min}(i\neqj)\)</span>的两个类别需要进行合并操作，变成一个新的类，该类的聚类中心位置为<spanclass="math inline">\(m_{new}=\frac{1}{n_i+n_j}(n_im_i+n_jm_j)\)</span></p><p>上述<span class="math inline">\(n_i\)</span>和<spanclass="math inline">\(n_j\)</span>表示这两个类别中样本的个数，新的聚类中心可以看作对这两个类别进行加权求和。如果其中一个类所包含的样本个数较多，所合成的新类就会更加偏向它。</p></li></ol><ul><li><spanclass="math inline">\(d_{min}\)</span>：两个类别对应聚类中心之间所允许最小距<spanclass="math inline">\(d_{min}\)</span>，是否进行合并的阈值</li></ul><p>分裂</p><ol type="1"><li><p>计算每个类别下所有样本在每个维度下的方差</p></li><li><p>针对每个类别的所有方差挑选出最大的方差<spanclass="math inline">\(\sigma_{max}\)</span></p></li><li><p>如果某个类别的<span class="math inline">\(\sigma_{max}\gtSigma\)</span>并且该类别所包含的样本数量<spanclass="math inline">\(n_i\ge2n_{min}\)</span>，则可以进行分裂操作4，否则退出</p></li><li><p>将满足步骤3中的类分裂成两个子类别并令<spanclass="math inline">\(K=K+1\)</span></p><p><spanclass="math inline">\(m_i^{(+)}=m_i+\sigma_{max},m_i^{-}=m_i-\sigma_{max}\)</span></p></li></ol><ul><li>最大方差Sigma</li></ul><h4 id="两个算法的比较">两个算法的比较</h4><ul><li>K-means算法通常适合于类别数目已知的聚类，而ISODATA算法则更加灵活</li><li>从算法角度看，两者相似，聚类中心都是通过样本均值的迭代计算决定</li><li>ISODATA算法加入了一些试探步骤，并且可以结合人机交互的结构，使其能利用中间结果所取得的经验更好地进行分类</li><li>ISODATA原理直观，但需要更多参数，并且某些参数很难确定，因此ISODATA算法实际过程中并没有很受欢迎</li></ul><h2 id="聚类评价">聚类评价</h2><p>几个评价指标：</p><ul><li>聚类中心之间的距离</li><li>聚类域中的样本数目</li><li>聚类域内样本的距离方差</li></ul><p>聚类目前还没有一种通用的准则，往往需要根据实际应用来选择合适的方法。</p><h3 id="常用评价指标标签未知">常用评价指标（标签未知）</h3><h4 id="紧密度compactnesscp">紧密度（Compactness，CP）</h4><p><spanclass="math inline">\(\overline{CP}=\frac{1}{K}\Sigma_{k=1}^K\overline{CP_k}\)</span></p><p>缺点：没有考虑类间聚类效果。</p><h4 id="间隔度separationsp">间隔度（Separation，SP）</h4><p><spanclass="math inline">\(\overline{SP}=\frac{2}{k^2-k}\Sigma_{i=1}^k\Sigma_{j=i+1}^k||w_i-w_j||_2\)</span></p><p><span class="math inline">\(w_i\)</span>表示第i簇的中心，<spanclass="math inline">\(w_j\)</span>表示第j簇的中心，<spanclass="math inline">\(\overline{SP}\)</span>值越大类间越分散。</p><p>缺点：没有考虑类内聚类效果</p><h4 id="davies-bouldin-indexdbi分类适确性指标">Davies-BouldinIndex(DBI)，分类适确性指标</h4><p><span class="math inline">\(DB=\frac{1}{k}\Sigma_{i=1}^kmax_{j\neqi}(\frac{\overline{C_i}+\overline{C_j}}{||w_i-w_j||_2})\)</span></p><p><spanclass="math inline">\(\overline{C_i}\)</span>表示第i簇的紧密度，<spanclass="math inline">\(w_i\)</span>表示第i簇的中心。</p><p>DB越小，表示类内越紧凑，类间越分散，</p><p>缺点：使用欧式距离，对于环状分布聚类评价很差</p><h4 id="dunn-validity-indexdvi邓恩指数">Dunn ValidityIndex(DVI)，邓恩指数</h4><p>缺点：对离散点的聚类评价高，对环状分布评价效果差</p><h3 id="常用评价指标标签已知">常用评价指标（标签已知）</h3><ul><li>Cluster Accuracy，CA，聚类准确率</li><li>Rand Index，RI，兰德指数</li><li>Adjusted Rand Index，ARI，调整兰德指数</li><li>Mutual Information，MI，互信息</li><li>Normalized Mutual Information，NMI，归一化互信息</li></ul><h2 id="前沿进展">前沿进展</h2><p>监督深度学习：</p><ol type="1"><li>收集大量具有差异性的样本</li><li>对数据进行清洗和精细标注</li><li>采用多块显卡长时间训练</li></ol><p>监督深度学习的困境：</p><ul><li>数据体量大</li><li>数据标注时间长</li><li>数据标注代价高</li></ul><p>现实中，获取原始未标注数据较容易，而典型的监督学习技术不能利用这些数据；</p><p>监督信号有时候会使得深度模型有偏。</p><h3 id="自监督学习">自监督学习</h3><p>无监督学习的一种形式，其中数据没有提供（人类标注的）监督信息。</p><ul><li>通常需要定义一个前置任务让网络学习我们关心的事情。</li><li>对于大部分前置任务，我们需要保留一部分数据，让网络学会预测。</li><li>从前置任务学习到的特征会被用到不同的下游任务（通常包含标注）</li></ul><p>自监督预训练：</p><ul><li>无标注数据</li><li>前置任务预训练</li></ul><p>下游任务迁移：</p><ul><li>有标签数据</li><li>训练测试数据集可不同</li><li>多种下游任务测试</li></ul><h4 id="自监督学习分类">自监督学习分类</h4><ul><li>前置任务学习</li><li>对比学习</li><li>非对比学习</li></ul><h4 id="前置任务学习">前置任务学习</h4><ul><li><p>生成式方法——图像着色</p></li><li><p>生成式方法——图像修复</p></li><li><p>判别式方法——图像拼图</p></li></ul><h4 id="对比学习">对比学习</h4><h4 id="非对比学习">非对比学习</h4>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习_01_概率与学习-KNN</title>
    <link href="/2023/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%A6%82%E7%8E%87%E4%B8%8E%E5%AD%A6%E4%B9%A0-KNN/"/>
    <url>/2023/09/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/01_%E6%A6%82%E7%8E%87%E4%B8%8E%E5%AD%A6%E4%B9%A0-KNN/</url>
    
    <content type="html"><![CDATA[<p>两岸猿声啼不住，轻舟已过万重山。</p><span id="more"></span><h1 id="概率与学习-knn">概率与学习-KNN</h1><p>20230912</p><p>18:30-20:10</p><h2 id="大纲">大纲</h2><ol type="1"><li>回顾</li><li>k-近邻分类器</li><li>最近邻分类器</li><li>k-近邻回归</li><li>降低近邻计算</li><li>扩展阅读</li></ol><h2 id="回顾">回顾</h2><p>统计学角度：机器学习的目的是得到映射 <spanclass="math display">\[x\rightarrow y\]</span></p><p>对不同类型的数据用手工/自动的方式进行特征工程，得到特征向量。</p><p>分类问题</p><ul><li>训练集：<spanclass="math display">\[D_{train}=\{(x_1,y_1),(x_2,y_2),...,(x_n,y_n)\}\]</span></li><li>训练样本：<span class="math display">\[x_i\in X\in R^d\]</span></li><li>样本标签：<span class="math display">\[y_i\inY=\{1,2,...,C\}\]</span></li><li>测试集：<spanclass="math display">\[D_test=\{\bar{x}_1,\bar{x}_2...\bar{x}_m\}\]</span></li></ul><p>回归问题</p><ul><li>训练集：<spanclass="math display">\[D_{train}=\{(x_1,y_1),(x_2,y_2),...,(x_n,y_n)\}\]</span></li><li>训练样本：<span class="math display">\[x_i\in X\in R^d\]</span></li><li>样本标签：<span class="math display">\[y_i\in R\]</span></li><li>测试集：<spanclass="math display">\[D_test=\{\bar{x}_1,\bar{x}_2...\bar{x}_m\}\]</span></li></ul><p>距离度量</p><ul><li>欧式距离</li><li>余弦相似性</li><li>曼哈顿距离</li><li>切比雪夫距离</li><li>马氏距离</li></ul><h2 id="k-近邻分类器">k-近邻分类器</h2><p>k-Nearest Neighbor Classfier, k-NN</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择k个最近（距离最小/相似度最大）的训练样本</li><li>采用投票法，将近邻中样本数最多的类别标签分配给<spanclass="math inline">\(\bar{x}\)</span></li></ul><p>k的取值的影响</p><ul><li>k一般取奇数值，避免平局</li><li>k取不同的值，分类结果可能不同</li><li>k值较小时，对噪声敏感，整体模型变得复杂，容易过拟合</li><li>k值较大时，对噪声不敏感，整体模型变得简单，容易欠拟合</li></ul><h2 id="最近邻分类器">最近邻分类器</h2><p>1-Nearest Neighbor Classfier, 1-NN</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择最近（距离最小/相似度最大）的训练样本<spanclass="math inline">\(i^*=argmax d(\bar{x},x_i)\)</span></li><li>采用投票法，将<spanclass="math inline">\(x_{i^*}\)</span>的类别标签分配给<spanclass="math inline">\(\bar{x}\)</span></li></ul><p>泛化错误率</p><ul><li>最近邻分类器的泛化错误率（测试样本x，其最近邻为z）<ul><li><span class="math inline">\(P(error)=1-\Sigma_{c\iny}P(c|x)P(c|z)\)</span></li></ul></li><li>贝叶斯最优分类器的结果：<spanclass="math inline">\(2\times(1-P(c^*|x))\)</span></li></ul><p>最近邻分类器虽然简单，但泛化错误率不超过贝叶斯分类器的两倍。</p><h2 id="k-近邻回归">k-近邻回归</h2><p>k-Nearest Neighbor Regression</p><ul><li>计算测试样本<span class="math inline">\(\bar{x}\)</span>和<spanclass="math inline">\(D_{train}\)</span>中所有训练样本<spanclass="math inline">\(x_i\)</span>的距离<spanclass="math inline">\(d(\bar{x},x_i)\)</span></li><li>对所有距离值（相似度值）进行升序/降序排列</li><li>选择k个最近（距离最小/相似度最大）的训练样本</li><li>将距离值的倒数作为权重，将k个近邻的标签值加权平均，作为<spanclass="math inline">\(\bar{x}\)</span>的预测值</li></ul><p>近邻平滑：核平滑法（kernel smoother）</p><ul><li>二次核</li><li>次方核</li><li>高斯核</li></ul><h2 id="讨论">讨论</h2><ul><li><p>k-NN是典型的“懒惰学习”。</p><p>训练阶段仅仅是把样本保存起来，训练时间开销为零，待收到测试样本后再进行处理。</p></li><li><p>SVM、CNN等是“急切学习”。</p><p>在训练阶段就对样本进行学习处理的方法，这类方法尝试在训练期间构造一个通用的与输入无关的目标函数。</p></li></ul><p>k-近邻分类器的优缺点</p><ul><li>优点<ul><li>精度高</li><li>对异常值不敏感</li><li>无数据输入假定</li></ul></li><li>缺点<ul><li>计算复杂度高</li><li>空间复杂度高</li></ul></li></ul><p>时间复杂度</p><ul><li>假设<spanclass="math inline">\(d(x_i,x_j)\)</span>是欧式距离，时间复杂度为<spanclass="math inline">\(O(d)\)</span></li><li>训练阶段：0</li><li>测试阶段：<span class="math inline">\(O(nd+nlogk)\)</span><ul><li>从n个数中选择k个最小的，时间复杂度为<spanclass="math inline">\(nlogk\)</span></li></ul></li><li>空间复杂度是？</li></ul><h2 id="降低计算">降低计算</h2><ul><li>特征维度2-5：维诺图</li><li>特征维度6-30：KD-Tree</li><li>特征高维：<ul><li>降维算法，如主成分分析（Principle Component Analysis）PCA</li><li>近似最近邻（approximate nearest neighbor, ANN）</li><li>哈希（hashing）</li></ul></li></ul><h3 id="维诺图">维诺图</h3><p>根据一组给定的目标，将一个平面划分成靠近每一个目标的多个区块。</p><ul><li><p>维诺图由一系列维诺单元组成，每个维诺单元是一个凸多面体</p><ul><li><p>假设X是一个点集，包含K个基点<spanclass="math inline">\((P_k)_{k\in K}\)</span>，那么维诺单元<spanclass="math inline">\(R_k\)</span>定义为：</p><p><span class="math inline">\(R_k=\{x\in X|d(x,P_k)\le d(x,P_j),\forallj\neq k\}\)</span></p></li></ul></li><li><p>查询或测试：给定一个查询<span class="math inline">\(q\inR^d\)</span>，找到<span class="math inline">\(P_k\inX\)</span>，使得<span class="math inline">\(q\in R_k\)</span></p></li><li><p>时间复杂度：</p><ul><li>2维数据：<spanclass="math inline">\(O(nlogn)\)</span>用来计算维诺图；</li><li>d维数据：使用二叉空间分割树进行点的定位，但是时间估计困难，难以量化</li></ul></li><li><p>适用范围：1-NN</p></li><li><p>适合特征维度：2～3维，可能4～5维</p></li></ul><h3 id="kd树">KD树</h3><p>KD树是一种对K维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。</p><p>KD树是二叉树，表示对K维空间的一个划分，构造KD树相当于不断用垂直于坐标轴的超平面将K维空间切分，构成一系列K维超矩形区域。KD树的每个结点对应于一个K维超矩形区域。</p><p>构造流程：</p><ol type="1"><li>确定split域。计算每个特征维度的方差，选定方差最大维度为split域。</li><li>确定Node-data域。</li><li>对剩下的数据点进行划分，确定左右子空间。</li><li>递归。在每个子空间继续进行空间划分，直到空间中只包含一个数据点。</li></ol><p>KD树搜索</p><ol type="1"><li>二叉搜索</li><li>回溯分析</li><li>返回最近邻</li></ol><p>时间复杂度</p><ul><li><p>寻找最近邻的时间复杂度为<spanclass="math inline">\(O(logn)\)</span></p></li><li><p>找到中位数的算法时间复杂度为<spanclass="math inline">\(O(n)\)</span></p></li><li><p>KD树搜索时间复杂度为<spanclass="math inline">\(O(nlogn)\)</span></p></li></ul><h3 id="降维">降维</h3><p>核心思想：通过某种数学变换将原始高维属性空间转变为一个低维子空间，来缓解维数灾难问题。</p><ul><li>多维缩放</li><li>主成分分析</li><li>局部线性潜入</li><li>ISOMAP</li></ul><h3 id="近似最近邻">近似最近邻</h3><p>核心思想：搜索可能是最近邻的数据项而不再只限于返回最可能的数据项，在牺牲可接受范围内的精度的情况下提高检索效率。</p><ul><li>不要求一定是距离最短的k个</li><li>如第k个最近邻，其距离为<spanclass="math inline">\(d_k\)</span>，则ANN要求其选取的所有k个样例的距离<spanclass="math inline">\(\hat{d}\le(1+\varepsilon)d_k\)</span></li><li>可以将k-NN搜索速度提高几个数量级</li></ul><p>FLANN：https://github.com/mariusmuja/flann</p><h3 id="哈希">哈希</h3><p>核心思想：利用哈希函数把任意长度的输入映射为固定长度的输出</p><h2 id="扩展阅读">扩展阅读</h2><h3 id="概率化k-nn">概率化k-NN</h3><p>通过定义似然函数来构造概率化的k-NN。</p><p>https://www.cc.gatech.edu/~afb/classes/CS7616-Spring2014/slides/CS7616-13a-PKNN.pdf</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_6_软件系统</title>
    <link href="/2023/09/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/6_%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/09/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/6_%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第六章-嵌入式软件系统">第六章 嵌入式软件系统</h1><h2 id="概述">1. 概述</h2><h3 id="嵌入式软件与桌面软件的对比">嵌入式软件与桌面软件的对比</h3><p>内存：有限</p><p>CPU：往往只是恰好满足要求</p><p>操作系统：Windows、Linux、RTOS、专有操作系统、裸机</p><p>实时行为：可预测、实时性</p><p>开发流程：资源少，交叉开发；代码需要在特定环境下运行</p><p>执行流程：多数嵌入式设备自开启起就会持续运行某个程序至系统关机</p><ul><li>该程序可能存储在ROM，也可能是从非易失性存储器转移到RAM中执行。</li></ul><p>每个嵌入式设备都不同：</p><ul><li>技术层面：不同的CPU架构、内存、外设、应用程序和操作系统。</li><li>商业运作层面的，比如手机开发、生产的商业模式就和核磁共振扫描仪完全不同。</li></ul><p>软件组件：适合嵌入式环境的库；与硬件交互的接口；网络支持；数据存储；GUI</p><h3 id="软硬件权衡">软硬件权衡</h3><p>软件主导硬件，有关硬件的决策会对软件产生影响。</p><p>软硬件可能是不同团队进行开发。</p><ul><li>微处理器的选择：可能影响软件效率</li><li>内存大小和组合</li><li>包含的外设</li></ul><h3 id="调试">调试</h3><p>在线仿真器ICE（In-Circuit Emulator）</p><ul><li><p>模拟CPU的功能，可以完全仿真芯片的行为</p></li><li><p>价格昂贵，难以普及，没有广泛使用</p></li></ul><p>监控调试器</p><ul><li><p>需要通信通道</p></li><li><p>因为占用系统资源的问题，在一些严格的场合下不适合使用</p></li></ul><p>片上调试</p><ul><li><p>例如，JTAG是边界扫描测试的一个标准协议，SWD（Serial WireDebug）仿真器</p></li><li><p>价格便宜，易于实现</p></li><li><p>广泛使用</p></li></ul><h3 id="自检">自检</h3><p>输入/输出电路</p><p>板载开关：用于配置或模式选择</p><p>状态显示：字符或LED（3种状态：开、关、闪烁）</p><h3 id="软件系统层次结构">软件系统层次结构</h3><figure><img src="/image/嵌入式系统概论/软件系统层次结构.png"alt="软件系统层次结构" /><figcaption aria-hidden="true">软件系统层次结构</figcaption></figure><h3 id="可视化程序模型">可视化程序模型</h3><p>将实时应用视为单个/多个执行线程</p><h4 id="单线程程序模型">单线程程序模型</h4><p>优点：</p><ul><li><p>编程和再编程非常快速简单</p></li><li><p>改变系统响应特性的同时，往模型上添加新功能插件也相当容易</p></li></ul><p>缺点：</p><ul><li><p>在于应用领域的限制</p></li><li><p>难以做到安全地再编程</p></li><li><p>很难应用到不同行为或不同环境的运行系统中去</p></li></ul><h4 id="多线程程序模型">多线程程序模型</h4><p>优点：</p><ul><li><p>允许将系统工作划分为几个逻辑阶段，然后编写相互独立的程序来处理各自的工作</p></li><li><p>所有处理过程并行</p></li><li><p>如果有更高吞吐量的需求，工程师可以在任务中引入新的通信和协作模型</p></li></ul><p>缺点：可能引入资源竞争</p><h4 id="建立模型的好处">建立模型的好处</h4><p>辅助测试和完善最终系统。</p><p>模型利用它所知的系统属性来描述整个系统，并能够被用于对系统特性的进一步研究。</p><p>使用程序模型开发软件和硬件，便于将整个实时系统全盘考虑。</p><p>模型使得工程师能够预测程序的运行，从而满足系统的性能需求和功能需求。</p><h4 id="模型之间的差异">模型之间的差异</h4><p>一些模型易于编写，但调试不易；一些模型难于编写，但调试容易。</p><p>一些模型使得程序运行得更快，但需要付出更多内存资源消耗的代价。</p><p>模型准确性与鲁棒性。</p><h2 id="设计模式">2. 设计模式</h2><h3 id="嵌入式软件架构模式">嵌入式软件架构模式</h3><p>分为业务逻辑与实时依赖硬件的逻辑，抽象层将所需操作的高级请求转换为低级命令。<imgsrc="/image/嵌入式系统概论/嵌入式软件架构.png"alt="嵌入式软件架构" /></p><p>对于基于微控制器的系统来说，最常用的架构模式有：</p><ul><li>非结构化单体架构</li><li>分层架构</li><li>事件驱动架构</li><li>微服务架构</li></ul><h4 id="非结构化单体架构">非结构化单体架构</h4><p>应用和与之相连的多个模块，模块之间也可以相互连接</p><ul><li>容易构建，难以维持规模和移植</li><li>与应用层的应用程序紧密耦合</li></ul><h4 id="分层架构">分层架构</h4><p>将应用程序的逻辑划分为若干独立的层，仅通过定义良好的抽象层进行交互。</p><ul><li><p>试图通过将应用程序分解为独立的层来改善非结构化单体架构的高耦合性。</p></li><li><p>最常用。</p></li><li><p>例：应用层、中间件层、操作系统层、驱动层、硬件层</p></li></ul><h4 id="事件驱动架构">事件驱动架构</h4><p>利用中断来立即响应事件。</p><ul><li>事件驱动的体系结构通常使用消息队列、信号量和事件标志来表示系统中发生了事件。</li><li>对于实时嵌入式应用程序和与能耗相关的应用程序非常有意义。</li><li>优点：可扩展、软件模块高内聚、低耦合。</li><li>缺点：无论何时需要做任何事，都有额外的开销和复杂性。</li></ul><h4 id="微服务架构">微服务架构</h4><p>将应用程序构建为为业务领域开发的小型自治服务的集合。</p><ul><li><p>微服务本质上是低耦合的，这使得它易于维护、可测试，可以快速扩展或移植。</p></li><li><p>微服务是围绕系统的业务逻辑组织的。</p><ul><li>业务逻辑：系统行为的业务规则和用例。</li></ul></li><li><p>缺点：</p><ul><li>在架构上，增加设计的复杂性；</li><li>由于具有其他体系结构中可能不需要的通信特性，它们可能会增加额外的开销和内存需求；</li><li>架构的分散性也意味着实时的、确定性的行为可能更具挑战性，实时和响应可能有额外的抖动；</li><li>可能会增加开发时间和预算。</li></ul></li></ul><h4 id="微内核架构microkernel-architecture">微内核架构，MicrokernelArchitecture</h4><p>也称插件化(Plug-in)架构，是一种面向功能拆分的可扩展架构。</p><ul><li>包含核心系统和插件模块。</li><li>具备模块化解耦、弹性部署的能力以及安全稳定的特性，非常符合物联网的发展。</li><li>进程间通信性能相对较低。</li></ul><h3 id="管理外设数据">管理外设数据</h3><p>轮询、中断、直接存储器访问（DMA）</p><h4 id="外设轮询">外设轮询</h4><p>让应用程序定期轮询外设，查看是否有任何数据可供管理和处理。</p><ul><li>优先级：无，按顺序运行</li><li>响应时间：所有任务的总和</li><li>变化的影响：修改任务的执行时间或添加任务会影响所有其他任务</li><li>优点：简单，没有共享数据问题</li><li>缺点：浪费处理周期；在处理外设时可能会有很多抖动和延迟</li></ul><h4 id="有限状态机">有限状态机</h4><p>只执行当前状态，每个状态决定下一个状态（非顺序执行）。</p><ul><li>优先级：每个状态决定下一个状态的优先级</li><li>响应时间：所有任务的总和</li><li>变化的影响：修改任务的执行时间或添加任务会影响所有其他任务</li><li>同样没有共享数据问题</li></ul><h4 id="中断设计模式">中断设计模式</h4><p>中断应用程序的正常流程，以允许中断处理程序运行代码来处理系统中发生的事件。</p><p>当设计ISR时，我们希望中断尽可能快地运行（最小化中断）。</p><ul><li><p>避免内存分配操作，如声明非静态变量、操作堆栈或使用动态内存</p></li><li><p>尽量减少函数调用，以避免时钟周期开销、不可重入函数或阻塞函数的问题</p></li></ul><h5 id="带有中断的轮询">带有中断的轮询</h5><ul><li><p>优先级：中断优先于主循环，中断的优先级</p></li><li><p>反应时间：所有任务的总和或中断执行时间</p></li><li><p>变更的影响：对中断服务例程的影响较小。与主循环的轮询相同。</p></li><li><p>共享数据：必须处理与中断服务例程共享的数据</p></li><li><p>优势：</p><ul><li><p>不需要浪费CPU周期来检查数据是否准备好</p></li><li><p>获取数据的延迟是确定的</p></li><li><p>抖动被最小化</p></li></ul></li><li><p>缺点：</p><ul><li>中断的设置可能比较复杂</li><li>必须小心不要使用频繁触发的中断</li><li>当使用中断来接收数据时，开发人员必须仔细管理他们在ISR中所做的工作。开发人员经常需要使用ISR来处理所需的即时操作，然后将处理和非紧急的工作卸载给应用程序，从而增加了软件设计的复杂性。</li></ul></li></ul><h5id="数据获取存储相关的中断设计模式">数据获取/存储相关的中断设计模式</h5><ul><li>线性数据存储</li><li>双缓冲区</li><li>环形/循环缓冲区</li><li>带有信号量的循环缓冲区</li><li>带有事件标志的循环缓冲区</li><li>消息队列</li></ul><p>线性数据存储：</p><ul><li><p>中断服务程序可以直接访问共享内存位置</p></li><li><p>线性数据存储可能是危险的：</p><ul><li>线性数据存储是经常遇到竞态条件的地方</li><li>用于存储应用程序和ISR之间的数据的共享变量也需要声明为volatile，以防止编译器优化</li></ul></li><li><p>数据存储必须由互斥锁保护，以防止竞态条件</p></li></ul><p>双缓冲区：可以缓解数据存储的一些竞态条件问题。</p><p>环形缓冲区：</p><p>环形缓冲区（Circular Buffer），也被称为循环缓冲区（CyclicBuffer）或者环形队列（RingBuffer），是一种数据结构类型，它在内存中形成一个环形的存储空间。</p><ul><li><p>特点：终点和起点相连形成一个环状结构。</p></li><li><p>在处理流数据和实现数据缓存等场景中具有广泛的应用。</p></li><li><p>在中断中接收到的实时数据可以从外设中移除并存储在循环缓冲区中。因此，中断可以尽可能快地运行，同时允许应用程序代码自行处理循环缓冲区。使用循环缓冲区有助于确保数据不丢失，中断速度快，合理地处理数据。</p></li></ul><p>带有通知的循环缓冲区：</p><ul><li>应用程序需要轮询缓冲区以查看是否有新的可用数据。<ul><li>信号量和事件标志</li></ul></li><li>在大多数实时操作系统中，使用事件标志比使用信号量更有效。</li></ul><p>消息队列：</p><ul><li><p>类似于使用带有信号量的线性缓冲区。</p></li><li><p>通常需要更多的RAM、ROM和处理能力。</p></li></ul><h4 id="dma">DMA</h4><p>无需CPU的交互情况下在RAM和外设之间以及内部传输数据。</p><ul><li><p>RAM到RAM</p></li><li><p>外设到RAM</p></li><li><p>外设到外设</p></li></ul><p>DMA控制器可以显著提高外设和应用程序之间的数据吞吐量。此外，可以利用DMA控制器减轻CPU运行ISR来传输数据的负担，并最大限度地减少浪费的计算周期。</p><h3 id="实时嵌入式软件常用设计模式">实时嵌入式软件常用设计模式</h3><p>单核</p><p>多核</p><p>发布和订阅模型</p><p>RTOS模式</p><p>处理中断和低功耗设计</p><h4 id="多核架构">多核架构</h4><p>同构多核，对称多核处理具有相同处理器架构的两个核。</p><p>异构多核架构，每个处理核心都有不同的底层架构。</p><h4 id="发布和订阅模型">发布和订阅模型</h4><p>在物联网领域广泛使用，ROS也使用。</p><ul><li>在许多情况下，物联网设备将启动电源，连接到云，然后订阅它想要接收的消息主题。该设备甚至还可以发布特定的主题。</li></ul><p>缺点：会导致应用程序占用更大的内存。</p><h4 id="rtos应用程序设计模式">RTOS应用程序设计模式</h4><p>资源同步：对共享资源的访问是否安全</p><ul><li>确保需要访问资源的多个任务或中断协调进行，避免竞争条件和内存损坏。</li><li>可以通过三种方式处理资源同步：中断锁、抢占锁和互斥锁。<ul><li>中断锁：禁用中断以在任务和中断之间提供资源同步</li><li>抢占锁：在临界区期间临时禁用RTOS内核抢占调度程序</li><li>互斥锁：通过创建一个对象来保护临界区，该对象的状态可以被检查，以确定是否可以安全访问共享资源，其唯一目的是为共享资源提供互斥</li><li>中断锁禁用系统中断，可能导致问题；抢占锁不禁用系统中断，但禁止内核抢占；互斥锁两者都不禁用。</li></ul></li></ul><p>活动同步：决定执行是否已达到特定状态</p><ul><li><p>单向同步（任务对任务）：使用二值信号量或事件标志来同步任务。</p></li><li><p>单向同步（中断到任务）：ISR给出信号量或事件标志后，继续执行直到完成为止。</p></li><li><p>双向同步：两个任务在它们之间的两个方向上进行协调。</p></li></ul><h4 id="广播设计模式">广播设计模式</h4><p>允许多个任务阻塞，直到给定信号量、出现事件标志，甚至将消息放入消息队列。</p><p>任务或ISR可以提供由多个任务使用的二值信号量广播。广播可能无法在所有实时操作系统中实现，必须检查RTOS是否支持。</p><ul><li>如果不支持广播，则可以创建由任务或中断给出的多个信号量。从设计的角度来看，使用多个信号量并不优雅，从实现的角度来看也不高效，但有时在软件中就是这样。</li></ul><h4 id="低功耗应用程序设计模式">低功耗应用程序设计模式</h4><p>关于低功耗设计模式，主要模式是尽可能地保持设备关闭。</p><ul><li>事件驱动中，事件之间没有实际工作要做时，应该将微控制器置于适当的低功耗状态，并关闭任何非必要的电子设备</li><li>除非发生唤醒事件，否则系统处于低功耗状态</li><li>实际工作完成后，系统恢复到低功耗状态</li></ul><p>建议：使用内置tickless模式的RTOS，或者扩展系统tick以使微控制器休眠更长时间</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_5_I/O与总线</title>
    <link href="/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/5_IO%E4%B8%8E%E6%80%BB%E7%BA%BF/"/>
    <url>/2023/09/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/5_IO%E4%B8%8E%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第五章-io与总线">第五章 I/O与总线</h1><h2 id="设备分类">1. 设备分类</h2><h3 id="按从属分类">按从属分类</h3><p>系统设备：操作系统启动时已注册的标准设备</p><ul><li>操作系统中有设备驱动程序和管理程序，例如闪存，触摸面板</li></ul><p>用户设备：操作系统启动时未注册的非标准设备</p><ul><li>设备驱动程序由用户提供，例如SD卡、U盘</li></ul><h3 id="按使用分类">按使用分类</h3><p>专用设备：同一时间只能被一个进程使用。</p><p>共享设备：可被多个进程同时寻址。</p><p>虚拟设备：通过虚拟技术将一台独占设备虚拟成多台逻辑设备供多个用户进程同时使用。</p><h3 id="按特征分类">按特征分类</h3><p>存储设备</p><p>输入/输出设备</p><ul><li>通常由机械部件和电子部件组成，电子部分称为设备控制器或适配器</li></ul><h3 id="按信息传输单元分类">按信息传输单元分类</h3><p>块设备：以块为单位组织和交换数据，是结构化设备，例如硬盘。</p><p>字符设备：以字符为单位组织和交换数据，是非结构化设备，例如串口、打印机。</p><ul><li>基本特征是传输速率低且不可寻址，执行输入/输出操作时经常使用中断。</li></ul><h2 id="输入输出">2. 输入/输出</h2><p>输入/输出接口需要多个寄存器：</p><ul><li>数据寄存器</li><li>控制寄存器</li><li>状态寄存器</li></ul><h3 id="可编程io">可编程I/O</h3><p>通信过程中选择控制寄存器或数据缓冲区的三种方法：</p><ul><li><p>独立I/O端口</p></li><li><p>内存映射I/O</p></li><li><p>混合解决方案，混合模型包括内存映射I/O数据缓冲区和用于控制寄存器的独立I/O端口</p></li></ul><p>Intel x86提供了in、out指令，大多数其他cpu使用内存映射I/O。</p><h4 id="独立io端口">独立I/O端口</h4><p>优点：</p><ul><li>I/O独立编址，不占用内存</li><li>使用I/O指令，程序清晰，很容易看出是I/O操作还是存储器操作</li><li>译码电路比较简单（I/O端口的地址空间较小，所用地址线较少）</li></ul><p>缺点：只能用专门I/O指令，访问端口办法少</p><h4 id="内存映射io">内存映射I/O</h4><p>优点：</p><ul><li><p>在内存映射I/O模式中，设备控制寄存器只是内存中的变量，可以像其他变量一样在C语言中寻址。因此，I/O设备驱动程序可以完全用C语言编写。</p></li><li><p>在这种模式下，不需要特殊的保护机制来阻止用户进程执行I/O操作。</p></li></ul><p>缺点：</p><ul><li><p>目前大多数嵌入式处理器都支持内存缓存。缓存设备控制寄存器会导致灾难。为了防止这种情况，必须为硬件提供选择性禁用缓存的功能，这将增加嵌入式系统中硬件和软件的复杂性。</p></li><li><p>如果只有一个地址空间，所有内存模块和所有I/O设备必须检查所有内存引用，以决定响应哪一个，这将严重影响系统性能。</p></li></ul><h3 id="忙等io">忙等I/O</h3><p>使用指令测试设备忙闲。</p><p>缺点：低效</p><ul><li>CPU在测试设备时不能做其他工作</li><li>很难同时进行输入/输出</li></ul><h3 id="中断io">中断I/O</h3><p>中断允许设备改变CPU中的控制流，调用子例程来处理设备。</p><ul><li>行为：基于子程序调用机制，强制下一条指令为预定义地址的子程序调用</li></ul><h4 id="中断的物理接口">中断的物理接口</h4><ul><li>CPU与设备通过CPU总线连接</li><li>CPU与设备握手</li><li>设备发出中断请求</li><li>CPU在能够处理中断时确认中断</li></ul><h4 id="优先级与向量">优先级与向量</h4><p>优先级：决定哪些中断首先得到CPU</p><ul><li>屏蔽：在挂起的中断完成之前，不会识别低于当前优先级的中断。</li><li>不可屏蔽中断NMI，最高优先级，不会被屏蔽，通常用于断电。</li></ul><p>向量：决定每种类型的中断调用什么代码</p><ul><li>中断向量表</li></ul><h4 id="中断序列">中断序列</h4><ol type="1"><li>CPU确认请求</li><li>设备发送向量</li><li>CPU调用中断处理程序</li><li>软件处理请求</li><li>CPU恢复前台程序状态</li></ol><h4 id="中断开销">中断开销</h4><p>中断处理程序执行时间</p><p>中断机制开销</p><p>寄存器保存/恢复</p><p>流水线相关的开销</p><p>缓存相关的开销</p><h4 id="中断设计">中断设计</h4><p>中断服务处理，Interrupt Service Routines，ISR</p><p>基本原则是保持处理程序简短（时间上）。</p><ul><li>避免循环和冗长复杂的指令。</li><li>尽快重新启用中断，先做硬件关键和不可重入的事情，然后执行中断启用指令。</li><li>预计花费时间和复杂度。</li></ul><p>C语言和汇编语言：</p><ul><li>汇编语言的花费时间易于估计，C语言难以估计</li><li>但是尽量使用C语言</li></ul><h4 id="调试intinta周期">调试INT/INTA周期</h4><ol type="1"><li><p>设备硬件产生中断脉冲</p></li><li><p>中断控制器(如果有的话)以优先级处理多个同时发生的请求，并向处理器发出单个中断</p></li><li><p>CPU响应一个中断确认周期</p></li><li><p>控制器在总线上发出一个中断向量</p></li><li><p>CPU读取向量并计算向量所指向的内存中的地址，然后获取这个值</p></li></ol><h4 id="查找丢失的中断">查找丢失的中断</h4><p>可以使用单个上行/下行计数器构建一个小电路，该计数器对每个中断进行计数，并减少每个中断确认的计数。如果计数器总是显示0或1的值，则一切正常。</p><p>一个经验法则将帮助最小化丢失的中断：在最早的安全点重新启用ISR中的中断。</p><h4 id="避免nmi">避免NMI</h4><p>NMI（不可屏蔽的中断）用于电源故障、系统关闭和即将发生的灾难，定时器或UART中断不是。</p><p>NMI甚至会破坏编码良好的中断处理程序，因为大多数isr在服务硬件的前几行代码中都是不可重入的。NMI也会阻碍堆栈管理工作。</p><p>NMI与大多数工具的混合效果很差。调试任何ISR-NMI或其他方式都是令人恼火的。很少有工具能很好地在ISR内单步执行和设置断点。</p><h4 id="断点问题">断点问题</h4><p>虽然断点确实是很棒的调试辅助工具，但是对于嵌入式代码是具有不确定性的。</p><p>使用实时trace，这是所有仿真器和一些智能逻辑分析仪都具有的功能。</p><h4 id="可重入">可重入</h4><p>例程必须满足以下条件才能重入:</p><ul><li><p>以原子方式使用所有共享变量，除非将每个共享变量分配给函数的特定实例</p></li><li><p>不调用不可重入的函数</p></li><li><p>不以非原子的方式使用硬件</p></li></ul><p>原子指不能被中断的操作。</p><p>消除不可重入代码的办法：</p><ul><li><p>避免共享变量。</p><p>全局变量是没完没了的调试问题和代码失败的根源。使用自动变量或动态分配内存。</p></li><li><p>在不可重入代码期间禁用中断。</p></li><li><p>信号量。</p></li></ul><h4 id="竞态条件">竞态条件</h4><p>设备或系统出现不恰当的执行时序，而得到不正确的结果。</p><p>参考计算机操作系统：进程的同步和互斥问题。</p><h2 id="总线">2. 总线</h2><p>总线是计算机各种功能部件之间传送信息的公共通信干线。</p><ul><li>一组传送线路 + 相关通信协议</li></ul><h3 id="总线协议">总线协议</h3><p>总线协议决定设备如何通信。</p><ul><li>协议由状态机指定，协议中的每个参与者都有一个状态机。</li><li>总线上的设备经历一系列的状态。</li><li>可包含异步逻辑行为。</li></ul><h3 id="系统总线配置">系统总线配置</h3><p>多总线允许并行：一个总线连接慢速设备，另一个独立总线连接高速设备。</p><p>桥连接两个总线。</p><p>常用总线：</p><figure><img src="/image/嵌入式系统概论/常用总线.png" alt="常用总线" /><figcaption aria-hidden="true">常用总线</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_4_存储器架构</title>
    <link href="/2023/09/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/4_%E5%AD%98%E5%82%A8%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/09/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/4_%E5%AD%98%E5%82%A8%E5%99%A8%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第四章-存储器架构">第四章 存储器架构</h1><h2 id="存储系统">1. 存储系统</h2><h3 id="存储系统-1">存储系统</h3><p>对许多应用来说，存储系统对整个系统性能的影响比对数据流水线的影响更大。</p><p>复杂性：在同一个嵌入式系统中，通常需要组合各种存储技术</p><ul><li>至少需要一些非易失性存储和一些易失性存储</li></ul><p>层次结构往往是必须的。</p><p>处理器架构的地址空间被分解成若干子空间来提供不同类型的存储器访问。</p><h3 id="易失性存储器">易失性存储器</h3><p>断电时内容消失的存储器。</p><p>随机存取存储器，RAM</p><ul><li>静态RAM，SRAM：速度快，面积大</li><li>动态RAM，DRAM：保持数据的时间很短，需要定期刷新；比SRAM更不稳定</li></ul><p>大多数嵌入式系统都包括一个SRAM，许多ES也会包括DRAM。</p><ul><li>只利用SRAM不能提供足够大的存储容量</li></ul><p>影响程序执行时间的因素</p><ul><li><p>被访问的存储器地址是映射到SRAM还是DRAM</p></li><li><p>DRAM可能在忙于刷新时被请求访问，因此DRAM刷新周期会引起访问时间的变化</p></li><li><p>访问历史也会影响存取时间</p></li></ul><h3 id="非易失性存储器">非易失性存储器</h3><p>不需要持续供电来保留存储在计算设备中的数据或程序代码。</p><ul><li><p>只读存储器ROM，或掩模ROM（MashROM）：内容在芯片工厂就已经固定</p></li><li><p>电可擦除可编程ROM，EEPROM</p></li><li><p>快闪存储器（Flash）</p></li><li><p>磁盘存储器</p></li></ul><h3 id="固件">固件</h3><p>固件（firmware）一般存储于设备中的电可擦除只读存储器或FLASH芯片中，一般可由用户通过特定的刷新程序进行升级。</p><p>可固化（ROMable）：可被编程到ROM芯片中的机器语言。作为“只读”芯片不能更新，可固化程序必须使用RAM或磁盘来保存变化的数据。</p><ul><li><p>代码将从ROM正确执行：不需要复制到RAM，但是RAM可能更快</p></li><li><p>代码和数据不能混用，除了常量数据</p></li></ul><h3 id="flash">Flash</h3><p>读取快于一般ROM，慢于RAM。</p><p>写入时间大大超过读取时间，且写入次数有限。</p><ul><li><p>SLC：速度快，存储密度低，稳定性好，成本高，约10万次擦写寿命，多用于高端企业级产品</p></li><li><p>MLC：速度一般，成本一般，约3000—10000次擦写寿命，应用于中高端SSD</p></li><li><p>TLC：速度慢，成本最低，约1000次擦写寿命</p></li></ul><p>类型：</p><ul><li><p>NOR：块擦除；擦除和写入时间较长，但能够像RAM那样访问</p></li><li><p>NAND：以块为单位；擦除和写入速度比较快；按页读取</p></li></ul><figure><img src="/image/嵌入式系统概论/Flash.png" alt="Flash" /><figcaption aria-hidden="true">Flash</figcaption></figure><h2 id="存储器层次结构">2. 存储器层次结构</h2><p>精确的分层机构取决于技术参数，也取决于应用领域</p><ul><li><p>处理器寄存器</p></li><li><p>工作存储器（或主存储器、主存）：实现了处理器存储地址所涵盖的存储器。通常，其容量在几MB到几GB之间，并且是易失的</p></li><li><p>缓冲存储器:高速缓存、地址转换高速缓存（TLB）以及暂存存储器（SPM）。</p></li><li><p>flash、磁盘等非易失性存储，也可基于互联网的存储器解决方案（如云）。</p></li></ul><h3 id="cache">Cache</h3><p>高速缓存的架构对应用程序的执行时间具有很大影响。</p><ul><li>潜在地提高了存储系统的能效。</li><li>设计时预测缓存是否命中很困难，这对实时性能的精确预测也是负担。</li><li>多级Cache</li></ul><h3 id="暂存存储器">暂存存储器</h3><p>SPM，也叫紧耦合内存TCM。</p><ul><li>SPM和主存统一编址，每当某个简单的地址解码器给出一个SPM地址范围内的地址时，SPM就被访问。</li><li>SPM通常和处理器集成在一个芯片上。</li><li>功耗低、速度快。</li></ul><h3 id="存储器访问时间难以预测">存储器访问时间难以预测</h3><p>虚拟存储器：使各种存储技术看起来是一个连续的地址空间</p><p>地址转换：把地址空间的逻辑地址转换成一种存储技术上的物理地址</p><ul><li>转换通常是由转换后备缓冲器（Translation LookasideBuffer，TLB）协助完成</li></ul><p>很难预测或理解访问存储器的时间需要多久，因而嵌入式系统设计人员通常比一般程序员需要更深入地理解存储器系统</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_3_微处理器</title>
    <link href="/2023/09/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/3_%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2023/09/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/3_%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第三章-嵌入式微处理器">第三章 嵌入式微处理器</h1><p>Embedded Microprocessor</p><h2 id="嵌入式系统硬件">1. 嵌入式系统硬件</h2><p>包含CPU、总线、存储器、输入/输出设备</p><p>常见微处理器：</p><ul><li>ARM</li><li>MIPS</li><li>PowerPC</li><li>X86</li></ul><h3 id="冯诺伊曼结构">冯诺伊曼结构</h3><ul><li>将程序指令存储器和数据存储器合并在一起的存储器结构</li><li>程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同</li><li>CPU寄存器: 程序计数器(PC)，指令寄存器(IR)，通用寄存器等。</li></ul><h3 id="哈佛结构">哈佛结构</h3><p>明显的特点：</p><ul><li><p>使用两个独立的存储器模块，分别存储指令和数据</p><p>每个存储模块都不允许指令和数据并存</p></li><li><p>使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，这两条总线之间毫无关联</p></li></ul><p>改进的哈佛结构，其结构特点为：</p><ul><li>使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存;</li><li>具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块(程序存储模块和数据存储模块)，公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输</li><li>两条总线由程序存储器和数据存储器分时共用</li></ul><p>大多数数字信号处理器（DSP）使用哈佛架构来处理流数据：</p><ul><li>更大的内存带宽</li><li>更可预测的带宽</li></ul><h3 id="risc和cisc">RISC和CISC</h3><ul><li>复杂指令集计算机，Complex instruction set computer，CISC<ul><li>多种寻址模式</li></ul></li><li>精简指令集计算机，Reduced instruction set computer，RISC<ul><li>流水线指令</li><li>访存指令只有load/store</li></ul></li></ul><h4 id="risc-v">RISC-V</h4><ul><li>简单、完全开源并且免费</li><li>将基准指令和扩展指令分开，可以通过扩展指令做定制化的模块和扩展<ul><li>RISC-V的基准指令集确定后将不会变化，这是RISC-V稳定性的重要保障</li></ul></li></ul><h4 id="设计系统芯片需要考虑">设计系统芯片需要考虑</h4><ul><li>成本</li><li>生态系统</li><li>碎片化风险</li><li>安全性</li><li>设计保证</li></ul><h3 id="编程模型">编程模型</h3><p>在程序中可以用道德寄存器集合。</p><ul><li>有些寄存器不可见</li></ul><h2 id="嵌入式微处理器分类">2. 嵌入式微处理器分类</h2><p>按位数可分为4、8、16等；</p><p>按功能可分为4种：</p><ul><li>嵌入式微处理单元（MPU）：类似CPU</li><li>嵌入式微控制器（MCU）：包含MPU与存储器、I/O接口和基本控制器</li><li>嵌入式DSP处理器：特殊设计系统和算法，用于信号处理</li><li>嵌入式SoC：集成MPU、存储器、外设控制器、通信功能等<ul><li>MCU通常不支持操作系统，裸机运行程序，快速响应实时任务和控制系统</li><li>SoC适合运行操作系统，性能和可靠性强，往往用于更高端的设备</li></ul></li></ul><h3 id="嵌入式微处理单元mpu">嵌入式微处理单元（MPU）</h3><p>嵌入式微处理器就是和通用计算机的处理器对应的CPU。</p><ul><li><p>功能和微处理器基本一样，具有32位以上，性能较高。</p></li><li><p>体积小、功耗少、成本低、可靠性高，有的可提供工业级应用。</p></li></ul><p>流行的嵌入式微处理器：ARM：Cortex-A系列、Power、MIPS</p><figure><img src="/image/嵌入式系统概论/框图.png" alt="框图" /><figcaption aria-hidden="true">框图</figcaption></figure><h3 id="嵌入式微控制器mcu">嵌入式微控制器（MCU）</h3><p>嵌入式微控制器就是将整个计算机系统的主要硬件集成到一块芯片中，芯片内部集成ROM/EPROM，RAM，总线，总线逻辑，定时/计数器，Watchdog，I/O，串行口等各种必要功能和外设。</p><ul><li>特点：<ul><li>一个系列的微控制器具有多种衍生产品</li><li>单片化，体积大大减小，功耗和成本降低，可靠性提高</li><li>是目前嵌入式工业的主流，约占嵌入式系统50%的份额</li></ul></li></ul><p>流行的嵌入式微控制器：</p><ul><li><p>通用系列：8051，Coldfire的MC683xx（32位），Cortex-M0/3/4/7/M33/M35P</p></li><li><p>半通用系列:支持I2C,CAN BUS及众多专用MCU和兼容系列</p></li></ul><h3 id="嵌入式dsp">嵌入式DSP</h3><p>嵌入式DSP是专门用于信号处理方面的处理器，其在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令执行速度。</p><p>应用领域：数字滤波、频谱分析、FFT</p><p>流行的嵌入式DSP：</p><ul><li>德州仪器（TI），c6000 与 c5000</li><li>模拟器件公司（ADI）</li><li>摩托罗拉（Motorola）公司</li></ul><h3 id="嵌入式soc">嵌入式SoC</h3><p>嵌入式SoC是追求产品系统最大包容的集成器件。绝大多数系统构件都在一个系统芯片内部。</p><p>SoC芯片可以有效地降低电子/信息系统产品开发成本，缩短开发周期，提高产品竞争力。</p><p>特点：</p><ul><li>结构简洁</li><li>体积小、功耗小</li><li>可靠性高</li><li>设计生产效率高</li></ul><p>流行的SoC：高通骁龙（Snapdragon）、海思</p><h3 id="现场可编程门阵列fpga">现场可编程门阵列，FPGA</h3><p>具有可编程特性的集成电路。</p><ul><li>赛灵思、阿尔特拉（被英特尔收购）</li></ul><h4 id="dsp和fpga">DSP和FPGA</h4><figure><img src="/image/嵌入式系统概论/DSP与FPGA.png" alt="DSP与FPGA" /><figcaption aria-hidden="true">DSP与FPGA</figcaption></figure><h2 id="嵌入式微处理器的特点">嵌入式微处理器的特点</h2><p>基础是通用微处理器；与通用微处理器的区别：</p><ul><li>体积小、重量轻、可靠性高、功耗低</li><li>成本低：片上存储、引脚与封装、代码密度</li><li>工作温度、抗电磁干扰、可靠性等方面增强</li></ul><h2 id="arm">ARM</h2><h3 id="arm公司">ARM公司</h3><p>成立于1990年11月，从Acorn电脑公司剥离出来。</p><ul><li><p>设计ARM系列的RISC处理器内核。</p></li><li><p>授权ARM核心设计的半导体合作 伙伴制造和销售给他们的客户。</p></li><li><p>同时开发技术以协助ARM架构的设计。</p><ul><li>软件工具、电路板、调试硬件、应用软件、总线架构、外围设备等。</li></ul></li></ul><h3 id="arm处理器的主要应用领域">ARM处理器的主要应用领域</h3><ul><li><p>消费类电子产品：</p><p>ARM技术在目前流行的数字音频播放器、数字机顶盒和游戏机中得到了广泛采用</p></li><li><p>无线通讯领域：</p><p>目前大部分无线通讯设备采用了ARM技术，ARM以其高性价比和低成本，在该领域的地位日益巩固</p></li><li><p>网络应用：</p><p>随着宽带技术的推广，采用ARM技术的ADSL芯片正逐步获得竞争优势，此外，ARM在语音及视频处理上进行了优化，并获得广泛支持，这也对DSP的应用领域提出了挑战</p></li><li><p>工业控制领域：</p><p>基于ARM核的微控制器芯片不但占据了高端微控制器的大部分市场份额，同时也逐渐向低端微控制器应用领域扩展，Cortex-M系列就是ARM公司推出的典型低功耗、高性价比32位工控微控制器，向传统的8位/16位微控制器提出了挑战</p></li><li><p>成像和安全产品：</p><p>现在流行的数码相机和打印机中绝大部分采用ARM技术，手机中的32位SIM智能卡也采用了ARM技术</p></li></ul><h3 id="arm处理器分类">ARM处理器分类</h3><p>结构体系版本（Architecture）</p><ul><li>ARM v4T</li><li>ARM v5TE</li><li>ARM v6</li><li>ARM Cortex（v7 ，v8）</li></ul><p>按应用特征分类</p><ul><li><p>应用处理器，Application Processor</p></li><li><p>实时控制处理器，Real-time Controller</p></li><li><p>微控制器，Micro-controller</p></li><li><p>SecurCore</p></li></ul><h3 id="arm架构">ARM架构</h3><p>典型的RISC：</p><ul><li>丰富的寄存器</li><li>加载/存储体系结构</li><li>简单寻址模式</li><li>统一和固定长度的指令字段</li></ul><p>增强功能：</p><ul><li>每条指令控制ALU和移位器</li><li>自动递增和自动递减寻址模式</li><li>多个加载/存储</li><li>条件执行</li></ul><p>特点：</p><ul><li>高性能</li><li>低代码</li><li>低功耗</li><li>低硅面积</li></ul><h3 id="流水线">流水线</h3><p>提高速度：大多数指令在一个周期内执行。</p><p>版本：</p><ul><li><p>3级（ARM7TDMI及更早版本）</p></li><li><p>5级（ARMS, ARM9TDMI）</p></li><li><p>6级（ARM10TDMI）</p></li></ul><p>流水线清空，导致执行速度变慢。</p><ul><li>分支指令</li></ul><p>分支预测技术</p><ul><li>静态</li><li>动态</li></ul><h3 id="meltdown-spectre">Meltdown &amp; Spectre</h3><p>近20年的Intel，AMD，Qualcomm厂家和其它ARM的处理器受到影响。</p><p>因为此次CPU漏洞特殊性，包括Linux，Windows，OSX等的操作系统平台参与了修复。</p><p>Firefox，Chrome，Edge等浏览器也发布了相关的安全公告和缓解方案。</p><h2 id="选择微处理器">选择微处理器</h2><h3 id="准则">准则</h3><ul><li>高效、经济<ul><li>速度、尺寸、功耗、易于升级、单位成本</li></ul></li><li>软件开发工具可用性<ul><li>汇编器、C编译器、仿真器</li></ul></li><li>广泛的可用性和可靠的微控制器来源</li></ul><h3 id="步骤">步骤</h3><ol type="1"><li>列出所需的硬件接口</li><li>检查软件架构</li><li>选择体系结构</li><li>确定内存要求</li><li>搜索微控制器</li><li>检查零件可用性</li><li>选择开发工具包</li><li>研究编译器和工具</li><li>开始尝试</li></ol>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_2_设计方法</title>
    <link href="/2023/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/2_%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <url>/2023/09/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/2_%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第二章-嵌入式系统设计方法">第二章 嵌入式系统设计方法</h1><h2 id="嵌入式系统设计面临的挑战">1. 嵌入式系统设计面临的挑战</h2><ul><li>硬件需求</li><li>多项功能在时间上的协调一致性、时限要求</li><li>系统功耗</li><li>系统可升级性</li><li>系统可靠性</li></ul><h3 id="设计者要求">设计者要求</h3><ul><li>懂得系统架构</li><li>了解硬件细节</li><li>软件设计满足<ul><li>实时要求</li><li>低功耗</li><li>代码量小</li></ul></li><li>了解领域知识</li></ul><h3 id="设计目标">设计目标</h3><ul><li>成本</li><li>性能</li><li>功耗</li><li>尺寸</li><li>可伸缩性和可重用性</li><li>容错</li><li>……</li></ul><h2 id="嵌入式系统的设计过程">2. 嵌入式系统的设计过程</h2><ul><li><p>问题：功能、性能要求、价格、开发周期等约束</p></li><li><p>设计：选择、折衷、分析比较、计算、评价</p></li></ul><h3 id="简化的设计流">简化的设计流</h3><figure><img src="/image/嵌入式系统概论/简化的设计流.png" alt="简化的设计流" /><figcaption aria-hidden="true">简化的设计流</figcaption></figure><h3id="嵌入式系统的设计过程的基本流程">嵌入式系统的设计过程的基本流程</h3><figure><img src="/image/嵌入式系统概论/基本流程.png" alt="基本流程" /><figcaption aria-hidden="true">基本流程</figcaption></figure><h3 id="v模型的设计流">V模型的设计流</h3><figure><img src="/image/嵌入式系统概论/V模型.png" alt="V模型" /><figcaption aria-hidden="true">V模型</figcaption></figure><h2 id="嵌入式系统设计方法学">3. 嵌入式系统设计方法学</h2><h3 id="体系结构设计">体系结构设计</h3><ul><li>满足规格说明的主要组件<ul><li>硬件：中央处理器、外围设备等</li><li>软件：必要的程序及其运行</li></ul></li><li>功能性和非功能性需求</li></ul><h4 id="硬件和软件组件设计">硬件和软件组件设计</h4><ul><li>开始编码前，必须花时间构建系统</li><li>有些组件是现成的，可以根据现有设计进行修改，还有一些必须从头开始设计</li></ul><h4 id="软硬件的划分">软硬件的划分</h4><p>嵌入式系统的设计涉及硬件与软件部件，设计中必须决定什么功能由硬件实现，什么功能由软件实现。</p><ul><li>硬件和软件具有双重性，这是划分决策的前提</li><li>软硬件变动对系统决策有影响</li><li>划分选择需考虑多种因素</li></ul><h5 id="通常由软件实现的部分">通常由软件实现的部分</h5><ul><li>操作系统功能<ul><li>任务调度</li><li>资源管理</li><li>设备驱动</li></ul></li><li>协议栈<ul><li>TCP/IP</li></ul></li><li>应用软件框架</li><li>除了基本系统、物理接口、基本逻辑电路，许多由硬件实现的功能都可以由软件实现</li></ul><h5 id="双重性部分">双重性部分</h5><ul><li>算法<ul><li>加密/解密</li><li>编码/解码</li><li>压缩/解压</li><li>等等</li></ul></li><li>数学运算<ul><li>浮点运算、FFT、等等</li></ul></li></ul><h4 id="软硬件技术对系统结构影响">软硬件技术对系统结构影响</h4><ul><li>硬软件设计的趋势——融合、渗透<ul><li>硬件设计的软件化：VHDL、Verilog、HANDEL-C</li><li>软件实现的硬件化：各种算法的ASIC</li></ul></li><li>对系统设计的影响——协同设计<ul><li>增加灵活性</li><li>增加了风险</li></ul></li></ul><h3 id="嵌入式系统设计方法的演变">嵌入式系统设计方法的演变</h3><ol type="1"><li>以PCB、CAD和在线仿真器为主要工具</li><li>EDA和EOS为开发平台</li><li>以IP内核库为设计基础，用软硬件协同设计技术的系统级设计方法</li></ol><h4 id="传统嵌入式系统设计过程">传统嵌入式系统设计过程</h4><ul><li>系统在一开始就被划分为软件和硬件两大部分</li><li>软件和硬件独立进行开发设计</li><li>硬件优先</li></ul><p>问题：</p><ul><li>软硬件间交互受很大限制<ul><li>凭经验划分软硬件</li><li>软硬件之间的相互性能影响很难评估</li></ul></li><li>系统集成相对滞后，NRE较大</li></ul><p>导致：</p><ul><li>设计质量差</li><li>设计修改难</li><li>研制周期不能有效保障</li></ul><h4 id="软硬件协同设计hwsw-co-design">软硬件协同设计HW/SW Co-design</h4><p>协同设计是指通过并行设计利用硬件和软件的协同作用来实现系统级目标。</p><p>协同设计试图通过提供分析方法来增加嵌入式系统设计的可预测性，这些分析方法告诉设计师一个系统是否满足其性能、功率和尺寸目标，并提供综合方法让设计师快速评估许多潜在的设计方法。</p><ul><li>它从90年代早期的一个新兴的学科变成了如今的主流技术。</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式_1_引言</title>
    <link href="/2023/09/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/1_%E5%BC%95%E8%A8%80/"/>
    <url>/2023/09/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/1_%E5%BC%95%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>眼花耳热后，意气素霓生。</p><span id="more"></span><h1 id="第一章-引言">第一章 引言</h1><h3 id="几个术语">几个术语</h3><ul><li><p>泛在计算：任何时间、任何地点的计算</p></li><li><p>不可见计算机：计算机被集成到物件中</p></li><li><p>普适计算：计算设备对日常生活的渗透</p></li><li><p>环境智能：生活环境中的计算机技术</p></li></ul><h2 id="嵌入式系统的定义">1. 嵌入式系统的定义</h2><h3 id="嵌入式系统">嵌入式系统</h3><p>以应用为中心，以计算机技术为基础，软硬件可裁减，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统。</p><ul><li><p>嵌入式系统（Emedded System）实际上是嵌入式计算机系统。</p></li><li><p>嵌入式系统就是一个具有特定功能或用途的隐藏在设备中的计算机软硬件集合体。</p></li><li><p>嵌入式系统三要素</p><ul><li>嵌入性：嵌入到对象体系中，有对象环境要求</li><li>专用性：软硬件按对象要求设计、裁减</li><li>计算机：实现对象的智能化功能</li></ul></li></ul><h3 id="信息物理系统">信息物理系统</h3><p>Cyber-Physical System（CPS），是计算进程和物理进程的集成。</p><ul><li><p>强调嵌入式系统和物理学的深度融合</p></li><li><p>深度融合了各类信息技术：传感器、嵌入式计算、云计算、网络通信</p><p>使各种信息化能力高度协同和自治</p></li><li><p>信息化能力：</p><p>3C：计算-Computer、通信-Communication、控制-Control</p></li></ul><h3 id="无线感知网络">无线感知网络</h3><p>Wireless sensornetwork/WSN，是由许多在空间中分布的自动装置组成的一种无线通信计算机网络，这些装置使用传感器协作地监控不同位置的物理或环境状况。</p><h3 id="物联网">物联网</h3><p>Internet ofThings（IoT），通过射频识别（RFID），红外感应器，全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物品与互联网相连接，进行信息交换和通信，以实现智能化识别、定位、跟踪、监控和管理的一种网络概念。</p><ul><li>面向生产的物联网技术开发被称为“工业4.0”。</li></ul><h3 id="发展历程">发展历程</h3><p>1960-1970：出现和兴起</p><p>1971-1989：走向繁荣，软硬件日益完善</p><p>1990-现在：走向纵深</p><h2 id="嵌入式系统的组成">2. 嵌入式系统的组成</h2><p>嵌入式系统一般由嵌入式硬件和软件组成：应用软件+中间件+运行内核+驱动+系统硬件</p><ul><li>硬件以微处理器为核心，集成存储器和系统专用的输入/输出设备</li><li>软件包括初始化代码及驱动、嵌入式操作系统和应用程序等</li></ul><h2 id="嵌入式系统的特点">3. 嵌入式系统的特点</h2><p>形式多样、面向特定应用</p><p>得到多种类型的处理器和处理器体系结构的支持</p><p>通常及其关注成本</p><p>实时性、可靠性</p><p>一般使用适应多种处理器、可剪裁、轻量型、实时可靠、可固化的嵌入式操作系统</p><p>需要专门工具和特殊方法进行开发</p><h2 id="嵌入式系统的分类">4. 嵌入式系统的分类</h2><p>处理器位数：8位、16位、32位、64位</p><p>应用：移动互联网、工业控制、可穿戴设备等</p><p>速度：</p><ul><li>强实时系统：响应时间毫秒或微秒级</li><li>一般实时系统：几秒级</li><li>弱实时系统：数十秒或更长</li></ul><p>确定性：</p><ul><li>硬实时系统：对系统响应时间有严格要求</li><li>软实时系统：系统响应时间不满足，不会导致系统出现致命错误或崩溃</li></ul><p>软件复杂程度：循环轮询、有限状态机、前后台、单/多处理器多任务系统</p><h2 id="嵌入式系统的发展趋势">5. 嵌入式系统的发展趋势</h2><p>嵌入式人工智能</p><p>嵌入式安全性</p><p>高计算需求和复杂性</p><p>软硬件协同设计</p><p>更高集成度</p><p>云计算</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式系统概论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑_提纲</title>
    <link href="/2023/08/05/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E6%8F%90%E7%BA%B2/"/>
    <url>/2023/08/05/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/%E6%8F%90%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<p>飞流直下三千尺，疑是银河落九天。</p><span id="more"></span><h1 id="提纲">提纲</h1><p>术语缩写：</p><ul><li>“$$”用于表示一个证明的结束。</li><li>“如果···那么···”，即“蕴含”，缩写为“<spanclass="math inline">\(···\Longrightarrow···\)</span>”；“逆蕴含”则为"<spanclass="math inline">\(···\Longleftarrow···\)</span>"。</li><li>“当且仅当”缩写为“<spanclass="math inline">\(iff\)</span>”或符号“<spanclass="math inline">\(\Longleftrightarrow\)</span>”</li><li>“因为”缩写为“<spanclass="math inline">\(\because\)</span>”，因此缩写为“<spanclass="math inline">\(\therefore\)</span>”</li><li>“<span class="math inline">\(x\neq y\)</span>”是“<spanclass="math inline">\(x=y\)</span>”的否定，“<spanclass="math inline">\(x\notin y\)</span>”是“<spanclass="math inline">\(x\in y\)</span>”的否定，类推至其它符号</li></ul><h2 id="一集合基础">一、集合基础</h2><h3 id="集合定义和表示">1. 集合定义和表示</h3><p>对象：人们感觉和思维中确定的某些事物，通常以其名称指代对象本身。</p><p>康托尔：集合是具有某种性质的、确定的、互异的对象所组成的整体。</p><p>表示方法：外延表示方法（列举法）和内涵表示方法</p><p>罗素悖论集合论：不能用更简单的数学概念来给集合下一个确定的定义。</p><h3 id="公理化集合论">2. 公理化集合论</h3><p>外延公理：如果集合<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>有相同元素，则<spanclass="math inline">\(X=Y\)</span>。</p><p>空集公理：存在一个不含任何元素的集合，称为空集，其它集合都称为非空的。</p><p>分离公理：如果<spanclass="math inline">\(\varphi\)</span>是一性质，则对于任意集合A和参数p，存在一个集合<spanclass="math inline">\(B=\{u\in X:\varphi (u,p)\}\)</span>，它包含所有具有这个性质的A中的元素u。</p><h3 id="幂集交集和并集">3. 幂集、交集和并集</h3><p>集合A的幂集<span class="math inline">\(\mathcal PA\)</span>的元素是A的所有子集，即：<span class="math inline">\(\mathcalP A=\{x|x\subseteq A \}\)</span>。</p><p>集合A与B的并集<span class="math inline">\(A\cupB\)</span>是属于A或属于B的元素的集合。</p><p>集合A与B的交集是所有A与B共有的元素的集合。</p><ul><li>A与B不相交，当且仅当二者的交集为空集</li></ul><p>对于非空集合A，其元素也是集合，有</p><ul><li><span class="math inline">\(\bigcupA=\{x|x属于A的某个元素\}\)</span></li><li><span class="math inline">\(\bigcapA=\{x|x属于A的每个元素\}\)</span></li></ul><h3 id="有序对">4. 有序对</h3><p>元素x和y的<strong>有序对</strong><span class="math inline">\(\langx,y\rang\)</span>定义：<span class="math inline">\(\lang x,y\rang=\langu,v\rang\quad iff\quad x=u且y=v\)</span>。</p><p>所有具有上述性质的定义都可以作为有序对的定义。</p><p>其中，一个标准的定义是<span class="math inline">\(\langx,y\rang=\{\{x\},\{x,y\} \}\)</span>。</p><p>一般地，对于<spanclass="math inline">\(n&gt;1\)</span>可以如下递归地定义<spanclass="math inline">\(n\)</span>元组：</p><p><span class="math inline">\(\lang x_1,x_2,...,x_{n+1}\rang=\lang\langx_1,x_2,...,x_n\rang,x_{n+1}\rang\)</span></p><p>为方便起见，对于<spanclass="math inline">\(n=1\)</span>，我们定义<spanclass="math inline">\(\lang x\rang=x\)</span>；这样上式对于<spanclass="math inline">\(n=1\)</span>也是成立的。</p><h4 id="有限序列">有限序列</h4><p>称S是A中元素的有限序列（有限串）当且仅当对某个正整数n，<spanclass="math inline">\(S=&lt;x_1,...,x_n&gt;\)</span>，其中每个<spanclass="math inline">\(x_i\in A\)</span>。</p><p>S的子段指一个有限序列<spanclass="math inline">\(&lt;x_k,x_{k+1},...,x_{m-1},x_m&gt;,1\leq k\leqm\leq n\)</span></p><ul><li>这个子段是初始段当且仅当<spanclass="math inline">\(k=1\)</span></li><li>这个子段是真子段当且仅当该子段与S不同</li></ul><h4 id="笛卡尔积">笛卡尔积</h4><p><span class="math inline">\(A\times B=\{\lang x,y\rang|x\in A,y\in B\}\)</span></p><p><spanclass="math inline">\(A^n\)</span>表示A中元素构成的所有的n元组组成的集合，比如<spanclass="math inline">\(A^3=(A\times A)\times A\)</span>。</p><h3 id="关系">5. 关系</h3><p>关系<span class="math inline">\(R\)</span>：有序对的集合。</p><ul><li>定义域，dom R：指所有满足<span class="math inline">\(\langx,y\rang\in R\)</span>的<spanclass="math inline">\(x\)</span>的集合</li><li>值域，ran R：指所有满足<span class="math inline">\(\lang x,y\rang\inR\)</span>的<span class="math inline">\(y\)</span>的集合</li></ul><h4 id="函数">函数</h4><p>函数是具有单值性质的关系。</p><p>关系<span class="math inline">\(F\)</span>，对于定义域中的每一个<spanclass="math inline">\(x\)</span>，都有唯一的y满足<spanclass="math inline">\(\lang x,y\rang\in F\)</span>，<spanclass="math inline">\(y\)</span>称为<spanclass="math inline">\(F\)</span>在<spanclass="math inline">\(x\)</span>上的值，记作<spanclass="math inline">\(F(x)\)</span>。</p><p>称函数F将定义域A映射到值域B。</p><ul><li><p>F是一个一一映射当且仅当对于B中的每个y，存在唯一的x使得<spanclass="math inline">\(\lang x,y\rang\in F\)</span>。</p></li><li><p>如果<span class="math inline">\(\langx,y\rang\)</span>在定义域dom F中，则记<spanclass="math inline">\(F(x,y)=F(\lang x,y\rang)\)</span>。</p></li><li><p>推广到n元：<spanclass="math inline">\(A\)</span>上的n元运算是一个将<spanclass="math inline">\(A^n\)</span>映射到<spanclass="math inline">\(A\)</span>中的函数。</p></li></ul><h4 id="关系的性质">关系的性质</h4><ol type="1"><li><p>R在A上是自反的，当且仅当对A中每个x都有<spanclass="math inline">\(\lang x,x\rang\in R\)</span>。</p></li><li><p>R是对称的，当且仅当如果<span class="math inline">\(\langx,y\rang\in R\)</span>，则<span class="math inline">\(\lang y,x\rang\inR\)</span>。</p></li><li><p>R是传递的，当且仅当如果<span class="math inline">\(\langx,y\rang\in R,\lang y,z\rang\in R\)</span>，则<spanclass="math inline">\(\lang x,z\rang\in R\)</span>。</p></li><li><p>R在A上满足三分律，当且仅当对A中任意的x和y，如下三种可能有且仅有一种成立：</p><ul><li><p><span class="math inline">\(\lang x,y\rang \inR\)</span></p></li><li><p><span class="math inline">\(x=y\)</span></p></li><li><p><span class="math inline">\(\lang y,z\rang\in R\)</span></p></li></ul></li><li><p>有序对的集合称为二元关系。</p></li><li><p>关系R是A上的等价关系当且仅当R是A上自反、对称和传递的一个二元关系。</p></li><li><p>关系R是A上的一个序关系当且仅当R是传递的且在A上满足三分律。</p></li><li><p>关系R的逆关系记为<spanclass="math inline">\(R^{-1}\)</span>，定义为<spanclass="math inline">\(R^{-1}=\{&lt;x,y&gt;|&lt;y,x&gt;\inR\}\)</span></p></li></ol><h3 id="偏序">6. 偏序</h3><p>设A为一个集合，R是A上的二元关系，称R为A上的<strong>偏序</strong>关系，如果满足如下条件：</p><ul><li><p>R具有自反性</p></li><li><p>R具有反对称性，且对任意<span class="math inline">\(x,y\inR\)</span>，如果<span class="math inline">\(xRy\)</span>且<spanclass="math inline">\(yRx\)</span>，则<spanclass="math inline">\(x=y\)</span></p></li><li><p>R具有传递性</p></li></ul><p>设A为一个集合，R是A上的二元关系，称R为A上的<strong>严格偏序</strong>关系，如果满足如下条件：</p><ul><li><p>R具有禁自反性，即任意x属于A都有非<spanclass="math inline">\(R(x,x)\)</span></p></li><li><p>R具有禁对称性，且对任意<span class="math inline">\(x,y\inA\)</span>，如果<span class="math inline">\(R(x,y)\)</span>，则非<spanclass="math inline">\(R(y,x)\)</span></p></li><li><p>R具有传递性</p></li></ul><p>极小元：</p><p><span class="math inline">\((A,\leq)\)</span>是偏序集，<spanclass="math inline">\(B\subseteq A,b\in B\)</span>，如果不存在<spanclass="math inline">\(x\in B\)</span>，使得<spanclass="math inline">\(x\neq b\)</span>且<spanclass="math inline">\(x\leq b\)</span>，则称b为B的关于<spanclass="math inline">\(\leq\)</span>关系的极小元。</p><h4 id="线序">线序</h4><p><spanclass="math inline">\((A,\leq)\)</span>是偏序集，如果A中任意两个元素x，y都在偏序关系<spanclass="math inline">\(\leq\)</span>下可以比较，则称<spanclass="math inline">\(\leq\)</span>关系是线序关系或全序关系。相应地称<spanclass="math inline">\((A,\leq)\)</span>为线序集或全序集。</p><ul><li>如果<span class="math inline">\(\leq\)</span>为A上的线序，则称<spanclass="math inline">\(&lt;\)</span>为A上的严格线序。</li></ul><h4 id="良序">良序</h4><p>设<spanclass="math inline">\((A,\le)\)</span>是线序集，如果A的任意非空子集都有<spanclass="math inline">\(\le\)</span>极小元，则称<spanclass="math inline">\((A,\le)\)</span>为良序集，且称<spanclass="math inline">\(\le\)</span>为A上的良序，或A被<spanclass="math inline">\(\le\)</span>良序。</p><ul><li>有穷的线序集都是良序集。</li></ul><p>良基偏序：</p><p>设<spanclass="math inline">\((A,\le)\)</span>是偏序集，如果A的任意非空子集都有<spanclass="math inline">\(\le\)</span>极小元，则称<spanclass="math inline">\((A,\le)\)</span>为良序集，且称<spanclass="math inline">\(\le\)</span>为A上的良序，或A被<spanclass="math inline">\(\le\)</span>良序。</p><h4 id="选择公理">选择公理</h4><p>对任意非空集合X，如果X中的元素均为非空集合，则存在映射f使得<spanclass="math inline">\(dom(f)=X\)</span>，且<spanclass="math inline">\(\forall x\in X\)</span>都有<spanclass="math inline">\(f(x)\in x\)</span>（称f为X上的选择函数）。</p><h4 id="乘积公理">乘积公理</h4><p>对任意集族<span class="math inline">\((X_i)_{i\inI}\)</span>，如果<spanclass="math inline">\(I\)</span>为非空集合，且对任意<spanclass="math inline">\(i\in I\)</span>，集合<spanclass="math inline">\(X_i\)</span>非空，则<spanclass="math inline">\(\prod_{i\in I}X_i\)</span>非空。</p><h4 id="可数">可数</h4><p>集合A是可数的，当且仅当存在某个函数将A一对一映射到自然数N中。</p><ul><li>设A是一个可数集，则所有由A的元素构成的有限序列的集合也可数。</li></ul><h3 id="自然数的定义">7. 自然数的定义</h3><ol type="1"><li><span class="math inline">\(0=\empty\)</span></li><li><span class="math inline">\(1=0^+=\{0\}\)</span></li><li><span class="math inline">\(2=1^+=\{0,1\}\)</span></li><li>假设我们已经定义了<spanclass="math inline">\(n=\{0,1,...,n-1\}\)</span>，则定义<spanclass="math inline">\(n+1=n^+=n\cup\{n\}=\{0,1,...,n-1,n\}\)</span></li><li>每个自然数都是从0开始经过有穷步后继运算的结果</li></ol><p>集合的后继运算：</p><p>设任意集合<span class="math inline">\(A\)</span>，称集合<spanclass="math inline">\(A\cup \{A\}\)</span>为<spanclass="math inline">\(A\)</span>的后继集合，简称<spanclass="math inline">\(A\)</span>的后继，记作<spanclass="math inline">\(A^+\)</span>，称<spanclass="math inline">\(A\)</span>为<spanclass="math inline">\(A^+\)</span>的前趋。</p><h4 id="无穷公理">无穷公理</h4><p>所有自然数组成的集合的整体是集合，记为<spanclass="math inline">\(\omega\)</span>。</p><h4 id="佐恩引理极大原则">佐恩引理/极大原则</h4><p>设A是一个集合，且满足对于任意的链<spanclass="math inline">\(C\subseteq A\)</span>，有集合<spanclass="math inline">\(\bigcupC\)</span>在A中，那么A中存在极大元m，即m不是A中其他任意元素的子集。</p><ul><li>一组集合C是一个链，当且仅当对于C中任意元素x和y，要么<spanclass="math inline">\(x\subseteq y\)</span>要么<spanclass="math inline">\(y\subseteq x\)</span></li></ul><h4 id="正则公理">正则公理</h4><p>每个非空集合A中总存在元素x使得<span class="math inline">\(x\capA=\empty\)</span>（此时称x为A的<span class="math inline">\(\in-\)</span>极小元）。</p><ul><li>不存在集合<span class="math inline">\(x\in x\)</span></li><li>不存在集合<span class="math inline">\(x,y\)</span>使得<spanclass="math inline">\(x\in y\)</span>且<span class="math inline">\(y\inx\)</span>。</li></ul><h4 id="数学归纳法">数学归纳法</h4><p>集合形式：</p><p>设S为一个集合，如果S满足如下两个条件：</p><ul><li><span class="math inline">\(0\in S\)</span></li><li>对任何自然数n，如果<span class="math inline">\(n\inS\)</span>，则<span class="math inline">\(n+1\in S\)</span></li></ul><p>则<span class="math inline">\(\omega \subseteqS\)</span>，即每个自然数都属于S。</p><p>性质形式：</p><p>设<span class="math inline">\(R\)</span>是性质，如果有</p><ol type="1"><li><span class="math inline">\(R(0)\)</span>成立，且</li><li>对任意自然数n，若<spanclass="math inline">\(R(n)\)</span>成立，<spanclass="math inline">\(R(n+1)\)</span>也成立</li></ol><p>则对任意自然数n都有<spanclass="math inline">\(R(n)\)</span>成立。</p><h4 id="传递集合">传递集合</h4><p>如果集合A的任意元素都是A的子集，则称A是传递集合。</p><ul><li><p>A为传递集合，则<span class="math inline">\(\forall x\in A,y\inx,y\in A\)</span>。</p></li><li><p>任意自然数、<spanclass="math inline">\(\omega\)</span>是传递集合</p></li></ul><h5 id="in三歧性"><span class="math inline">\(\in\)</span>三歧性</h5><p><span class="math inline">\(\forall x,y\in A有x\in y或x=y或y\inx\)</span></p><ul><li><span class="math inline">\(\omega\)</span>具有三歧性</li></ul><p>任意自然数n、m，定义</p><ul><li><span class="math inline">\(m&lt;n当且仅当m\in n\)</span></li><li><span class="math inline">\(m\le n当且仅当m&lt;n或m=n\)</span></li></ul><h3 id="有穷和无穷集合">8. 有穷和无穷集合</h3><h4 id="等势集合">等势集合</h4><p>设A、B为两个集合，如果存在A到B上的双射，则称A与B等势，或称A与B对等，记为<spanclass="math inline">\(A\sim B\)</span>。</p><ul><li>等势关系为等价关系。</li></ul><p>如果存在A到B的单射，则称A的势不超过B的势，记为<spanclass="math inline">\(A\preceq B\)</span>。</p><p>如果<span class="math inline">\(A\preceqB\)</span>但A与B不等势，则记作<span class="math inline">\(A\precB\)</span>。</p><h5 id="康托尔伯恩斯坦定理">康托尔伯恩斯坦定理</h5><p>设A、B为两个集合，假设<span class="math inline">\(A\preceq B,B\preceqA\)</span>，则<span class="math inline">\(A\sim B\)</span>。</p><h4 id="有穷与无穷集合">有穷与无穷集合</h4><p>和某个自然数等势的集合为有穷集合，否则为无穷集合。</p><ul><li>抽屉原理：集合A为有穷集合，当且仅当它不与它的任何真子集等势</li></ul><p>每一个无穷集合都有无数无穷子集。</p><ul><li>如果A是无穷集合，则<span class="math inline">\(\omega\preceqA\)</span>。</li><li>A是无穷集合当且仅当它与自身的一个真子集等势。</li><li>引理：假设A是非空集合且<span class="math inline">\(\bigcupA=A\)</span>，则A是无穷集合。</li></ul><h4 id="可数与不可数集合">可数与不可数集合</h4><p>若集合<span class="math inline">\(A\preceq\omega\)</span>，即存在A到<spanclass="math inline">\(\omega\)</span>的单射，则称A可数，否则为不可数。</p><ul><li>若<spanclass="math inline">\(A\sim\omega\)</span>，则称A为可数的无穷集合。</li><li>可数多个可数集合的并集可数。</li></ul><p>不可数集的构造：</p><ol type="1"><li><p>康托尔定理：<span class="math inline">\(\forall A,A\prec \mathcalP(A)\)</span></p></li><li><p>对角线方法证明(0,1)不可数。</p></li></ol><p>连通性假设：<span class="math inline">\(\forall A,\omega\preceqA\)</span>且<span class="math inline">\(A\preceq\R\)</span>，则要么<spanclass="math inline">\(A\sim\omega\)</span>，要么<spanclass="math inline">\(A\sim\R\)</span>。</p><ul><li>换言之，不存在集合<span class="math inline">\(A\)</span>使得<spanclass="math inline">\(\omega\preceq A\)</span>且<spanclass="math inline">\(A\preceq\R。\)</span></li></ul><h3 id="序数">9. 序数</h3><p>序数：具有三歧性的传递集合。</p><ul><li><p>如果<span class="math inline">\(\alpha\)</span>是序数，<spanclass="math inline">\(\alpha^+\)</span>也是序数；序数的每个元素也是序数。</p></li><li><p>对任意两个序数<spanclass="math inline">\(\alpha、\beta\)</span>都有<spanclass="math inline">\(\alpha\in\beta\)</span>，或者<spanclass="math inline">\(\alpha=\beta\)</span>，或者<spanclass="math inline">\(\beta\in\alpha\)</span>。</p></li></ul><p>对于自然数n，归纳定义<spanclass="math inline">\(\omega+n\)</span>：</p><ol type="1"><li><span class="math inline">\(\omega+0=\omega\)</span></li><li><span class="math inline">\(\omega+(n+1)=(\omega+n)^+\)</span></li></ol><p>对任意自然数有<spanclass="math inline">\(\omega+n\)</span>为序数。</p><p>用<span class="math inline">\(O_n\)</span>表示所有序数的类。</p><ul><li><p><span class="math inline">\(O_n\)</span>不是集合，否则<spanclass="math inline">\(O_n\)</span>是序数，<spanclass="math inline">\(O_n\subseteqO_n\)</span>，与正则公理矛盾。</p></li><li><p>任何序数在属于关系上是良序集，我们用&lt;表示序数的属于关系。</p></li></ul><h4 id="替换公理">替换公理</h4><p>设<spanclass="math inline">\(P(x,y)\)</span>为类关系，A是一个集合，如果<spanclass="math inline">\(\forall x\in A\)</span>，有唯一<spanclass="math inline">\(y_x\)</span>，使得<spanclass="math inline">\(P(x,y_x)\)</span>成立，则<spanclass="math inline">\(\{y_x|x\in A\}\)</span>是集合。</p><h4 id="同构定理">同构定理</h4><p>设<spanclass="math inline">\((A,\le_A)\)</span>是良序集，则存在唯一的序数<spanclass="math inline">\(\alpha\)</span>，使得<spanclass="math inline">\((A,\le_A)\)</span>和<spanclass="math inline">\((\alpha,\le)\)</span>序同构。</p><ul><li>序同构：存在双射<spanclass="math inline">\(f:A\rightarrow\alpha\)</span>，对<spanclass="math inline">\(\forall x,y\in A\)</span>，<spanclass="math inline">\(x\le_A y\)</span>当且仅当<spanclass="math inline">\(f(x)\le f(y)\)</span>。</li></ul><h4 id="极限序数">极限序数</h4><p>不是后继序数的非零序数称为极限序数。</p><ul><li><p>后继序数：设<spanclass="math inline">\(\alpha\)</span>为序数，如果存在序数<spanclass="math inline">\(\beta\)</span>使得<spanclass="math inline">\(\alpha=\beta^+\)</span>，则称<spanclass="math inline">\(\alpha\)</span>为后继序数。</p></li><li><p>大于0的自然数都是后继序数，<spanclass="math inline">\(\omega\)</span>是最小的极限序数。</p></li></ul><p><span class="math inline">\(\alpha\)</span>为极限序数当且仅当：</p><ul><li><p>对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都有<spanclass="math inline">\(\beta^+\lt\alpha\)</span>。</p></li><li><p><spanclass="math inline">\(\alpha\)</span>中无最大元，即对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都存在<spanclass="math inline">\(\gamma\lt\alpha\)</span>，使得<spanclass="math inline">\(\beta\lt\gamma\)</span>。</p></li></ul><h4 id="可数序数">可数序数</h4><p>如果序数是可数集合，则称它为可数序数。</p><ol type="1"><li>定义<spanclass="math inline">\(\omega_1=\{\alpha|\alpha是可数序数\}\)</span>。<ul><li><span class="math inline">\(\omega_1\)</span>是不可数序数。</li></ul></li><li>定义<spanclass="math inline">\(\omega_{\alpha+1}=\{\beta|\beta是序数且\beta\preceq\omega_\alpha\}\)</span>。</li><li>定义<spanclass="math inline">\(\omega_\lambda=\bigcup\{\omega_\alpha|\alpha\lt\lambda\}\)</span>。</li></ol><p>对任意序数<spanclass="math inline">\(\alpha,\beta\)</span>，如果<spanclass="math inline">\(\beta\lt\alpha\)</span>，则<spanclass="math inline">\(\omega_\beta\prec\omega_\alpha\)</span>。</p><h3 id="超穷归纳法">10. 超穷归纳法</h3><p>扩展数学归纳法：</p><p>设<span class="math inline">\(R(x)\)</span>为一个性质，假设</p><ol type="1"><li><p><span class="math inline">\(R(0)\)</span>成立</p></li><li><p>对任意的序数<spanclass="math inline">\(\alpha\)</span>，如果<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\alpha+1)\)</span>也成立</p></li><li><p>对于任意的极限序数<spanclass="math inline">\(\lambda\)</span>，如果<spanclass="math inline">\(\forall\alpha\lt\lambda\)</span>，<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\lambda)\)</span>成立</p></li></ol><p>那么对于任意的序数<spanclass="math inline">\(\alpha\)</span>都有<spanclass="math inline">\(R(\alpha)\)</span>成立。</p><p>超穷归纳法定义序数加法<spanclass="math inline">\(\alpha+\beta\)</span>：</p><ol type="1"><li><span class="math inline">\(\alpha+0=\alpha\)</span></li><li><spanclass="math inline">\(\alpha+\beta^+=(\alpha+\beta)^+\)</span></li><li><spanclass="math inline">\(\alpha+\lambda=\bigcup_{\beta\lt\lambda}(\alpha+\beta)\)</span>，<spanclass="math inline">\(\lambda\)</span>为极限序数</li></ol><p>超穷归纳法定义序数乘法<spanclass="math inline">\(\alpha·\beta\)</span>：</p><ol type="1"><li><span class="math inline">\(\alpha·0=0\)</span></li><li><spanclass="math inline">\(\alpha·\beta^+=(\alpha·\beta)+\alpha\)</span></li><li><spanclass="math inline">\(\alpha·\lambda=\bigcup_{\beta\lt\lambda}(\alpha·\beta)\)</span>，<spanclass="math inline">\(\lambda\)</span>为极限序数</li></ol><p>序数加法和乘法都满足结合律。</p><p>超穷归纳定义<span class="math inline">\(V_\alpha\)</span>：</p><ol type="1"><li><span class="math inline">\(V_0=\empty\)</span></li><li><span class="math inline">\(V_{\alpha+1}=V_\alpha\cup\mathcalP(V_\alpha)\)</span></li><li><spanclass="math inline">\(V_\lambda=\bigcup_{\alpha\lt\lambda}V_\alpha\)</span>，<spanclass="math inline">\(\lambda\)</span>为极限序数</li></ol><h3 id="基数">11. 基数</h3><p>用来衡量集合中元素的多少。</p><p>设<spanclass="math inline">\(\alpha\)</span>是一个序数，如果对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>都有<spanclass="math inline">\(\beta\prec\alpha\)</span>，则称<spanclass="math inline">\(\alpha\)</span>是基数。</p><ul><li>每个自然数都是基数，<spanclass="math inline">\(\omega\)</span>也是基数，当把它作为基数时，通常写作<spanclass="math inline">\(\omega_0\)</span>。</li><li><span class="math inline">\(\omega_\alpha\)</span>是基数。</li></ul><p>定义<spanclass="math inline">\(Card=\omega\cup\{\omega_\alpha|\alpha\inO_n\}\)</span>，它是所有基数组成的类。</p><p>对任意集合<spanclass="math inline">\(A\)</span>，都存在唯一的基数与它等势，称作它的基数或势，记作<spanclass="math inline">\(|A|\)</span>。</p><p>后续内容暂略，详见0927.p48</p><h2 id="二命题逻辑">二、命题逻辑</h2><p>形式语言：符号集、语法规则、与自然语言间的翻译。</p><h3 id="语言">1. 语言</h3><p>命题逻辑的符号集：</p><ol type="1"><li>逻辑符号：<ul><li>命题联结符：<spanclass="math inline">\(\neg,\and,\or,\rightarrow,\leftarrow\)</span></li><li>括号</li></ul></li><li>参数：命题符号，例如<spanclass="math inline">\(A_1,A_2,...\)</span></li></ol><p>表达式是符号的有限序列，合式公式是语法正确的表达式。</p><p>5种命题联结符对应5种公式构造运算，合式公式由这5种公式构造运算和命题符号构造。</p><ul><li><span class="math inline">\(\mathcalD_\neg(\alpha)=(\neg\alpha)\)</span></li><li><span class="math inline">\(\mathcalD_\or(\alpha,\beta)=(\alpha\or\beta)\)</span></li><li><span class="math inline">\(\mathcalD_\and(\alpha,\beta)=(\alpha\and\beta)\)</span></li><li><span class="math inline">\(\mathcalD_\rightarrow(\alpha,\beta)=(\alpha\rightarrow\beta)\)</span></li><li><span class="math inline">\(\mathcalD_\leftrightarrow(\alpha,\beta)=(\alpha\leftrightarrow\beta)\)</span></li></ul><h4 id="归纳法则二元">归纳法则(二元)</h4><p>称集合S在二元函数f作用下是封闭的，当且仅当<spanclass="math inline">\(\forall x,y\in S,f(x,y)\in S\)</span>。</p><p>如果S是包含所有命题符号的合式公式的集合且在5种运算下封闭，那么S是所有合式公式的集合。</p><h3 id="真值指派">2. 真值指派</h3><p>对于命题符号集合<spanclass="math inline">\(S\)</span>，一个真值指派<spanclass="math inline">\(v\)</span>是指函数<spanclass="math inline">\(v:S\rightarrow\{F,T\}\)</span>，这个函数给<spanclass="math inline">\(S\)</span>中的每个符号指定了一个真值<spanclass="math inline">\(T\)</span>或<spanclass="math inline">\(F\)</span>。</p><p><spanclass="math inline">\(S\)</span>通过5种公式构造运算得到合式公式集合<spanclass="math inline">\(\overline S\)</span>，对应地将<spanclass="math inline">\(v\)</span>扩展到<spanclass="math inline">\(\overline v\)</span>，<spanclass="math inline">\(\overline v\)</span>根据命题联结符的规则给<spanclass="math inline">\(\overlineS\)</span>中每个合式公式指派一个真值<spanclass="math inline">\(T\)</span>或<spanclass="math inline">\(F\)</span>。</p><ul><li>对于S的任意真值指派v，通过5种运算构造出的<spanclass="math inline">\(\overline v\)</span>是唯一的。</li></ul><p>称一个真值指派v满足合式公式<spanclass="math inline">\(\varphi\)</span>当且仅当<spanclass="math inline">\(\overline v(\varphi)=T\)</span>。</p><h4 id="重言蕴涵">重言蕴涵</h4><p>合式公式集合<spanclass="math inline">\(\Sigma\)</span>，合式公式<spanclass="math inline">\(\tau\)</span>：</p><p><span class="math inline">\(\Sigma\)</span>重言蕴涵<spanclass="math inline">\(\tau\)</span>，记作<spanclass="math inline">\(\Sigma\models\tau\)</span>，当且仅当满足<spanclass="math inline">\(\Sigma\)</span>中每个公式的真值指派也满足<spanclass="math inline">\(\tau\)</span>。</p><ul><li><spanclass="math inline">\(\Sigma=\varnothing\)</span>，则任意真值指派能满足<spanclass="math inline">\(\tau\)</span>，这时称<spanclass="math inline">\(\tau\)</span>为重言式，记作<spanclass="math inline">\(\models\tau\)</span>。</li><li>如果没有真值指派能满足<spanclass="math inline">\(\Sigma\)</span>中每个公式，那么<spanclass="math inline">\(\Sigma\models\tau\)</span>恒真。</li></ul><p>如果<span class="math inline">\(\Sigma\)</span>中只有一个元素<spanclass="math inline">\(\sigma\)</span>，用<spanclass="math inline">\(\sigma\models\tau\)</span>取代<spanclass="math inline">\(\{\sigma\}\models\tau\)</span>。</p><ul><li>如果<span class="math inline">\(\sigma\models\tau\)</span>且<spanclass="math inline">\(\tau\models\sigma\)</span>，则称<spanclass="math inline">\(\sigma\)</span>和<spanclass="math inline">\(\tau\)</span>重言等价。</li></ul><h4 id="紧致性定理">紧致性定理</h4><p>设<spanclass="math inline">\(\Sigma\)</span>是合式公式的无限集合，如果对<spanclass="math inline">\(\Sigma\)</span>的任意有限子集<spanclass="math inline">\(\Sigma_0\)</span>，都存在一个真值指派能满足<spanclass="math inline">\(\Sigma_0\)</span>中的每个合式公式，那么就存在一个真值指派能满足<spanclass="math inline">\(\Sigma\)</span>的所有合式公式。</p><ul><li>另见第6节。</li></ul><h4 id="典型重言式">典型重言式</h4><ol type="1"><li><p><spanclass="math inline">\(\and,\or,\leftrightarrow\)</span>的交换律和结合律</p></li><li><p>分配律：</p><p><span class="math inline">\((A\and(B\or C))\leftrightarrow((A\andB)\or(A\and C))\)</span></p><p><span class="math inline">\((A\or(B\and C))\leftrightarrow((A\orB)\and(A\or C))\)</span></p></li><li><p>否定：</p><p><span class="math inline">\((\neg(\neg A))\leftrightarrowA\)</span></p><p><span class="math inline">\((\neg(A\rightarrowB))\leftrightarrow(A\or(\neg B))\)</span></p><p><span class="math inline">\((\neg(A\leftrightarrowB))\leftrightarrow((A\and(\neg B)\or((\neg A)\or B))\)</span></p><p>德摩根律：</p><p><span class="math inline">\((\neg(A\and B))\leftrightarrow((\negA)\or(\neg B))\)</span></p><p><span class="math inline">\((\neg(A\or B))\leftrightarrow((\negA)\and(\neg B))\)</span></p></li><li><p>其他：</p><p>排中律：<span class="math inline">\(A\or(\neg A)\)</span></p><p>矛盾律：<span class="math inline">\(\neg(A\and(\neg A))\)</span></p><p>逆否律：<span class="math inline">\((A\rightarrowB)\leftrightarrow((\neg B)\rightarrow(\neg A))\)</span></p><p>输出律：<span class="math inline">\(((A\and B)\rightarrowC)\leftrightarrow(A\rightarrow(B\rightarrow C))\)</span></p></li></ol><h3 id="解析算法">3. 解析算法</h3><p>证明使用括号可以消除语义模糊。</p><ul><li>每个合式公式具有同样多的左右括号。</li><li>合式公式的任意一个真的初始段含有的左括号多于右括号。</li></ul><p>解析算法过程：将给定表达式转化为一棵确定的树。</p><ol type="1"><li>树底只有命题符号时，过程结束；否则，选择其中一个非命题符号的表达式继续进行</li><li>第一个符号必定是<spanclass="math inline">\((\)</span>，第二个符号如果是<spanclass="math inline">\(\neg\)</span>则到4，否则到3</li><li>从左开始扫描表达式，直到遇见<spanclass="math inline">\((\alpha\)</span>，这里<spanclass="math inline">\(\alpha\)</span>是一个非空的左右括号平衡的表达式，下一个符号必是<spanclass="math inline">\(\or,\and,\rightarrow,\leftrightarrow\)</span>中的一个，剩下的部分是<spanclass="math inline">\(\beta)\)</span>。在当前树下添加两个新结点<spanclass="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>，返回1</li><li>表达式的前两个符号为<spanclass="math inline">\((\neg\)</span>，剩余的部分为<spanclass="math inline">\(\beta)\)</span>，在当前树下添加新结点<spanclass="math inline">\(\beta\)</span>，返回1</li></ol><h4 id="波兰记法">波兰记法</h4><p>5种构造运算改为：</p><ul><li><span class="math inline">\(\mathcalD_\neg(\alpha)=\neg\alpha\)</span></li><li><span class="math inline">\(\mathcalD_\or(\alpha,\beta)=\or\alpha\beta\)</span></li><li><span class="math inline">\(\mathcalD_\and(\alpha,\beta)=\and\alpha\beta\)</span></li><li><span class="math inline">\(\mathcalD_\rightarrow(\alpha,\beta)=\rightarrow\alpha\beta\)</span></li><li><span class="math inline">\(\mathcalD_\leftrightarrow(\alpha,\beta)=\leftrightarrow\alpha\beta\)</span></li></ul><h4 id="省略括号">省略括号</h4><ol type="1"><li>最外层括号可省略</li><li>否定符号外的括号可省略</li><li>应用析取和合取符号时尽量保持公式的简短</li><li>重复使用相同连接符号，先计算右边</li></ol><h3 id="归纳和递归">4. 归纳和递归</h3><h4 id="归纳法则">归纳法则</h4><p>假设<span class="math inline">\(C\)</span>是由<spanclass="math inline">\(B\)</span>中的元素通过<spanclass="math inline">\(\mathcal F\)</span>中的函数生成的，若<spanclass="math inline">\(S\)</span>是<spanclass="math inline">\(C\)</span>的子集，<spanclass="math inline">\(S\)</span>包含<spanclass="math inline">\(B\)</span>并且在<spanclass="math inline">\(\mathcal F\)</span>中的运算下是封闭的，那么<spanclass="math inline">\(S=C\)</span>。</p><h4 id="自由生成">自由生成</h4><p>称C是由B在<span class="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>的作用下自由生成的，当且仅当<spanclass="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>在C上的限制<spanclass="math inline">\(f_c\)</span>和<spanclass="math inline">\(g_c\)</span>满足以下条件：</p><ol type="1"><li><span class="math inline">\(f_c\)</span>和<spanclass="math inline">\(g_c\)</span>是一对一的</li><li><span class="math inline">\(f_c\)</span>的值域、<spanclass="math inline">\(g_c\)</span>的值域与集合B两两不交</li></ol><h4 id="递归定理">递归定理</h4><p>设U的子集C是由B在<span class="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>的作用下自由生成的，其中<spanclass="math inline">\(f:U\times U\rightarrow U,g:U\rightarrowU\)</span>。</p><p>设V是集合，函数F、G和h满足<span class="math inline">\(F:V\timesV\rightarrow V,G:V\rightarrow V,h:B\rightarrow V\)</span>。</p><p>那么存在<strong>唯一</strong>的函数<spanclass="math inline">\(\overline h:C\rightarrow V\)</span>使得：</p><ol type="1"><li>对B中的x，<span class="math inline">\(\overlineh(x)=h(x)\)</span></li><li>对C中的x，y，<span class="math inline">\(\overlineh(f(x,y))=F(\overline h(x),\overline h(y))\)</span>，<spanclass="math inline">\(\overline h(g(x))=G(\overline h(x))\)</span></li></ol><p>含义：只要我们正确地定义了基础情况（对应于B集合和h函数）和递归步骤（对应于f、g、F和G），那么递归扩展的过程是唯一和确定的。</p><h4 id="唯一可读性定理">唯一可读性定理</h4><p>合式公式的集合是由命题符号集在5种运算的作用下自由生成的，于是是真值指派的扩展是唯一的。</p><h3 id="命题联结符">5. 命题联结符</h3><h4 id="布尔函数">布尔函数</h4><p>k元布尔函数是指从<spanclass="math inline">\(\{F,T\}^k\)</span>到<spanclass="math inline">\(\{F,T\}\)</span>的函数。</p><p><span class="math inline">\(B_\alpha^n\)</span>(简写为<spanclass="math inline">\(B_\alpha\)</span>)定义为<spanclass="math inline">\(B_\alpha^n(X_1,...,X_n)=\alpha\)</span>的真值，当<spanclass="math inline">\(A_1=X_1,...,A_n=X_n\)</span>，</p><p>称为含有n个不同命题符号<spanclass="math inline">\(A_1,...,A_n\)</span>的合式公式<spanclass="math inline">\(\alpha\)</span><strong>实现</strong>的n元布尔函数。</p><ul><li>设G是一个n元布尔函数，<spanclass="math inline">\(n\ge1\)</span>，可以找到合式公式<spanclass="math inline">\(\alpha\)</span>实现G。</li></ul><p>设<span class="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>是合式公式，它们的命题符号在<spanclass="math inline">\(A_1,...,A_n\)</span>中，那么</p><ol type="1"><li><spanclass="math inline">\(\alpha\models\beta\)</span>当且仅当对所有的<spanclass="math inline">\(\vec X\in\{F,T\}^n,B_\alpha(\vec X)\leB_\beta(\vec X)\)</span>。</li><li><span class="math inline">\(\alpha\)</span>重言等价于<spanclass="math inline">\(\beta\)</span>当且仅当<spanclass="math inline">\(。B_\alpha=B_\beta\)</span></li><li><span class="math inline">\(\models\alpha\)</span>当且仅当<spanclass="math inline">\(B_\alpha\)</span>是具有真值T的常函数。</li></ol><h4 id="析取范式">析取范式</h4><p>显式给出了满足公式的真值指派。</p><p><spanclass="math inline">\(\alpha=\gamma_1\or...\or\gamma_k\)</span>，其中每个<spanclass="math inline">\(\gamma_i\)</span>是合取式<spanclass="math inline">\(\gamma_i=\beta_1\and...\and\beta_n\)</span>。</p><ul><li><p>对于任意可满足的合式公式，可以找到一个与其重言等价的析取范式。</p><p><spanclass="math inline">\(\{\and,\or,\neg\}\)</span>是完备的，每个布尔函数都可以由只使用<spanclass="math inline">\(\{\and,\or,\neg\}\)</span>中的联结词的合式公式实现。</p></li><li><p><span class="math inline">\(\{\neg,\and\}\)</span>和<spanclass="math inline">\(\{\neg,\or\}\)</span>都是完备的。</p></li></ul><h4 id="零元联结词">零元联结词</h4><p>两个0元布尔函数F和T，对应联结真值总为F的符号<spanclass="math inline">\(\bot\)</span>真值总为T的符号<spanclass="math inline">\(\top\)</span>。</p><h4 id="一元联结词">一元联结词</h4><p>否定联结词<spanclass="math inline">\(\neg\)</span>，恒等函数，上述的两个常值函数。</p><h4 id="二元联结词">二元联结词</h4><p><spanclass="math inline">\(\or,\and,\rightarrow,\leftarrow,\leftrightarrow\)</span></p><p><span class="math inline">\(+\)</span>：排他或，<spanclass="math inline">\((A\or B)\and\neg(A\and B)\)</span></p><p><span class="math inline">\(|\)</span>：与非，<spanclass="math inline">\(\neg(A\and B)\)</span></p><p><span class="math inline">\(\gt\)</span>：<spanclass="math inline">\(F\lt T\)</span>的排序，<spanclass="math inline">\(A\and(\neg B)\)</span></p><p><span class="math inline">\(&lt;\)</span>：<spanclass="math inline">\(F\lt T\)</span>的排序，<spanclass="math inline">\((\neg A)\and B\)</span></p><p><span class="math inline">\(\downarrow\)</span>：或非，<spanclass="math inline">\(\neg(A\or B)\)</span></p><p><span class="math inline">\(|\)</span>和<spanclass="math inline">\(\downarrow\)</span>是完备的。（<spanclass="math inline">\(\neg\alpha\)</span>等价于<spanclass="math inline">\(\alpha|\alpha\)</span>和<spanclass="math inline">\(\alpha\downarrow\alpha\)</span>）</p><h3 id="紧致性和能行性">6. 紧致性和能行性</h3><h4 id="紧致性定理-1">紧致性定理</h4><p>合式公式的集合是可满足的当且仅当它的每个有限子集是可满足的（有限可满足的）。</p><h4 id="能行性">能行性</h4><p>对于给定的表达式，存在一个能行的判定过程用来确定它是否是合式公式。</p><ul><li>即解析算法。</li></ul><h4 id="可判定性">可判定性</h4><p>表达式集合<spanclass="math inline">\(\Sigma\)</span>是可判定的当且仅当对于给定的表达式<spanclass="math inline">\(\alpha\)</span>，存在能行的过程判定<spanclass="math inline">\(\alpha\)</span>是否属于<spanclass="math inline">\(\Sigma\)</span>。</p><p>对于给定的有限多个合式公式的集合<spanclass="math inline">\(\Sigma;\tau\)</span>，存在能行的判定过程判定<spanclass="math inline">\(\Sigma\models\tau\)</span>是否成立。</p><ul><li>真值表。</li></ul><p>对于有限集合<spanclass="math inline">\(\Sigma\)</span>，它的重言推论集合是可判定的。特别地，重言式的集合是可判定的。</p><h4 id="能行可枚举">能行可枚举</h4><p>表达式集合A是能行可枚举的，当且仅当对于任意给定的表达式<spanclass="math inline">\(\varepsilon\)</span>，存在一个能行的判定过程，当<spanclass="math inline">\(\varepsilon\inA\)</span>成立时，返回判定结果。</p><ul><li>也称为半可判定的，区别在于，如果还没有得到<spanclass="math inline">\(\varepsilon\inA\)</span>，这个过程可能不停地运行下去。</li></ul><h4 id="kleene定理">Kleene定理</h4><p>表达式组成的一个集合是可判定的当且仅当它和它的补集都是能行可枚举的。</p><p>如果<spanclass="math inline">\(\Sigma\)</span>是合式公式的可判定集合，那么它的重言推论的集合是能行可枚举的。</p><h2 id="三一阶逻辑">三、一阶逻辑</h2><h3 id="语言-1">1. 语言</h3><p>一阶语言的符号集：</p><ol type="1"><li>逻辑符号<ul><li>括号</li><li>命题联结符号</li><li>变量</li><li>等于符号（可选）</li></ul></li><li>参数<ul><li>量词符号</li><li>谓词符号</li><li>常数符号</li><li>函数符号</li></ul></li></ol><p>表达式是符号的任意有限序列。</p><p>项是常数符号和变量通过使用0次或多次函数运算构成的表达式。</p><p>原子公式是项与谓词符号构成的表达式，相当于命题逻辑中的命题符号。</p><p>合式公式是原子公式通过0次或多次使用命题联结符和量词符号构成的表达式。</p><p>可以用显式书写每一个符号的方式来指定一个合式公式。</p><p>简化：</p><ul><li><p><span class="math inline">\((\alpha\or\beta)\)</span>简化<spanclass="math inline">\(((\neg\alpha)\rightarrow\beta)\)</span></p></li><li><p><span class="math inline">\((\alpha\and\beta)\)</span>简化<spanclass="math inline">\((\neg(\alpha\rightarrow(\neg\beta)))\)</span></p></li><li><p><spanclass="math inline">\((\alpha\leftrightarrow\beta)\)</span>简化<spanclass="math inline">\(((\alpha\rightarrow\beta)\and(\beta\rightarrow\alpha))\)</span></p></li><li><p><span class="math inline">\(\exist x\alpha\)</span>简化<spanclass="math inline">\((\neg\forall x(\neg\alpha))\)</span></p></li></ul><p>缩写和记法：</p><ul><li><p>最外层的括号可以省略</p></li><li><p>尽量少使用<spanclass="math inline">\(\neg,\or,\and,\rightarrow,\exist\)</span></p></li><li><p>当联结符号重复出现，表达式从右边开始分组</p></li></ul><h4 id="自由变量">自由变量</h4><p>考虑任意变量x，对每一个合式公式<spanclass="math inline">\(\alpha\)</span>，x在<spanclass="math inline">\(\alpha\)</span>中自由出现的递归定义：</p><ol type="1"><li>对原子公式<span class="math inline">\(\alpha\)</span>，x在<spanclass="math inline">\(\alpha\)</span>中自由出现当且仅当x出现在<spanclass="math inline">\(\alpha\)</span>中</li><li>x在<spanclass="math inline">\((\neg\alpha)\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>中自由出现</li><li>x在<spanclass="math inline">\((\alpha\rightarrow\beta)\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>或<spanclass="math inline">\(\beta\)</span>中自由出现</li><li>x在<span class="math inline">\(\forallv_i\alpha\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>中自由出现且<spanclass="math inline">\(x\neq v_i\)</span></li></ol><p>如果合式公式<spanclass="math inline">\(\alpha\)</span>中没有自由变量出现，那么<spanclass="math inline">\(\alpha\)</span>就是一个句子。</p><h3 id="真值与模型">2. 真值与模型</h3><p>一阶语言的<strong>结构</strong>指明：</p><ul><li><p>全称量词所指的事物集合</p></li><li><p>其他参数（谓词和函数符号）的含义</p></li></ul><p>形式上，一阶语言的一个<strong>结构</strong><spanclass="math inline">\(\mathfrak{A}\)</span>是一个函数，其定义域为参数的集合，且满足</p><ol type="1"><li><span class="math inline">\(\mathfrak{A}\)</span>为全称量词<spanclass="math inline">\(\forall\)</span>指派一个<strong>非空</strong>集合<spanclass="math inline">\(|\mathfrak{A}|\)</span>，称为<spanclass="math inline">\(\mathfrak{A}\)</span>的论域或者定义域</li><li><spanclass="math inline">\(\mathfrak{A}\)</span>为每一个n元谓词符号P指派一个n元关系，<spanclass="math inline">\(P^\mathfrak{A}\subseteq|\mathfrak{A}|^n\)</span>，即<spanclass="math inline">\(P^\mathfrak{A}\)</span>是P上一个n元组的集合</li><li><spanclass="math inline">\(\mathfrak{A}\)</span>给每个常数符号c指派一个论域<spanclass="math inline">\(|\mathfrak{A}|\)</span>中的元素<spanclass="math inline">\(c^\mathfrak{A}\)</span></li><li><spanclass="math inline">\(\mathfrak{A}\)</span>给每个n元函数符号f指派一个<spanclass="math inline">\(|\mathfrak{A}|\)</span>上的n元运算<spanclass="math inline">\(f^\mathfrak{A}:|\mathfrak{A}|^n\rightarrow|\mathfrak{A}|\)</span></li></ol><p>称一个结构是这个句子的<strong>模型</strong>，当使用该结构可以将形式语言的句子翻译为真的自然语言。</p><p>令：</p><ul><li><span class="math inline">\(\varphi\)</span>是语言中的合式公式</li><li><span class="math inline">\(\mathfrak{A}\)</span>是语言的结构</li><li><spanclass="math inline">\(s:V\rightarrow|\mathfrak{A}|\)</span>是从集合V的所有变量到A的论域<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数。</li></ul><p>由<span class="math inline">\(\mathfrak A\)</span>确定的<spanclass="math inline">\(\varphi\)</span>的翻译是真的，则称对于<spanclass="math inline">\(\mathfrak{A}\)</span>，s满足<spanclass="math inline">\(\varphi\)</span>的含义为<spanclass="math inline">\(\models_\mathfrak{A} \varphi[s]\)</span>。</p><p>对于每个句子<span class="math inline">\(\sigma\)</span>，如果<spanclass="math inline">\(\mathfrak{A}\)</span>以每个从V到<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数s满足<spanclass="math inline">\(\sigma\)</span>，那么称<spanclass="math inline">\(\sigma\)</span>在<spanclass="math inline">\(\mathfrak{A}\)</span>中是真的，<spanclass="math inline">\(\mathfrak{A}\)</span>是<spanclass="math inline">\(\sigma\)</span>的模型。</p><ul><li><spanclass="math inline">\(\mathfrak{A}\)</span>是句子集合的模型当且仅当<spanclass="math inline">\(\mathfrak{A}\)</span>是句子集合中每个句子的模型。</li></ul><p>模型刻画：</p><ol type="1"><li><span class="math inline">\(\models_\mathfrakA(\alpha\and\beta)[s]\)</span>当且仅当<spanclass="math inline">\(\models_\mathfrak A\alpha[s],\models_\mathfrak A\beta[s]\)</span>，<span class="math inline">\(\forall\)</span>和<spanclass="math inline">\(\leftrightarrow\)</span>类似</li><li><span class="math inline">\(\models_\mathfrak A\existx\alpha[s]\)</span>当且仅当存在某个<spanclass="math inline">\(d\in|\mathfrak A|\)</span>，具有属性<spanclass="math inline">\(\models_\mathfrak A\alpha[s(x|d)]\)</span></li></ol><h4 id="逻辑蕴涵">逻辑蕴涵</h4><p>设<span class="math inline">\(\Gamma\)</span>是合式公式的集合，<spanclass="math inline">\(\varphi\)</span>是一个合式公式：</p><p><span class="math inline">\(\Gamma\)</span>逻辑蕴涵<spanclass="math inline">\(\varphi\)</span>，记作<spanclass="math inline">\(\Gamma\models\varphi\)</span>，当且仅当对语言的每个结构<spanclass="math inline">\(\mathfrak{A}\)</span>和每个函数<spanclass="math inline">\(s:V\rightarrow|\mathfrak{A}|\)</span>，如果<spanclass="math inline">\(\mathfrak{A}\)</span>以s满足<spanclass="math inline">\(\Gamma\)</span>的每个元素，那么<spanclass="math inline">\(\mathfrak{A}\)</span>也以s满足<spanclass="math inline">\(\varphi\)</span>。</p><ul><li>恒真公式：<spanclass="math inline">\(\varnothing\models\varphi\)</span>，简写为<spanclass="math inline">\(\models\varphi\)</span>，对每个结构<spanclass="math inline">\(\mathfrak{A}\)</span>和每个函数s，<spanclass="math inline">\(\mathfrak{A}\)</span>以s满足<spanclass="math inline">\(\varphi\)</span>。</li></ul><h4 id="可定义性">可定义性</h4><p>考虑结构<spanclass="math inline">\(\mathfrak{A}\)</span>和合式公式<spanclass="math inline">\(\varphi\)</span>，其自由变元在<spanclass="math inline">\(v_1,...,v_k\)</span>中，可以构建<spanclass="math inline">\(\mathfrak{A}\)</span>上的k元关系</p><p><span class="math inline">\(\{\langa_1,...,a_k\rang|\models_\mathfrak A\varphi(a_1,...,a_k) \}\)</span></p><p>称此k元关系是在<spanclass="math inline">\(\mathfrak{A}\)</span>由<spanclass="math inline">\(\varphi\)</span>定义的。</p><p><span class="math inline">\(|\mathfrak{A}|\)</span>上的k元关系在<spanclass="math inline">\(\mathfrak{A}\)</span>中是可定义的当且仅当存在能够定义它的一个公式。</p><h4 id="结构类">结构类</h4><p>对句子集<span class="math inline">\(\Sigma\)</span>，用<spanclass="math inline">\(Mod\;\Sigma\)</span>表示<spanclass="math inline">\(\Sigma\)</span>的所有模型组成的类，即某种语言的所有结构的类，在这种语言中<spanclass="math inline">\(\Sigma\)</span>的每个元素都是真的。</p><ul><li>对单个句子<spanclass="math inline">\(\tau\)</span>，我们简单记作<spanclass="math inline">\(Mod\;\tau\)</span>，而不用<spanclass="math inline">\(Mod\{\tau\}\)</span>。</li></ul><p>语言的结构类<span class="math inline">\(\mathcalK\)</span>是<strong>初等类</strong>（<spanclass="math inline">\(EC\)</span>），当且仅当对某个句子<spanclass="math inline">\(\tau\)</span>，<spanclass="math inline">\(\mathcal K=Mod\;\tau\)</span>。</p><p><span class="math inline">\(\mathcal K\)</span>是广义初等类（<spanclass="math inline">\(EC_\Delta\)</span>）当且仅当对某个句子集合<spanclass="math inline">\(\Sigma\)</span>，<spanclass="math inline">\(\mathcal K=Mod\;\Sigma\)</span>。</p><h4 id="同态">同态</h4><p>从<span class="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>的一个<strong>同态</strong>是一个函数<spanclass="math inline">\(h:|\mathfrak{A}|\rightarrow|\mathfrak{B}|\)</span>，具有下列性质：</p><ul><li><p>对每个n元谓词参数<span class="math inline">\(P\)</span>和<spanclass="math inline">\(|\mathfrak{A}|\)</span>中元素的任意n元组<spanclass="math inline">\(\lang a_1,...,a_n\rang\)</span></p><p><span class="math inline">\(\lang a_1,...,a_n\rang\inP^\mathfrak{A}\; iff\;\lang h(a_1),...,h(a_n)\rang\inP^\mathfrak{B}\)</span></p></li><li><p>对每个n元函数符号f和任意n元组</p><p><spanclass="math inline">\(h(f^\mathfrak{A}(a_1,...,a_n))=f^\mathfrak{B}(h(a_1),...,h(a_n))\)</span></p></li><li><p>对于常数符号c，<span class="math inline">\(h(c^\mathfrakA)=c^\mathfrak{B}\)</span></p></li></ul><p>如果h是一对一的，那么这种同态称为<spanclass="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>中的<strong>同构</strong>。</p><p>如果存在<span class="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>上的同构，那么<spanclass="math inline">\(\mathfrak{A}\)</span>和<spanclass="math inline">\(\mathfrak{B}\)</span>称作是同构的，记作<spanclass="math inline">\(\mathfrak A\cong \mathfrak{B}\)</span>。</p><p>称两个结构<span class="math inline">\(\mathfrak{A}\)</span>和<spanclass="math inline">\(\mathfrak{B}\)</span>是初等等价的，记作<spanclass="math inline">\(\mathfrak{A}\equiv\mathfrak{B}\)</span>，当且仅当对任意的句子<spanclass="math inline">\(\sigma\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\sigma\Leftrightarrow\models_\mathfrak{B}\sigma\)</span>。</p><ul><li>同构的结构是初等等价的。</li></ul><p>同态定理：设h是从<spanclass="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>中的同态，s将变量的集合映射到<spanclass="math inline">\(|\mathfrak{B}|\)</span>中。</p><ul><li><p>对每个项t，我们有<spanclass="math inline">\(h(\overline{s}(t))=h\overline{\circ}s(t)\)</span>，其中<spanclass="math inline">\(\overline{s}(t)\)</span>是在<spanclass="math inline">\(\mathfrak{B}\)</span>中计算的，而<spanclass="math inline">\(h\overline{\circ}s(t)\)</span>是在<spanclass="math inline">\(\mathfrak{B}\)</span>中计算的。</p></li><li><p>对每个不包含等于符号的无量词的公式<spanclass="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\alpha[s]\;iff\;\models_\mathfrak{B}\alpha[h\circs]\)</span></p></li><li><p>如果h是一对一的，那么对每个无量词的公式<spanclass="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\alpha[s]\;iff\;\models_\mathfrak{B}\alpha[h\circs]\)</span></p></li><li><p>第二、三条可以删去无量词</p></li></ul><h3 id="演绎计算">3. 演绎计算</h3><p>证明应该是：</p><ul><li><p>有限长的；</p></li><li><p>能够进行验证的；</p></li></ul><p>无假设条件的可证明的公式集合必须是能行可枚举的。</p><h4 id="形式演绎">形式演绎</h4><p>选择一个有限的公式集合<spanclass="math inline">\(\Lambda\)</span>，称之为逻辑公理；使用假言推理的推理规则。</p><ul><li>假言推理：从公式<span class="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\alpha\rightarrow\beta\)</span>，可以得到<spanclass="math inline">\(\beta\)</span>。</li></ul><p>从<span class="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的一个<strong>演绎</strong>是一个有限的公式序列<spanclass="math inline">\(\lang \alpha_0,...,\alpha_n\rang\)</span>使得<spanclass="math inline">\(\alpha_n=\varphi\)</span>，对每个<spanclass="math inline">\(k\le n\)</span>有：</p><ol type="1"><li><spanclass="math inline">\(\alpha_k\in(\Gamma\cup\Lambda)\)</span>，或者</li><li><spanclass="math inline">\(\alpha_k\)</span>可以由出现在该公式前的两个公式通过假言推理得到。</li></ol><p>如果存在这样的演绎，则称<spanclass="math inline">\(\varphi\)</span>是由<spanclass="math inline">\(\Gamma\)</span>可演绎推出的，或者<spanclass="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\Gamma\)</span>的<strong>定理</strong>，记作<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>。</p><ul><li><p>从<span class="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的一个演绎可以看作是一个构造序列。</p></li><li><p>一个定理不只有一个唯一的演绎。</p></li></ul><p>归纳：设S是包含<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>的合式公式的集合，并且在假言推理下封闭，那么S包含<spanclass="math inline">\(\Gamma\)</span>的所有定理。</p><h4 id="逻辑公理">逻辑公理</h4><p>任意合式公式都是其自身的一个概化，逻辑公理都是如下形式合式公式的概化，其中x和y都是变量，<spanclass="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>都是合式公式。</p><ol type="1"><li>重言式</li><li><span class="math inline">\(\forallx\alpha\rightarrow\alpha_t^x\)</span>，其中t为x在<spanclass="math inline">\(\alpha\)</span>中的替换</li><li><span class="math inline">\(\forallx(\alpha\rightarrow\beta)\rightarrow(\forall x\alpha\rightarrow\forallx\beta)\)</span></li><li><span class="math inline">\(\alpha\rightarrow\forallx\alpha\)</span>，其中x在<spanclass="math inline">\(\alpha\)</span>中不是自由出现的</li></ol><p>如果语言包含相等符号则还要加上两组：</p><ol start="5" type="1"><li><span class="math inline">\(x=x\)</span></li><li><spanclass="math inline">\(x=y\rightarrow(\alpha\rightarrow\alpha&#39;)\)</span>，其中<spanclass="math inline">\(\alpha\)</span>是原子的且<spanclass="math inline">\(\alpha&#39;\)</span>是有限次的将<spanclass="math inline">\(\alpha\)</span>中的x替换为y的到的。</li></ol><p>合式公式<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\psi\)</span>的<strong>概化</strong>当且仅当对某个<spanclass="math inline">\(n\ge0\)</span>和某些变量<spanclass="math inline">\(x_1,...,x_n\)</span>，<spanclass="math inline">\(\varphi=\forall x_1...\forallx_n\psi\)</span>。</p><h5 id="替换">替换</h5><p>替换的递归定义：</p><ol type="1"><li>对原子公式<span class="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\alpha_t^x\)</span>是将公式<spanclass="math inline">\(\alpha\)</span>中自由出现的变量x都替换为t所得到的表达式。</li><li><spanclass="math inline">\((\neg\alpha)_t^x=(\neg\alpha_t^x)\)</span></li><li><spanclass="math inline">\((\alpha\rightarrow\beta)_t^x=(\alpha_t^x\rightarrow\beta_t^x)\)</span></li><li><span class="math inline">\((\forall y\alpha)_t^x=\begin{cases}\forall y\alpha\quad 如果x=y\\ \forall y(\alpha_t^x)\quad 如果x\neq y\end{cases}\)</span></li></ol><p>可替换性可以类似地递归定义。</p><h5 id="重言式">重言式</h5><p>基本公式：原子公式和形式为<span class="math inline">\(\forallx\alpha\)</span>的公式。</p><ul><li>任何公式都可以由基本公式通过<spanclass="math inline">\(\epsilon_\neg\)</span>和<spanclass="math inline">\(\epsilon_\rightarrow\)</span>的运算构造。</li><li>第一组公理都是命题逻辑重言式的概化。</li></ul><p><span class="math inline">\(\Gamma\vdash\varphi\)</span>当且仅当<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>重言蕴涵<spanclass="math inline">\(\varphi\)</span>。</p><h4 id="演绎和元定理">演绎和元定理</h4><p>自然语言中的定理称为<strong>元定理</strong>。</p><h5 id="概化定理">概化定理</h5><p>如果<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>且x不在<spanclass="math inline">\(\Gamma\)</span>的任何公式中自由出现，那么<spanclass="math inline">\(\Gamma\vdash\forall x\varphi\)</span>。</p><ul><li>规则T：如果<spanclass="math inline">\(\Gamma\vdash\alpha_1,...,\Gamma\vdash\alpha_n\)</span>，且<spanclass="math inline">\(\{\alpha_1,...,\alpha_n\}\)</span>重言蕴涵<spanclass="math inline">\(\beta\)</span>，那么<spanclass="math inline">\(\Gamma\vdash\beta\)</span>。</li></ul><h5 id="演绎定理">演绎定理</h5><p>如果<spanclass="math inline">\(\Gamma;\gamma\vdash\varphi\)</span>，那么<spanclass="math inline">\(\Gamma\vdash(\gamma\rightarrow\varphi)\)</span>。</p><ul><li>逆定理也成立，实际上逆定理就是假言推理。</li></ul><h5 id="不和谐">不和谐</h5><p>称一个公式集合是不和谐的当且仅当对某个<spanclass="math inline">\(\beta\)</span>，<spanclass="math inline">\(\beta\)</span>与<spanclass="math inline">\(\neg\beta\)</span>都是这个集合的定理。</p><ul><li>此时任意公式都是该集合的定理，<spanclass="math inline">\(\beta\rightarrow\neg\beta\rightarrow\alpha\)</span>是重言式。</li></ul><h5 id="逆否律">逆否律</h5><p><spanclass="math inline">\(\Gamma;\varphi\vdash\neg\psi\)</span>当且仅当<spanclass="math inline">\(\Gamma;\psi\vdash\neg\varphi\)</span>。</p><h5 id="归谬法">归谬法</h5><p><spanclass="math inline">\(\Gamma;\varphi\)</span>是不和谐的，那么<spanclass="math inline">\(\Gamma\vdash\neg\varphi\)</span>。</p><h3 id="可靠性和完备性理论">4. 可靠性和完备性理论</h3><p>可靠性定理：<spanclass="math inline">\(\Gamma\vdash\varphi\Rightarrow\Gamma\models\varphi\)</span>，可满足的公式集是和谐的。</p><p>完备性定理：<span class="math inline">\(\Gamma\models\varphi\Rightarrow\Gamma\vdash\varphi\)</span>，和谐的公式集是可满足的。</p><h4 id="紧致性定理-2">紧致性定理</h4><ol type="1"><li>如果<spanclass="math inline">\(\Gamma\models\varphi\)</span>，那么存在某个有限的<spanclass="math inline">\(\Gamma_0\subseteq\Gamma\)</span>，有<spanclass="math inline">\(\Gamma_0\models\varphi\)</span>。</li><li>如果<span class="math inline">\(\Gamma\)</span>的每个有限子集<spanclass="math inline">\(\Gamma_0\)</span>都是有限可满足的，那么<spanclass="math inline">\(\Gamma\)</span>是可满足的。</li></ol><p>特别地，句子集<spanclass="math inline">\(\Sigma\)</span>有模型当且仅当其每个有限子集有模型。</p><h4 id="可枚举定理">可枚举定理</h4><p>对合理的语言，恒真合式公式集合是能行可枚举的。</p><ul><li>合理的语言指其参数集合能行可枚举。</li></ul><h3 id="理论的模型">5. 理论的模型</h3><p>理论是逻辑蕴涵意义下封闭的句子集合。</p><p>结构<span class="math inline">\(\mathfrak A\)</span>的理论，记作<spanclass="math inline">\(Th\;\mathfrak A\)</span>，是<spanclass="math inline">\(\mathfrak A\)</span>中为真的所有句子的集合。</p><p>句子集合<spanclass="math inline">\(\Sigma\)</span>逻辑蕴涵的所有句子的集合是它的推论集，记作<spanclass="math inline">\(Cn\Sigma=\{\sigma|\Sigma\models\sigma\}=Th\;Mod\;\Sigma\)</span>。</p><p>理论T称为是完备的，当且仅当对每个句子<spanclass="math inline">\(\sigma\)</span>，<spanclass="math inline">\(\sigma\in T\)</span>或者<spanclass="math inline">\(\neg\sigma\in T\)</span>。</p><p>理论T是可公理化的，当且仅当存在可判定的句子集合<spanclass="math inline">\(\Sigma\)</span>，使得<spanclass="math inline">\(T=Cn\Sigma\)</span>。</p><p>理论T是有限可公理化的，当且仅当存在可判定的有限句子集合<spanclass="math inline">\(\Sigma\)</span>，使得<spanclass="math inline">\(T=Cn\Sigma\)</span>。</p><p>一个可公理化的理论是能行可枚举的。</p><p>完备的可公理化理论是可判定的。</p><h2 id="四不可判定性">四、不可判定性</h2><p>数论语言是包含=和以下参数的一阶语言：</p><ul><li><span class="math inline">\(\forall\)</span>：对任意自然数</li><li><span class="math inline">\(\mathbf 0\)</span>：常数符号</li><li><span class="math inline">\(S\)</span>：后继函数</li><li><span class="math inline">\(\lt\)</span>：二元谓词符号</li><li><span class="math inline">\(+,·,E\)</span>：加法、乘法和幂乘</li></ul><p>数论的结构可以写作<span class="math inline">\(\mathfrakN=(\N;0,S,\lt,+,·,E)\)</span></p><p>这个模型的理论<span class="math inline">\(Th\;\mathfrakN\)</span>就是数论。</p><h3 id="可表示性">1. 可表示性</h3><p>一个关系在T中是可表示的，当且仅当存在一个公式，它在T中表示该关系。</p><h4 id="丘奇论题">丘奇论题</h4><p>设T是一个可公理化的和谐理论，R在T中可表示，则R是可判定的。</p><p>丘奇论题：自然数上的关系R是递归的，当且仅当R在某个有限可公理化的和谐理论中可表示。</p><ul><li>一个关系是可判定的当且仅当它是递归的。</li></ul><h4 id="可计算性">可计算性</h4><p>函数<spanclass="math inline">\(f:\N^k\rightarrow\N\)</span>是可计算的，当且仅当对于给定的k元自然数组<spanclass="math inline">\(\vec a\)</span>，存在一个能行的过程给出<spanclass="math inline">\(f(\vec a)\)</span>的值。</p><ul><li><p>对于函数<spanclass="math inline">\(f:\N^k\rightarrow\N\)</span>，以下三个论述等价</p><ol type="a"><li><p>f是可计算的</p></li><li><p>f是可判定的</p></li><li><p>f是能行可枚举的</p></li></ol></li></ul><h4 id="可表示函数">可表示函数</h4><p>设<span class="math inline">\(g\)</span>是n元函数，<spanclass="math inline">\(h_1,...,h_n\)</span>是m元函数，<spanclass="math inline">\(f\)</span>由下式定义：</p><p><spanclass="math inline">\(f(a_1,...,a_m)=g(h_1(a_1,...,a_m),...,h_n(a_1,...,a_m))\)</span></p><p>如果<spanclass="math inline">\(g,h_1,...,h_n\)</span>是可函数表示的，那么可以找到一个公式函数表示<spanclass="math inline">\(f\)</span>。</p><h3 id="不完全性和不可判定性">2. 不完全性和不可判定性</h3><h4 id="不动点引理">不动点引理</h4><p>对于只含有自由变元<span class="math inline">\(v_1\)</span>的公式<spanclass="math inline">\(\beta\)</span>，可以找到句子<spanclass="math inline">\(\sigma\)</span>使得<spanclass="math inline">\(\vdash[\sigma\leftrightarrow\beta(S^{\#\sigma}0)]\)</span>。</p><p>塔斯基不可定义定理：集合<span class="math inline">\(\#Th\;\mathfrakN\)</span>在<span class="math inline">\(\mathfrakN\)</span>中是不可定义的。</p><h4 id="哥德尔不完全性定理">哥德尔不完全性定理</h4><p>如果<span class="math inline">\(A\in Th\;\mathfrakN\)</span>，并且<spanclass="math inline">\(\#A\)</span>是递归的，则<spanclass="math inline">\(Cn\;A\)</span>不是一个完全理论。</p><h4 id="丘奇定理">丘奇定理</h4><p>在数论语言中，取值为真的句子的哥德尔数的集合不是递归的。</p><h4 id="递归可枚举">递归可枚举</h4><p>自然数上的一个关系是递归可枚举的，当且仅当它具有形式<spanclass="math inline">\(\{\vec a|\exist b\lang\vec a,b\rang\inQ\}\)</span>，其中Q是递归的。</p><ul><li>以下关于m元关系R的结论等价：<ul><li>R是递归可枚举的</li><li>R是某个递归函数Q的定义域</li><li>对于某个递归的(m+1)元关系Q，<span class="math inline">\(R=\{\langa_1,...,a_m\rang|\exist b_1,...,b_n\lang a_1,...,a_m,b_1,...,b_n\rang\inQ\}\)</span></li></ul></li></ul><h3 id="递归函数">3. 递归函数</h3><h4 id="部分函数和全函数">部分函数和全函数</h4><p>m元部分函数是指<spanclass="math inline">\(dom\;f\subseteq\N^m\)</span>且<spanclass="math inline">\(ran\;f\subseteq\N\)</span>的函数<spanclass="math inline">\(f\)</span>，对<span class="math inline">\(\veca\notin dom\;f\)</span>，称<span class="math inline">\(f(\veca)\)</span>无定义。</p><p>如果<span class="math inline">\(dom\;f=\N^m\)</span>，称<spanclass="math inline">\(f\)</span>为全函数。</p><p>m元部分函数<spanclass="math inline">\(f\)</span>是<strong>可计算的</strong>当且仅当存在一个可行的过程使得：</p><ol type="1"><li>对于<span class="math inline">\(dom\;f\)</span>中的m元组<spanclass="math inline">\(\vec a\)</span>，这个过程能够得出<spanclass="math inline">\(f(\vec a)\)</span>，并且</li><li>对于不在<span class="math inline">\(dom\;f\)</span>中的<spanclass="math inline">\(\vec a\)</span>，这个过程没有输出值。</li></ol><p>m元部分函数<spanclass="math inline">\(f\)</span>是可计算的当且仅当<spanclass="math inline">\(f\)</span>作为关系是能行可枚举的。</p><h4 id="范式定理">范式定理</h4><p>在<span class="math inline">\(\lange,a_1,...,a_m\rang\)</span>的值是<spanclass="math inline">\([[e]]_m(a_1,...,a_m)\)</span>的m+1元部分函数是部分递归函数。</p><ul><li>对于每个<span class="math inline">\(e\ge0\)</span>，<spanclass="math inline">\([[e]]_m\)</span>是部分递归函数。</li><li>对于任意m元部分递归函数，都存在某个e，使得这个部分递归函数等于<spanclass="math inline">\([[e]]_m\)</span>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数理逻辑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑_2_一阶逻辑</title>
    <link href="/2023/08/03/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/2_%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91/"/>
    <url>/2023/08/03/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/2_%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<p>飞流直下三千尺，疑是银河落九天。</p><span id="more"></span><h1 id="第二章-一阶逻辑">第二章 一阶逻辑</h1><h2 id="一阶语言">2.1 一阶语言</h2><h3 id="公式">公式</h3><p>表达式是符号的任意有限序列。</p><ul><li>大多数表达式是没有意义的，但是项和合式公式是具有特定意义的表达式。</li></ul><p>项是语言中的名词和代词，是可以翻译成对象名称的表达式。</p><ul><li>项定义为在常数符号和变量之前加上函数符号构成的表达式。<ul><li>如果没有函数符号，那么项就是常数符号和变量。</li></ul></li><li>项的集合是由常数符号和变量通过使用0次和多次运算<spanclass="math inline">\(F_f\)</span>得到的表达式的集合。</li></ul><p>原子公式是指那些没有使用联结符号和量词符号的合式公式。</p><ul><li>原子公式由n元谓词符号和n个项组成。</li></ul><p>合式公式的集合是由原子公式通过0次或多次使用<spanclass="math inline">\(\varepsilon_\neg,\varepsilon_\rightarrow\)</span>和<spanclass="math inline">\(Q_i(i=1,2,...)\)</span>运算构成的表达式的集合。</p><h3 id="自由变量">自由变量</h3><p>考虑任意变量x，对每一个合式公式<spanclass="math inline">\(\alpha\)</span>，x在<spanclass="math inline">\(\alpha\)</span>中自由出现的递归定义：</p><ol type="1"><li>对原子公式<span class="math inline">\(\alpha\)</span>，x在<spanclass="math inline">\(\alpha\)</span>中自由出现当且仅当x出现在<spanclass="math inline">\(\alpha\)</span>中</li><li>x在<spanclass="math inline">\((\neg\alpha)\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>中自由出现</li><li>x在<spanclass="math inline">\((\alpha\rightarrow\beta)\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>或<spanclass="math inline">\(\beta\)</span>中自由出现</li><li>x在<span class="math inline">\(\forallv_i\alpha\)</span>中自由出现当且仅当x在<spanclass="math inline">\(\alpha\)</span>中自由出现且<spanclass="math inline">\(x\neq v_i\)</span></li></ol><p>如果合式公式<spanclass="math inline">\(\alpha\)</span>中没有自由变量出现，那么<spanclass="math inline">\(\alpha\)</span>就是一个句子。</p><h3 id="符号">符号</h3><p>可以用显式书写每一个符号的方式来指定一个合式公式。</p><p>惯用的缩写和记法：</p><ul><li><p><span class="math inline">\((\alpha\or\beta)\)</span>简化<spanclass="math inline">\(((\neg\alpha)\rightarrow\beta)\)</span></p></li><li><p><span class="math inline">\((\alpha\and\beta)\)</span>简化<spanclass="math inline">\((\neg(\alpha\rightarrow(\neg\beta)))\)</span></p></li><li><p><spanclass="math inline">\((\alpha\leftrightarrow\beta)\)</span>简化<spanclass="math inline">\(((\alpha\rightarrow\beta)\and(\beta\rightarrow\alpha))\)</span></p></li><li><p><span class="math inline">\(\exist x\alpha\)</span>简化<spanclass="math inline">\((\neg\forall x(\neg\alpha))\)</span></p></li><li><p>最外层的括号可以省略</p></li><li><p>尽量少使用<spanclass="math inline">\(\neg，\rightarrow\)</span>和<spanclass="math inline">\(\exist，\or，\and\)</span></p></li><li><p>当联结符号重复出现，表达式从右边开始分组</p></li></ul><h2 id="真值与模型">2.2 真值与模型</h2><p>一阶语言的结构指明：</p><ul><li><p>全称量词所指的事物集合</p></li><li><p>其他参数（谓词和函数符号）的含义</p></li></ul><p>形式上，一阶语言的一个<strong>结构</strong><spanclass="math inline">\(\mathfrak{A}\)</span>是一个函数，其定义域为参数的集合，且满足</p><ol type="1"><li><span class="math inline">\(\mathfrak{A}\)</span>为全称量词<spanclass="math inline">\(\forall\)</span>指派一个非空集合<spanclass="math inline">\(|\mathfrak{A}|\)</span>，称为<spanclass="math inline">\(\mathfrak{A}\)</span>的论域或者定义域</li><li><spanclass="math inline">\(\mathfrak{A}\)</span>为每一个n元谓词符号P指派一个n元关系，<spanclass="math inline">\(P^\mathfrak{A}\subseteq|\mathfrak{A}|^n\)</span>，即<spanclass="math inline">\(P^\mathfrak{A}\)</span>是P上一个n元组的集合</li><li><spanclass="math inline">\(\mathfrak{A}\)</span>给每个常数符号c指派一个论域<spanclass="math inline">\(|\mathfrak{A}|\)</span>中的元素<spanclass="math inline">\(c^\mathfrak{A}\)</span></li><li><spanclass="math inline">\(\mathfrak{A}\)</span>给每个n元函数符号f指派一个<spanclass="math inline">\(|\mathfrak{A}|\)</span>上的n元运算<spanclass="math inline">\(f^\mathfrak{A}:|\mathfrak{A}|^n\rightarrow|\mathfrak{A}|\)</span></li></ol><p>称一个结构是这个句子的<strong>模型</strong>，当使用该结构可以将形式语言的句子翻译为真的自然语言。</p><p><spanclass="math inline">\(\models_\mathfrak{A}\sigma\)</span>（句子<spanclass="math inline">\(\sigma\)</span>在结构<spanclass="math inline">\(\mathfrak{A}\)</span>中是真的）的定义：</p><p>令<spanclass="math inline">\(\varphi\)</span>是语言中的合式公式，<spanclass="math inline">\(\mathfrak{A}\)</span>是语言的结构，<spanclass="math inline">\(s:V\rightarrow|\mathfrak{A}|\)</span>是从集合V的所有变量到A的论域<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数。那么定义对于<spanclass="math inline">\(\mathfrak{A}\)</span>，s满足<spanclass="math inline">\(\varphi\)</span>的含义为<spanclass="math inline">\(\models_\mathfrak{A} \varphi[s]\)</span>。</p><ul><li><p>假定<span class="math inline">\(s_1\)</span>和<spanclass="math inline">\(s_2\)</span>是从<spanclass="math inline">\(V\)</span>到<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数，它们在合式公式<spanclass="math inline">\(\varphi\)</span>中自由出现的所有变量上取值相同，那么<spanclass="math inline">\(\models_\mathfrak{A} \varphi[s_1]\quad iff\quad\models_\mathfrak{A}\varphi[s_2]\)</span></p></li><li><p>对每个句子<spanclass="math inline">\(\sigma\)</span>，以下必有一条被满足：</p><ul><li><span class="math inline">\(\mathfrak{A}\)</span>以每个从V到<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数S满足<spanclass="math inline">\(\sigma\)</span></li><li><spanclass="math inline">\(\mathfrak{A}\)</span>无法以任何一个从V到<spanclass="math inline">\(|\mathfrak{A}|\)</span>的函数满足<spanclass="math inline">\(\sigma\)</span></li></ul><p>如果前者成立，称<span class="math inline">\(\sigma\)</span>在<spanclass="math inline">\(\mathfrak{A}\)</span>中是真的，即<spanclass="math inline">\(\mathfrak{A}\)</span>是<spanclass="math inline">\(\sigma\)</span>的模型，反之则是假的。</p></li><li><p><spanclass="math inline">\(\mathfrak{A}\)</span>是句子集合的模型当且仅当<spanclass="math inline">\(\mathfrak{A}\)</span>是句子集合中每个句子的模型。</p></li></ul><h3 id="逻辑蕴涵">逻辑蕴涵</h3><p>设<span class="math inline">\(\Gamma\)</span>是合式公式的集合，<spanclass="math inline">\(\varphi\)</span>是一个合式公式，那么<spanclass="math inline">\(\Gamma\)</span>逻辑蕴涵<spanclass="math inline">\(\varphi\)</span>，记作<spanclass="math inline">\(\Gamma\models\varphi\)</span>，当且仅当对语言的每个结构<spanclass="math inline">\(\mathfrak{A}\)</span>和每个函数<spanclass="math inline">\(s:V\rightarrow|\mathfrak{A}|\)</span>，使得<spanclass="math inline">\(\mathfrak{A}\)</span>以s满足<spanclass="math inline">\(\Gamma\)</span>的每个元素，<spanclass="math inline">\(\mathfrak{A}\)</span>也以s满足<spanclass="math inline">\(\varphi\)</span>。</p><ul><li>对句子集合<spanclass="math inline">\(\Sigma;\tau,\Sigma\models\tau\)</span>当且仅当<spanclass="math inline">\(\Sigma\)</span>的每个模型也是<spanclass="math inline">\(\tau\)</span>中的模型。句子<spanclass="math inline">\(\tau\)</span>是恒真的当且仅当其在每个结构下都是真的。</li></ul><h3 id="结构的可定义性">结构的可定义性</h3><p>论域上子集的可定义性：</p><p>结构<span class="math inline">\(\mathfrak{A}\)</span>和合式公式<spanclass="math inline">\(\varphi\)</span>，其自由变元在<spanclass="math inline">\(v_1,...,v_k\)</span>之中，那么可以构建<spanclass="math inline">\(|\mathfrak{A}|\)</span>上的k元关系<spanclass="math inline">\(\{|&lt;a_1,...,a_k&gt;|\models_\mathfrak{A}\varphi[a_1,...,a_k]\}\)</span>，称此k元关系是在<spanclass="math inline">\(\mathfrak{A}\)</span>中由<spanclass="math inline">\(\varphi\)</span>定义的。</p><ul><li>一般地，<spanclass="math inline">\(|\mathfrak{A}|\)</span>上的k元关系在<spanclass="math inline">\(\mathfrak{A}\)</span>中是可定义的当且仅当存在能够定义它的一个公式。</li></ul><p>对句子集<span class="math inline">\(\Sigma\)</span>，用<spanclass="math inline">\(Mod\;\Sigma\)</span>表示<spanclass="math inline">\(\Sigma\)</span>的所有模型组成的类，即某种语言的所有结构的类，在这种语言中<spanclass="math inline">\(\Sigma\)</span>的每个元素都是真的。对单个句子<spanclass="math inline">\(\tau\)</span>，我们简单记作<spanclass="math inline">\(Mod\;\tau\)</span>，而不用<spanclass="math inline">\(Mod\{\tau\}\)</span>。</p><p>语言的结构类K是<strong>初等类</strong>(elementary class，<spanclass="math inline">\(EC\)</span>)，当且仅当对某个句子<spanclass="math inline">\(\tau\)</span>，<spanclass="math inline">\(K=Mod\;\tau\)</span>。K是广义初等类(elementaryclass in wider sense，<spanclass="math inline">\(EC_\Delta\)</span>)当且仅当对某个句子集合<spanclass="math inline">\(\Sigma\)</span>，<spanclass="math inline">\(K=Mod\;\Sigma\)</span>。</p><h3 id="同态">同态</h3><p>从<span class="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>的一个<strong>同态</strong>是一个函数<spanclass="math inline">\(h:|\mathfrak{A}|\rightarrow|\mathfrak{B}|\)</span>，具有下列性质：</p><ul><li><p>对每个n元谓词参数<span class="math inline">\(P\)</span>和<spanclass="math inline">\(|\mathfrak{A}|\)</span>中元素的任意n元组<spanclass="math inline">\(&lt;a_1,...,a_n&gt;\)</span></p><p><span class="math inline">\(&lt;a_1,...,a_n&gt;\in P^\mathfrak{A}\;iff\;&lt;h(a_1),...,h(a_n)&gt;\in P^\mathfrak{B}\)</span></p></li><li><p>对每个n元函数符号f和任意n元组</p><p><spanclass="math inline">\(h(f^\mathfrak{A}(a_1,...,a_n))=f^\mathfrak{B}(h(a_1),...,h(a_n))\)</span></p></li><li><p>对于常数符号c，<spanclass="math inline">\(h(c^A)=c^\mathfrak{B}\)</span></p></li></ul><p>如果h是一对一的，那么这种同态称为<spanclass="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>中的<strong>同构</strong>。</p><p>如果存在<span class="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>上的同构，那么<spanclass="math inline">\(\mathfrak{A}\)</span>和<spanclass="math inline">\(\mathfrak{B}\)</span>称作是同构的，记作<spanclass="math inline">\(A\cong \mathfrak{B}\)</span>。</p><h4 id="同态定理">同态定理</h4><p>同态定理：设h是从<spanclass="math inline">\(\mathfrak{A}\)</span>到<spanclass="math inline">\(\mathfrak{B}\)</span>中的同态，s将变量的集合映射到<spanclass="math inline">\(|\mathfrak{B}|\)</span>中。</p><ul><li><p>对每个项t，我们有<spanclass="math inline">\(h(\overline{s}(t))=h\overline{\circ}s(t)\)</span>，其中<spanclass="math inline">\(\overline{s}(t)\)</span>是在<spanclass="math inline">\(\mathfrak{B}\)</span>中计算的，而<spanclass="math inline">\(h\overline{\circ}s(t)\)</span>是在<spanclass="math inline">\(\mathfrak{B}\)</span>中计算的。</p></li><li><p>对每个不包含等于符号的无量词的公式<spanclass="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\alpha[s]\;iff\;\models_\mathfrak{B}\alpha[h\circs]\)</span></p></li><li><p>如果h是一对一的，那么对每个无量词的公式<spanclass="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\alpha[s]\;iff\;\models_\mathfrak{B}\alpha[h\circs]\)</span></p></li><li><p>第二、三条可以删去无量词</p></li></ul><p>称两个结构<span class="math inline">\(\mathfrak{A}\)</span>和<spanclass="math inline">\(\mathfrak{B}\)</span>是初等等价的，记作<spanclass="math inline">\(\mathfrak{A}\equiv\mathfrak{B}\)</span>，当且仅当对任意的句子<spanclass="math inline">\(\sigma\)</span>，<spanclass="math inline">\(\models_\mathfrak{A}\sigma\Leftrightarrow\models_\mathfrak{B}\sigma\)</span>。</p><ul><li>同构的结构是初等等价的。</li></ul><p>设h是A的自同构，R是|A|上的n元关系，那么对|A|中任意的<spanclass="math inline">\(a_1,...,a_n\)</span>，<spanclass="math inline">\(&lt;a_1,...,a_n&gt;\inR\Leftrightarrow&lt;h(a_1),...,h(a_n)&gt;\in R\)</span>。</p><h2 id="解析算法">2.3 解析算法</h2><h3 id="项的解析">项的解析</h3><p>定义符号函数K，使得对符号s，<spanclass="math inline">\(K(s)=1-n\)</span>，其中n是项的个数。</p><p><span class="math inline">\(K(x)=1-0=1\)</span>，对变量x；</p><p><span class="math inline">\(K(c)=1-0=1\)</span>，对常数符号c；</p><p><span class="math inline">\(K(f)=1-n\)</span>，对n元函数符号f；</p><p>通过如下方式将K扩充到表达式的集合：<spanclass="math inline">\(K(s_1s_2...s_n)=K(s_1)+...+K(s_n)\)</span></p><ul><li><p>对于任意项t，<span class="math inline">\(K(t)=1\)</span></p></li><li><p>项的任意终段是一个或者多个项的连接</p></li><li><p>一个项的任意真的初始段都不是项，如果<spanclass="math inline">\(t_1\)</span>是<spanclass="math inline">\(t\)</span>的真的初始段，那么<spanclass="math inline">\(K(t_1)\lt 1\)</span></p></li></ul><p>项的唯一可解释性定理：项集是由变量集和常数符号通过<spanclass="math inline">\(F_f\)</span>运算自由生成的。</p><h3 id="公式解析">公式解析</h3><p><span class="math inline">\(K(()=-1\)</span>；</p><p><span class="math inline">\(K())=1\)</span>；</p><p><span class="math inline">\(K(\forall)=-1\)</span>；</p><p><span class="math inline">\(K(\neg)=0\)</span>；</p><p><span class="math inline">\(K(\rightarrow)=-1\)</span>；</p><p><span class="math inline">\(K(=)=-1\)</span>；</p><p><span class="math inline">\(K(P)=1-n\)</span>，对n元谓词符号P。</p><p>对于任意合式公式<span class="math inline">\(\alpha\)</span>，<spanclass="math inline">\(K(\alpha)=1\)</span></p><ul><li><p>对于合式公式<spanclass="math inline">\(\alpha\)</span>的任意真的初始段<spanclass="math inline">\(\alpha&#39;\)</span>，<spanclass="math inline">\(K(\alpha&#39;)\lt 1\)</span></p></li><li><p>公式的任何真的初始段都不是公式</p></li></ul><p>公式的唯一可解释性定理：合式公式的结合是由原子公式通过<spanclass="math inline">\(\varepsilon_\neg,\varepsilon_\rightarrow,Q_i\)</span>运算自由生成的</p><h2 id="演绎计算">2.4 演绎计算</h2><p>证明应该是：</p><ul><li><p>有限长的；</p></li><li><p>能够进行验证的；</p></li></ul><p>无假设条件的可证明的公式集合必须是能行可枚举的。</p><h3 id="形式演绎">2.4.1 形式演绎</h3><p>选择一个有限的公式集合<spanclass="math inline">\(\Lambda\)</span>，称之为逻辑公理；</p><p>制定推理规则，这些规则可以使我们从某些公式获得新的公式。</p><p>对于公式集合<span class="math inline">\(\Gamma\)</span>，<spanclass="math inline">\(\Gamma\)</span>的<strong>定理</strong>是指由<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>中的公式通过有限次使用推理规则得到的公式。</p><ul><li><p>公式<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\Gamma\)</span>的定理，记作<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>。</p><p>为了得到公式<span class="math inline">\(\varphi\)</span>，由<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>使用推理规则的公式序列称为从<spanclass="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的一个演绎。</p></li></ul><p>我们选择的推理规则是假言推理。</p><h4 id="假言推理">假言推理</h4><p>从公式<span class="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\alpha\rightarrow\beta\)</span>，可以得到<spanclass="math inline">\(\beta\)</span>：<spanclass="math inline">\(\frac{\alpha,\alpha\rightarrow\beta}{\beta}\)</span>。</p><h4 id="演绎">演绎</h4><p>从<span class="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的一个演绎是一个有限的公式序列<spanclass="math inline">\(&lt;\alpha_0,...,\alpha_n&gt;\)</span>，使得<spanclass="math inline">\(\alpha_n=\varphi\)</span>，且对每个<spanclass="math inline">\(k\le n\)</span>，或者</p><ul><li><p><span class="math inline">\(\alpha_k\)</span>在<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>中</p></li><li><p><spanclass="math inline">\(\alpha_k\)</span>可以由序列中出现在该公式之前的两个公式通过假言推理得到，即：</p><p>对于小于k的i和j，<span class="math inline">\(\alpha_j\)</span>是<spanclass="math inline">\(\alpha_i\rightarrow\alpha_k\)</span>。</p></li></ul><p>如果存在这样的演绎，则称<spanclass="math inline">\(\varphi\)</span>是由<spanclass="math inline">\(\Gamma\)</span>可演绎推出的，或者<spanclass="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\Gamma\)</span>的定理，记作<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>。</p><ul><li><p>从<span class="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的一个演绎可以看作是一个构造序列。</p></li><li><p>一个定理不只有一个唯一的演绎。</p></li></ul><h4 id="归纳原理">归纳原理</h4><p>设S是包含<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>的合式公式的集合，并且在假言推理下封闭，那么S包含<spanclass="math inline">\(\Gamma\)</span>的所有定理。</p><h4 id="逻辑公理">逻辑公理</h4><p>任意合式公式都是其自身的一个概化，逻辑公理都是如下形式合式公式的概化，其中x和y都是变量，<spanclass="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>都是合式公式。</p><ol type="1"><li>重言式</li><li><span class="math inline">\(\forallx\alpha\rightarrow\alpha_t^x\)</span>，其中t为x在<spanclass="math inline">\(\alpha\)</span>中的替换</li><li><span class="math inline">\(\forallx(\alpha\rightarrow\beta)\rightarrow(\forall x\alpha\rightarrow\forallx\beta)\)</span></li><li><span class="math inline">\(\alpha\rightarrow\forallx\alpha\)</span>，其中x在<spanclass="math inline">\(\alpha\)</span>中不是自由出现的</li></ol><p>如果语言包含相等符号则还要加上两组：</p><ol start="5" type="1"><li><span class="math inline">\(x=x\)</span></li><li><spanclass="math inline">\(x=y\rightarrow(\alpha\rightarrow\alpha&#39;)\)</span>，其中<spanclass="math inline">\(\alpha\)</span>是原子的且<spanclass="math inline">\(\alpha&#39;\)</span>是有限次的将<spanclass="math inline">\(\alpha\)</span>中的x替换为y的到的。</li></ol><p>合式公式<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\psi\)</span>的<strong>概化</strong>当且仅当对某个<spanclass="math inline">\(n\ge0\)</span>和某些变量<spanclass="math inline">\(x_1,...,x_n\)</span>，<spanclass="math inline">\(\varphi=\forall x_1...\forallx_n\psi\)</span>。</p><h4 id="替换">替换</h4><p>替换的递归定义：</p><ol type="1"><li>对原子公式<span class="math inline">\(\alpha\)</span>，<spanclass="math inline">\(\alpha_t^x\)</span>是将公式<spanclass="math inline">\(\alpha\)</span>中自由出现的变量x都替换为t所得到的表达式。</li><li><spanclass="math inline">\((\neg\alpha)_t^x=(\neg\alpha_t^x)\)</span></li><li><spanclass="math inline">\((\alpha\rightarrow\beta)_t^x=(\alpha_t^x\rightarrow\beta_t^x)\)</span></li><li><span class="math inline">\((\forall y\alpha)_t^x=\begin{cases}\forall y\alpha\quad 如果x=y\\ \forall y(\alpha_t^x)\quad 如果x\neq y\end{cases}\)</span></li></ol><p>可替换的递归定义</p><ol type="1"><li><p>对原子公式<span class="math inline">\(\alpha\)</span>，在<spanclass="math inline">\(\alpha\)</span>中t可以替换x。</p></li><li><p>在<spanclass="math inline">\((\neg\alpha)\)</span>中t可以替换x当且仅当在<spanclass="math inline">\(\alpha\)</span>中t可以替换x。在<spanclass="math inline">\((\alpha\rightarrow\beta)\)</span>中t可以替换x当且仅当在<spanclass="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>中t都可以替换x。</p></li><li><p>在<span class="math inline">\(\forally\alpha\)</span>中t可以替换x当且仅当</p><ul><li>x在<span class="math inline">\(\forally\alpha\)</span>中不是自由出现的；或</li><li>y在t中不出现且在<spanclass="math inline">\(\alpha\)</span>中t可以替换x。</li></ul></li></ol><h4 id="重言式">重言式</h4><p>基本公式：原子公式和形式为<span class="math inline">\(\forallx\alpha\)</span>的公式。</p><ul><li>任何公式都可以由基本公式通过<spanclass="math inline">\(\epsilon_\neg\)</span>和<spanclass="math inline">\(\epsilon_\rightarrow\)</span>的运算构造。</li><li>第一组公理都是命题逻辑重言式的概化。</li></ul><p>定理：<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>当且仅当<spanclass="math inline">\(\Gamma\cup\Lambda\)</span>重言蕴涵<spanclass="math inline">\(\varphi\)</span>。</p><h3 id="演绎与元定理">2.4.2 演绎与元定理</h3><p>自然语言中的定理称为<strong>元定理</strong>。</p><h4 id="概化定理">概化定理</h4><p>如果<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>且x不在<spanclass="math inline">\(\Gamma\)</span>的任何公式中自由出现，那么<spanclass="math inline">\(\Gamma\vdash\forall x\varphi\)</span>。</p><p>引理（规则T）：如果<spanclass="math inline">\(\Gamma\vdash\alpha_1,...,\Gamma\vdash\alpha_n\)</span>，且<spanclass="math inline">\(\{\alpha_1,...,\alpha_n\}\)</span>重言蕴涵<spanclass="math inline">\(\beta\)</span>，那么<spanclass="math inline">\(\Gamma\vdash\beta\)</span>。</p><h4 id="演绎定理">演绎定理</h4><p>如果<spanclass="math inline">\(\Gamma;\gamma\vdash\varphi\)</span>，那么<spanclass="math inline">\(\Gamma\vdash(\gamma\rightarrow\varphi)\)</span>。</p><ul><li>逆定理也成立，实际上逆定理就是假言推理。</li></ul><h5 id="逆否律">逆否律</h5><p><spanclass="math inline">\(\Gamma;\varphi\vdash\neg\psi\)</span>当且仅当<spanclass="math inline">\(\Gamma;\psi\vdash\neg\varphi\)</span>。</p><ul><li>证明：<ul><li>由演绎定理，<spanclass="math inline">\(\Gamma;\varphi\vdash\neg\psi\Rightarrow\Gamma\vdash\varphi\rightarrow\neg\psi\)</span></li><li>由规则T，又<spanclass="math inline">\(\varphi\rightarrow\neg\psi\)</span>重言蕴涵<spanclass="math inline">\(\psi\rightarrow\neg\varphi\)</span>，上式<spanclass="math inline">\(\Rightarrow\Gamma\vdash\psi\rightarrow\neg\varphi\)</span></li><li>由假言推理，上式<spanclass="math inline">\(\Rightarrow\Gamma;\psi\vdash\neg\varphi\)</span></li></ul></li></ul><h5 id="不和谐">不和谐</h5><p>称一个公式集合是不和谐的当且仅当对某个<spanclass="math inline">\(\beta\)</span>，<spanclass="math inline">\(\beta\)</span>与<spanclass="math inline">\(\neg\beta\)</span>都是这个集合的定理。</p><ul><li>此时任意公式都是该集合的定理，<spanclass="math inline">\(\beta\rightarrow\neg\beta\rightarrow\alpha\)</span>是重言式。</li></ul><h5 id="归谬法">归谬法</h5><p><spanclass="math inline">\(\Gamma;\varphi\)</span>是不和谐的，那么<spanclass="math inline">\(\Gamma\vdash\neg\varphi\)</span>。</p><h3 id="策略">2.4.3 策略</h3><p>对于给定的<span class="math inline">\(\Gamma\)</span>和<spanclass="math inline">\(\varphi\)</span>，证明<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>的策略：</p><ul><li>穷举合式公式的有限序列直到发现一个<spanclass="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\varphi\)</span>的演绎</li><li>在自然语言中给出<spanclass="math inline">\(\Gamma\)</span>的真值蕴涵<spanclass="math inline">\(\varphi\)</span>的真值的证明，再形式化为形式语言</li><li>仅基于<span class="math inline">\(\varphi\)</span>的语法形式：<ul><li>设<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\((\psi\rightarrow\theta)\)</span>，那么可以证明<spanclass="math inline">\(\Gamma;\psi\vdash\theta\)</span>。</li><li>设<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\forall x\psi\)</span>，如果x在<spanclass="math inline">\(\Gamma\)</span>中不是自由出现的，那么可以证明<spanclass="math inline">\(\Gamma\vdash\psi\)</span>。</li><li>设<span class="math inline">\(\varphi\)</span>是某个公式的否定：<ul><li>如果<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\neg(\psi\rightarrow\theta)\)</span>，那么可以证明<spanclass="math inline">\(\Gamma\vdash\psi\)</span>和<spanclass="math inline">\(\Gamma\vdash\neg\theta\)</span></li><li>如果<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\neg\neg\psi\)</span>，那么可以证明<spanclass="math inline">\(\Gamma\vdash\psi\)</span></li><li>如果<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\(\neg\forall x\psi\)</span>，可以证明<spanclass="math inline">\(\Gamma\vdash\neg\psi_t^x\)</span>，其中t是在<spanclass="math inline">\(\psi\)</span>中可替换x的某个项。<ul><li>这并非总是可行的，有可能会出现<spanclass="math inline">\(\Gamma\vdash\neg\forallx\psi\)</span>但对每个项t，<spanclass="math inline">\(\neg(\Gamma\vdash\neg\psi_{t}^x)\)</span></li></ul></li></ul></li></ul></li></ul><h4 id="常数的概化">常数的概化</h4><p>设<spanclass="math inline">\(\Gamma\vdash\varphi\)</span>，且c是不在<spanclass="math inline">\(\Gamma\)</span>中出现的常数符号，那么存在变量y(不出现在<spanclass="math inline">\(\varphi\)</span>)使得<spanclass="math inline">\(\Gamma\vdash\forally\varphi_y^c\)</span>。另外，存在从<spanclass="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\forally\varphi_y^c\)</span>的演绎，在此演绎中不出现c。</p><ul><li><p>推论：设<spanclass="math inline">\(\Gamma\vdash\varphi_c^x\)</span>，其中常数符号c不在<spanclass="math inline">\(\Gamma\)</span>或<spanclass="math inline">\(\varphi\)</span>中出现，那么<spanclass="math inline">\(\Gamma\vdash\forallx\varphi\)</span>，并且存在从<spanclass="math inline">\(\Gamma\)</span>到<spanclass="math inline">\(\forall x\varphi\)</span>的演绎，<spanclass="math inline">\(\Gamma\)</span>中不出现c。</p></li><li><p><span class="math inline">\(EI\)</span>规则：设常数符号c不在<spanclass="math inline">\(\varphi、\psi\)</span>或者<spanclass="math inline">\(\Gamma\)</span>中出现，且<spanclass="math inline">\(\Gamma;\varphi_c^x\vdash\psi\)</span>，那么<spanclass="math inline">\(\Gamma;\existx\varphi\vdash\psi\)</span>，即存在从<spanclass="math inline">\(\Gamma;\exist x\varphi\)</span>到<spanclass="math inline">\(\psi\)</span>的演绎，其中不出现c。</p></li></ul><h4 id="字母变换式的存在性">字母变换式的存在性</h4><p>设<spanclass="math inline">\(\varphi\)</span>是公式，t是项，x是变量，那么可以找到一个公式<spanclass="math inline">\(\varphi&#39;\)</span>(与<spanclass="math inline">\(\varphi\)</span>的不同之处仅在于约束变量的选择)使得：</p><ol type="1"><li><spanclass="math inline">\(\varphi\vdash\varphi&#39;\)</span>且<spanclass="math inline">\(\varphi&#39;\vdash\varphi\)</span></li><li>在<spanclass="math inline">\(\varphi&#39;\)</span>中用t可以替换x</li></ol><p>该公式<span class="math inline">\(\varphi&#39;\)</span>称为<spanclass="math inline">\(\varphi\)</span>的字母变换式。</p><h4 id="相等">相等</h4><p>由<spanclass="math inline">\(v_1=v_2\)</span>给出的关系是自反的、对称的和传递的（也就是等价关系）。</p><h2 id="可靠性与完备性理论">2.5 可靠性与完备性理论</h2><h3 id="演绎计算的可靠性与完备性">演绎计算的可靠性与完备性</h3><p>可靠性定理：<spanclass="math inline">\(\Gamma\vdash\varphi\Rightarrow\Gamma\models\varphi\)</span>。</p><ul><li>引理：逻辑公理都是恒真的。</li></ul><p>完备性定理：<span class="math inline">\(\Gamma\models\varphi\Rightarrow\Gamma\vdash\varphi\)</span>。</p><h4 id="替换引理">替换引理</h4><p>替换<spanclass="math inline">\(\varphi\)</span>和s中的执行结果是等价的。</p><h3 id="完备性定理哥德尔1930">完备性定理（哥德尔，1930）</h3><ol type="a"><li><p>如果<spanclass="math inline">\(\Gamma\models\varphi\)</span>，那么<spanclass="math inline">\(\Gamma\vdash\varphi\)</span></p></li><li><p>任意和谐的公式集都是可满足的</p></li></ol><h3 id="紧致性定理">紧致性定理</h3><ol type="1"><li>如果<spanclass="math inline">\(\Gamma\models\varphi\)</span>，那么存在某个有限的<spanclass="math inline">\(\Gamma_0\subseteq\Gamma\)</span>，有<spanclass="math inline">\(\Gamma_0\models\varphi\)</span>。</li><li>如果<span class="math inline">\(\Gamma\)</span>的每个有限子集<spanclass="math inline">\(\Gamma_0\)</span>都是有限可满足的，那么<spanclass="math inline">\(\Gamma\)</span>是可满足的。</li></ol><p>特别地，句子集<spanclass="math inline">\(\Sigma\)</span>有模型当且仅当其每个有限子集有模型。</p><h3 id="可枚举定理">可枚举定理</h3><p>对合理的语言，恒真合式公式集合是能行可枚举的。</p><p>推论：设<spanclass="math inline">\(\Gamma\)</span>是合理语言的合式公式的可判定集。</p><ol type="1"><li><p><spanclass="math inline">\(\Gamma\)</span>的定理集是能行可枚举的；</p></li><li><p>由<spanclass="math inline">\(\Gamma\)</span>逻辑蕴涵的公式集<spanclass="math inline">\(\{\varphi|\Gamma\models\varphi\}\)</span>是能行可枚举的。</p></li></ol><h2 id="理论的模型">2.6 理论的模型</h2><p>理论是逻辑蕴涵意义下封闭的句子集合。</p><p>结构<span class="math inline">\(\mathfrak A\)</span>的理论，记作<spanclass="math inline">\(Th\;\mathfrak A\)</span>，是<spanclass="math inline">\(\mathfrak A\)</span>中为真的所有句子的集合。</p><p><spanclass="math inline">\(\Sigma\)</span>逻辑蕴涵的所有句子的集合称为它的推论集，记作<spanclass="math inline">\(Cn\Sigma=\{\sigma|\Sigma\models\sigma\}=Th\;Mod\;\Sigma\)</span>。</p><p>理论T称为是完备的，当且仅当对每个句子<spanclass="math inline">\(\sigma\)</span>，<spanclass="math inline">\(\sigma\in T\)</span>或者<spanclass="math inline">\(\neg\sigma\in T\)</span>。</p><p>理论T是可公理化的，当且仅当存在可判定的句子集合<spanclass="math inline">\(\Sigma\)</span>，使得<spanclass="math inline">\(T=Cn\Sigma\)</span>。</p><p>理论T是有限可公理化的，当且仅当存在可判定的有限句子集合<spanclass="math inline">\(\Sigma\)</span>，使得<spanclass="math inline">\(T=Cn\Sigma\)</span>。</p><p>一个可公理化的理论是能行可枚举的。</p><p>完备的可公理化理论是可判定的。</p>]]></content>
    
    
    <categories>
      
      <category>数理逻辑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑_0_集合基础</title>
    <link href="/2023/08/01/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/0_%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/08/01/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/0_%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>飞流直下三千尺，疑是银河落九天。</p><span id="more"></span><h1 id="第零章-集合基础">第零章 集合基础</h1><h2 id="集合论符号">集合论符号</h2><ul><li>“$$”用于表示一个证明的结束。</li><li>“如果···那么···”，即“蕴含”，缩写为“<spanclass="math inline">\(···\Longrightarrow···\)</span>”；“逆蕴含”则为"<spanclass="math inline">\(···\Longleftarrow···\)</span>"。</li><li>“当且仅当”缩写为“<spanclass="math inline">\(iff\)</span>”或符号“<spanclass="math inline">\(\Longleftrightarrow\)</span>”</li><li>“因为”缩写为“<spanclass="math inline">\(\because\)</span>”，因此缩写为“<spanclass="math inline">\(\therefore\)</span>”</li><li>“<span class="math inline">\(x\neq y\)</span>”是“<spanclass="math inline">\(x=y\)</span>”的否定，“<spanclass="math inline">\(x\notin y\)</span>”是“<spanclass="math inline">\(x\in y\)</span>”的否定，类似符号可推广</li></ul><p>集合是指一些对象的全体，这些对象称为集合的元素或成员。</p><ul><li><p><span class="math inline">\(t\in A\)</span>表示t是A的元素，<spanclass="math inline">\(x=y\)</span>表示x和y是同一个元素</p></li><li><p>如果A和B是两个集合，且对于任意元素t都有</p><p><span class="math inline">\(t\in A\quad iff\quad t\in B\)</span></p><p>那么<span class="math inline">\(A=B\)</span>。</p></li></ul><p>集合论的基本思想：集合是由其元素所确定的。</p><p>对于集合A，<spanclass="math inline">\(A;t\)</span>表示一个新的集合，其元素包括A的元素和元素t（可能是新的），即：</p><p><span class="math inline">\(A;t=A\cup \{t\}\)</span></p><p>集合的表示方法：</p><ul><li>列举法，也称为外延表示方法。</li><li>内涵表示方法，即这个集合由具有某些性质P的对象构成</li></ul><p>如果集合A的所有元素都是集合B的元素，我们称A是B的子集，记作<spanclass="math inline">\(A\subseteq B\)</span>。</p><ul><li>任何集合都是其自身的子集，空集是每个集合的子集</li></ul><h2 id="集合">集合</h2><p>对象是人们感觉和思维中确定的某些事物。我们总是使用对象的名来谈论它。</p><ul><li>对象的名称也可以作为对象，这时候我们通常加引号用以区别</li></ul><h3 id="集合的定义">集合的定义</h3><p>康托尔的集合定义：具有某种性质的、确定的、互异的对象所组成的整体。</p><ul><li>确定性：对于任意集合A和任意元素a，a是否是A的元素是客观确定的</li><li>互异性：一个集合中任意两个对象是不相等的</li></ul><p>罗素悖论集合论：不能用更简单的数学概念来给集合下一个确定的定义</p><ul><li>集合的概念是不能定义的</li><li>康托尔的集合定义只是对集合的一个描述</li></ul><p>罗素悖论：<span class="math inline">\(A=\{A:A\notinA\}\)</span>，可以推导出<span class="math inline">\(A\inA\)</span>当且仅当<span class="math inline">\(A\notin A\)</span>。</p><p>这说明弗雷格根据康托尔的表述引入的概括原则（对任意确定的性质P，所有基于性质P的对象组成的群体就是集合）是有问题的。</p><h3 id="公理化">公理化</h3><h4 id="外延公理-extensionality">外延公理 Extensionality</h4><p>如果X和Y有相同元素，则<spanclass="math inline">\(X=Y\)</span>。即</p><p><span class="math inline">\(A=B\quad iff\quad \forall x(x\in A\quadiff\quad x\in B)\)</span></p><h4 id="空集公理">空集公理</h4><p>存在一个集合，它不含任何元素，除此之外的其他集合都称为非空的。</p><p>空集是每个集合的子集。</p><h4 id="分离公理-separation">分离公理 Separation</h4><p>如果<spanclass="math inline">\(\varphi\)</span>是一性质，则对于任意集合A和参数p，存在一个集合<spanclass="math inline">\(B=\{u\in X:\varphi (u,p)\}\)</span>，它包含所有具有这个性质的A中的元素u。</p><ul><li>由外延公理，分离公理中的集合B是唯一确定的。</li></ul><p>Paring无序对公理：对任意a，b，存在一个集合<spanclass="math inline">\(\{a,b\}\)</span>，恰好含有元素a，b。</p><h2 id="关系">关系</h2><h3 id="幂集交集并集">幂集、交集、并集</h3><ul><li><p>集合A的幂集<span class="math inline">\(\RhoA\)</span>的元素是A的所有子集，即：</p><p><span class="math inline">\(\Rho A=\{x|x\subseteq A\}\)</span></p></li><li><p>集合A与B的并集<span class="math inline">\(A\cupB\)</span>是属于A或属于B的元素的集合</p></li><li><p>集合A与B的交集是所有A与B共有的元素的集合</p><ul><li>A与B不相交，当且仅当二者的交集为空集</li></ul></li></ul><p>对于非空集合A，其元素也是集合，有</p><ul><li><span class="math inline">\(\bigcupA=\{x|x属于A的某个元素\}\)</span></li><li><span class="math inline">\(\bigcapA=\{x|x属于A的每个元素\}\)</span></li></ul><h3 id="有序对">有序对</h3><h4 id="有序对的定义">有序对的定义</h4><p>元素x和y的有序对<spanclass="math inline">\(&lt;x,y&gt;\)</span>定义如下：</p><p><span class="math inline">\(&lt;x,y&gt;=&lt;u,v&gt;\quad iff\quadx=u且y=v\)</span></p><p>所有具有上述性质的定义都可以作为有序对的定义。</p><p>其中，一个标准的定义是<spanclass="math inline">\(&lt;x,y&gt;=\{\{x\},\{x,y\} \}\)</span></p><p>有序三元组可以定义为<spanclass="math inline">\(&lt;x,y,z&gt;=&lt;&lt;x,y&gt;,z&gt;\)</span></p><p>更一般地，对于<spanclass="math inline">\(n&gt;1\)</span>可以如下递归地定义n元组：</p><p><spanclass="math inline">\(&lt;x_1,x_2,...,x_{n+1}&gt;=&lt;&lt;x_1,x_2,...,x_n&gt;,x_{n+1}&gt;\)</span></p><p>为方便起见，对于<spanclass="math inline">\(n=1\)</span>，我们定义<spanclass="math inline">\(&lt;x&gt;=x\)</span>；这样上式对于<spanclass="math inline">\(n=1\)</span>也是成立的。</p><h4 id="有限序列">有限序列</h4><p>称S是A中元素的有限序列（有限串）当且仅当对某个正整数n，<spanclass="math inline">\(S=&lt;x_1,...,x_n&gt;\)</span>，其中每个<spanclass="math inline">\(x_i\in A\)</span>。</p><p>S的子段指一个有限序列<spanclass="math inline">\(&lt;x_k,x_{k+1},...,x_{m-1},x_m&gt;,1\leq k\leqm\leq n\)</span></p><ul><li>这个子段是初始段当且仅当<spanclass="math inline">\(k=1\)</span></li><li>这个子段是真子段当且仅当该子段与S不同</li></ul><p>如果<spanclass="math inline">\(&lt;x_1,...,x_n&gt;=&lt;y_1,...,y_n&gt;\)</span>，易证<spanclass="math inline">\(x_i=y_i,1\leq i\leq n\)</span></p><p>如果<spanclass="math inline">\(&lt;x_1,...,x_m&gt;=&lt;y_1,...y_n&gt;\)</span>，未必有<spanclass="math inline">\(m=n\)</span>，因为每个有序三元组也是一个有序对。</p><ul><li>只有当某个<span class="math inline">\(x_i\)</span>本身是<spanclass="math inline">\(y_i\)</span>的一个有限序列，或某个<spanclass="math inline">\(y_i\)</span>本身是<spanclass="math inline">\(x_i\)</span>的一个有限序列时，m和n才不相等。</li></ul><p>引理：如果<spanclass="math inline">\(&lt;x_1,...,x_m&gt;=&lt;y_1,...,y_m,...,y_{m+k}&gt;\)</span>，那么<spanclass="math inline">\(x_1=&lt;y_1,...,y_{k+1}&gt;\)</span></p><h4 id="笛卡尔积">笛卡尔积</h4><p>笛卡尔积<span class="math inline">\(A\times B\)</span>是所有序对<spanclass="math inline">\(&lt;x,y&gt;\)</span>的集合，其中<spanclass="math inline">\(x\in A,y\in B\)</span>，即<spanclass="math inline">\(A\times B=\{&lt;x,y&gt;|x\in A,y\in B\}\)</span></p><p><spanclass="math inline">\(A^n\)</span>表示A中元素构成的所有的n元组组成的集合，比如<spanclass="math inline">\(A^3=(A\times A)\times A\)</span></p><h3 id="关系-1">关系</h3><p>关系是有序对的集合。</p><ul><li>关系R的定义域记为dom R，是所有满足<spanclass="math inline">\(&lt;x,y&gt;\in R\)</span>的元素x的集合</li><li>关系R的值域记作ran R，是所有满足<spanclass="math inline">\(&lt;x,y&gt;\in R\)</span>的元素y的集合</li><li>dom R和ran R并称为R的域，记作fld R</li></ul><p>A上的n元关系是<span class="math inline">\(A_n\)</span>的子集，若<spanclass="math inline">\(n&gt;1\)</span>，它就是一个关系；<spanclass="math inline">\(n=1\)</span>，A上的一元关系只是A的一个子集。</p><ul><li><p>A上的一个特殊的二元关系是恒等关系<spanclass="math inline">\(\{&lt;x,x&gt;|x\in A \}\)</span></p></li><li><p>对于A上的二元关系R和A的一个子集B，R对B的限制指交集<spanclass="math inline">\(R\cap B^n\)</span></p></li></ul><p>对于关系R，定义：</p><ul><li><p>R在A上是自反的，当且仅当对A中每个x都有<spanclass="math inline">\(&lt;x,x&gt;\in R\)</span></p></li><li><p>R是对称的，当且仅当如果<span class="math inline">\(&lt;x,y&gt;\inR\)</span>，则<span class="math inline">\(&lt;y,x&gt;\inR\)</span></p></li><li><p>R是传递的，当且仅当如果<span class="math inline">\(&lt;x,y&gt;\inR,&lt;y,z&gt;\in R\)</span>，则<spanclass="math inline">\(&lt;x,z&gt;\in R\)</span></p></li></ul><p>R在A上满足三分律，当且仅当对A中任意的x和y，如下三种可能有且仅有一种成立：</p><ul><li><span class="math inline">\(&lt;x,y&gt;\in R\)</span></li><li><span class="math inline">\(x=y\)</span></li><li><span class="math inline">\(&lt;y,z&gt;\in R\)</span></li></ul><p>关系R是A上的一个等价关系当且仅当R是A上自反、对称和传递的一个二元关系；</p><p>关系R是A上的一个序关系当且仅当R是传递的且在A上满足三分律。</p><ul><li><p>对于A上的等价关系R盒<span class="math inline">\(x\inA\)</span>，定义x的等价类为<spanclass="math inline">\(\{y|&lt;x,y&gt;\in R\}\)</span></p><p>等价类划分了A，每个等价类都是A的子集，A的每个元素恰好只属于一个等价类。</p></li></ul><p>关系R的逆关系记为<spanclass="math inline">\(R^{-1}\)</span>，定义为<spanclass="math inline">\(R^{-1}=\{&lt;x,y&gt;|&lt;y,x&gt;\inR\}\)</span></p><h3 id="函数">函数</h3><p>一个具有单值性质的关系F，对于定义域domF中的每一个x，都有唯一的y满足<span class="math inline">\(&lt;x,y&gt;\inF\)</span>。通常，这个唯一的y称F在x上的值F(x)。</p><p>我们称F将定义域A映射到值域B，F是一个函数。</p><ul><li><p>F是一个一一映射当且仅当对于B中的每个y，存在唯一的x使得<spanclass="math inline">\(&lt;x,y&gt;\in F\)</span></p></li><li><p>如果<span class="math inline">\(&lt;x,y&gt;\)</span>在定义域domF中，则记<spanclass="math inline">\(F(x,y)=F(&lt;x,y&gt;)\)</span></p></li><li><p>这个记法可以推广到n元</p></li></ul><p>A上的n元运算是一个将<spanclass="math inline">\(A^n\)</span>映射到A中的函数。</p><h3 id="偏序关系">偏序关系</h3><p>序的一般理论：</p><p>设A为一个集合，R是A上的二元关系，称R为A上的偏序关系，如果满足如下条件：</p><ul><li><p>R具有自反性</p></li><li><p>R具有反对称性，且对任意<span class="math inline">\(x,y\inR\)</span>，如果<span class="math inline">\(xRy\)</span>且<spanclass="math inline">\(yRx\)</span>，则<spanclass="math inline">\(x=y\)</span></p></li><li><p>R具有传递性</p></li></ul><p>设A为一个集合，R是A上的二元关系，称R为A上的严格偏序关系，如果满足如下条件：</p><ul><li><p>R具有禁自反性，即任意x属于A都有非<spanclass="math inline">\(R(x,x)\)</span></p></li><li><p>R具有禁对称性，且对任意<span class="math inline">\(x,y\inA\)</span>，如果<span class="math inline">\(R(x,y)\)</span>，则非<spanclass="math inline">\(R(y,x)\)</span></p></li><li><p>R具有传递性</p></li></ul><p>自然数集N上面的小于关系就是严格的偏序关系。</p><p>极小元的定义：</p><p>如果<spanclass="math inline">\((A,\leq)\)</span>是偏序集，B包含于A，b属于B，称b为B的关于<spanclass="math inline">\(\leq\)</span>关系的极小元，如果不存在x属于B，使得<spanclass="math inline">\(x\neq b\)</span>且<spanclass="math inline">\(x\leq b\)</span>。</p><h3 id="良序关系">良序关系</h3><p>线序的定义：</p><p>如果<spanclass="math inline">\((A,\leq)\)</span>是偏序集，A中任意两个元素x，y都在偏序关系<spanclass="math inline">\(\leq\)</span>下可以比较，即要么<spanclass="math inline">\(x\leq y\)</span>，要么<spanclass="math inline">\(y\leq x\)</span>，则称<spanclass="math inline">\(\leq\)</span>关系是线序关系或全序关系。相应地称<spanclass="math inline">\((A,\leq)\)</span>为线序集或全序集。</p><p>如果<span class="math inline">\(\leq\)</span>为A上的线序，则称<spanclass="math inline">\(&lt;\)</span>为A上的严格线序。</p><p>良序的定义：</p><p>设<spanclass="math inline">\((A,\le)\)</span>是线序集，如果A的任意非空子集都有<spanclass="math inline">\(\le-\)</span>极小元，则称<spanclass="math inline">\((A,\le)\)</span>为良序集，且称<spanclass="math inline">\(\le\)</span>为A上的良序，或称A被<spanclass="math inline">\(\le\)</span>良序。</p><p>如果<spanclass="math inline">\(\le\)</span>是R上的良序，有时也称<spanclass="math inline">\(&lt;\)</span>是A上的良序。</p><ul><li>有穷的线序集都是良序集。</li><li>在定义中如果只要求偏序而不是线序，就称为良基偏序。</li></ul><h4 id="良序问题">良序问题</h4><p>是否对任意的集合A，都存在A上的良序关系？</p><p>良序原则：任意的集合都可以被良序</p><ul><li>良序原则和Zorn引理等价</li></ul><h3 id="乘积公理">乘积公理</h3><p>对任意集族<span class="math inline">\((X_i)_{i\inI}\)</span>，如果I为非空集合，且对任意<span class="math inline">\(i\inI\)</span>，集合<span class="math inline">\(X_i\)</span>非空，则<spanclass="math inline">\(\prod_{i\in I}X_i\)</span>非空。</p><h3 id="选择公理">选择公理</h3><p>对任意非空集合X，如果X中的元素均为非空集合，则存在映射f使得<spanclass="math inline">\(dom(f)=X\)</span>，且<spanclass="math inline">\(\forall x\in X\)</span>都有<spanclass="math inline">\(f(x)\in x\)</span>（称f为X上的选择函数）。</p><h3 id="可数">可数</h3><p>集合A是可数的，当且仅当存在某个函数将A一对一映射到自然数N中。</p><ul><li>设A是一个可数集，则所有由A的元素构成的有限序列的集合也可数</li></ul><h2 id="有穷与无穷集合">有穷与无穷集合</h2><h3 id="自然数的定义">自然数的定义</h3><p>集合的后继：</p><p>设A为任意的集合，我们称集合<span class="math inline">\(A\cup\{A\}\)</span>为A的后继集合，简称A的后继，记作<spanclass="math inline">\(A^+\)</span>，而A为<spanclass="math inline">\(A^+\)</span>的前趋。</p><p>自然数的定义：</p><ol type="1"><li><span class="math inline">\(0=\empty\)</span></li><li><span class="math inline">\(1=0^+=\{0\}\)</span></li><li><span class="math inline">\(2=1^+=\{0,1\}\)</span></li><li>假设我们已经定义了<spanclass="math inline">\(n=\{0,1,...,n-1\}\)</span>，则定义<spanclass="math inline">\(n+1=n^+=n\cup\{n\}=\{0,1,...,n-1,n\}\)</span></li><li>每个自然数都是从0开始经过有穷步后继运算的结果</li></ol><h3 id="无穷公理">无穷公理</h3><p>所有自然数组成的集合的整体是集合，记为<spanclass="math inline">\(\omega\)</span>。</p><h3 id="佐恩引理或极大原则">佐恩引理或极大原则</h3><p>设A是一个集合，且满足对于任意的链<spanclass="math inline">\(C\subseteq A\)</span>，有集合<spanclass="math inline">\(\bigcupC\)</span>在A中，那么A中存在极大元m，即m不是A中其他任意元素的子集。</p><ul><li>我们说一组集合C是一个链，当且仅当对于C中任意元素x和y，要么<spanclass="math inline">\(x\subseteq y\)</span>要么<spanclass="math inline">\(y\subseteq x\)</span></li></ul><h3 id="数学归纳法">数学归纳法</h3><p>集合形式的数学归纳法：</p><p>设S为一个集合，如果S满足如下两个条件：</p><ul><li><span class="math inline">\(0\in S\)</span></li><li>对任何自然数n，如果<span class="math inline">\(n\inS\)</span>，则<span class="math inline">\(n+1\in S\)</span></li></ul><p>则<span class="math inline">\(\omega \subseteqS\)</span>，即每个自然数对属于S。</p><h4 id="正则公理">正则公理</h4><p>每个非空集合A中总存在元素x使得<span class="math inline">\(x\capA=\empty\)</span>（此时称x为A的<span class="math inline">\(\in-\)</span>极小元）。</p><p>正则公理的蕴含：</p><ul><li><p>不存在集合<span class="math inline">\(x\in x\)</span></p></li><li><p>不存在集合x,y使得<span class="math inline">\(x\iny\)</span>且<span class="math inline">\(y\inx\)</span>。一般地，不存在集合<spanclass="math inline">\(x_1,...,x_n\)</span>使得<spanclass="math inline">\(x_1\in x_2,...,x_{n-1}\in x_n,x_n\inx_1\)</span>。</p><p>不存在集合<span class="math inline">\(\{x_n|n\in \omega使得每个n\in\omega 都有x_{n+1}\in x_n\}\)</span></p></li></ul><p>集合形式的数学归纳法证明：暂略，20230912，P30</p><p>性质形式的数学归纳原理：</p><p>设R是性质，如果有</p><ol type="1"><li>R(0)成立，且</li><li>对任意自然数n，若R(n)成立，R(n+1)也成立</li></ol><p>则对任意自然数n都有R(n)成立。</p><h4 id="传递集合">传递集合</h4><p>设A是一个集合，如果A的任意元素都是A的子集，则称A是传递集合。</p><ul><li><p>A为传递集合，则<span class="math inline">\(\forall x\in A,y\inx,y\in A\)</span>。</p></li><li><p>每个自然数都是传递集合</p></li><li><p><spanclass="math inline">\(\omega\)</span>是传递集合，即对任意自然数n都有n是<spanclass="math inline">\(\omega\)</span>的传递集合</p></li><li><p>引理：<span class="math inline">\(\forall n,m\in N,如果n\subseteqm,有n=m或者n\in m\)</span></p></li></ul><p>$<span class="math inline">\(-三歧性：\)</span>x,yA有xy或x=y或yx$</p><ul><li><span class="math inline">\(\omega\)</span>具有三歧性</li></ul><p>任意自然数n、m，定义</p><ul><li><span class="math inline">\(m&lt;n当且仅当m\in n\)</span></li><li><span class="math inline">\(m\le n当且仅当m&lt;n或m=n\)</span></li></ul><h3 id="有穷集合和无穷集合">有穷集合和无穷集合</h3><h4 id="等势集合">等势集合</h4><p>设A、B为两个集合，如果存在A到B上的双射，则称A与B等势，或称A与B对等，记为<spanclass="math inline">\(A～B\)</span></p><ul><li>直观上，A与B等势，则A和B有同样多的元素。</li></ul><p>等势关系是等价关系，即</p><ul><li><span class="math inline">\(\forall A,A～A\)</span></li><li><span class="math inline">\(\forallA,B,如果A～B,则B～A\)</span></li><li><span class="math inline">\(\forallA,B,C,如果A～B,B～C,则A～C\)</span></li></ul><h4 id="康托尔伯恩斯坦定理">康托尔伯恩斯坦定理</h4><p>设A、B为两个集合，假设<span class="math inline">\(A\preceq B,B\preceqA\)</span>，则<span class="math inline">\(A～B\)</span></p><h4 id="有穷集合">有穷集合</h4><p>和某个自然数等势的集合为有穷集合，否则为无穷集合。</p><ul><li><p>每个自然数都是有穷集合</p></li><li><p>引理：假设A是有穷集合，x不属于A，则<spanclass="math inline">\(A\cup \{x\}\)</span>是有穷集合</p></li><li><p>引理：集合A是有穷集合，当且仅当存在自然数n，使得<spanclass="math inline">\(A\preceq n\)</span></p></li><li><p>对任意的自然数n，n的每个真子集都不与n等势</p><ul><li>抽屉原理：集合A为有穷集合，当且仅当它不与它的任何真子集等势</li></ul></li></ul><h4 id="可数集合">可数集合</h4><p>若集合<span class="math inline">\(A\preceq\omega\)</span>，即存在A到<spanclass="math inline">\(\omega\)</span>的单射，则称A可数</p><ul><li>若<spanclass="math inline">\(A～\omega\)</span>，则称A为可数的无穷集合</li><li>定理：可数多个可数集合的并集可数</li></ul><h4 id="无穷集合">无穷集合</h4><p>每一个无穷集合都有无数无穷子集。</p><ul><li>如果A是无穷集合，则<span class="math inline">\(\omega\preceqA\)</span></li><li>A是无穷集合当且仅当它与自身的一个真子集等势</li><li>引理：假设A是非空集合且<span class="math inline">\(\bigcupA=A\)</span>，则A是无穷集合</li></ul><h4 id="不可数集合">不可数集合</h4><p>不是可数集合的无穷集合为不可数元集合。</p><ul><li><p>康托尔定理：<span class="math inline">\(\forall A,A\prec\Rho(A)\)</span></p></li><li><p>区间(0,1)不可数</p></li><li><p>连通性假设：<span class="math inline">\(\forall A,\omega\preceqA且A\preceq R，则要么A～\omega，要么A～R。\)</span></p><p><span class="math inline">\(换言之，不存在集合A使得\omega\preceqA且A\preceq R。\)</span></p></li></ul><h4 id="序数">序数</h4><p>每一个良序集合都与一个自然数序同构。</p><ul><li>设<spanclass="math inline">\((A,\le_A)\)</span>为一个良序集，A有穷，则存在一个自然数n，使得<spanclass="math inline">\((A,\le_A)\)</span>与<spanclass="math inline">\((n,\le)\)</span>序同构</li></ul><p>具有三歧性的传递集合叫做序数</p><ul><li>0是序数</li><li>每个自然数都是序数</li><li><span class="math inline">\(\omega\)</span>是序数</li></ul><p>引理：如果<span class="math inline">\(\alpha\)</span>是序数，<spanclass="math inline">\(\alpha^+\)</span>也是序数；序数的每个元素也是序数。</p><p>对于自然数n，归纳定义<spanclass="math inline">\(\omega+n\)</span>：</p><ol type="1"><li><span class="math inline">\(\omega+0=\omega\)</span></li><li><span class="math inline">\(\omega+(n+1)=(\omega+n)^+\)</span></li></ol><p>对任意自然数有<spanclass="math inline">\(\omega+n\)</span>为序数。</p><p>定理：对任意两个序数<spanclass="math inline">\(\alpha、\beta\)</span>都有<spanclass="math inline">\(\alpha\in\beta\)</span>，或者<spanclass="math inline">\(\alpha=\beta\)</span>，或者<spanclass="math inline">\(\beta\in\alpha\)</span>。</p><ul><li>证明：0912 P42</li></ul><p>用<span class="math inline">\(O_n\)</span>表示所有序数的类。</p><ul><li><p><span class="math inline">\(O_n\)</span>不是集合，否则<spanclass="math inline">\(O_n是序数，O_N\subseteqO_n\)</span>，与正则公理矛盾。</p></li><li><p>任何序数在属于关系上是良序集，我们用&lt;表示序数的属于关系</p></li></ul><p>定理：假设S中每个元素都是序数，那么<spanclass="math inline">\(\bigcup S\)</span>也是序数。</p><ul><li><span class="math inline">\(\omega\)</span>是序数</li><li>设<spanclass="math inline">\(S_0=\{\omega,\omega+1,...,\omega+n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega+\omega\)</span>或<spanclass="math inline">\(\omega·2\)</span><ul><li>类似地，可以定义<spanclass="math inline">\(\omega·3,...,\omega·n,...\)</span></li></ul></li><li>设<spanclass="math inline">\(S_1=\{\omega,\omega·2,...,\omega·n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega·\omega\)</span>或<spanclass="math inline">\(\omega^2\)</span><ul><li>类似地，可以定义<spanclass="math inline">\(\omega^3,...,\omega^n,...\)</span></li></ul></li><li>设<spanclass="math inline">\(S_2=\{\omega,\omega^2,...,\omega^n,...\}\)</span>，则<spanclass="math inline">\(\bigcup S_0\)</span>是序数，记为<spanclass="math inline">\(\omega^\omega\)</span></li></ul><p>上述<span class="math inline">\(\omega^n\)</span>和<spanclass="math inline">\(\omega^\omega\)</span>为序数算数，不是笛卡尔积。</p><p>替换公理：设<spanclass="math inline">\(P(x,y)\)</span>为类关系，A是一个集合，如果<spanclass="math inline">\(\forall x\in A\)</span>，有唯一<spanclass="math inline">\(y_x\)</span>，使得<spanclass="math inline">\(P(x,y_x)\)</span>成立，则<spanclass="math inline">\(\{y_x|x\in A\}\)</span>是集合。</p><h4 id="超穷归纳法">超穷归纳法</h4><p>设<span class="math inline">\(\alpha\)</span>为序数</p><ul><li>如果存在序数<span class="math inline">\(\beta\)</span>使得<spanclass="math inline">\(\alpha=\beta^+\)</span>，则称<spanclass="math inline">\(\alpha\)</span>为后继序数</li><li>不是后继序数的非零序数称为极限序数</li></ul><p>设<span class="math inline">\(\alpha\neq 0\)</span>为序数，则</p><ul><li><spanclass="math inline">\(\alpha\)</span>为极限序数当且仅当对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都有<spanclass="math inline">\(\beta^+\lt\alpha\)</span></li><li><span class="math inline">\(\alpha\)</span>是极限序数当且仅当<spanclass="math inline">\(\alpha\)</span>中无最大元，即对任意的<spanclass="math inline">\(\beta\lt\alpha\)</span>，都存在<spanclass="math inline">\(\gamma\lt\alpha\)</span>，使得<spanclass="math inline">\(\beta\lt\gamma\)</span></li></ul><p>超穷归纳法原理：</p><p>设<span class="math inline">\(R(x)\)</span>为一个性质</p><ol type="1"><li><p>假设<span class="math inline">\(R(0)\)</span>成立</p></li><li><p>对任意的序数<spanclass="math inline">\(\alpha\)</span>，如果<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\alpha+1)\)</span>也成立</p></li><li><p>对于任意的极限序数<spanclass="math inline">\(\lambda\)</span>，如果对每一<spanclass="math inline">\(\alpha\lt\lambda\)</span>都有<spanclass="math inline">\(R(\alpha)\)</span>成立，则<spanclass="math inline">\(R(\lambda)\)</span>成立</p><p>那么对于任意的序数<spanclass="math inline">\(\alpha\)</span>都有<spanclass="math inline">\(R(\alpha)\)</span>成立</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数理逻辑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>毛概-期末复习</title>
    <link href="/2023/06/15/%E6%AF%9B%E6%A6%82%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/15/%E6%AF%9B%E6%A6%82%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1id="毛泽东思想和中国特色社会主义理论体系概论-期末复习">毛泽东思想和中国特色社会主义理论体系概论期末复习</h1><span id="more"></span><p>任课教师：武海宝</p><h3 id="科学社会主义">科学社会主义</h3><ul><li>科学社会主义确认金融资本是现代社会各种病症的根源。</li><li>共产主义不是对财产的否定，而是对社会财产的私人垄断的否定。</li></ul><p>伦理社会主义：</p><p>伦理社会主义是在自然经济时代发展起来的，它强调人与人之间的和谐，与宗教、大同理想、家族文化等各种形态相结合，以一种改良的身份去批评资本主义，但它无法改变资本主义的基本逻辑</p><h2 id="新民主主义革命">新民主主义革命</h2><h3 id="中国社会主义革命道路探索">中国社会主义革命道路探索</h3><h4 id="中国的两步走">中国的两步走</h4><p>中国革命必须分为两个步骤。第一步，改变这个殖民地、半殖民地、半封建的社会形态，使之变成一个独立的民主主义的社会，第二部，使这个革命向前发展，建立一个社会主义的社会。——毛泽东《新民主主义论》</p><h4 id="三湾改编">三湾改编</h4><p>1927年9月至10月，毛泽东在江西省永新县三湾村领导了三湾改编。</p><p>毛泽东创造性地确立了支部建在连上、官兵平等等一系列治军方略。三湾改编是中国共产党建设新型人民军队最早的一次成功探索和实践。</p><p>意义：</p><ul><li>从政治上和组织上保证了党对军队的绝对领导，是我党建设新型人民军队最早的一次成功探索和实践，标志着毛泽东建设人民军队思想的开始形成</li><li>初步解决了如何把以农民和旧军人为主要成分的革命军队建设成为一支无产阶级新型人民军队的问题，奠定了政治强军的基础</li><li>实现民主主义，对团结广大士兵群众、瓦解敌军起到巨大作用</li></ul><h4 id="新民主主义革命的基本纲领">新民主主义革命的基本纲领</h4><ul><li>没收封建地主阶级的土地归农民所有；没收官僚资本主义的垄断资本归国家所有；保护民族工商业</li><li>建立无产阶级领导下的一切反帝反封建的人民联合专政的民主共和国，这就是新民主主义的共和国</li><li>实行人民大众的反帝反封建的文化，即民族的、科学的、大众的文化</li></ul><h4 id="新旧民主主义革命的异同">新旧民主主义革命的异同</h4><ul><li>相同点：<ul><li>社会性质：都发生在半殖民地半封建社会</li><li>革命任务：都是反对外国资本主义侵略和本国封建统治</li><li>革命性质：都属于资产阶级民主革命的范畴</li></ul></li><li>不同点：<ul><li>领导力量：旧民主主义革命的领导是资产阶级，新民主主义革命的领导是无产阶级</li><li>指导思想：旧民主主义革命是资产阶级的平等、自由思想和民族观念，新民主主义革命是马克思主义</li><li>革命前途：旧民主主义革命是建立资产阶级民主共和国，新民主主义革命在完成民主革命任务后，还要进入社会主义社会</li><li>革命发展和群众发动的深度、广度：旧民主主义革命的纲领不彻底，群众发动不充分，土地问题不能彻底解决；新民主主义革命提出了彻底的革命纲领，广泛发动群众，解决了民主革命的中心问题，即土地问题</li><li>结果不同：旧民主主义革命有胜利的一面，但最终果实被窃取，革命任务没有完成，社会性质没有改变，在这一意义讲是最终遭到了失败；新民主主义革命的胜利成为了社会主义的必要准备，社会主义是新民主主义革命的必然结果</li><li>旧民主主义革命属于世界资产阶级革命的一部分，新民主主义革命属于无产阶级世界革命的一部分</li></ul></li></ul><h3 id="新民主主义社会">新民主主义社会</h3><ul><li>政治上，新民主主义的国家实行工人阶级领导的、工农联盟为基础的、团结各民主阶级和国内各民族的人民民主专政。</li><li>经济上：</li></ul><table><thead><tr class="header"><th>成分</th><th>来源</th><th>性质</th><th>地位</th></tr></thead><tbody><tr class="odd"><td>国营经济</td><td>没收官僚资本</td><td>社会主义</td><td>领导地位</td></tr><tr class="even"><td>合作社经济</td><td>个体向社会主义集体经济过渡</td><td>半社会主义</td><td></td></tr><tr class="odd"><td>个体经济</td><td>个体农业、手工业</td><td>个体经济</td><td>绝对优势</td></tr><tr class="even"><td>私人资本主义经济</td><td>民族资本主义</td><td>资本主义</td><td></td></tr><tr class="odd"><td>国家资本主义经济</td><td>私人资本主义经济向社会主义国营经济过渡</td><td>半社会主义</td><td></td></tr></tbody></table><p>新民主主义社会，是指在新民主主义革命胜利的基础上，建立起来的既不是资产阶级共和国也不是无产阶级共和国的的各个革命阶级联合专政的共和国，是落后国家进行革命的特有社会形态。</p><ul><li>性质：过渡性社会形态，隶属于社会主义体系</li><li>特点：既有社会主义因素，也有资本主义因素</li><li>从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期</li><li>过渡时期的时间，中央领导估计大约需要10年、15年或者更久</li></ul><h4 id="过渡时期总路线">过渡时期总路线</h4><p>从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造。</p><h4id="中国社会主义改造道路三大改造">中国社会主义改造道路：三大改造</h4><ul><li>农业合作化，将小农经济改造为农业集体主义经济</li><li>手工业社会主义改造，通过合作化道路，把个体手工业转变为社会主义劳动群众集体所有制经济</li><li>资本主义工商业社会主义改造，通过国家资本主义的形式，采取和平赎买的政策，将民族资本主义经济改造成社会主义公有制企业，而且将所有制改造与人的改造相结合，努力使剥削者成为自食其力的劳动者</li></ul><p>社会主义改造时期，把实现国家的工业化作为党在过渡时期总路线的主体，受苏联的影响，一度过多强调重工业和基础设施的发展，促使党思考如何走中国工业化道路的问题。</p><h4 id="中国工业化道路的目标和方针">中国工业化道路的目标和方针</h4><ul><li>总方针：以农业为基础，以工业为主导，以农、轻、重为序发展国民经济</li><li>农业为重工业提供积累资金和原料，同时提供市场</li><li>目标：逐步建立独立的比较完整的基础工业体系和国防工业体系</li></ul><h3 id="中国无产阶级的主要优点">中国无产阶级的主要优点</h3><ol type="1"><li>革命性强。深受帝国主义、封建主义、资本主义的三重压迫，具有强烈的反抗意识</li><li>和广大农民有着天然联系，容易和农民结成亲密的联盟</li><li>集中在沿海、沿江大中城市，便于组织</li></ol><p>新民主主义革命的动力：农民</p><h2 id="改革开放">改革开放</h2><h3 id="家庭联产承包责任制和土地流转">家庭联产承包责任制和土地流转</h3><p>家庭联产承包责任制和统分结合的双层经营体制：</p><p>所有权、承包权和经营权三权分置，经营权流转的格局。农业用地在土地承包期限内，可以通过转包、转让、入股、合作、租赁、互换等方式出让经营权。</p><h3id="中国社会主义农业改革和发展的两个飞跃">中国社会主义农业改革和发展的两个飞跃</h3><p>两个飞跃是邓小平晚年关于我国农业改革和发展的重要思考</p><ol type="1"><li>废除人民公社，实行家庭联产承保责任制</li><li>适应科学生产、生产社会化的需要，再度发展集体经济</li></ol><h3id="中国特色社会主义市场经济制度的体制优势">中国特色社会主义市场经济制度的体制优势</h3><ul><li>从落后国家率先取得胜利的社会主义，还不能一下子排除掉资本。中国从新民主主义社会到改革开放，基本探索出一个相对稳定的制度形式，也就是公有制主导下的市场经济</li><li>以公有制为主体的社会主义市场经济制度既能充分利用市场、充分利用一般职能资本的积极作用来推动社会发展，又能避免金融资本的剥削性、寄生性、投机性积累及其所导致的一系列问题，创造了一条不同于西方的现代化道路</li></ul><h2 id="社会主义">社会主义</h2><h3 id="社会主义的本质">社会主义的本质</h3><ul><li>解放和发展生产力——基本经济制度的内在属性</li><li>消灭剥削，消除两极分化——基本经济制度的内在张力</li><li>最终达到共同富裕</li></ul><h3 id="三个代表">三个代表</h3><p>三个代表是建党理论。</p><p>中国共产党始终代表</p><ul><li>中国先进生产力的发展要求</li><li>中国先进文化的前进方向</li><li>中国最广大人民的根本利益</li></ul><h3 id="科学发展观">科学发展观</h3><ul><li>第一要义是发展</li><li>核心是以人为本</li><li>基本要求是全面协调可持续发展</li><li>根本方法是统筹兼顾</li></ul><h3 id="十个坚持">十个坚持</h3><ul><li>坚持党的领导</li><li>坚持人民至上</li><li>坚持理论创新</li><li>坚持独立自主</li><li>坚持中国道路</li><li>坚持胸怀天下</li><li>坚持开拓创新</li><li>坚持敢于斗争</li><li>坚持统一战线</li><li>坚持自我革命</li></ul><h2 id="使命型政党">使命型政党</h2><h3 id="理论渊源">理论渊源</h3><p>⻢克思：过去的一切运动都是少数人的或者为少数人谋利益的运动。无产阶级的运动是绝大多数人的，为绝大多数人谋利益的独立的运动。在无产阶级和资产阶级的斗争所经历的各个发展阶段上，共产党人始终代表整个运动的利益。</p><h3 id="人民利益的统一性完整性">人民利益的统一性、完整性</h3><ul><li>区别公意和众意：<ul><li>卢梭在《社会契约论》中说：“公意和众意之间经常有着很大的差别。公意总是着眼于公共利益，而众意则着眼于私利，它只是个体意志的总和。”</li></ul></li></ul><h3 id="中国共产党是使命型政党">中国共产党是使命型政党</h3><ul><li>把国家从金融资本、金融寡头的工具变成社会利益的集中代表，这是社会主义国家的国体概念。作为社会联合所有制的代理人来执行职能的国家，这是一种和新自由主义消极国家不一样的积极国家，这种积极国家又要依赖一个先锋队、依赖一个使命型政党。</li><li>这种政党不同于⻄方那样一种选举型政党。选举型政党容易分裂人⺠的意志，而人⺠意志的分裂有利于金融寡头对经济、政治的支配。</li><li>共产党作为先锋队的组织，作为人⺠意志的集中表现，作为一个没有自己特殊私利的政党，共产党的合法性依据先进的纲领、依据人⺠⺠主、依据自我革命。社会主义政权的一系列的组织形式不同于⻄方三权分立的政治制度。</li></ul><h4id="使命型政党和西方选举型政党的区别">使命型政党和西方选举型政党的区别</h4><ul><li>基于全心全意为人民服务的马克思主义政党；建立在人性恶和权力恶的双重不信任文化基础上的政党</li><li>作为整体的部分而服务于本体的政党；割裂于整体而利用本体牟利的政党</li></ul><h2 id="我国的政治制度">我国的政治制度</h2><h4 id="人民民主专政国体">人民民主专政——国体</h4><p>中国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家。</p><p>人民民主专政是中国的国家根本性质</p><p>只有人民民主专政才能终结国外列强操控的军阀割据。</p><p>军阀割据的社会根源：</p><ul><li>中国社会的半封建性，中国具有分散性的封建地主经济的必然产物</li><li>中国社会的半殖民性，帝国主义分而治之的侵略政策必然导致军阀割据</li></ul><h4 id="人民代表大会制度政体">人民代表大会制度——政体</h4><ul><li>人民通过人民代表大会有效行使国家权力</li><li>全国人民代表大会是最高国家权力机关，地方人民代表大会是地方国家权力机关</li><li>各级国家行政机关、监察机关、审判机关、检察机关都由人民代表大会产生，对人大负责，受人大监督。人民代表大会有立法权、监督权、决定权、任免权</li><li>人大代表来自人民，横向上，来自各地区、各民族、各方面、各阶层；纵向上，全国、省、市、县、乡五级都有人民代表大会，具有广泛代表性</li></ul><h4id="中国共产党领导的多党合作和政治协商制度">中国共产党领导的多党合作和政治协商制度</h4><p>中国共产党是执政党，八个民主党派是接受中国共产党领导、同中国共产党亲密合作的参政党。</p><ul><li>在中国，没有反对党，也没有在野党。中国既不是一党专政，也不是多党竞争、轮流执政，而是“共产党领导、多党派合作，共产党执政、多党派参政”。</li></ul><h4 id="民主实践选举民主">民主实践：选举民主</h4><ul><li><p>人⺠通过选举、投票行使权利，选出代表自己意愿的人来掌握并行使权力，是中国⺠主的一种主要形式，是人⺠实现当家作主的主要体现。</p></li><li><p>中国的选举是广泛的，有国家机构选举、村(居)委会选举、企事业单位职工代表大会选举等，涵盖了国家政治生活和社会生活的各个方面。</p></li><li><p>中国的选举是平等的，人⺠的选举权和被选举权得到充分保障，一人一票、票票等值</p></li><li><p>中国的选举是真实的，不受金钱操控，选⺠按照自己的意愿选出自己信任的人。</p></li><li><p>国家机构选举：从全国人大到乡级人大，五级人⺠代表大会代表均由⺠主选举产生，每届任期5年。选⺠直接选举产生县乡两级人大代表，县级以上人大代表由下一级人大选举产生。各级国家机关领导人员均由同级人大选举产生或者决定任命。</p></li><li><p>基层选举：村(居)⺠委员会选举和企事业单位职工代表大会选举。村(居)⺠依法定期选举产生村(居)⺠委员会成员。在企事业单位中，职工代表大会是职工当家作主、行使⺠主管理权力的机构。</p></li></ul><h4 id="民主实践协商民主">民主实践：协商民主</h4><ul><li><p>人⺠在通过选举、投票行使权利的同时，在重大决策前和决策过程中进行充分协商，尽可能就共同性问题取得一致意⻅。协商⺠主是中国⺠主独特的、独有的、独到的⺠主形式。</p></li><li><p>协商⺠主形式:提案、会议、座谈、论证、听证、评估、咨询、网络、⺠意调查等多种途径和方式，在决策之前和决策实施之中开展广泛协商。</p></li></ul><p>缺乏协商民主：英国脱欧</p><p>票决至上：一人一票是民主的一种形式，但绝非其唯一和全部</p><h4 id="政党和民主">政党和民主</h4><ul><li>中国共产党的领导，是中国发展全过程人⺠⺠主的根本保证。</li><li>把中国14亿多人⺠的意愿表达好、实现好，必须有坚强有力的统一领导。</li><li>中国共产党始终坚持以人⺠为中心、坚持人⺠主体地位，真正为人⺠执政、靠人⺠执政；充分发挥总揽全局、协调各方的领导核心作用。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-目标代码生成</title>
    <link href="/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
    <url>/2023/06/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>子不语</p><span id="more"></span><h1 id="目标代码生成">目标代码生成</h1><h2 id="risc-v">RISC-V</h2><h3 id="寄存器">寄存器</h3><ul><li><p>zero：存放常数0，不允许修改</p></li><li><p>ra：存放返回地址</p></li><li><p>t0~t6：保存临时变量</p></li><li><p>pc：保存下一条指令的地址</p></li></ul><h3 id="指令">指令</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">t0</span>, <span class="hljs-number">20</span><span class="hljs-comment"># li: load immediate</span><br>li <span class="hljs-built_in">t1</span>, <span class="hljs-number">22</span><br><span class="hljs-keyword">add </span><span class="hljs-built_in">t2</span>, <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">t1</span><br></code></pre></td></tr></table></figure><p>li指令是一条伪指令，最终会翻译为addi t0, zero, 20的形式</p><ul><li>负数则为addi t0, zero, -20</li><li>没有subi指令</li></ul><h3 id="系统调用">系统调用</h3><ol type="1"><li>把服务号写入a7寄存器</li><li>把参数写入a0、a1、a2、a3、fa0、...</li><li><code>ecall</code></li><li>从结果寄存器中获得返回值</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">1</span><span class="hljs-comment"># service 1 is print integer</span><br><span class="hljs-keyword">add </span><span class="hljs-built_in">a0</span>, <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">zero</span><span class="hljs-comment"># load desired int into a0</span><br>ecall<br></code></pre></td></tr></table></figure><h3 id="代码段">代码段</h3><ul><li><p>.开始的指令是写给汇编器的指令</p></li><li><p>.data存储全局变量</p><ul><li><code>g: .word 0</code></li><li><code>msg: .string "sss"</code>以\0结尾的string</li><li><code>msg: .ascii "sds"</code>的string不以\0结尾</li></ul></li><li><p>.text存储运行代码</p><ul><li><code>la t0, g      # la: load address</code></li><li><code>lw t0, 0(t0) # lw: load word</code></li><li><code>sw t6, 0(t0) #sw: store word</code></li></ul></li></ul><p>默认在程序开始添加.text</p><ul><li>打印字符串：</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">4</span><br>la <span class="hljs-built_in">a0</span>, msg<br>ecall<br></code></pre></td></tr></table></figure><ul><li>mv</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">li <span class="hljs-built_in">a7</span>, <span class="hljs-number">1</span><br>mv <span class="hljs-built_in">a0</span>, <span class="hljs-built_in">t6</span> <span class="hljs-comment">#add a0, t6, zero</span><br>ecall<br></code></pre></td></tr></table></figure><ul><li>数组：偏移地址</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.data</span><br><span class="hljs-symbol">numbers:</span> <span class="hljs-meta">.word</span> -<span class="hljs-number">30</span>, <span class="hljs-number">30</span>, -<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span><br><br><span class="hljs-meta">.text</span><br>la <span class="hljs-built_in">t0</span>, numbers<br><span class="hljs-keyword">lw </span><span class="hljs-built_in">t1</span>, <span class="hljs-number">12</span>(<span class="hljs-built_in">t0</span>)<span class="hljs-comment"># 偏移12个字节，到20</span><br><span class="hljs-keyword">addi </span><span class="hljs-built_in">t1</span>, <span class="hljs-built_in">t1</span>, <span class="hljs-number">90</span><br><span class="hljs-keyword">sw </span><span class="hljs-built_in">t1</span>, <span class="hljs-number">12</span>(<span class="hljs-built_in">t0</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-语法分析</title>
    <link href="/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2023/06/03/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>子不语</p><span id="more"></span><h1 id="语法分析">语法分析</h1><p>文法：一组描述良构程序语法结构的精确的规则</p><ul><li>文法给出了一个程序设计语言的精确易懂的语法规约</li><li>对于某些类型的文法，我们可以自动地构造出高效的语法分析器，它能够确定一个源程序的语法结构。同时，语法分析器的构造过程可以揭示出语法的二义性，还能发现一些容易在语法的初始设计阶段被忽略的问题</li><li>一个正确设计的文法给出了一个语言的结构，该结构有助于把源程序翻译成正确的目标代码，也有助于检测错误</li><li>一个文法支持逐步加入可以完成新任务的新语言构造从而迭代地演化和开发语言。如果对语言的实现遵循语言的文法结构，那么在实现中加入这些新构造的工作就变得更容易</li></ul><h2 id="一引论">一、引论</h2><h3 id="语法分析器的作用">语法分析器的作用</h3><p>语法分析器从词法分析器获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成，能够以易于理解的方式报告语法错误，并且能够从常见的错误中恢复并继续处理程序的其余部分。</p><ul><li><p>对于良构的程序，语法分析器构造出一棵语法分析树，并把它传递给编译器的其他部分进一步处理。</p></li><li><p>处理文法的语法分析器大体上可分为三种类型：</p><ul><li>通用的：效率较低不能用于编译器产品</li><li>自顶向下的：从语法分析树的顶部开始向底部构造语法分析树</li><li>自底向上的：从叶结点开始逐步向根结点构造<ul><li>语法分析器的输入总是按从左到右的方式被扫描，每次扫描一个符号</li></ul></li></ul></li></ul><h3 id="语法错误的处理">语法错误的处理</h3><p>错误的不同层次：</p><ul><li>词法错误</li><li>语法错误</li><li>语义错误</li><li>逻辑错误</li></ul><p>可行前缀特性：</p><p>一旦发现输入的某个前缀不能够通过添加一些符号而形成这个语言的串，就可以立即检测到语法错误。</p><p>错误恢复的一般策略：恐慌模式和短语层次恢复</p><ul><li>恐慌模式恢复<ul><li>一旦发现错误就不断丢弃输入中的符号，知道找到同步词法单元集合中的某个元素<ul><li>同步词法单元通常是界限符，如分号和右大括号</li><li>跳过大量输入，但简单且能保证不会进入无限循环</li></ul></li></ul></li><li>短语层次的恢复<ul><li>将余下输入的某个前缀替换为另一个串，使之可以继续分析<ul><li>必须小心选择替换方法以免无限循环</li></ul></li></ul></li><li>错误产生式<ul><li>预测常见错误，在文法中加入错误产生式</li></ul></li><li>全局纠正<ul><li>通过最小的改动序列将错误输入串转换为语法正确的串<ul><li>开销大，仅具理论价值</li></ul></li></ul></li></ul><h2 id="二上下文无关文法">二、上下文无关文法</h2><h3 id="上下文无关文法的定义">上下文无关文法的定义</h3><p>上下文无关文法（Context-free grammar，CFG）</p><p>一个上下文无关文法由终结符号，非终结符号，一个开始符号和一组产生式组成。</p><ul><li><p>终结符号是组成串的基本符号</p></li><li><p>非终结符号是表示串的集合的语法变量</p></li><li><p>一个文法中，某个非终结符号被指定为开始符号</p></li><li><p>一个文法的产生式描述了将终结符号和非终结符号组合成串的方法，其组成元素：</p><ul><li>一个被称为产生式头或左部的非终结符号，这个产生式定义了这个头所代表的串集合的一部分</li><li>符号<spanclass="math inline">\(\rightarrow\)</span>。有时也使用::=来替代箭头</li><li>一个由零个或多个终结符号与非终结符号组成的产生式体或右部</li></ul></li></ul><p>语义：上下文无关文法G定义了一个语义L(G)</p><p>约定：</p><ul><li>常用开始符号S</li><li>常用表达式、项和因子的非终结符号E、T、F</li><li>一般第一个产生式的头为开始符号</li></ul><h3 id="推导">推导</h3><p>将某个产生式的左边替换成它的右边。</p><ul><li><p>每一步推导需要选择替换哪个非终结符号，以及使用哪个产生式</p></li><li><p>一次推导：<spanclass="math inline">\(\Longrightarrow\)</span></p></li><li><p>一次或多次推导：<spanclass="math inline">\(\Longrightarrow^+\)</span></p></li><li><p>零次或多次推导：<spanclass="math inline">\(\Longrightarrow^*\)</span></p></li></ul><p>如果<span class="math inline">\(S\Longrightarrow^*\alpha\)</span>，其中S为文法G的开始符号，称<spanclass="math inline">\(\alpha\)</span>为G的一个句型。</p><ul><li>文法G的一个句子是不包含非终结符号的句型</li><li>文法生成的语言是它的所有句子的集合，称为上下文无关语言</li><li>两个生成相同语言的文法是等价的</li></ul><p>最左推导：总是选择每个句型的最左非终结符号</p><p>最右推导：总是选择每个句型的最右边的非终结符号</p><p>正则表达式的表达能力严格弱于上下文无关文法。</p><p>正则表达式转上下文无关文法：</p><ol type="1"><li>转NFA或DFA</li><li>自动机每个状态转为上下文无关文法的一个非终结符号</li><li>逐步转换</li></ol><h4 id="二义性">二义性</h4><p>如果一个文法可以为某个句子生成多棵语法分析树，那么它就是二义性的。</p><p>消除二义性</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">stmt</span>: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span><br>| <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span> <span class="hljs-keyword">else</span> <span class="hljs-type">stmt</span><br>| other<br></code></pre></td></tr></table></figure><p>修改规则：每个else和最近的尚未匹配的then匹配</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">stmt</span>: matched_stmt<br>| open_stmt<br>matched_stmt: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> thrn matched_stmt <span class="hljs-keyword">else</span> matched_stmt<br>| other<br>open_stmt: <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then <span class="hljs-type">stmt</span><br> | <span class="hljs-keyword">if</span> <span class="hljs-type">expr</span> then matched_stmt <span class="hljs-keyword">else</span> open_stmt<br></code></pre></td></tr></table></figure><h4 id="左递归">左递归</h4><p>如果一个文法中有一个非终结符号使得对某个串<spanclass="math inline">\(\alpha\)</span>存在一个推导<spanclass="math inline">\(A\Longrightarrow^+A\alpha\)</span>，那么这个文法就是左递归的。</p><ul><li>自顶向下语法分析不能处理左递归文法</li></ul><p>消除直接左递归：</p><ol type="1"><li>将A的全部产生式分组：<span class="math inline">\(A\rightarrowA\alpha_1|A\alpha_2|...|A\alpha_m|\beta_1|\beta_2|...|\beta_n\)</span>，其中<spanclass="math inline">\(\beta_i\)</span>都不以A开始</li><li>将A的产生式替换为<ul><li><span class="math inline">\(A\rightarrow\beta_1A^{&#39;}|\beta_2A^{&#39;}|...|\beta_nA^{&#39;}\)</span></li><li><span class="math inline">\(A^{&#39;}\rightarrow\alpha_1A^{&#39;}|\alpha_2A^{&#39;}|...|\alpha_nA^{&#39;}|\epsilon\)</span></li></ul></li></ol><p>消除间接左递归：先化为直接左递归，再使用上述方法</p><ul><li>该方法下的文法不能存在环和<spanclass="math inline">\(\epsilon\)</span>产生式</li></ul><h4 id="提取左公因子">提取左公因子</h4><p>对于每个非终结符号A，找出它的两个或多个选项之间的最长公共前缀<spanclass="math inline">\(\alpha\)</span>，若<spanclass="math inline">\(\alpha \neq\epsilon\)</span>，即存在一个非平凡的公共前缀，将所有<spanclass="math inline">\(A\rightarrow\alpha\beta_1|\alpha\beta_2|...|\alpha\beta_n|\gamma\)</span>替换为</p><ul><li><span class="math inline">\(A\rightarrow \alphaA^{&#39;}|\gamma\)</span></li><li><span class="math inline">\(A^{&#39;}\rightarrow\beta_1|\beta_2|...|\beta_n\)</span></li></ul><p>其中<span class="math inline">\(\gamma\)</span>为A所有不以<spanclass="math inline">\(\alpha\)</span>开始的产生式体。</p><ul><li>不断应用上述转换，直到每个非终结符号的任意两个产生式体没有公共前缀为止</li></ul><h3 id="自顶向下的语法分析">自顶向下的语法分析</h3><p>为输入串构造语法分析树，从语法分析树的根结点开始，按照先根次序创建这棵语法分析树的各个结点。可以被看作寻找输入串的最左推导的过程。</p><ul><li>根结点是文法的起始符号S</li><li>每个中间结点表示对某个非终结符应用某个产生式进行推导</li><li>叶结点为词法单元流，仅包括终结符号和特殊的文件结束符$（EOF）</li></ul><p>对于有些文法，可以构造出向前看k个输入符号的预测分析器，这类文法称为LL(k)文法。</p><h4 id="递归下降">递归下降</h4><p>为每一个非终结符写一个递归函数，内部按需调用其他非终结符对应的递归函数进行下降。</p><h4 id="预测分析表">预测分析表</h4><p>指明每个非终结符在面对不同的词法单元或文件结束符时，该选择哪个产生式或报错。</p><p>首行为各个终结符和$，首列为各个非终结符。</p><h5 id="first和follow集合">FIRST和FOLLOW集合</h5><p><span class="math inline">\(First(\alpha)\)</span>是可以从<spanclass="math inline">\(\alpha\)</span>推导得到的句型的<strong>首终结符号</strong>的集合。</p><p><span class="math inline">\(First(\alpha)=\{t\inT\cup\{\epsilon\}|\alpha\Longrightarrow^*t\beta\or\alpha\Longrightarrow^*\epsilon \}\)</span></p><p>如果非终结符A的所有产生式对应的FIRST集合不相交，那么只需查看当前词法单元即可确定选择的产生式。</p><ul><li>单个符号X的<span class="math inline">\(First(X)\)</span>的计算<ul><li>先判断是否是终结符，若是，则<spanclass="math inline">\(First(X)\)</span>即其自身</li><li>否则，判断X的每一条产生式，且需要判断X可否推导出空串</li></ul></li><li>符号串<span class="math inline">\(\alpha\)</span>的<spanclass="math inline">\(First(\alpha)\)</span>的计算，<spanclass="math inline">\(\alpha=X\beta\)</span><ul><li>若<span class="math inline">\(\epsilon\notin L(X)\)</span>，即<spanclass="math inline">\(First(X)\)</span></li><li>若<span class="math inline">\(\epsilon\in L(X)\)</span>，为<spanclass="math inline">\((First(X)\setminus\{\epsilon\})\cupFirst(\beta)\)</span></li><li>如果<span class="math inline">\(\epsilon\in\alpha\)</span>，将<spanclass="math inline">\(\epsilon\)</span>加入<spanclass="math inline">\(First(\alpha)\)</span></li></ul></li></ul><p><spanclass="math inline">\(Follow(A)\)</span>是可能在某些句型中<strong>紧跟在A右边的终结符</strong>的集合。</p><p>对于任意的产生式左部非终结符<span class="math inline">\(A\inN\)</span>：</p><p><span class="math inline">\(Follow(A)=\{t\in T\cup\{\$\}|\exists.S\Longrightarrow^*s=^\triangle At\gamma\}\)</span></p><p>考虑产生式<span class="math inline">\(A\rightarrow\alpha\)</span>，如果从<spanclass="math inline">\(\alpha\)</span>可以推导出空串，则只有当当前词法单元属于<spanclass="math inline">\(Follow(A)\)</span>，才可以选择该产生式。</p><ul><li>非终结符X的<span class="math inline">\(Follow(X)\)</span>的计算<ul><li>若X是开始符号，则<span class="math inline">\(\$\)</span>也在<spanclass="math inline">\(Follow(X)\)</span>中<ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cup\{\$\}\)</span></li></ul></li><li>若X是某产生式右部最后一个符号，即<spanclass="math inline">\(A\rightarrow \alpha X\)</span><ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cupFollow(A)\)</span></li></ul></li><li>若X是某产生式右部中间的一个符号，即<spanclass="math inline">\(A\rightarrow \alpha X\beta\)</span><ul><li><span class="math inline">\(Follow(X)\leftarrow Follow(X)\cup(First(\beta)\setminus\{\epsilon\})\)</span></li><li>若<span class="math inline">\(\epsilon\inFirst(\beta)\)</span>，<span class="math inline">\(Follow(X)\leftarrowFollow(X)\cup Follow(A)\)</span></li></ul></li></ul></li></ul><p>根据First和Follow集合计算确定给定文法G的预测分析表：</p><p>对应每条产生式<spanclass="math inline">\(A\rightarrow\alpha\)</span>与终结符t，如果</p><ul><li><span class="math inline">\(t\in First(\alpha)\)</span></li><li><span class="math inline">\(\epsilon\in First(\alpha)\and t\inFollow(A)\)</span></li></ul><p>则在表格[A,t]中填入<spanclass="math inline">\(A\rightarrow\alpha\)</span></p><h4 id="ll1文法">LL(1)文法</h4><ul><li><p>从左向右读入词法单元</p></li><li><p>在推导的每一步，LL(1)总是选择最左边的非终结符进行展开</p></li><li><p>如果文法G的预测分析表是无冲突的，则G是LL(1)文法。</p><ul><li>对于当前选择的非终结符，仅根据输入中当前的词法单元即可确定需要哪条产生式</li></ul></li></ul><p>非递归的预测分析算法：使用栈保存终结符和非终结符</p><h3 id="adaptive-ll算法">Adaptive LL(*)算法</h3><p>Adaptive LL(*)算法，简称ALLStar算法。</p><h4 id="优先级上升算法">优先级上升算法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;)&#x27;</span><br>| INT<br>| ID<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>: (<br><span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-built_in">expr</span>[0] <span class="hljs-string">&#x27;)&#x27;</span><br>| INT<br>| ID<br>)<br>(&#123;5 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-built_in">expr</span>[6]<br>| &#123;4 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[5]<br>)*<br>)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;!&#x27;</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| ID<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>:(ID<br>| <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-built_in">expr</span>[4]<br>)<br>(&#123;3 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;!&#x27;</span><br>| &#123;2 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>)*<br>;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span>: <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;;&#x27;</span> EOF;<br><br><span class="hljs-built_in">expr</span>: &lt;assoc = right&gt; <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-built_in">expr</span><br>| <span class="hljs-built_in">expr</span> <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span><br>| INT<br>;<br></code></pre></td></tr></table></figure><p>expr转化为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">expr</span>[int _p]<br>:( INT )<br>(&#123;3 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>|&#123;2 &gt;= <span class="hljs-variable">$_p</span>&#125;? <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-built_in">expr</span>[3]<br>)*<br>;<br></code></pre></td></tr></table></figure><p>总结：</p><p>按原产生式排序优先级；</p><p>左结合运算符右操作符优先级上升，右结合运算符右操作符优先级不变。</p><h4 id="antlr4的错误报告与恢复">ANTLR4的错误报告与恢复</h4><p>共四类词法、语法错误</p><ul><li>词法错误：LexerNoViableAltException</li><li>语法错误<ul><li>NoViableAltException：非终结符的可选分支均不可行</li><li>InputMismatchException：可选分支不匹配</li><li>FailedPerdicateException</li></ul></li></ul><h3 id="自底向上的语法分析">自底向上的语法分析</h3><p>自底向上的、不断归约的、基于句柄识别自动机的、适用于LR文法的LR语法分析器。</p><h4 id="自底向上构建语法分析树">自底向上构建语法分析树</h4><ul><li>根结点是文法起始符号S</li><li>叶结点是词法单元流，仅包含终结符号与特殊文件结束符$</li><li>每个中间非终结符结点表示使用它的某条产生式进行归约</li></ul><h4 id="lr语法分析器">LR语法分析器</h4><ul><li>从左向右扫描输入</li><li>构建反向最右推导</li></ul><p>LR语法分析器的状态：</p><p>在任意时刻，语法分析树的上边缘和剩余的输入构成当前句型。</p><ul><li>LR语法分析器使用栈存储语法分析树的上边缘，它包含了语法分析器目前所知的所有信息。</li></ul><p>栈上操作：</p><ul><li>移入输入符号</li><li>按产生式归约</li></ul><h4 id="lr分析表">LR分析表</h4><p>在当前状态（编号）下，面对当前文法符号时，该采取什么动作</p><ul><li><p>第一列为状态，用数字编号</p></li><li><p>其后的一组列为ACTION列，其首行为文法符号，余行指明动作</p></li><li><p>再之后的一组列为GOTO列，其首行为归约的文法符号，余行指明转换到的状态</p></li><li><p><spanclass="math inline">\(s_n\)</span>：移入输入符号，并进入状态n</p></li><li><p><spanclass="math inline">\(r_k\)</span>：使用k号产生式进行归约</p></li><li><p><span class="math inline">\(g_n\)</span>：转换到状态n</p></li><li><p><span class="math inline">\(acc\)</span>：成功接受，结束</p></li><li><p>空白：错误</p></li></ul><p>示例（SLR(1)分析表）：</p><figure><img src="/image/编译原理/LR分析表.png" alt="LR分析表" /><figcaption aria-hidden="true">LR分析表</figcaption></figure><p>栈中存储语法分析器的状态（编号），编码了语法分析树的上边缘。</p><p>如何构造LR分析表？</p><h5 id="句柄">句柄</h5><p>在输入串的反向最右推导中，如果下一步是逆用产生式<spanclass="math inline">\(A\rightarrow \alpha\)</span>，则称<spanclass="math inline">\(\alpha\)</span>为当前句型的句柄。</p><ul><li>LR语法分析器的关键就是高效寻找每个归约步骤所使用的句柄。</li></ul><p>存在一种LR语法分析方法，保证句柄总是出现在栈顶。</p><h5 id="lr0句柄识别有穷自动机">LR(0)句柄识别有穷自动机</h5><p>LR(0)项：文法G的一个LR(0)项是G的某个产生式加上一个位于体部的点。</p><ul><li>项指明了语法分析器已经观察到了某个产生式的某个前缀</li><li>例：<span class="math inline">\(A\rightarrow XYZ\)</span>的项<ul><li><span class="math inline">\(A\rightarrow ·XYZ\)</span></li><li><span class="math inline">\(A\rightarrow X·YZ\)</span></li><li><span class="math inline">\(A\rightarrow XY·Z\)</span></li><li><span class="math inline">\(A\rightarrow XYZ·\)</span></li></ul></li><li>项集：若干项构成的集合，可以表示句柄识别自动机的一个状态</li><li>项集族：若干项集的集合，可以表示句柄识别自动机的状态集</li></ul><p>增广文法：文法G的增广文法G‘为在G中加入产生式<spanclass="math inline">\(S&#39;\rightarrow S\)</span>的文法。</p><p>状态的划分：“点”的位置</p><ul><li><p>点指明了栈顶，左边是栈中内容，右边是期望看到的文法符号。</p></li><li><p>以<span class="math inline">\(E&#39;\rightarrow·E\)</span>为初始状态，推导点右边的内容。</p></li><li><p>逐步推导接受文法符号后的内容。</p></li></ul><p>示例：</p><figure><img src="/image/编译原理/LR0句柄识别自动机.png"alt="LR0句柄识别自动机" /><figcaption aria-hidden="true">LR0句柄识别自动机</figcaption></figure><p><span class="math inline">\(J=GOTO(I,X)=CLOSURE({[A\rightarrow\alphaX·\beta]|[A\rightarrow\alpha·X\beta]\in I})\)</span></p><p>接受状态：<span class="math inline">\(F=\{I\in C|\exist[A\rightarrow\alpha·]\in I \}\)</span></p><p>GOTO函数拆分成ACTION表（针对终结符）和GOTO表（针对非终结符）。</p><p>上图转化为的表：</p><figure><img src="/image/编译原理/LR0分析表.png" alt="LR0分析表" /><figcaption aria-hidden="true">LR0分析表</figcaption></figure><p>LR(0)分析表构造规则</p><ul><li><p><span class="math inline">\(GOTO(I_i,a)=I_j\and a\inT\Longrightarrow ACTION[i,a]\leftarrow sj\)</span></p></li><li><p><span class="math inline">\(GOTO(I_i,A)=I_j\and A\inN\Longrightarrow GOTO[i,A]\leftarrow gj\)</span></p></li><li><p><span class="math inline">\([k: A\rightarrow\alpha·]\in I_i\andA\neq S&#39;\Longrightarrow\forall t\inT\cup\{\$\}.ACTION[i,t]=rk\)</span></p></li><li><p><span class="math inline">\([S&#39;\rightarrow S·]\inI_i\Longrightarrow ACTION[i,\$]\leftarrow acc\)</span></p></li></ul><p>改进第三规则即为SLR(1)分析表：</p><p><span class="math inline">\([k: A\rightarrow\alpha·]\in I_i\and A\neqS&#39;\Longrightarrow\forall t\in Follow(A).ACTION[i,t]=rk\)</span></p><p>LR(0)文法</p><p>如果文法G的LR(0)分析表是无冲突的，则G是LR(0)文法。</p><ul><li>LR(0)分析表每一行选用的归约产生式是相同的。</li></ul><p>SLR(1)文法</p><p>如果文法G的SLR(1)分析表无冲突，则G是SLR(1)文法。</p><p>两类可能的冲突：移入/归约冲突、归约/归约冲突</p><h2 id="三属性文法">三、属性文法</h2><p>属性文法：为上下文无关文法赋予语义</p><p>在语义分析过程中实现属性文法，语义动作嵌入的位置决定了何时执行该动作。</p><p>基本思想：一个动作在它左边的所有文法符号都处理过之后立即执行</p><h3 id="语法制导定义">语法制导定义</h3><p>Syntax-Directed Definition，SDD</p><p>一个上下文无关文法和属性及规则的结合。</p><ul><li>每个文法符号都可以关联多个属性</li><li>每个产生式都可以关联一组规则</li></ul><p>SDD唯一确定了语法分析树上每个非终结符节点的属性；</p><p>SDD没有规定以什么方式、什么顺序计算这些属性值。</p><h4 id="综合属性">综合属性</h4><p>结点N的综合属性只能通过N的子结点或N本身的属性进行定义。</p><h4 id="s属性定义">S属性定义：</h4><p>如果一个SDD的每个属性都是综合属性，则它是S属性定义。</p><p>依赖图用于确定一棵给定的语法分析树中各个属性实例之间的依赖关系。</p><p>S 属性定义的依赖图刻画了属性实例之间自底向上的信息流动。</p><h4 id="继承属性">继承属性</h4><p>结点N上的继承属性只能通过N的父结点、N本身和N的兄弟结点上的属性来定义。</p><p>继承属性<spanclass="math inline">\(T^{&#39;}.inh\)</span>用于在表达式中从左到右传递中间计算结果</p><table><thead><tr class="header"><th>产生式</th><th>语法规则</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(T\rightarrow FT^{&#39;}\)</span></td><td><span class="math inline">\(T^{&#39;}.inh=F.val\)</span>；<spanclass="math inline">\(T.val=T^{&#39;}.syn\)</span>；</td></tr><tr class="even"><td><span class="math inline">\(T^{&#39;}\rightarrow*FT_1^{&#39;}\)</span></td><td><span class="math inline">\(T^{&#39;}_1.inh=T^{&#39;}.inh\timesF.val\)</span>；<spanclass="math inline">\(T^{&#39;}.syn=T^{&#39;}_1.syn\)</span>；</td></tr><tr class="odd"><td><span class="math inline">\(T^{&#39;}\rightarrow\epsilon\)</span></td><td><spanclass="math inline">\(T^{&#39;}.syn=T^{&#39;}.inh\)</span>；</td></tr><tr class="even"><td><span class="math inline">\(F\rightarrow digit\)</span></td><td><span class="math inline">\(F.val=digit.lexval\)</span>；</td></tr></tbody></table><p>综合属性<spanclass="math inline">\(T^{&#39;}.syn\)</span>则用以计算最终结果。</p><h4 id="l属性定义">L属性定义</h4><p>如果一个SDD的每个属性要么是综合属性，要么是继承属性，则它是L属性定义。</p><ul><li><p>继承属性规则需满足限制：</p><p>对于<span class="math inline">\(A\rightarrowX_1X_2...X_n\)</span>及其对应规则定义的<spanclass="math inline">\(X_i.a\)</span>，这个规则只能使用</p><ul><li>和产生式头A关联的继承属性</li><li>位于<spanclass="math inline">\(X_i\)</span>左边的文法符号的相关的综合属性或继承属性</li><li>和这个<spanclass="math inline">\(X_i\)</span>的实例本身相关的继承属性或综合属性，但是在这个<spanclass="math inline">\(X_i\)</span>的全部属性组成的依赖图中不存在环</li></ul></li></ul><p>数组类型文法：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">T:</span> BC<br><span class="hljs-symbol">B:</span> INT<br><span class="hljs-symbol">C:</span> <span class="hljs-string">&#x27;[&#x27;</span> INT <span class="hljs-string">&#x27;]&#x27;</span> C<br></code></pre></td></tr></table></figure><p>有符号二进制数文法</p><table><thead><tr class="header"><th>产生式</th><th>属性规则</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(Number\rightarrow SignList\)</span></td><td><spanclass="math inline">\(List.pos=0;\)</span>$if(Sign.neg){Number.val=-List.val;}<span class="math display">\[else\{Number.val=List.val;\}$ || $Sign\rightarrow +$           |$Sign.neg=false;$                                            || $Sign\rightarrow -$           |$Sign.neg=true;$                                             || $List\rightarrow Bit$         | $Bit.pos =List.pos;\]</span>List.val=Bit.val;$</td></tr><tr class="even"><td><span class="math inline">\(List\rightarrow List_1Bit\)</span></td><td><span class="math inline">\(List_1.pos=List.pos+1;\)</span><spanclass="math inline">\(Bit.pos=List.pos;\)</span><spanclass="math inline">\(List.val=List_1.val+Bit.val;\)</span></td></tr><tr class="odd"><td><span class="math inline">\(Bit\rightarrow 0\)</span></td><td><span class="math inline">\(Bit.val=0;\)</span></td></tr><tr class="even"><td><span class="math inline">\(Bit\rightarrow 1\)</span></td><td><span class="math inline">\(Bit.val=1;\)</span></td></tr></tbody></table><h4 id="后缀表示">后缀表示</h4><p>递归定义：</p><ul><li>如果E是一个常量或变量，则E的后缀表示是E本身</li><li>如果E是形如<span class="math inline">\(E_1 opE_2\)</span>的表达式，则E的后缀表示是<spanclass="math inline">\(E_1&#39;E_2&#39;op\)</span>，这里的<spanclass="math inline">\(E_1&#39;\)</span>和<spanclass="math inline">\(E_2&#39;\)</span>是<spanclass="math inline">\(E_1\)</span>和<spanclass="math inline">\(E_2\)</span>的后缀表达式</li><li>如果E是形如<spanclass="math inline">\((E_1)\)</span>的表达式，则E的后缀表示是<spanclass="math inline">\(E_1\)</span>的后缀表示</li></ul><h3 id="语法制导的翻译方案">语法制导的翻译方案</h3><p>Syntax-Directed translation，SDT</p><p>在其产生式体中嵌入语义动作的上下文无关文法。</p><ul><li>用大括号包括规则，写在产生式之后。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理-词法分析</title>
    <link href="/2023/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2023/06/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>子不语</p><span id="more"></span><h1 id="词法分析">词法分析</h1><h2 id="一词法分析器的作用">一、词法分析器的作用</h2><h3 id="词法分析器的主要任务">词法分析器的主要任务</h3><p>读入源程序的输入字符，将它们组成词素，生成并输出一个词法单元序列，每个词法单元对应于一个词素。</p><p>词法分析器负责读取源程序，因此还会完成一些识别词素之外的任务，例如：</p><ul><li>过滤源程序中的注释与空白</li><li>将编译器生成的错误信息与源程序位置关联</li><li>宏预处理</li></ul><p>此后，进入词法分析阶段。</p><p>词法分析与语法分析分离的原因：</p><ol type="1"><li>简化编译器设计：简化词法分析和语法分析中的一些任务</li><li>提高编译器效率：使用专用于词法分析的一些技术</li><li>增强编译器可移植性：输入设备的特殊性可限制于词法分析中</li></ol><h3 id="术语">术语</h3><ul><li>词素：源程序中的一个字符序列，和某个词法单元的模式匹配，被词法分析器识别为该词法单元的一个实例</li><li>词法单元：一个词法单元名和一个可选的属性值</li><li>模式：一个词法单元的词素可能具有的形式</li></ul><p>词法单元的一般类别：</p><ol type="1"><li>关键字，其模式为其本身</li><li>运算符</li><li>表示符</li><li>常量词法单元</li><li>标点符号</li></ol><h3 id="词法错误">词法错误</h3><p>当出现所有词法单元的模式都无法和剩余输入的某个前缀相匹配的情况，词法分析器就不能继续处理输入。</p><p>“恐慌模式”恢复：从剩余的输入中不断删除字符，直到词法分析器能够在剩余输入的开头发现一个正确的语法单元为止。</p><p>其他恢复动作：</p><ul><li>从剩余的输入中删除一个字符</li><li>向剩余的输入中插入一个遗漏的字符</li><li>用一个字符来替换另一个字符</li><li>交换两个相邻的字符</li></ul><h2 id="二输入缓冲">二、输入缓冲</h2><p>在编译一个大型源程序时需要处理大量的字符，利用两个交替读入的缓冲区可以减少处理字符的开销。</p><p>每个缓冲区都有N个字符，通常N为一个磁盘块的大小。可以使用系统读取命令一次将N个字符读入到缓冲区中，若读入的剩余字符不足N个，则会有一个特殊字符(如eof)标记源文件的结束，该字符不同于任何可能出现在源程序中的字符。</p><p>程序为输入维护了两个指针：</p><ul><li>lexemeBegin指针：指向当前词素的开始处</li><li>forward指针：一直向前扫描，直到发现某个模式被匹配为止</li></ul><p>确定一个词素后，词法分析器将这个词素记录下来，然后用lexemeBegin指向词素后第一个字符。</p><h3 id="哨兵标记">哨兵标记</h3><p>每次前移forward时，都须检查是否到了缓冲区的末尾，若是，则须加载另一个缓冲区。</p><p>我们扩展每一个缓冲区，在它们的末尾加上一个哨兵字符来完成对缓冲区末端的测试，这个哨兵字符的一个选择就是eof。</p><h2 id="三词法单元的规约">三、词法单元的规约</h2><h3 id="串和语言">串和语言</h3><ul><li><p>字母表：一个有限的符号集合。</p></li><li><p>串：某个字母表中符号的一个有穷序列。</p><ul><li>串s的长度，通常记作|s|。空串是长度为0的串，用𝜖表示。</li></ul></li><li><p>语言：某个给定字母表上一个任意的可数的串集合。</p></li></ul><p>串的一些术语：</p><ol type="1"><li>串的前缀是从其尾部删除0个或多个符号后得到的串，包括其本身和𝜖</li><li>串的后缀是从其首部删除0个或多个符号后得到的串，包括其本身和𝜖</li><li>串的子串是删除某个前缀和某个后缀后得到的串</li><li>串的真前缀、真后缀、真子串不等于其本身</li><li>串的子序列是从其中删除0个或多个符号后得到的串</li></ol><h4 id="串的连接">串的连接</h4><p>如果x和y是串，那么x和y的连接(记作xy)是把y附加到x后形成的串。</p><p>可以把连接看成两个串的乘积，定义串的指数运算：</p><p>串的0次方为𝜖，n次方为n个该串的连接。</p><h4 id="语言上的运算">语言上的运算</h4><p>并、连接、闭包</p><ul><li><p>L和M的并：<span class="math inline">\(L\cup M = \{s|s\in L\ors\in M\}\)</span></p></li><li><p>L和M的连接：<span class="math inline">\(LM= \{st|s\in L\and t\inM\}\)</span></p></li><li><p>L的Kleene闭包：将L连接0次或多次后得到的串集，记为<spanclass="math inline">\(L^*\)</span></p></li><li><p>L的正闭包：将L连接1次或多次后得到的串集，记为<spanclass="math inline">\(L^+\)</span></p></li></ul><h3 id="正则表达式的递归定义">正则表达式的递归定义</h3><p>归纳基础：</p><ol type="1"><li>𝜖是一个正则表达式，<span class="math inline">\(L(\epsilon ) =\{\epsilon\}\)</span>，即该语言只包含空串</li><li>如果a是字母表上的一个符号，那么a是一个正则表达式，并且<spanclass="math inline">\(L(a) =\{a\}\)</span>，即该语言只包含一个符号串a</li></ol><p>归纳步骤：由小的正则表达式构造大的正则表达式的步骤有四个部分。假定r和s都是正则表达式，分别表示语言L(r)和L(s)，那么：</p><ol type="1"><li><spanclass="math inline">\((r)\)</span>是一个正则表达式，表示语言<spanclass="math inline">\(L(r)\)</span></li><li><spanclass="math inline">\((r)(s)\)</span>是一个正则表达式，表示语言<spanclass="math inline">\(L(r)L(s)\)</span></li><li><spanclass="math inline">\((r)^*\)</span>是一个正则表达式，表示语言<spanclass="math inline">\((L(r))^*\)</span></li><li><spanclass="math inline">\((r)|(s)\)</span>是一个正则表达式，表示语言<spanclass="math inline">\(L(r)\cup L(s)\)</span></li></ol><p>采取如下约定来舍去不需要的括号：</p><ol type="1"><li>一元运算符*具有最高的优先级，并且左结合</li><li>连接具有次高的优先级，并且左结合</li><li>|的优先级最低，并且左结合</li></ol><p>正则集合：可以用一个正则表达式定义的语言。</p><p>称两个表示相同语言的正则表达式等价。</p><p>以下为一些正则表达式的代数定律</p><ol type="1"><li><span class="math inline">\(r|s=s|r\)</span>，即|运算具有交换性</li><li><spanclass="math inline">\(r|(s|t)=(r|s)|t\)</span>，|运算具有结合性</li><li><span class="math inline">\(r(st)=(rs)t\)</span>，连接可结合</li><li><span class="math inline">\(r(s|t)=rs|rt\)</span>，<spanclass="math inline">\((s|t)r=st|sr\)</span>连接对|可分配</li><li><span class="math inline">\(\epsilon\)</span>是连接的单位元</li><li>闭包中一定包含<span class="math inline">\(\epsilon\)</span></li><li><span class="math inline">\(r^*=r^{**}\)</span>，*具有幂等性</li></ol><p>正则定义：为某些正则表达式命名，使用这些名称来表示正则表达式。</p><p>正则表达式的扩展：</p><ol type="1"><li>单目后缀运算符+用以表示一个正则表达式及其语言的正闭包</li><li>单目后缀运算符?表示“0或1个出现”，?具有和+与*相同的优先级、结合性</li><li>字符类：用<spanclass="math inline">\([a_1a_2...a_n]\)</span>缩写<spanclass="math inline">\(a_1|a_2|...|a_n\)</span>，如果<spanclass="math inline">\([a_1a_2...a_n]\)</span>形成一个逻辑上连续的序列，可以表示成<spanclass="math inline">\([a_1-a_n]\)</span></li></ol><p>至此，我们可以使用正则表达式来表示一个模式。</p><h3 id="java正则表达式">Java正则表达式</h3><h4 id="单个字符">单个字符</h4><table><thead><tr class="header"><th>正则表达式</th><th>规则</th></tr></thead><tbody><tr class="odd"><td>A</td><td>指定字符</td></tr><tr class="even"><td>48c</td><td>指定Unicode字符</td></tr><tr class="odd"><td>.</td><td>任意字符</td></tr><tr class="even"><td> 数字0～9</td><td></td></tr><tr class="odd"><td></td><td>大小写字母、数字和下划线</td></tr><tr class="even"><td></td><td>空格、Tab键</td></tr><tr class="odd"><td></td><td>非数字</td></tr><tr class="even"><td></td><td>非</td></tr><tr class="odd"><td></td><td>非</td></tr></tbody></table><h4 id="多个字符">多个字符</h4><table><thead><tr class="header"><th>正则表达式</th><th>规则</th></tr></thead><tbody><tr class="odd"><td>A*</td><td>任意个数字符</td></tr><tr class="even"><td>A+</td><td>至少一个字符</td></tr><tr class="odd"><td>A？</td><td>0或1个字符</td></tr><tr class="even"><td>A{n}</td><td>指定个数字符</td></tr><tr class="odd"><td>A{2,3}</td><td>指定范围个数字符</td></tr><tr class="even"><td>A{n,}</td><td>至少n个字符</td></tr><tr class="odd"><td>A{,n}</td><td>最多n个字符</td></tr></tbody></table><h4 id="复杂匹配规则">复杂匹配规则</h4><table><thead><tr class="header"><th>正则表达式</th><th>规则</th><th>可以匹配</th></tr></thead><tbody><tr class="odd"><td>^</td><td>开头</td><td>字符串开头</td></tr><tr class="even"><td>$</td><td>结尾</td><td>字符串结束</td></tr><tr class="odd"><td>[ABC]</td><td>[...]内任意字符</td><td><code>A</code>,<code>B</code>,<code>C</code></td></tr><tr class="even"><td>[A-F0-9xy]</td><td>指定范围的字符</td><td><code>A</code>,...,<code>F</code>,<code>0</code>,...,<code>9</code>,<code>x</code>,<code>y</code></td></tr><tr class="odd"><td>[^A-F]</td><td>指定范围外的字符</td><td>非<code>A</code>~<code>F</code></td></tr><tr class="even"><td>AB|CD|EF</td><td>AB或者CD或者EF</td><td><code>AB</code>,<code>CD</code>,<code>EF</code></td></tr></tbody></table><h2 id="四词法单元的识别">四、词法单元的识别</h2><p>检查输入字符串，并在其前缀中找出一个和某个模式匹配的词素。</p><h3 id="状态转换图">状态转换图</h3><p>将模式转换成具有特定风格的流图，称为状态转换图。</p><ol type="1"><li>其中包含一组结点或圆圈，即状态，每个状态代表一个可能在词法分析器扫描输入串的过程中匹配到的情况。</li><li>状态图中的边从图的一个状态指向另一个状态，每条边的标号包含了一个或多个符号。</li></ol><p>规则：</p><ol type="1"><li>接受状态或最终状态指已经找到一个词素的状态，用双层的圈表示。</li><li>若需要在接受状态回退数个位置，就在该接受状态附近加上相应数目的*。</li><li>初始状态由一条没有出发结点的标号为start的边指定，是没有读入任何输入前状态转换图的位置。</li></ol><h3 id="保留字和标识符的处理">保留字和标识符的处理</h3><ol type="1"><li>初始化时即将各保留字填入符号表中</li><li>为每个关键字建立单独的状态转换图</li></ol><h2 id="五有穷状态机">五、有穷状态机</h2><ul><li>不确定的有穷状态机 (Nondeterministic Finite Automata，NFA)<ul><li>对边上的标号没有限制，一个符号标记离开同一状态的多条边，并且空串也可作为标号</li></ul></li><li>确定的有穷状态机 (Deterministic Finite Automata，DFA)<ul><li>对于每个状态及输入自动机的每个符号，有且只有一条离开该状态，以该符号为标号边</li></ul></li></ul><h3 id="不确定有穷状态机">不确定有穷状态机</h3><p>组成部分：</p><ol type="1"><li>一个有穷的状态集合S</li><li>一个输入符号集合<spanclass="math inline">\(\Sigma\)</span>，即输入字母表，假设空串的<spanclass="math inline">\(\epsilon\)</span>不是字母表中的元素</li><li>一个转换函数，为每个状态和<span class="math inline">\(\Sigma \cup\{\epsilon\}\)</span>中每个符号给出相应后继状态的集合</li><li>S中的一个状态<spanclass="math inline">\(s_0\)</span>被指定为开始状态</li><li>S的一个子集F被指定为接受状态的集合</li></ol><h4 id="转换图">转换图</h4><p>不管是不确定有穷状态机还是确定有穷状态机，都可以表示为一张转换图，图中的结点是状态，带有标号的边表示自动机的转换函数。从状态s到状态t存在一条标号为a的边当且仅当状态t是状态s在输入a之后的后继状态之一。</p><p>和状态转换图的区别：</p><ul><li>同一个符号可以标记从同一状态出发到达多个目标状态的多条边</li><li>一条边的标号不仅可以是输入字母表中的符号，也可以是空符号串<spanclass="math inline">\(\epsilon\)</span></li></ul><h4 id="转换表">转换表</h4><p>从次行起的各行对应各状态，首行的各列对应于输入符号和$$。</p><ul><li>对应于一个给定状态和给定输入的条目是将NFA的转换函数应用于这些参数后得到的值</li><li>如果转换函数没有给出对应于某个状态-输入对的信息，就将<spanclass="math inline">\(\varnothing\)</span>放入对应表项中</li></ul><p>转换表易于确定给定状态与输入符号对应的转换，但当输入字母表较大且多数状态在多数输入字符上无转换时需占用大量空间。</p><h4 id="自动机接受输入字符串">自动机接受输入字符串</h4><p>一个不确定有穷状态机接受输入字符串，当且仅当对应的转换图中存在一条从开始状态到某个接受状态的路径上的标号(忽略空串)组成该字符串。</p><p>由一个不确定有穷状态机定义的语言为从开始状态到接受状态的所有路径上标号串的集合。可以用<spanclass="math inline">\(L(A)\)</span>表示自动机A接受的语言。</p><h3 id="确定有穷状态机">确定有穷状态机</h3><p>组成部分：</p><ol type="1"><li>一个有穷的状态集合S</li><li>一个输入符号集合<spanclass="math inline">\(\Sigma\)</span>，即输入字母表，假设空串的<spanclass="math inline">\(\epsilon\)</span>不是字母表中的元素</li><li>一个转换函数，为每个状态和<spanclass="math inline">\(\Sigma\)</span>中每个符号给出相应后继状态的集合</li><li>S中的一个状态<spanclass="math inline">\(s_0\)</span>被指定为开始状态</li><li>S的一个子集F被指定为接受状态的集合</li></ol><p>不确定有穷状态机的特例</p><ul><li>没有输入<span class="math inline">\(\epsilon\)</span>的转换动作</li><li>对每个状态s和每个输入符号a，有且仅有一条为标号a的边离开s</li></ul><p>不确定有穷状态机抽象地表示了用来识别某个语言中的串的算法，而相应的确定有穷状态机则是一个简单具体的识别串的算法。</p><ul><li><p>在构造词法分析器时，真正实现或模拟的是确定有穷状态机。</p></li><li><p>每个正则表达式和每个确定有穷状态机都可以被转变成为一个接受相同语言的确定有穷状态机。</p></li></ul><h2 id="六从正则表达式到自动机">六、从正则表达式到自动机</h2><p>正则表达式——&gt;不确定有穷状态机——&gt;确定有穷状态机——&gt;词法分析器</p><p>第一步：Thompson构造法</p><p>第二步：子集构造法</p><h3 id="thompson构造法">Thompson构造法</h3><p>基本思想：按结构归纳</p><p>记r的不确定有穷状态机为N(r)。</p><p>根据正则表达式的递归定义进行构造：</p><ul><li>𝜖是一个正则表达式<ul><li>初始状态接受<spanclass="math inline">\(\epsilon\)</span>到达结束状态</li></ul></li><li>字母表上的一个符号a是一个正则表达式<ul><li>初始状态接受a到达结束状态</li></ul></li><li><span class="math inline">\((r)\)</span>是一个正则表达式<ul><li>等同于r的不确定有穷状态机</li></ul></li><li><span class="math inline">\((r)(s)\)</span>是一个正则表达式<ul><li>将r的结束状态和s的初始状态合并</li></ul></li><li><span class="math inline">\((r)^*\)</span>是一个正则表达式<ul><li>r的结束状态接受<spanclass="math inline">\(\epsilon\)</span>到达开始状态或系统结束状态</li><li>系统初始状态接受<spanclass="math inline">\(\epsilon\)</span>到r的初始状态或系统结束状态</li></ul></li><li><span class="math inline">\((r)|(s)\)</span>是一个正则表达式<ul><li>系统初始状态接受<spanclass="math inline">\(\epsilon\)</span>到达r和s的初始状态，r和s的结束状态接受<spanclass="math inline">\(\epsilon\)</span>到达系统结束状态</li></ul></li></ul><p>复杂度：<span class="math inline">\(O(n)\)</span></p><h4 id="nr的性质">N(r)的性质</h4><ul><li>开始状态和接受状态唯一</li><li>开始状态没有入边，接受状态没有出边</li><li>N(r)的状态数<span class="math inline">\(|S|\leq 2\times|r|\)</span>，其中|r|为r中运算符和运算分量的总和</li><li>每个状态最多有两个<spanclass="math inline">\(\epsilon\)</span>入边与两个<spanclass="math inline">\(\epsilon\)</span>出边（<spanclass="math inline">\(r|s\)</span>的情况下）</li><li>$a$，每个状态最多有一个a入边和一个a出边</li></ul><h3 id="子集构造算法">子集构造算法</h3><p>r的确定有穷状态机记为D(r)。</p><p>让构造得到的DFA每个状态对应于NFA的一个状态集合。</p><ol type="1"><li>使用NFA开始状态的<spanclass="math inline">\(\epsilon\)</span>闭包确定DFA的开始状态</li><li>根据NFA开始状态的<spanclass="math inline">\(\epsilon\)</span>闭包的转换确定DFA开始状态的转换</li><li>逐步进行DFA的模拟</li></ol><p>复杂度：<spanclass="math inline">\(O(2^n)\)</span>，极限情况下有<spanclass="math inline">\(\Omega (2^n)\)</span></p><p>闭包与不动点</p><p>集合T的函数f闭包为对T进行任意次或0次f的结果的集合。</p><p>若存在f(x)=x，则x称为f的不动点。</p><h3 id="dfa最小化算法">DFA最小化算法</h3><p>基本思想：等价的状态可以合并</p><p>状态等价的定义：</p><p>状态s和t等价，即两者接受相同的字符时，会到达相同的状态。记为s～t。</p><ul><li>但是无法判断初始等价的状态，无法进行递归合并。</li><li>于是使用不等价进行划分。</li></ul><p><span class="math inline">\(s不等价于t\Longleftrightarrow \existsa\in \Sigma. (s\rightarrow^a s&#39;) \and (t \rightarrow^at&#39;)\and(s&#39;不等价于t&#39;)\)</span></p><p>步骤：</p><ol type="1"><li>接受状态和非接受状态必然不等价，以此为初始条件进行等价状态的递归划分。</li><li>合并等价的状态。</li></ol><p>使用该算法前，需要确保该自动机确实是DFA，检查是否需要补充死状态。</p><h3 id="从dfa到词法分析器">从DFA到词法分析器</h3><ul><li><p>最前优先匹配：匹配匹配到的最优先的接受状态</p></li><li><p>最长优先匹配：匹配最长的字符串</p></li></ul><p>模拟DFA步骤</p><ol type="1"><li>模拟运行DFA，直到无法继续为止（输入结束或状态无转移）</li><li>若当前状态为接受状态，则识别成功</li><li>否则回溯至最近一次经过的接受状态，识别成功</li><li>若回溯到初始状态，则报错，删除当前字符，运行第1步</li></ol><h3 id="从dfa到正则表达式">从DFA到正则表达式</h3><p>暂略</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第六章_并发程序设计</title>
    <link href="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第六章-并发程序设计">第六章 并发程序设计</h1><h2 id="并发进程">6.1 并发进程</h2><h3 id="顺序程序设计">6.1.1 顺序程序设计</h3><p>进程在处理器上的顺序执行是严格按序的，一个操作结束后，才能开始后续操作。</p><p>顺序程序设计：把一个程序设计成顺序执行的程序模块。</p><ul><li>顺序不仅在一个程序模块内部，也在多个程序模块之间。</li></ul><p>顺序程序设计的特点：</p><ul><li>程序执行的顺序性</li><li>程序环境的封闭性</li><li>执行结果的确定性</li><li>计算过程的可再现性</li></ul><h3 id="进程的并发性">6.1.2 进程的并发性</h3><p>进程的并发性（Concurrency）是指一组进程的执行在时间上是重叠的。</p><ul><li>宏观上，并发性反映一个时间段中几个进程都在同一处理器上，处于运行还未运行结束状态</li><li>微观上，任一时刻仅有一个进程在处理器上运行</li></ul><h4 id="并发程序设计">并发程序设计</h4><p>使一个程序分成若干个可同时执行的程序模块的方法称为并发程序设计（concurrentprogramming），每个程序模块和它执行时所处理的数据就组成一个进程。</p><p>并发进程的分类：无关的、交互的</p><ul><li>无关的并发进程：一个进程的执行与其他并发进程的进展无关<ul><li>并发进程的无关性是进程的执行与时间无关的一个充分条件，又称为Bernstein条件</li></ul></li><li>交互的并发进程：一个进程的执行可能影响其他并发进程的结果</li></ul><h4 id="bernstein条件">Bernstein条件</h4><ul><li><p>程序<spanclass="math inline">\(p_i\)</span>在执行期间引用的变量集，记为<spanclass="math inline">\(R(p_i)=\{a_{i1},a_{i2},...,a_{in}\}\)</span>，</p></li><li><p>程序<spanclass="math inline">\(p_i\)</span>在执行期间改变的变量集，记为<spanclass="math inline">\(W(p_i)=\{b_{i1},b_{i2},...,b_{im}\}\)</span></p></li><li><p>若两个进程的程序<span class="math inline">\(p_1\)</span>和<spanclass="math inline">\(p_2\)</span>能满足Beinstein条件，即满足</p><p><span class="math inline">\((R(p_1)\cap W(p_2))\cup (R(p_2)\capW(p_1))\cup (W(p_1)\cap W(p_2))=\varnothing\)</span>，</p><p>则这两个并发进程的执行与时间无关</p></li></ul><p>与时间有关的错误：对于一组交互的并发进程，执行的相对速度无法相互控制，各种与时间有关的错误就有可能出现。</p><ul><li>与时间有关错误的表现形式：结果不唯一、永远等待</li></ul><h3 id="进程的交互竞争和协作">6.1.3 进程的交互：竞争和协作</h3><p>进程之间存在两种基本关系：竞争关系和协作关系</p><ul><li>竞争关系：一个进程的执行可能影响到同其竞争资源的其他进程，如果两个进程要访问同一资源，那么一个进程通过操作系统分配得到该资源，另一个将不得不等待</li><li>协作关系：某些进程为了完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的信号之前应阻塞自己，直到其他合作进程发来协调信号后方被唤醒并继续执行。</li></ul><h4 id="资源竞争的两个控制问题">资源竞争的两个控制问题</h4><ul><li>死锁：一组进程如果都获得了部分的资源，还想要得到其他进程所占有的资源，最终所有的进程都将陷入死锁</li><li>饥饿：一个进程由于其他进程总是优先于它而被无限期拖延</li><li>操作系统需要保证诸进程能互斥地访问临界资源，既要解决饥饿问题，又要解决死锁问题</li></ul><h4 id="进程的互斥与同步">进程的互斥与同步</h4><p>进程的互斥（mutual exclusion）是解决进程间竞争关系的手段。</p><ul><li>若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源</li></ul><p>进程的同步（Synchronization）是解决进程间协作关系的手段。</p><ul><li>两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一个协作进程的信号，当一个进程没有得到来自于另一个进程的信号则需等待。</li></ul><p>进程的互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，是对进程使用资源次序上的一种协调。</p><h2 id="临界区管理">6.2 临界区管理</h2><h3 id="互斥与临界区">6.2.1 互斥与临界区</h3><ul><li><p>并发进程中与共享变量有关的程序段称为临界区（criticalsection）</p><p>共享变量代表的资源称为临界资源</p></li><li><p>与同一变量有关的临界区分散在各进程的程序段中，而各进程的执行速度不可预见</p></li><li><p>如果保证进程在临界区执行时，不让另一个进程进入临界区，即各进程对共享变量的访问互斥，就不会造成与时间有关的错误。</p></li></ul><h4id="临界区调度原则dijkstra1965">临界区调度原则（Dijkstra，1965）</h4><ul><li>一次至多一个进程能够进入临界区内执行</li><li>如果已有进程在临界区，其他试图进入的进程应等待</li><li>进入临界区内的进程应在有限时间内退出，以便让等待进程中的一个进入</li></ul><h3 id="临界区管理-1">6.2.2 临界区管理</h3><p>临界区管理的简单方法（忙式等待/反复测试）：</p><ul><li>Peterson算法</li><li>关中断</li><li>对换指令</li><li>测试并建立指令</li></ul><p>存在的问题：</p><ul><li>对不能进入临界区的进程，采用忙式等待测试法，浪费CPU时间</li><li>将测试能否加入临界区的责任推给各个竞争的进程会削弱系统的可靠性，加重编程负担</li></ul><p>通用的解决方案：信号量与PV操作</p><h4 id="peterson算法">Peterson算法</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">bool</span> inside[<span class="hljs-number">2</span>];<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">enum</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125; turn;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">P0</span><span class="hljs-params">()</span></span>&#123;<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>turn = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(inside[<span class="hljs-number">1</span>]&amp;&amp;turn==<span class="hljs-number">1</span>);<br>&#123;临界区&#125;;<br>inside[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P1</span><span class="hljs-params">()</span></span>&#123;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(inside[<span class="hljs-number">0</span>]&amp;&amp;turn==<span class="hljs-number">0</span>)<br>&#123;临界区&#125;;<br>inside[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 1:1交替</span><br><span class="hljs-keyword">enum</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125; turn;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">P0</span><span class="hljs-params">()</span></span>&#123;<br>turn = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(turn==<span class="hljs-number">1</span>);<br>&#123;临界区&#125;;<br>turn = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">process <span class="hljs-title">P1</span><span class="hljs-params">()</span></span>&#123;<br>turn = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(turn==<span class="hljs-number">0</span>);<br>&#123;临界区&#125;;<br>turn = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关中断">关中断</h4><ul><li>实现互斥的最简单方法</li></ul><h4 id="测试并建立指令">测试并建立指令</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//TS指令实现进程互斥</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TS</span><span class="hljs-params">(<span class="hljs-type">bool</span> &amp;x)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(x)&#123;<br>    x = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> s = <span class="hljs-literal">true</span>;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">Pi</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">TS</span>(s)); <span class="hljs-comment">//上锁</span><br>  &#123;临界区&#125;;<br>  s = <span class="hljs-literal">true</span>;      <span class="hljs-comment">//开锁</span><br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h4 id="对换指令">对换指令</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//对换指令实现进程互斥</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SWAP</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> &amp;a, <span class="hljs-built_in">bool</span> &amp;b</span>)</span>&#123;<br><span class="hljs-built_in">bool</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-built_in">bool</span> <span class="hljs-keyword">lock</span> = <span class="hljs-literal">false</span>;<br><span class="hljs-function">cobegin</span><br><span class="hljs-function">Process <span class="hljs-title">Pi</span>()</span>&#123;<br><span class="hljs-built_in">bool</span> key = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">do</span>&#123;<br>SWAP(key, <span class="hljs-keyword">lock</span>);<br>&#125;<span class="hljs-keyword">while</span>(key);<span class="hljs-comment">//上锁</span><br>&#123;临界区&#125;;<br>SWAP&#123;key, <span class="hljs-keyword">lock</span>&#125;;<span class="hljs-comment">//开锁</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号量与pv操作">6.3 信号量与PV操作</h2><h3id="信号量与pv操作的数据结构与原语操作">信号量与PV操作的数据结构与原语操作</h3><p>设s为一个记录型数据结构，一个分量为整型量value，另一个为信号量队列queue，P和V操作原语的定义：</p><ul><li>P(s)：将信号量s减去1，若结果小于0，则调用P(s)的进程被设置成等待信号量s的状态</li><li>V(s)：将信号量s加1，若结果不大于0，则释放一个等待信号量s的进程，其转为就绪态</li></ul><p>对于信号量，只允许使用P和V原语操作访问，不能直接对信号量的整型值和队列作操作</p><p>原语：CPU处于内核态，在关中断环境下执行的一段指令序列</p><ul><li>原子性：不被中断，确保安全且完整执行这段指令序列</li></ul><h4 id="几个经典问题">几个经典问题</h4><h5 id="哲学家就餐问题互斥">哲学家就餐问题（互斥）</h5><p>有五个哲学家围坐在一圆桌旁，桌中央有一盘通心面，每人面前有一只空盘子，每两人之间放一把叉子。每个哲学家思考、饥饿、然后吃通心面。为了吃面，每个哲学家必须获得两把叉子，且每人只能直接从自己左边或右边去取叉子。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">semaphore fork<span class="hljs-literal">[<span class="hljs-number">5</span>]</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<br>fork<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=<span class="hljs-number">1</span>;<br>semaphore room=<span class="hljs-number">4</span>; <span class="hljs-comment">//增加一个侍者，设想有两个房间1号房间是会议室，2号房间是餐厅</span><br>cobegin<br>process philosopher<span class="hljs-constructor">_i()</span>&#123; <span class="hljs-comment">//i=0,1,2,3,4</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>think<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">room</span>)</span>; <span class="hljs-comment">//控制最多允许4位哲学家进入2号房间餐厅取叉子</span><br><span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>; <span class="hljs-comment">//偶数哲学家先右手</span><br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span> % <span class="hljs-number">5</span> ]); <span class="hljs-comment">//后左手</span><br>eat<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>;<br>V (fork<span class="hljs-literal">[(<span class="hljs-identifier">i</span>+<span class="hljs-number">1</span>) % <span class="hljs-number">5</span>]</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span> % <span class="hljs-number">5</span> ]); <span class="hljs-comment">//奇数哲学家，先左手</span><br><span class="hljs-constructor">P(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>; <span class="hljs-comment">//后右手</span><br>eat<span class="hljs-literal">()</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[(<span class="hljs-params">i</span>+1)</span>%<span class="hljs-number">5</span>]);<br><span class="hljs-constructor">V(<span class="hljs-params">fork</span>[<span class="hljs-params">i</span>])</span>;<br>&#125;<br><span class="hljs-constructor">V(<span class="hljs-params">room</span>)</span>;<br>&#125;<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h5 id="生产者与消费者问题同步">生产者与消费者问题（同步）</h5><p>有n个生产者和m个消费者，连接在一个有k个单位缓冲 区的有界缓冲上。</p><p>其中，生产者进程<spanclass="math inline">\(Producer_i\)</span>和消费者进程<spanclass="math inline">\(Consumer_j\)</span>都是并发进程，只要缓冲区未满，生产者<spanclass="math inline">\(Producer_i\)</span>生产的产品就可投入缓冲区；只要缓冲区不空，消费者进程<spanclass="math inline">\(Consumer_j\)</span>就可从缓冲区取走并消耗产品。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">产品 Buffer<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>semaphore put = k, get = <span class="hljs-number">0</span>;<span class="hljs-comment">//可以put或get的缓冲区数</span><br><span class="hljs-built_in">int</span> putPos = getPos = <span class="hljs-number">0</span>;<span class="hljs-comment">//put或get的位置</span><br>semaphore p = g = <span class="hljs-number">1</span>;<span class="hljs-comment">//互斥使用put或get的位置</span><br><br>process <span class="hljs-constructor">Producer_i()</span>&#123;<br>&#123;生产产品&#125;;<br><span class="hljs-constructor">P(<span class="hljs-params">put</span>)</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">p</span>)</span>;<br>Buffer<span class="hljs-literal">[<span class="hljs-identifier">putPos</span>]</span> = 产品;<br>putPos = (putPos + <span class="hljs-number">1</span>) % k;<br><span class="hljs-constructor">V(<span class="hljs-params">p</span>)</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">get</span>)</span>;<br>&#125;<br><br>process <span class="hljs-constructor">Consumer_i()</span>&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">get</span>)</span>;<br><span class="hljs-constructor">P(<span class="hljs-params">g</span>)</span>;<br>产品 = Buffer<span class="hljs-literal">[<span class="hljs-identifier">getPos</span>]</span>;<br>getPos = (getPos + <span class="hljs-number">1</span>) % k;<br><span class="hljs-constructor">V(<span class="hljs-params">g</span>)</span>;<br><span class="hljs-constructor">V(<span class="hljs-params">put</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管程">6.4 管程</h2><h3 id="管程和条件变量">6.4.1 管程和条件变量</h3><p>管程的引入：</p><ul><li>把分散在各进程中的临界区集中管理</li><li>防止进程的违法同步操作</li><li>便于用高级语言来编写程序</li></ul><h4 id="管程的定义">管程的定义</h4><p>由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。</p><p>管程的属性：共享性、安全性、互斥性</p><h4 id="管程的形式">管程的形式</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">type 管程名<span class="hljs-operator">=</span>monitor &#123;<br>局部变量说明<span class="hljs-comment">;</span><br>  条件变量说明<span class="hljs-comment">;</span><br>  初始化语句<span class="hljs-comment">;</span><br>define 管程内定义的，管程外可调用的过程或函数名列表<span class="hljs-comment">;</span><br>use 管程外定义的，管程内将调用的过程或函数名列表<span class="hljs-comment">;</span><br>过程名/函数名(形式参数表) &#123;<br>&lt;过程/函数体&gt;<span class="hljs-comment">;</span><br>&#125;<br>...<br>过程名/函数名(形式参数表) &#123;<br>&lt;过程/函数体&gt;<span class="hljs-comment">;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管程的条件变量">管程的条件变量</h4><p>只有在管程中才能被访问，它对管程内所有过程是全局的，只能通过两个原语操作来控制</p><ul><li><p>wait()：阻塞调用进程并释放管程，直到另一个进程在该条件变量上执行signal()</p></li><li><p>signal()：释放由于对条件变量执行wait()而被阻塞的其他进程，若无，信号不被保存</p></li><li><p>使用signal释放等待进程时，可能出现两个进程同时停留在管程内</p><ul><li><p>执行signal的进程等待，直到被释放进程退出管程或等待另一个条件变量</p></li><li><p>被释放进程等待，直到执行signal的进程退出管程或等待另一个条件</p></li><li><p>Hoare采用前一种方法。</p></li></ul></li></ul><h3 id="管程的实现">6.4.2 管程的实现</h3><h4 id="hoare管程">Hoare管程</h4><p>Hoare使用P和V操作原语来实现对管程中过程的互斥调用，以及实现对共享资源互斥使用的管理。</p><ul><li>wait和signal操作可被设计成可以中断的进程</li></ul><h4 id="hoare管程数据结构">Hoare管程数据结构</h4><ol type="1"><li>mutex</li></ol><ul><li>对于每个管程，使用用于管程中过程互斥调用的信号量mutex（初值为1）</li><li>进程调用管程中的任何过程时，应执行P(mutex)，进程退出管程时，需要判断是否有进程在next信号量等待，如果有（即next_count&gt;0），则通过V(next)唤醒一个发出signal的进程，否则应执行V(mutex)开放管程，以便让其他调用者进入</li><li>为了使进程在等待资源期间，其他进程能进入管程，在wait操作中也必须执行V(mutex)</li></ul><ol start="2" type="1"><li>next和next-count</li></ol><ul><li><p>对每个管程，引入信号量next（初值为0），发出signal操作的进程应该用P(next)阻塞自己，直到被释放进程退出管程或产生其他等待条件</p></li><li><p>next-count（初值为0），记录next上等待的进程个数</p></li></ul><ol start="3" type="1"><li>x-sem和x-count</li></ol><ul><li>x-sem（初值为0），申请资源无法满足时，执行P(x-sem)阻塞。由于释放资源时，需知道是否有其他进程在等待资源，用计数器x-count（初值为0）记录等待资源的进程数</li><li>执行signal操作时，应让等待资源的诸进程中的某个进程立即恢复运行，而不让其他进程抢先进入管程，这使用V(x-sem)实现</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">typedef <span class="hljs-keyword">struct</span> Monitor&#123;<br>semaphore mutex;<br>semaphore next;<br><span class="hljs-built_in">int</span> next_count;<br>&#125;<br>mutex = <span class="hljs-number">1</span>;<br>next = <span class="hljs-number">0</span>;<br>next_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//enter()和leave()操作</span><br>void enter(Monitor &amp;m)&#123;<br><span class="hljs-constructor">P(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<br>&#125;<br>void leave<span class="hljs-literal">()</span>&#123;Monitor &amp;m&#125;&#123;<br><span class="hljs-keyword">if</span>(m.next_count&gt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">//wait()</span><br>void wait(semaphore &amp;x_sem, <span class="hljs-built_in">int</span> x_count, Monitor &amp;m)&#123;<br>x_count++;<span class="hljs-comment">//等待资源进程个数加1</span><br><span class="hljs-keyword">if</span>(m.next_count&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//判断是否有发出过signal的进程</span><br><span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<span class="hljs-comment">//释放</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-constructor">V(<span class="hljs-params">m</span>.<span class="hljs-params">mutex</span>)</span>;<span class="hljs-comment">//开放管程</span><br><span class="hljs-constructor">P(<span class="hljs-params">x_sem</span>)</span>;<span class="hljs-comment">//等待资源进程阻塞自己</span><br>x_count--;<span class="hljs-comment">//等待资源进程个数减1</span><br>&#125;<br><br><span class="hljs-comment">//signal()</span><br>void signal(semaphore &amp;x_sem, <span class="hljs-built_in">int</span> x_count, Monitor &amp;m)&#123;<br><span class="hljs-keyword">if</span>(x_count&gt;<span class="hljs-number">0</span>)&#123;<br>m.next_count++;<span class="hljs-comment">//发出signal进程数加1</span><br><span class="hljs-constructor">V(<span class="hljs-params">x_sem</span>)</span>;<span class="hljs-comment">//释放一个等待资源的进程</span><br><span class="hljs-constructor">P(<span class="hljs-params">m</span>.<span class="hljs-params">next</span>)</span>;<span class="hljs-comment">//发出signal的进程阻塞自己</span><br>m.next_count--;<span class="hljs-comment">//发出signal的进程个数减1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="管程求解进程的同步和互斥问题">6.4.3管程求解进程的同步和互斥问题</h3><p>互斥问题：读者写者问题、哲学家就餐问题</p><p>同步问题：生产者与消费者问题、苹果桔子问题</p><h4 id="哲学家就餐问题">哲学家就餐问题</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs perl">type philosophers=monitor<br>enum &#123;thinking,hungry,eating&#125; <span class="hljs-keyword">state</span>[<span class="hljs-number">5</span>];<br>semaphore self[<span class="hljs-number">5</span>]; <span class="hljs-keyword">int</span> self_count[<span class="hljs-number">5</span>]; Monitor M;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">5</span>;i++) <span class="hljs-keyword">state</span>[i] = thinking;<br>define pickup, putdown;<br><span class="hljs-keyword">use</span> enter, leave, <span class="hljs-keyword">wait</span>, signal;<br><br>void pickup(<span class="hljs-keyword">int</span> i)&#123;<br>enter(M);<br><span class="hljs-keyword">state</span>[i] = hungry;<br>test(i);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">state</span>[i] != eating)<br><span class="hljs-keyword">wait</span>(self[i], self_count[i], M);<br>leave(M);<br>&#125;<br><br>void putdown(<span class="hljs-keyword">int</span> i)&#123; <span class="hljs-regexp">//i</span>=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,..,<span class="hljs-number">4</span><br>enter(M);<br>  <span class="hljs-keyword">state</span>[i] = thinking;<br>    test((i-<span class="hljs-number">1</span>)%5);<br>    test((i+<span class="hljs-number">1</span>)%5);<br>leave(M);<br>&#125;<br><br>void test(<span class="hljs-keyword">int</span> k)&#123; <span class="hljs-regexp">//</span>k=<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,...,<span class="hljs-number">4</span> <br><span class="hljs-keyword">if</span>((<span class="hljs-keyword">state</span>[(k-<span class="hljs-number">1</span>)%5] != eating) &amp;&amp; (<span class="hljs-keyword">state</span>[k] == hungry) <br>&amp;&amp;(<span class="hljs-keyword">state</span>[(k+<span class="hljs-number">1</span>)%5] != eating)) <br><span class="hljs-keyword">state</span>[k]=eating;<br>signal(self[k], self_count[k], IM);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生产者与消费者问题">生产者与消费者问题</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> <span class="hljs-built_in">product</span>=monitor<br>item Buffer[k];//缓冲区<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">in</span>, <span class="hljs-keyword">out</span>;//存取位置<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>;<br>semaphore full, empty;<br><span class="hljs-built_in">int</span> full_count, empty_count;<br>Monitor m;<br>define append, take;<br><span class="hljs-keyword">use</span> enter, leave, <span class="hljs-keyword">wait</span>, signal;<br><br>void append(item x)&#123;<br>enter(m);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">count</span> == k) <span class="hljs-keyword">wait</span>(full, full_count, m);<br>Buffer[<span class="hljs-keyword">in</span>] = x;<br><span class="hljs-keyword">in</span> = (<span class="hljs-keyword">in</span> + <span class="hljs-number">1</span>) % k;<br><span class="hljs-built_in">count</span>++;<br>signal(empty, empty_count, m);<br>leave(m);<br>&#125;<br><br>void take(item x)&#123;<br>enter(m);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">count</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">wait</span>(empty, empty_count, m);<br>x = Buffer[<span class="hljs-keyword">out</span>];<br><span class="hljs-keyword">out</span> = (<span class="hljs-keyword">out</span> + <span class="hljs-number">1</span>) % k;<br><span class="hljs-built_in">count</span>--;<br>signal(full, full_count, m);<br>leave(m);<br>&#125;<br><br>cobegin<br>process producer_i()&#123;<br><span class="hljs-built_in">product</span>.append(x);<br>&#125;<br>process consumer_i()&#123;<br><span class="hljs-built_in">product</span>.take(x);<br>&#125;<br>coend<br></code></pre></td></tr></table></figure><h2 id="进程通信">6.5 进程通信</h2><h3 id="进程通信-1">6.5.1 进程通信</h3><p>当进程互相交互时，必须满足两个基本要求：同步和通信</p><ul><li>为实施互斥，进程间需要同步</li><li>为了协作，进程间需要交换信息</li></ul><p>消息传递提供了最典型的消息传递原语：send和receive</p><h4 id="进程直接通信">进程直接通信</h4><ul><li>对称直接寻址，发送进程和接收进程必须命名对方以便通信，原语定义如下：<ul><li><code>send(P, message)</code>发送消息到进程P</li><li><code>receive(Q, message)</code>接收来自进程Q的消息</li></ul></li><li>非对称直接寻址，只要发送者命名接收者，而接收者不需命名发送者<ul><li><code>send(P, message)</code>发送消息到进程P</li><li><code>receive(id, message)</code>接收来自任何进程的消息，id置为与其通信的进程名称</li></ul></li></ul><p>进程P向Q发送消息：</p><pre><code class=" mermaid">graph LR进程P--&gt;内核--&gt;进程Q</code></pre><p>消息格式：消息头与消息体（即消息内容），</p><ul><li>消息头包括：消息类型、目标ID、源ID、消息长度、控制信息</li></ul><h4 id="进程间接通信">进程间接通信</h4><ul><li><p>消息不是直接从发送者发送到接收者，而是发送到由临时保存这些信息的队列组成的一个共享数据结构，这些队列通常称为信箱。</p></li><li><p>一个进程给合适的信箱发送消息，另一进程从信箱中获得消息。</p></li><li><p>间接通信的通信原语定义：</p><ul><li><p><code>send(A, message)</code>把消息传送到信箱A</p></li><li><p><code>receive(A, message)</code>从信箱A接收消息</p></li></ul></li></ul><p>信箱可以分成信箱头和信箱体两部分，信箱头指出信箱容量、信件格式、存放信件位置的指针等；信箱体用来存放信件。信箱体分成若干个可容纳一封信的区。</p><ul><li>send：若指定信箱未满，将信件送入信箱中指针指示的位置，并释放该信箱中信件的等待者，否则，发送信件者被置为等待信箱状态</li><li>receive：如果指定信箱中有信，则取出一封信件，并释放等待信箱的等待者，否则，接收信件者被置成等待信箱中信件的状态</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> box = record<br><span class="hljs-built_in">int</span> size;<span class="hljs-comment">//信箱大小</span><br><span class="hljs-built_in">int</span> count;<span class="hljs-comment">//现有信件数</span><br>message<span class="hljs-literal">[<span class="hljs-identifier">n</span>]</span> letter;<br>semaphore s1, s2;<span class="hljs-comment">//等信箱和等信件信号量</span><br><br>procedure send(box B, message M)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count<span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>size) <span class="hljs-constructor">W(B.<span class="hljs-params">s1</span>)</span>;<span class="hljs-comment">//R和W时让进程入队和出队的两个过程</span><br><span class="hljs-built_in">int</span> i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count + <span class="hljs-number">1</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = M;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count = i;<br><span class="hljs-constructor">R(B.<span class="hljs-params">s2</span>)</span>;<br>&#125;<br><br>procedure receive(box B, message M)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) <span class="hljs-constructor">W(B.<span class="hljs-params">s2</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count - <span class="hljs-number">1</span>;<br>x = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>count;i++)&#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>letter<span class="hljs-literal">[<span class="hljs-identifier">i</span> + <span class="hljs-number">1</span>]</span>;<br>&#125;<br>&#125;<br><span class="hljs-constructor">R(B.<span class="hljs-params">s1</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消息传递的若干问题">消息传递的若干问题</h4><ul><li>信箱容量问题</li><li>多进程与信箱相连的信箱接收问题</li><li>信箱的所有权问题<ul><li>信箱为操作系统所有，是指操作系统统一设置信箱，归系统所有，供相互通信的进程共享，例：消息缓冲机制</li></ul></li><li>信件的格式问题和其他有关问题</li><li>通信进程的同步问题</li></ul><h4 id="消息缓冲通信">消息缓冲通信</h4><h5 id="基本思想">基本思想</h5><p>由操作系统统一管理一组用于通信的消息缓冲存储区，每个消息缓冲存储区可以存放一个消息。</p><p>当一个进程需要发送消息：</p><ol type="1"><li>先在自己的消息发送区内生成待发送的消息，包括接收进程名、消息长度、消息正文等。</li><li>向系统申请一个消息缓冲区，把消息从发送区复制到消息缓冲区中。复制过程中，系统会将接收进程名换为发送进程名，以便接收者识别。</li><li>该消息缓冲区被挂在接收消息的进程的消息队列上，供接收者在需要时从消息队列中摘下并复制到消息接收区使用，同时释放消息缓冲区。</li></ol><p>消息缓冲通信涉及的数据结构：</p><ul><li>sender：发送消息的进程名或标识符</li><li>size：发送的消息长度</li><li>text：发送的消息正文</li><li>next-ptr：指向下一个消息缓冲区的指针</li></ul><p>在进程的PCB中涉及通信的数据结构：</p><ul><li>mptr：消息队列首指针</li><li>mutex：消息队列互斥信号量，初始为1</li><li>sm：表示接收进程信号队列上消息的个数，初值为0，是控制收发进程同步的信号量</li></ul><h5 id="发送和接收原语的实现">发送和接收原语的实现</h5><ul><li>发送原语Send：<ul><li>申请一个消息缓冲区，把发送区内容复制到这个缓冲区中</li><li>找到接收进程的PCB，执行P(mutex)</li><li>把缓冲区挂在接收进程消息队列尾部</li><li>执行V(sm)</li><li>执行V(mutex)</li></ul></li><li>接收原语Receive：<ul><li>执行P(sm)查看是否有信件</li><li>执行P(mutex)，取消息</li><li>执行V(mutex)</li><li>把消息缓冲区内容复制到接收区，释放消息缓冲区</li></ul></li></ul><h4 id="管道和套接字">管道和套接字</h4><p>基于信箱的消息传递方式的一种变体，与传统的信箱方式等价，但没有设定消息的边界。</p><ul><li>即，若一个进程发送10条100字节的消息，另一个进程接收1000个字节，接收者将获得10条消息。</li></ul><h3 id="高级进程通信机制">6.5.2 高级进程通信机制</h3><h4 id="基于流的进程通信">基于流的进程通信</h4><ul><li><p>多个进程使用一个共享的消息缓冲区（可称为管道、多路转接器、套接字）。</p></li><li><p>一些进程向消息缓冲区中写入字符流</p></li><li><p>一些进程从消息缓冲区中读出字符流</p></li><li><p>信息以任意长度的字符流交换。</p></li></ul><h4 id="基于rpc的高级通信规约">基于RPC的高级通信规约</h4><p>采用客户/服务器计算模式，服务器进程提供一系列过程/服务，供客户进程调用；客户进程通过调用服务器进程提供的过程/服务获得服务。</p><ul><li>考虑到客户计算机和服务器计算机的硬件异构性，外部数据表示XDR被引入来转换每台计算机的特殊数据格式为标准数据格式。</li></ul><h5 id="rpc执行步骤">RPC执行步骤</h5><ol type="1"><li>客户进程以普通方式调用客户存根</li><li>客户存根组织RPC消息并执行Send，激活内核程序</li><li>内核把消息通过网络发送到远地内核</li><li>远地内核把消息送到服务器存根</li><li>服务器存根取出消息中参数后调用服务器过程</li><li>服务器过程执行完后把结果返回至服务器存根</li><li>服务器存根进程将它打包并激活内核程序</li><li>服务器内核把消息通过网络发送至客户机内核</li><li>客户内核把消息交给客户存根</li><li>客户存根从消息中取出结果并返回给客户进程</li><li>客户进程获得控制权并得到了过程调用的结果</li></ol><figure><img src="/image/计算机操作系统/远程过程调用RPC.png"alt="远程过程调用RPC" /><figcaption aria-hidden="true">远程过程调用RPC</figcaption></figure><h2 id="死锁">6.6 死锁</h2><h3 id="死锁的产生">6.6.1 死锁的产生</h3><h4 id="死锁产生的可能原因">死锁产生的可能原因</h4><ul><li>进程推进顺序不当</li><li>PV操作使用不当</li><li>资源分配不当</li><li>对临时性资源使用不加限制</li></ul><h4 id="死锁的定义">死锁的定义</h4><p>一个进程集合中的每一个进程都在等待只能由该集合中的其他进程才能引发的事件。</p><h4 id="系统形成死锁的四个必要条件">系统形成死锁的四个必要条件</h4><ul><li>互斥条件：系统中存在进程应互斥使用的临界资源</li><li>占有和等待条件：进程请求资源不得到满足而等待时，不释放已占有的资源</li><li>不剥夺条件：已被占有的资源只能被属主释放，不允许被其他进程剥夺</li><li>循环等待条件：存在循环等待链，每个进程都在链中等待下一个进程所持有的资源</li></ul><h3 id="死锁的防止">6.6.2 死锁的防止</h3><ul><li>破坏互斥条件：使资源可同时访问而不是互斥使用</li><li>破坏占有和等待条件：静态分配</li><li>破坏不剥夺条件：剥夺式调度</li><li>上述方法均导致资源利用率和吞吐率低</li></ul><h4 id="层次分配策略">层次分配策略</h4><p>破坏占有和等待条件、循环等待条件。</p><ul><li>资源被分为多个层次</li><li>当进程得到某一层的一个资源后，它只能再申请较高层次的资源</li><li>当进程要释放某层的一个资源时，必须先释放占有的较高层次的资源</li><li>当进程得到某一层的一个资源，并想申请该层的另一个资源，必须先释放该层中的已占资源</li></ul><p>变种：按序分配，资源排序，不得申请序数比占有资源序数小的资源。</p><h3 id="死锁的避免">6.6.3 死锁的避免</h3><h4 id="银行家算法">银行家算法</h4><ul><li>银行家拥有一笔周转资金</li><li>客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能归还贷款</li><li>银行家应谨慎地贷款，防止出现坏账<ul><li>操作系统——银行家</li><li>资源——周转资金</li><li>进程——客户</li></ul></li></ul><p>银行家算法的数据结构：</p><p>一个系统有n个进程和m种不同的资源，定义包含以下向量和矩阵的数据结构：</p><ul><li>系统每类资源总数：该m个元素的向量为系统中每类资源的数量<ul><li><span class="math inline">\(Resource=(R_1,R_2,...,R_m)\)</span></li></ul></li><li>每类资源未分配数量：该m个元素的向量为系统中每类资源尚可供分配数量<ul><li><spanclass="math inline">\(Available=(V_1,V_2,...,V_m)\)</span></li></ul></li><li>最大需求矩阵：每个进程对每类资源最大需求量，<spanclass="math inline">\(C_{ij}\)</span>表示进程<spanclass="math inline">\(P_i\)</span>需<spanclass="math inline">\(R_j\)</span>类资源最大数<ul><li><span class="math inline">\(Claim=\begin{pmatrix}C_{11} &amp; C_{12}&amp; ... &amp; C_{1m} \\ C_{21} &amp; C_{22} &amp; ... &amp; C_{2m} \\... \\ C_{n1} &amp; C_{n2} &amp; ... &amp; C_{nm}\end{pmatrix}\)</span></li></ul></li><li>分配矩阵：进程当前分得资源数，<spanclass="math inline">\(A_{ij}\)</span>表示进程<spanclass="math inline">\(P_{i}\)</span>已分得<spanclass="math inline">\(R_j\)</span>类资源个数<ul><li><span class="math inline">\(Allocation=\begin{pmatrix}A_{11} &amp;A_{12} &amp; ... &amp; A_{1m} \\ A_{21} &amp; A_{22} &amp; ... &amp;A_{2m} \\ ... \\ A_{n1} &amp; A_{n2} &amp; ... &amp; A_{nm}\end{pmatrix}\)</span></li></ul></li></ul><p>确定成立的关系式：</p><ul><li><span class="math inline">\(R_i=V_i+\sum A_{ki}\)</span>，对<spanclass="math inline">\(i=1,...,m,k=i,...,n\)</span><ul><li>表示所有资源要么已被分配，要么尚可分配</li></ul></li><li><span class="math inline">\(C_{ki} \leq R_i\)</span>，对<spanclass="math inline">\(i=1,...,m,k=1,...,n\)</span><ul><li>表示进程申请资源数不能超过系统拥有的资源总数</li></ul></li><li><span class="math inline">\(A_{ki} \leq C_{ki}\)</span>，对<spanclass="math inline">\(i=1,...,m,k=1,...n\)</span><ul><li>表示进程申请任何类资源数不能超过声明的最大资源需求数</li></ul></li></ul><p>一种死锁的避免策略：</p><p>系统中若要启动一个新进程工作，其对资源<spanclass="math inline">\(R_i\)</span>的需求仅当满足以下不等式：</p><p><span class="math inline">\(R_i \geq C_{(n+1)i} + \sumC_{ki}\)</span>，对<spanclass="math inline">\(i=1,...,m,k=1,...n\)</span></p><p>即应满足当前系统中所有进程对资源<spanclass="math inline">\(R_i\)</span>的最大资源需求数加上启动的新进程的最大资源需求数不超过系统拥有的最大数。</p><h5 id="系统安全性">系统安全性</h5><p>系统在时刻<spanclass="math inline">\(T_0\)</span>是安全的，仅当存在一个进程序列<spanclass="math inline">\(P_1,...,P_n\)</span>，对进程<spanclass="math inline">\(P_k\)</span>满足公式：</p><p><span class="math inline">\(C_{ki} - A_{ki} \leq V_i+\sumA_{ji}\)</span>，对i=1,...,m,k=1,...n$</p><h5 id="银行家算法基本思想">银行家算法基本思想</h5><ol type="1"><li>系统中的所有进程进入进程集合。</li><li>在安全状态下系统收到进程的资源请求后，先把资源试探性分配给它。</li><li>系统用剩下的可用资源和进程集合中其他进程还要的资源数作比较，在进程集合中找到剩余资源能满足最大需求量的进程，从而保证这个进程运行完毕并归还全部资源。</li><li>把这个进程从集合中去掉, 系统的剩余资源更多了。反复执行上述步骤。<ul><li>进程退出系统，资源回收</li></ul></li><li>最后，检查进程集合，若为空表明本次申请可行，系统处于安全状态,可实施本次分配；否则，有进程执行不完，系统处于不安全状态，本次资源分配暂不实施，让申请进程等待。</li></ol><h3 id="死锁的检测和解除">6.6.4 死锁的检测和解除</h3><p>系统定时进行死锁的检测，如检测到，则解除它。</p><h4 id="进程-资源分配图">进程-资源分配图</h4><ul><li><p>约定<span class="math inline">\(P_i\rightarrowR_j\)</span>为请求边，表示进程<spanclass="math inline">\(P_i\)</span>申请资源类<spanclass="math inline">\(R_j\)</span>中的一个资源得不到满足而处于等待<spanclass="math inline">\(R_j\)</span>类资源的状态，该有向边从进程开始指到方框的边缘，表示进程<spanclass="math inline">\(P_i\)</span>申请<spanclass="math inline">\(R_j\)</span>中的一个资源。</p></li><li><p>约定<span class="math inline">\(R_j \rightarrowP_i\)</span>为分配边，表示<spanclass="math inline">\(R_j\)</span>类中的一个资源已被进程<spanclass="math inline">\(P_i\)</span>占用。由于已把一个具体的资源分配给了进程<spanclass="math inline">\(P_i\)</span>，故该有向边从方框内的某个黑圆点出发指向进程。</p></li></ul><p>死锁资源分配图示例：</p><figure><img src="/image/计算机操作系统/死锁资源分配图示例.png"alt="死锁资源分配图示例" /><figcaption aria-hidden="true">死锁资源分配图示例</figcaption></figure><ul><li>如果进程-资源分配图中无环路，则此时系统中没有发生死锁</li><li>如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充要条件，环路中的进程便为死锁进程</li><li>如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则，环路是系统发生死锁的必要条件而不是充分条件</li></ul><p>如果能在进程-资源分配图中消去此进程的所有请求边和分配边，成为孤立结点，经一系列简化，使所有进程成为孤立结点，则该图是可完全简化的</p><ul><li>系统为死锁状态的充分条件是，此进程-资源分配图是不可完全简化的</li></ul><h4 id="死锁的安全性测试算法">死锁的安全性测试算法</h4><p>类似于死锁避免算法，不同在于前者考虑了检查每个进程还需要的所有资源能否满足要求，后者则要根据进程的当前申请资源量来判断系统是否进入不安全状态。</p><p>一种检测方法：</p><ol type="1"><li>currentAvailable=available</li><li>若allocation[k,*]!=0，令finish[k]=false，否则finish[k]=true</li><li>寻找一个k，满足条件(finish[k]==false)&amp;&amp;(request[k,*]&lt;=currentavail[*])，找不到则跳到5</li><li>currentAvailable[*]=currentAvailable[*]+allocation[k,*]，finish[k]=true，跳至3</li><li>如果存在k(1≤k≤n)，finish[k]=false，则系统处于死锁状态，并且finish[k]=false的P_k为处于死锁的进程。</li></ol><h4 id="死锁的解除">死锁的解除</h4><ul><li><p>结束所有进程的执行，重新启动操作系统。</p><ul><li>以前工作全部作废，损失很大。</li></ul></li><li><p>撤销陷于死锁的所有进程，解除死锁继续运行。</p></li><li><p>逐个撤销陷于死锁的进程，回收其资源重新分派，直至死锁解除。</p></li><li><p>剥夺陷于死锁的进程占用的资源，但并不撤销它，直至死锁解除。</p><ul><li>可仿照撤销陷于死锁进程的条件来选择剥夺资源的进程</li></ul></li><li><p>根据系统保存的检查点，让所有进程回退，直到足以解除死锁</p><ul><li>要求系统建立保存检查点、 回退及重启机制。</li></ul></li><li><p>当检测到死锁时，可能存在某些未卷入死锁的进程，随着这些进程执行到结束，有可能释放足够的资源来解除死锁。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第五章_文件管理</title>
    <link href="/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第五章-文件管理">第五章 文件管理</h1><h2 id="文件系统概述">5.1 文件系统概述</h2><h3 id="文件的概念">5.1.1 文件的概念</h3><p>具有符号名的，在逻辑上具有完整意义的一组相关信息项的序列</p><p>文件名是由字母、数字和其他符号组成的一个字符串，其格式和长度因系统而异</p><h4 id="文件的命名">文件的命名</h4><ul><li>一般包括文件名和扩展名<ul><li>前者用于识别文件，后者用于标识文件特性，两者用小数点隔开</li></ul></li><li>每个操作系统都有约定的扩展名，Windows系统中有：<ul><li>.com表示可执行的二进制代码文件</li><li>.exe表示可执行的浮动二进制代码文件</li><li>.lib表示库程序文件</li><li>.bat表示批命令文件</li><li>.obj表示编译或汇编生成的目标文件</li></ul></li></ul><h4 id="文件的分类">文件的分类</h4><ul><li>按用途：系统文件、库文件、用户文件</li><li>按保护级别：只读文件、读写文件、不保护文件</li><li>按信息时限：临时文件、永久文件、档案文件</li><li>按设备类型：磁盘文件、磁带文件、光盘文件、软盘文件</li><li>还可以按文件的逻辑结构或物理结构分类</li></ul><h4 id="引入文件的优点">引入文件的优点</h4><ul><li>用户使用方便</li><li>文件安全可靠</li><li>文件可备份</li><li>文件可共享</li></ul><h3 id="文件系统及其功能">5.1.2 文件系统及其功能</h3><h4 id="文件系统的概念">文件系统的概念</h4><p>操作系统中负责存取和管理信息的模块，用统一方式管理用户和系统信息的存储、检索、更新、共享和保护，为用户提供一整套方便有效的文件使用和操作方法。</p><ul><li>文件系统中的文件和用户概念中的逻辑结构以及存储器中的存储结构密切相关，因此，同一个文件需要从逻辑文件和物理文件两个侧面观察。</li></ul><h4 id="文件系统的功能">文件系统的功能</h4><p>文件系统面向用户的功能：</p><ul><li>文件的按名存取</li><li>文件的共享和保护</li><li>文件的操作和使用</li></ul><p>为了实现这些功能，操作系统必须考虑：</p><ul><li>文件目录的建立和维护</li><li>存储空间的分配和回收</li><li>数据的保密和保护</li><li>监督用户存取和修改文件的权限</li><li>实现在不同存储介质上信息的表示方式、编址方式、存储次序，以及信息检索等问题</li></ul><h4 id="文件系统的组成">文件系统的组成</h4><pre><code class=" mermaid">graph文件系统---文件的组织---组织方法---逻辑结构:\n流式文件\n记录式文件组织方法---物理结构:\n顺序文件\n连接文件\n直接文件\n索引文件文件系统---文件的存取---存取方法:\n顺序存取\n索引存取\n文件系统---文件的控制---控制系统:\n逻辑控制系统\n物理控制系统文件系统---文件的使用---文件操作:\n打开\n关闭\n读\n写\n控制</code></pre><h2 id="文件的组织">5.2 文件的组织</h2><h3 id="文件的存储">5.2.1 文件的存储</h3><h4 id="卷和块">卷和块</h4><p>文件存储介质有磁带、光盘和磁盘。</p><ul><li>卷是存储介质的物理单位，对应于一盘磁带、一块软盘、一片光盘、一个硬盘分区</li><li>块是存储介质上连续信息所组成的一个区域，也称为物理记录<ul><li>块是主存储器和辅助存储器进行信息交换的物理单位，每次总是交换一块或整数块信息</li><li>决定块的大小要考虑用户使用方式、数据传输效率和存储设备类型等因素</li><li>不同类型的存储介质，块的长短常常不同；对同一类型的存储介质，块的大小一般相同，但也可以不同</li><li>外围设备由于机械动作或识别不同块的要求，两个相邻块之间必须留有间隙，间隙是块之间不记录用户代码信息的区域</li></ul></li></ul><h4 id="顺序存取存储设备的信息安排">顺序存取存储设备的信息安排</h4><p>顺序存储设备是严格依赖信息的物理位置次序进行定位和读写的存储设备。</p><ul><li>磁带是最常用的一种顺序存取存储设备，它具有存储容量大、稳定可靠、卷可装卸和易于保存等优点，广泛用于存档<ul><li>磁带的突出特点是块长的变化范围较大，块可以很小，也可以很大，原则上没有限制</li></ul></li><li>光盘也是一种顺序存取存储设备</li></ul><h4 id="直接存取存储设备的信息安排">直接存取存储设备的信息安排</h4><p>磁盘是一种直接存取存储设备，又称为随机存取存储设备。 -移臂与旋转两维组织，存取速度高 -每个物理地址有确定的位置和唯一的地址，存取任何一个物理块所需的时间几乎不依赖于此信息的位置</p><h3 id="文件的逻辑结构">5.2.2 文件的逻辑结构</h3><p>逻辑文件，又称为文件的逻辑结构。</p><ul><li>独立于物理环境的，用户概念中的抽象信息组织方式</li><li>用户能观察到并加以处理的数据集合</li></ul><p>文件的逻辑结构分为两种：流式文件和记录式文件。</p><h4 id="流式文件">流式文件</h4><p>文件内的数据不再组成记录，只是由一串依次的字节组成的信息流序列。</p><ul><li>这种文件常常按长度来读取所需信息，也可以用插入的特殊字符作为分界。</li></ul><h4 id="记录式文件">记录式文件</h4><p>一种有结构的文件，是若干逻辑记录信息所组成的记录流文件。</p><ul><li>逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位</li></ul><p>记录式文件与数据库</p><ul><li>数据库管理系统也支持逻辑记录</li><li>有别于记录式文件的是，数据库中的记录之间可以通过数据冗余构成某种联系</li><li>数据库管理系统支持基于联系的数据查询，文件系统则不行</li></ul><h4 id="记录的成组与分解">记录的成组与分解</h4><p>一个物理记录只存放一个逻辑记录可能造成极大的浪费。</p><p>若干个逻辑记录合并成一组，写入一个块，称为记录的成组。</p><ul><li>每块中的逻辑记录数称为块因子</li></ul><p>对于流式文件，一个物理记录可以存放很多个连续字节</p><h5 id="成组与分解操作">成组与分解操作</h5><ol type="1"><li>系统设置独立于用户数据区的输入/输出缓冲区</li><li>记录的成组操作在输出缓冲区内进行，凑满一块后才将缓冲区内的信息写到存储介质上</li><li>当存储介质上的一个物理记录读进输入缓冲区后，把逻辑记录从块中分离出来的操作称为记录的分解操作</li></ol><p>成组与分解的特征：</p><ul><li>优点：记录成组与分解节省存储空间，减少输入/输出操作次数，提高系统效率</li><li>提前读与推迟写<ul><li>提前读：用户读请求，导致包含该逻辑记录的物理块读如输入缓冲区，这一操作可能读入了多个逻辑记录</li><li>推迟写：用户写请求，首先是写入输出缓冲区，只有当该缓冲区中的逻辑记录满后才会引起实际输出</li></ul></li></ul><h3 id="文件的物理结构">5.2.3 文件的物理结构</h3><p>文件的物理结构和组织是指文件在物理存储空间中的存放方法和组织关系，又称为物理文件。</p><ul><li>文件的存储结构涉及块的划分、记录的排列、索引的组织、信息的搜索等问题</li><li>直接影响文件系统性能</li></ul><h4 id="顺序文件">顺序文件</h4><p>将一个文件中逻辑上连续的信息存放到存储介质的依次相邻的块中形成顺序结构，这类文件称为顺序文件，也称连续文件。</p><ul><li><p>例：磁带文件、光盘文件</p></li><li><p>优点：顺序存取记录时速度较快</p><ul><li>常用于批处理文件和系统文件</li><li>采用磁带存放顺序文件，总可以保持快速存取存储的优点</li></ul></li><li><p>缺点：建立文件前需要能预先确定文件长度以便分配存储空间；修改、插入和增加文件记录有困难</p></li></ul><h4 id="连接文件">连接文件</h4><p>连接文件又称串联文件，使用连接字来表示文件中各个物理块之间的先后次序。</p><ul><li><p>第一块文件信息的物理地址由文件目录给出，每一块的连接字指出了文件的下一个物理块位置，连接字内容为0时，表示文件至本块结束。</p></li><li><p>输入井、输出井都是连接文件</p></li><li><p>优点：易于对文件记录做增、删、改，易于动态增长记录；不必预先确知文件长度；存储空间利用率高</p></li><li><p>缺点：存放指针需要额外的存储空间，由于存取需通过缓冲区，待获得连接字后，才能找到下一物理块的地址，因而仅适用于顺序存取</p></li></ul><h4 id="直接文件">直接文件</h4><p>直接文件又称散列文件，通过计算记录的关键字建立与其物理存储地址之间的对应关系，这种变换通常采用散列。</p><ul><li>计算寻址结构可能出现冲突，解决办法有拉链法、循环探查法、二次散列法、溢出区法等</li></ul><h4 id="索引文件">索引文件</h4><p>索引文件为每个文件建立了一张索引表，其中每个表目包含一个记录的键（逻辑记录号）及其存储地址。</p><ul><li>索引表的地址可由文件目录指出，查阅索引表先找到相应记录键，然后获得数据存储地址</li></ul><p>访问方式：</p><ul><li>索引文件在文件存储器上分为索引区和数据区</li><li>访问索引文件的两步操作：查找索引表，获得记录的物理地址</li><li>需要两次访问辅助存储器，若文件索引表已预先掉入主存储器，可减少一次内外存信息交换</li></ul><p>索引结构时连接结构的一种扩展，克服了连接文件只能作顺序存取的缺点，但增加了索引表的空间开销和查找时间。</p><p>索引表的组织：一级索引、二级索引、多级索引</p><h2 id="文件目录">5.3 文件目录</h2><h3 id="文件目录结构">5.3.1 文件目录结构</h3><p>文件目录是实现文件的按名存取的关键数据结构。</p><ul><li>文件系统的基本功能之一就是负责文件目录的建立、维护和检索，要求编排的目录便于查找、防止冲突</li><li>文件目录需要永久保存，因此也组织成文件存放在磁盘上</li></ul><h4 id="一级目录结构">一级目录结构</h4><p>在操作系统中构造一张线性表，与每个文件的相关属性占一个目录项，构成一级目录结构</p><ul><li>由于用户与文件众多，容易重名，不利于记忆</li></ul><h4 id="二级目录结构">二级目录结构</h4><ul><li>第一级为主文件目录，用于管理所有用户文件目录，目录项登记系统接受的用户名和该用户文件目录的地址</li><li>第二级为用户文件目录，为该用户的每个文件保存一个登记栏，内容与一级目录的目录项相同</li><li>每个用户只允许查看自己的文件目录</li></ul><p>二级目录结构的特点：</p><ul><li>可以检查访问文件者的存取权限，实现对文件的保密和保护</li><li>对同一个用户而言，依然存在文件多、易重名的问题</li></ul><h4 id="树形目录结构">树形目录结构</h4><p>每一级目录可以登记下一级目录，也可以登记文件，形成层次文件目录结构，一般采用树形目录结构，根是根目录，非叶节点为子目录，叶节点为文件</p><ul><li>较好地反映现实世界中具有层次关系的数据集合，较准确地反映系统内部文件的组织结构</li><li>不位于同一末端子目录的不同文件可以重名</li><li>易于规定不同层次货子树中文件的不同存取权限，便于文件的保护、保密和共享</li></ul><p>树形目录结构的文件定位</p><ul><li>一个文件的全名包括从根目录到文件为止的所有子目录路径</li><li>各子目录名间用文件分隔符分开</li><li>一个硬盘分区组织成一棵子树<ul><li>每棵子树对应一个逻辑盘符（Windows）</li><li>众多子树嫁接成一棵大树（UNIX）</li></ul></li></ul><h3 id="文件目录的管理">5.3.2 文件目录的管理</h3><h4 id="文件查找">文件查找</h4><p>系统跟去用户提供的文件路径（绝对/相对）搜索各级文件目录，找到文件。</p><ul><li>现代操作系统都有改变工作目录的命令。</li></ul><h4 id="目录项查找">目录项查找</h4><p>搜索具体目录项时，可以采用顺序查找法或二分查找、杂凑法等方式查找。</p><ul><li>目录项按一定顺序编排时可用二分查找</li><li>杂凑法，把每个文件名经过变换函数变换成唯一的目录表表项。</li></ul><h4 id="活动文件表">活动文件表</h4><ul><li><p>树形目录结构存在的问题：一个文件经过许多目录节点时，使用不方便，系统在沿路径查找目录时，要多次访问文件存储器，使访问速度大大减慢。</p></li><li><p>若将所有文件的目录都复制到主存，访问速度加快但主存开销大。</p></li><li><p>一种办法是，把常用的和正在使用的文件目录复制进主存</p></li></ul><p>系统为每个用户进程建立一张活动文件表，用户使用一个文件前，先通过打开操作，把该文件有关目录信息复制到指定主存区域，有关信息填入活动文件表，以建立用户进程和该文件索引的联系。</p><p>不再使用该文件时，使用关闭操作，切断用户进程和这个文件的联系，同时若该目录已被修改过，更新辅存中对应的文件目录。</p><h2 id="文件的共享保护和保密">5.4 文件的共享、保护和保密</h2><p>文件是计算机系统的重要资源，文件系统需要具有保障文件安全的手段，提供文件保密的措施，有效实现文件共享。</p><ul><li>文件共享是指不同用户共同使用某些文件</li><li>文件保护是指防止文件被破坏</li><li>文件保密是指防止文件及其内容被其他用户窃取</li></ul><h3 id="文件的共享">5.4.1 文件的共享</h3><p>文件共享是计算机用户完成共同任务所必需的。</p><ul><li>好处：减少用户大量重复性劳动；免除系统复制文件的工作；节省文件占用的存储空间；减少程序设计输入/输出文件的次数</li></ul><p>文件共享的并发控制：</p><ul><li>在允许文件共享的系统中，操作系统应提供手段实现对共享文件的同步控制</li><li>多个进程可能同时存取一个文件如果它们同时进行读操作，操作系统应对文件进行公用控制</li><li>如果有进程进行写操作，操作系统须提供同步控制机制以保证文件数据完整性</li></ul><p>文件的保密：</p><ul><li>文件保密是指文件及其内容不能被未经文件主授权的其他用户窃取</li><li>保密措施：<ul><li>隐蔽文件目录</li><li>设置口令</li><li>使用密码</li></ul></li></ul><h3 id="文件的保护">5.4.2 文件的保护</h3><p>文件保护是指防止文件被破坏。操作系统须提供文件保护机制，实现文件完整性。</p><p>常见的文件保护方法：文件副本；文件存取矩阵；文件属性</p><h4 id="文件副本">文件副本</h4><p>文件系统必须要有防止硬软件故障，保存信息完整性的能力，文件副本是主要实现机制。</p><ul><li>动态多副本技术</li><li>转储、备份和恢复</li></ul><h5 id="动态多副本">动态多副本</h5><p>在多个介质上维持同一内容的文件，在更新内容时同时进行。</p><p>增加了设备费用和系统负载，一般适用于容量较小且较为重要的文件，当文件发生故障时只需切换到备用设备即可。</p><p>一般适用于不需更新的系统文件及专用文件，</p><h5 id="文件转储">文件转储</h5><p>定时将文件复制转储到其他介质上，当某介质上出现故障时，复原转储文件。</p><p>转储的两种方式：</p><ul><li>一，一定时间间隔或一个单位处理结束时，系统自动复写更新过的文件和数据</li><li>二，每天或每周把文件信息全部复写，需要时再通过装入转储文件来恢复系统</li></ul><h4 id="文件的存取控制矩阵">文件的存取控制矩阵</h4><p>系统为每个用户设置访问每个文件对象的存取属性，则全部用户对全部文件的存取属性就组成一个二维矩阵，称为存取控制矩阵。</p><ul><li>由于操作系统具有很多用户和众多文件，存取控制矩阵是一个稀疏矩阵，可以将其简化为一张存取控制表<ul><li>每行包括：用户、文件、存取属性</li><li>仅登记那些对文件拥有存取属性的部分</li></ul></li></ul><p>基于存取控制矩阵/表的文件保护：</p><ul><li>存取属性：可以有访问、读、写、执行、创建、删除、授权等</li><li>系统通过查阅矩阵/表核对用户对文件的存取权限</li><li>文件主通过命令进行授权甚至授权权的转授</li><li>系统管理用户等同于文件主权限，获得对系统文件的授访问权权限</li></ul><h4 id="文件属性">文件属性</h4><p>存取控制表的一种简化方法是用户分类，再针对每类用户规定文件属性。</p><ul><li>用户分类：属主、合作者、其他</li><li>文件属性：读、写、执行</li><li>文件属性可以放在文件目录项中，管理大为简化</li><li>用户使用文件时，通过核对文件属性，实现保护</li></ul><h2 id="文件的使用">5.5 文件的使用</h2><h3 id="文件存取方法">5.5.1 文件存取方法</h3><p>文件存取方法是操作系统为用户程序提供的使用文件的技术和手段，在某种程度上依赖于文件的物理结构。</p><h4 id="顺序存取">顺序存取</h4><p>按记录顺序进行读写操作的存取方法。</p><ul><li>读操作根据读指针读出当前记录，同时推进读指针，指向下一次要读出的记录</li><li>写操作则设置写指针，把一个记录写到文件末端，同时推进写指针</li><li>允许对读指针进行前进或后退整数个记录的操作</li></ul><h4 id="直接存取">直接存取</h4><p>快速地以任意次序直接读写某个记录。</p><h4 id="索引存取">索引存取</h4><p>基于索引文件的索引存取方法。</p><ul><li>信息块的地址可以通过查找记录键换算出</li><li>也可以采用顺序存取或直接存取的方法</li><li>实际都采用多级索引加速记录查找</li></ul><h3 id="文件的使用-1">5.5.2 文件的使用</h3><p>用户通过两类接口与文件系统联系。</p><ul><li>一类是与文件有关的操作命令</li><li>另一类是提供给用户程序的文件类系统调用，如下</li></ul><h4 id="建立文件">建立文件</h4><p>参数：文件名、设备类、文件属性及存取控制信息</p><p>流程：在相应设备上建立一个文件目录项，分配第一个物理块，在活动文件表中申请一个项，登记有关目录信息，返回一个文件句柄。</p><h4 id="撤销文件">撤销文件</h4><p>参数：文件名、设备类</p><p>流程：若文件未关闭，先关闭文件；若为共享文件，进行联访处理；在目录文件中删除对应目录项，释放文件占用的文件存储空间</p><h4 id="打开文件">打开文件</h4><p>参数：文件名、设备类、打开方式</p><p>流程：在主存活动文件表中申请一个项，返回一个文件句柄；跟踪文件名查找目录文件，把目录信息复制到活动文件表相应栏，按存取控制说明检查访问的合法性；对共享文件进行相应的额外处理</p><h4 id="关闭文件">关闭文件</h4><p>参数：文件句柄</p><p>流程：将活动文件表中该文件的当前使用用户数减一，若此值为0，则收回此活动文件表，完成推迟写；若活动文件表目内容已被改过，则应先将表目内容写回文件存储器上相应表目中，使文件目录保存最新状态。</p><h4 id="读写文件">读写文件</h4><p>参数：文件句柄、用户数据区地址、读写的记录或字节数</p><p>按文件句柄从活动文件表中找到该目录的目录项信息；根据目录项指出的该文件逻辑和物理组织方式，把相关逻辑记录转换成物理块</p><h4 id="定位文件">定位文件</h4><p>调整所打开文件的读写指针位置</p><p>参数：文件句柄，定位指针</p><h2 id="文件系统的实现">5.6 文件系统的实现</h2><h3 id="辅存空间管理">1. 辅存空间管理</h3><h4 id="辅存空间的分配方式">辅存空间的分配方式</h4><ul><li>连续分配：存放在辅存空间连续存储区中（连续的存储块号）<ul><li>优点是顺序访问速度快，管理简单</li><li>为了获得足够大的连续存储区，需要定时进行碎片整理</li></ul></li><li>非连续分配：动态分配给若干扇区或簇，不要求连续<ul><li>辅存空间管理效率高，便于文件动态增长和收缩</li></ul></li></ul><h4 id="空闲块的管理">空闲块的管理</h4><h5 id="位示图">位示图</h5><p>使用若干字节构成一张表，表中每一字位对应一个物理块，字位的顺序和块的相对次序一致，字位为1表示相应块已占用，字位为0表示该块空闲。</p><p>优点：可以把位示图全部或大部分保存在主存中，配合位操作指令实现高速物理块分配与去配。</p><h5 id="空闲块成组连接法">空闲块成组连接法</h5><h3 id="文件系统的实现层次">2. 文件系统的实现层次</h3><ul><li>用户接口：接受用户发来的系统调用，进行语法检查，进入逻辑文件控制子系统</li><li>逻辑文件控制子系统：根据文件路径名，搜索文件目录，建立活动文件表，根据文件结构和存取方法，把逻辑记录转换成相对物理块号和块内相对地址</li><li>文件保护子系统：识别调用者身份，验证存取权限，判定本次文件操作的合法性</li><li>物理文件控制子系统：实现缓冲区管理，根据物理结构，将对应相对物理块号转换为实际物理块号，负责文件存储空间的分配，生存输入/输出控制系统调用形式</li><li>输入/输出控制子系统：执行具体的物理块输入/输出操作</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第四章_设备管理</title>
    <link href="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第四章-设备管理">第四章 设备管理</h1><h2 id="设备管理基础">4.1 设备管理基础</h2><h3 id="设备管理概述">4.1.1 设备管理概述</h3><h4 id="输入输出设备及其分类">1. 输入/输出设备及其分类</h4><ul><li><p>输入/输出设备，又称外围设备、外设，用于计算机系统与外部世界的信息交换或存储。</p></li><li><p>输入/输出操作：内存和外设间的信息传送操作</p><ul><li>影响计算机系统的通用性和可扩展性</li><li>影响计算机系统综合处理能力及性价比</li></ul></li></ul><p>输入/输出设备分类：</p><ul><li>信息传输视角：分为输入设备、输出设备和输入输出设备</li><li>交互功能视角：分为人机交互设备、存储设备和机机通信设备</li><li>设备管理视角：分为字符设备、块设备和网络设备</li></ul><h4 id="设备管理的目标">2. 设备管理的目标</h4><p>解决设备和CPU速度的不匹配，使主机和设备充分并行工作，提高设备使用效率。</p><p>屏蔽设备的物理细节和操作过程，配置驱动程序，提供同一界面。</p><ul><li>抽象为裸设备</li><li>抽象为设备文件</li></ul><h4 id="设备管理的功能">3. 设备管理的功能</h4><ul><li>设备中断管理</li><li>缓冲区管理</li><li>设备的分配与去配</li><li>设备驱动调度</li><li>虚拟设备的实现</li></ul><h4 id="设备管理的实现层次">4. 设备管理的实现层次</h4><ul><li>输入/输出硬件<ul><li>输入/输出设备及其接口线路</li><li>控制部件</li><li>通道</li></ul></li><li>输入/输出软件<ul><li>系统输入/输出软件</li><li>用户空间输入/输出软件</li></ul></li></ul><h3 id="输入输出控制方式">4.1.2 输入/输出控制方式</h3><h4 id="设备控制器">1. 设备控制器</h4><p>为达到模块化和通用性的设计目标，通常分开设置设备的机械部件和电子部件。</p><p>电子部件成为设备控制器，又称为设备适配器、输入/输出控制器(模块/接口等)。</p><p>系统与控制器交互，而非与设备交互，设备控制器具体控制设备进行输入/输出。</p><h5 id="设备控制器的功能">设备控制器的功能</h5><p>设备控制器是CPU与设备之间的接口。</p><ul><li>接受和识别CPU或通道发来的命令</li><li>实现数据交换</li><li>发现和记录设备及其自身的状态信息，供CPU处理时使用</li><li>当连接多台设备时，识别设备地址</li></ul><h4 id="三种基本输入输出控制方式">2. 三种基本输入/输出控制方式</h4><h5 id="轮询方式">轮询方式</h5><ul><li>处理器向控制器发送输入/输出命令，轮询输入/输出结果</li><li>若设备未就绪，则重复测试过程，直至设备就绪</li><li>执行内存数据交换</li><li>等待输入/输出操作完成后，处理器才可以继续其他操作</li></ul><h5 id="中断方式">中断方式</h5><ul><li>处理器向控制器发出具体输入/输出命令，然后继续执行后续指令<ul><li>若进程支持异步输入/输出，后续指令仍然可以是该进程中指令</li><li>否则该进程在这个中断上挂起，处理器执行其他工作</li></ul></li><li>控制器检查设备状态，就绪后发出中断</li><li>CPU响应中断，进行中断处理，执行内存数据交换</li></ul><h5 id="dmadirect-memory-access直接存储器访问方式">DMA（Direct MemoryAccess，直接存储器访问）方式</h5><p>DMA模块：替代处理器来控制主存和设备控制器间的数据交换</p><ul><li>处理器向DMA模块发出输入/输出命令</li><li>处理器继续执行其他工作，DMA模块负责传送全部数据</li><li>数据传送结束后，DMA中断处理器</li></ul><h5 id="dma方式中的周期窃取">DMA方式中的周期窃取</h5><p>DMA和CPU同时通过总线访问内存，CPU会把总线的占有权让给DMA一个或几个主存周期。</p><p>周期窃取对CPU与主存的数据交换影响不大</p><ul><li>数据传送过程是不连续、不规则的</li><li>CPU大部分情况下与Cache进行数据交换，直接访问内存较少</li></ul><p>总结：</p><ul><li>轮询：CPU等待设备就绪，参与内存数据交换</li><li>中断：CPU不等待设备就绪，响应中断后参与内存数据交换</li><li>DMA：CPU不等待设备就绪，不参与主存数据交换</li></ul><h4 id="输入输出通道及其工作方式">3. 输入/输出通道及其工作方式</h4><h5 id="输入输出通道">输入/输出通道</h5><p>又称为通道控制器、输入/输出处理器，用于完成逻辑上独立的输入/输出任务。</p><p>采用四级连接：处理器、通道、控制器、设备</p><ul><li>通道可控制多台同类或不同类设备</li></ul><p>处理器不再执行输入/输出指令，而是在主存中组织通道程序，由输入/输出通道执行。</p><h5 id="输入输出通道的工作流程">输入/输出通道的工作流程</h5><ol type="1"><li>CPU遇到输入/输出任务，组织通道程序，置通道程序地址字CAW，启动指定通道</li><li>通道从CAW获得通道程序，控制输入/输出设备进行操作，CPU执行其他任务</li><li>输入/输出操作完成后，输入/输出通道发出中断，CPU处理中断，并从通道程序状态字CSW获得通道执行情况，处理输入/输出操作</li></ol><ul><li>CPU与通道高度并行工作</li></ul><h3 id="总线与输入输出">4.1.3 总线与输入/输出</h3><h4 id="总线对输入输出的影响">1. 总线对输入/输出的影响</h4><ul><li>输入/输出和CPU速度不匹配、各设备输入/输出速度不匹配</li><li>总线使主机和设备充分并行，提高系统效率</li></ul><h4 id="几种经典总线模型">2. 几种经典总线模型</h4><h5 id="单总线结构模型">单总线结构模型</h5><p>将CPU、主存和输入/输出模块连接到同一总线</p><ul><li><p>优点：结构简单、易于扩充</p></li><li><p>缺点：设备多时总线压力大，传输时间延长，慢速外设占用带宽多</p></li></ul><h5 id="三级总线模型">三级总线模型</h5><p>主存和Cache通过主存总线连接，主存总线和扩展总线上的输入/输出设备通过扩展总线接口缓冲</p><ul><li>优点：主存和输入/输出之间的数据传送、处理器的内存活动分离，可以支持更多输入/输出设备</li><li>缺点：不适用于输入/输出设备数据速率相差太大的情形</li></ul><h5id="南桥输入输出控制器与北桥主存控制器">南桥（输入/输出控制器）与北桥（主存控制器）</h5><p>通过存储总线、PCI总线、E(ISA)总线分别连接主存、高速输入/输出设备和低速输入/输出设备。</p><p>优点：可以支持不同数据速率的输入输出设备。</p><pre><code class=" mermaid">graph LRCPU--处理器总线---北桥--存储总线---Cache北桥--桥间接口---南桥南桥---PCI总线---E总线</code></pre><h5 id="一种基于通道的服务器总线模型">一种基于通道的服务器总线模型</h5><p>支持CPU、主存和多个输入/输出通道之间的数据传送</p><p>支持输入/输出通道和输入/输出控制器，以及输入/输出控制器和设备之间的数据传送。</p><ul><li>CPU通过主存控制器连接主存</li><li>CPU、主存和主存控制器均连接在一条与各个输入/输出通道连接的总线上</li><li>各个输入/输出通道分别与负责的输入/输出控制器连接</li><li>各个输入/输出控制器分别与负责的设备连接</li></ul><h2 id="设备管理软件">4.2 设备管理软件</h2><h3 id="输入输出软件的实现层次">4.2.1 输入/输出软件的实现层次</h3><h4 id="输入输出软件的设计">1. 输入/输出软件的设计</h4><p>设计目标：</p><ul><li>高效率：改善设备效率，尤其是磁盘输入/输出操作的效率</li><li>通用性：用统一标准来管理所有设备</li></ul><p>设计思路：</p><ul><li>把软件组织成层次结构，底层软件用来屏蔽硬件细节，高层软件向用户提供简洁、友善、统一的界面</li></ul><p>设计需要考虑的问题：</p><ul><li>设备无关性：访问设备的程序与具体设备无关</li><li>出错处理：低层软件能处理的错误不让高层软件感知</li><li>同步/异步传输：支持阻塞和中断驱动两种工作方式</li><li>缓冲技术：建立内存数据缓冲区，提高吞吐量</li></ul><h4 id="输入输出软件的实现层次-1">2. 输入/输出软件的实现层次</h4><p>从低到高有：</p><ol type="1"><li>输入/输出硬件：执行输入/输出操作</li><li>输入/输出中断处理程序：处理输入/输出中断，报告输入/输出错误，唤醒输入/输出设备驱动程序</li><li>输入/输出设备驱动程序：设备寄存器初始化，启动输入/输出操作，检查输入/输出状态</li><li>独立于设备的输入/输出软件：设备的命名、保护、阻塞、缓冲、分配、跟踪</li><li>用户空间的输入/输出软件：输入/输出系统调研、输入/输出格式化、SPOOLing</li></ol><h3 id="输入输出软件的实现">4.2.2 输入/输出软件的实现</h3><h4 id="输入输出中断处理程序">1. 输入/输出中断处理程序</h4><p>输入/输出中断处理程序位于操作系统底层，与硬件设备密切相关，与系统其余部分尽可能少地发生联系。</p><ul><li>进程请求输入/输出操作时，通常被阻塞</li><li>数据传输结束后产生输入/输出中断</li><li>CPU响应请求并转入中断处理程序</li></ul><h5 id="输入输出中断处理程序的功能">输入/输出中断处理程序的功能</h5><p>检查设备状态寄存器，判断中断原因，根据输入/输出操作完成情况进行相应处理</p><ul><li>如果数据传输有误，向上层软件报告设备出错信息，实施重新执行</li><li>如果正常结束，唤醒等待传输的进程，使其转换为就绪态</li><li>如果有等待传输的输入/输出命令，通知相应软件开启下一个输入/输出请求</li></ul><h4 id="设备驱动程序">2. 设备驱动程序</h4><ul><li>包括与设备密切相关的所有代码</li><li>从独立于设备的软件中接受输入/输出请求</li><li>把用户提交的逻辑输入/输出请求转化为物理输入/输出操作的启动和执行</li><li>监督设备是否正确执行，访问数据缓冲区，进行必要的纠错处理</li></ul><h5 id="设备驱动程序的功能">设备驱动程序的功能</h5><ul><li>设备初始化：在设备传输数据时，预置设备、控制器以及通道状态</li><li>执行设备驱动例程：负责启动设备，进行数据传输；对于通道，负责组织通道程序，启动通道工作</li><li>执行与设备相关的具体中断处理，负责处理设备、控制器及通道所发出的各种具体中断</li></ul><h5 id="设备驱动程序的层次">设备驱动程序的层次</h5><p>每个设备驱动程序原则上只处理一种设备，或者一类紧密相关的设备。</p><p>设备驱动程序的分层实现：</p><ul><li>高层/处理类设备，底层/处理具体设备</li><li>系统建立栈，接到输入/输出请求时先调用栈顶的驱动程序，然后继续向下调用底层驱动程序，直至所有物理操作被处理</li><li>这一方式使设备驱动的实现结构清晰，易于移植，但会增加一部分系统开销</li></ul><h4 id="独立于设备的输入输出软件">3. 独立于设备的输入/输出软件</h4><p>执行适用于所有设备的常用输入/输出功能，并向用户层软件提供一致性接口，包括：</p><ul><li>设备命名：通过路径名寻址设备</li><li>设备保护：用户是否有权访问设备</li><li>提供与设备无关的数据单位：字符、块</li><li>缓冲技术：调整CPU与输入/输出速度不匹配</li><li>分配和状态跟踪：分配设备</li><li>错误处理与报告：驱动无法处理的错误</li></ul><h4 id="用户空间的输入输出软件">4. 用户空间的输入/输出软件</h4><ul><li>库函数：操作系统内核外，使用库函数实现的输入/输出软件，运行时与应用程序链接</li><li>虚拟设备：用一类设备模拟另一类设备的仿真输入/输出软件</li></ul><h3 id="输入输出缓冲">4.2.3 输入/输出缓冲</h3><h4 id="输入输出缓冲-1">1. 输入/输出缓冲</h4><h5 id="设置输入输出缓冲的目的">设置输入/输出缓冲的目的</h5><ul><li>解决CPU与设备之间速度不匹配的矛盾</li><li>协调逻辑记录大小和物理记录大小不一致的问题</li><li>提高CPU和设备的并行性</li><li>减少输入/输出操作对CPU的中断次数</li><li>放宽对CPU中断响应时间的要求</li></ul><h5 id="输入输出缓冲区">输入/输出缓冲区</h5><p>在内存中开辟的存储区，专门用于临时存放输入/输出操作的数据</p><p>操作过程：</p><ul><li>写操作：将数据送至缓冲区，直到写满或需要写出，待适当时候系统将缓冲区内容写到设备上</li><li>读操作：系统将设备上的物理记录读至缓冲区，根据要求将当前所需要的数据从缓冲区中读出并传送给进程</li></ul><h4 id="几种缓冲技术">2. 几种缓冲技术</h4><h5 id="单缓冲技术">单缓冲技术</h5><p>操作系统在主存系统区中开设一个缓冲区。</p><ul><li>输入：先把数据读至缓冲区，再把缓冲区数据送至用户区，应用程序处理数据，如此往复，系统继续读入后续数据</li><li>输出，把数据从用户区传送至缓冲区，再将数据输出至设备，应用程序继续请求输出</li></ul><h5 id="双缓冲技术">双缓冲技术</h5><p>操作系统在主存系统区开设两个缓冲区。</p><ul><li>输入：先把数据输入缓冲区1，再从缓冲区1把数据传到用户区，供应用程序处理（同时设备可将数据传送到缓冲区2）</li><li>输出：先将数据从用户区传送到缓冲区1，再将数据传送到设备（同时应用程序可将数据传送到缓冲区2）</li></ul><h5 id="循环缓冲技术">循环缓冲技术</h5><p>操作系统分配一组缓冲区，每个缓冲区有指向下一个缓冲区的链接指针，构成循环</p><ul><li>调节设备和进程速度不匹配的问题</li></ul><h2 id="独占型外围设备的分配">4.3 独占型外围设备的分配</h2><h3 id="设备独立性">4.3.1 设备独立性</h3><ul><li><p>用户通常不指定物理设备，而是指定逻辑设备，使得用户进程和物理设备分离，再通过其他途径建立逻辑设备和物理设备间的映射。</p></li><li><p>设备管理中需要将逻辑设备名转换为物理设备名，为此系统需要提供逻辑设备名和物理设备名的对应表以供转换使用</p></li></ul><h4 id="设备独立性的优点">设备独立性的优点</h4><ul><li>应用程序与具体物理设备无关，系统增减或变更设备时不需要修改原程序</li><li>易于应对各种输入/输出设备故障，提高系统的可靠性</li><li>增加设备分配的灵活性，有利于更加有效地利用设备资源，实现多道程序设计</li></ul><h3 id="独占型外围设备的分配-1">4.3.2 独占型外围设备的分配</h3><h4 id="设备分配方式">设备分配方式</h4><p>独占型外围设备：一次只能由一个进程独占使用</p><p>分配方式：</p><ul><li>静态分配：进程运行前申请<ul><li>实现简单，能防止系统发生死锁，但会降低设备利用率</li></ul></li><li>动态分配：进程随用随申请<ul><li>提高设备利用率</li></ul></li></ul><h4 id="设备分配的数据结构">设备分配的数据结构</h4><p>设备类表</p><ul><li>每类设备对应于设备类表中的一栏</li><li>包括设备类、总台数、空闲台数、设备表起始地址等</li><li>支持设备独立性</li></ul><p>设备表</p><ul><li>每类设备有各自的设备表，用来登记这类设备的每台物理设备</li><li>包括：物理设备名，逻辑设备名，占有设备的进程，分配标志，好/坏标志等</li></ul><h2 id="共享型外围设备的驱动">4.4 共享型外围设备的驱动</h2><h3 id="磁盘的物理结构">4.4.1 磁盘的物理结构</h3><h4 id="磁盘结构">1. 磁盘结构</h4><ul><li>磁盘一般由多个盘片组成</li><li>每个盘片一般由两个盘面</li><li>盘面包括多个同心圆结构的磁道，不同盘面上位于相同位置的磁道构成柱面</li><li>每个磁道分为固定多个扇区，相邻扇区组合成簇</li><li>物理块的地址：<ul><li>柱面号，磁道号，扇区号</li><li>0面0道1扇区（此处面指磁头而不是柱面）</li></ul></li></ul><h4 id="磁盘读写数据的方式">2. 磁盘读写数据的方式</h4><p>读写数据时，磁头必须定位到指定磁道上的指定扇区的开始处，过程为：</p><ol type="1"><li>寻道：控制移动臂到达指定柱面</li><li>旋转：等待要读写的扇区旋转到磁头下</li><li>选择磁头号，进行数据传送</li></ol><h4 id="磁盘存取时间">3. 磁盘存取时间</h4><p>磁盘完成数据读写所需要的时间，是寻道时间、旋转延迟、传送时间的总和。</p><p><spanclass="math inline">\(T_a=T_s+\frac{1}{2r}+\frac{b}{rN}\)</span></p><p>其中，<span class="math inline">\(T_a\)</span>为存取时间，<spanclass="math inline">\(T_s\)</span>为寻道时间，<spanclass="math inline">\(r\)</span>为磁盘旋转速度（转/秒），<spanclass="math inline">\(b\)</span>为要传送的字节数，<spanclass="math inline">\(N\)</span>为一个磁道中的字节数。</p><h3 id="磁盘的驱动调度">4.4.2 磁盘的驱动调度</h3><p>磁盘可能同时接收到若干输入/输出请求，如果随机响应，性能会很差。</p><p>驱动调度：操作系统的磁盘调度策略，按照最佳次序执行处理访问磁盘的多个输入/输出请求，以减少磁盘访问的总处理时间。</p><p>驱动调度策略有移臂调度和旋转调度。</p><h4 id="移臂调度及其算法">移臂调度及其算法</h4><ul><li><p>目的：使移动臂的移动时间最短以减少寻道总时间</p></li><li><p>算法：</p><ul><li>先来先服务：移臂距离大，性能差</li><li>最短查找时间优先<ul><li>先执行查找时间最短的请求，寻道性能较好</li><li>存在“饥饿”现象</li></ul></li><li>单向扫描：移动臂向一个方向扫描，归途不提供服务</li><li>双向扫描：移动臂向一个方向移动，到达最后一个柱面再向反方向移动</li><li>电梯调度：改进双向扫描，当前移动方向没有访问请求时就改变方向</li></ul></li></ul><h4 id="旋转调度及其策略">旋转调度及其策略</h4><p>目的：使旋转延迟的总时间最少</p><p>循环排序：</p><ul><li><p>通过优化输入/输出请求排序，在最少旋转圈数内完成位于同一柱面的访问请求</p></li><li><p>旋转位置测定硬件和多磁头同时读写技术有利于提高旋转调度的效率</p></li></ul><p>优化分布：</p><ul><li>通过信息在存储空间的排列方式来减少旋转延迟</li><li>交替排序：由于磁盘匀速旋转，可能处理当前扇区数据时，下个扇区已经跳过。因此，可对扇区间隔编号，交叉因子为n:1表示相邻编号间间隔n-1个扇区</li><li>相邻扇区集中成簇读写</li><li>按柱面集中存储数据，可以减少数据读写时的移臂操作</li></ul><h2 id="虚拟设备">4.5 虚拟设备</h2><h3 id="spooling系统">4.5.1 SPOOLing系统</h3><h4 id="虚拟设备-1">1. 虚拟设备</h4><p>使用一类物理设备模拟另一类物理设备的技术。</p><p>示例：</p><ul><li>内存模拟磁盘</li><li>块设备模拟字符设备</li><li>输入输出重定向</li></ul><h4 id="spooling系统-1">2. SPOOLing系统</h4><p>SPOOLing（Simultaneous Peripheral OperationsOn-Line，外部设备联机并行操作），是关于慢速字符设备如何与计算机主机交换信息的一种技术，通常称为“假脱机技术”。</p><p>一个经典的SPOOLing系统：</p><ul><li>用高速的磁盘设备来模拟慢速的字符设备，缩短进程在内存中的驻留时间</li><li>慢速输出设备先输出到输出井</li><li>进程运行过程中只从输入井读入数据，只向输出井输出数据，使得全部输入/输出都基于磁盘</li><li>加快进程周转时间，提高系统吞吐量</li></ul><p>该系统的软件组成：</p><ul><li>预输入系统：预先把数据从输入设备传送到磁盘输入井</li><li>缓输出设备：把数据从磁盘输出并传送到输出设备</li><li>井管理程序：控制进程和井之间的数据交换（输入/输出重定向）</li></ul><p>打印SPOOLing系统：打印机守护进程和SPOOLing打印目录</p><ul><li>守护进程是唯一有特权使用打印机设备的进程</li><li>打印文件前，用户进程先产生完整的待输出文件，存放在打印目录下</li><li>打印机空闲时，启动守护进程，打印待输出文件</li></ul><h3 id="批处理系统的作业管理">4.5.2 批处理系统的作业管理</h3><ul><li>作业说明语言：用于作业控制的语言</li><li>作业说明书：刻画具体作业的控制方式</li><li>作业状态：输入状态（预输入）、后备状态（空闲）、运行状态（运行）、完成状态（缓输出）</li><li>作业调度：从后备状态作业中选择部分进入运行状态</li><li>作业调度算法：优先数、短作业、响应比、设备搭配等</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第三章_存储管理</title>
    <link href="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第三章-存储管理">第三章 存储管理</h1><h2 id="存储管理基础">3.1 存储管理基础</h2><h3 id="基本内容">3.1.1 基本内容</h3><p>逻辑地址(相对地址)，用户编程所使用的地址空间，从0开始编号，两种形式：</p><ol type="1"><li>一维，即地址</li><li>二维，段号：段内地址</li></ol><p>物理地址(绝对地址)，处理器执行指令时按照物理地址进行。</p><h4 id="段式程序设计">段式程序设计</h4><p>将一个程序设计成多个段(代码段、数据段、堆栈段，等等)。</p><p>用户可以应用段覆盖技术(程序设计技术)扩展内存空间使用量。</p><h4 id="主存储器的复用">主存储器的复用</h4><p>多道程序设计需要复用主存</p><ul><li>按照分区复用</li></ul><p>主存划分为多个固定/可变尺寸的分区，一个程序/程序段占用一个分区</p><ul><li>按照页架复用</li></ul><p>主存划分为多个固定大小的页架，一个程序/程序段占用多个页架</p><h4 id="存储管理的基本模式">存储管理的基本模式</h4><ol type="1"><li>单连续存储管理：一维逻辑地址空间的程序占用一个主存固定/可变分区</li><li>段式存储管理：段式二维逻辑地址空间的程序占用多个主存可变分区</li><li>页式存储管理：一维逻辑地址空间的程序占用多个主存页架区</li><li>段页式存储管理：段式二维逻辑地址空间的程序占用多个主存页架区</li></ol><figure><img src="/image/计算机操作系统/存储管理基本模式.png"alt="存储管理基本模式" /><figcaption aria-hidden="true">存储管理基本模式</figcaption></figure><h3 id="存储管理功能">3.1.2 存储管理功能</h3><p>地址转换：又称重定位，将逻辑地址转换为绝对地址</p><p>静态重定位：程序装入内存时进行重定位，早期小型OS使用，由装入程序执行</p><p>动态重定位：CPU执行程序时进行重定位，效率依赖硬件地址转换机构</p><h4 id="主存储器空间的分配和去配">主存储器空间的分配和去配</h4><ul><li><p>分配：进程装入主存时，存储管理软件进行具体的主存分配操作，并设置表格记录主存空间的分配情况</p></li><li><p>去配：当某个进程撤离或主动归还主存资源时，存储管理软件收回其占用的全部或部分存储空间，调整主存分配表信息</p></li></ul><h4 id="主存储器空间的共享">主存储器空间的共享</h4><ul><li>多个进程共享主存储器资源：多道程序设计技术使若干个程序同时进入主存储器，各自占用一定数量的存储空间，共同使用一个主存储器</li><li>多个进程共享主存储器的某些区域：若干个协作进程有共同的主存程序或者主存数据块</li></ul><h4 id="存储保护">存储保护</h4><p>为避免主存中多个进程相互干扰，须对主存中程序和数据进行保护：</p><ul><li>私有主存区信息：可读写</li><li>公共区共享信息：根据授权</li><li>非本进程信息：不可读写</li></ul><p>需软硬件协同完成：CPU检查是否允许访问，不允许则产生地址保护异常。</p><h4 id="主存空间的扩充">主存空间的扩充</h4><p>存储扩充：把磁盘作为主存扩充，只把部分进程或进程的部分内容装入内存</p><ol type="1"><li>对换技术：把部分不运行的进程调出</li><li>虚拟技术：只调入进程的部分内容</li></ol><p>需软硬件协同完成：</p><ol type="1"><li>对换进程决定对换，硬件机构调入</li><li>CPU处理到不在主存的地址，发出虚拟地址异常，OS将其调入再执行指令</li></ol><h3 id="虚拟存储器">3.1.3 虚拟存储器</h3><p>主存容量限制了用户编程与多道程序设计的道数—&gt;部分调入进程内容。</p><h4 id="虚拟存储器的基本思想">虚拟存储器的基本思想</h4><ol type="1"><li>存储管理把进程全部信息放在辅存中，执行时先将其中一部分装入主存，之后根据执行行为随用随调</li><li>若主存空间不足，存储管理根据执行将主存中暂时不用的信息调出到辅存</li></ol><h4 id="实现思路">实现思路</h4><p>建立和自动管理两个地址空间</p><ol type="1"><li>主存：实际地址空间，承载进程执行</li><li>辅存：虚拟地址空间，容纳进程装入</li></ol><p>对于用户，计算机系统具有一个容量大得多的主存空间，即虚拟存储器</p><p>虚拟存储器是一种地址空间扩展技术，通常意义上对用户编程是透明的，除非用户需要进行高性能程序设计。</p><h3 id="存储管理的硬件支撑">3.1.4 存储管理的硬件支撑</h3><h4 id="存储器的组织层次">存储器的组织层次</h4><figure><img src="/image/计算机操作系统/存储器组织层次.png"alt="存储器组织层次" /><figcaption aria-hidden="true">存储器组织层次</figcaption></figure><p>存储管理是操作系统管理主存储器的软件部分。</p><p>为了更好的处理性能，部分主存程序与数据被调入Cache；</p><p>为了获得更大虚拟地址空间，存储管理需要管理更大的虚拟存储器。</p><h4 id="高速缓冲存储器cache">高速缓冲存储器(Cache)</h4><p>介于CPU和主存间的高速小容量存储器。</p><p>构成：高速存储器、联想存储器、地址转换部件、替换部件等。</p><ol type="1"><li>联想存储器：根据内容进行寻址的存储器</li><li>地址转换部件：通过联想存储器建立目录表以实现快速地址转换，命中时直接访问Cache，未命中时从内存读取放入Cache</li><li>替换部件：缓存已满时按一定策略进行数据块替换，并修改地址转换部件</li></ol><p>组织：由于中央处理器芯片面积和成本，Cache很小</p><p>根据成本控制，划分为L1、L2、L3三级。</p><ol type="1"><li>L1Cache：分为数据缓存和指令缓存，内置，成本最高，对CPU性能影响最大，通常在32-256KB</li><li>L2 Cache：分内置和外置两种，后者性能低。通常在512KB-8MB</li><li>L3 Cache：多为外置，在游戏和服务器领域有效。</li></ol><p>对很多应用而言，改善总线比设置L3更加有利于提升系统性能</p><h4 id="存储管理与硬件支撑">存储管理与硬件支撑</h4><ol type="1"><li>程序执行与数据访问的局部性原理—&gt;使用Cache可大幅提升程序执行效率</li><li>动态重定位、存储保护等，无硬件支撑在效率上无意义</li><li>无虚拟地址中断，虚拟存储器无法实现</li><li>无页面替换等硬件支撑机制，虚拟存储器在效率上无意义</li></ol><p>存储保护的硬件支撑：限长寄存器与逻辑地址比较判断是否越界</p><p>地址转换的硬件支撑：基址寄存器与逻辑地址运算得物理地址</p><h2 id="单连续分区存储管理">3.2 单连续分区存储管理</h2><p>每个进程占用一个物理上完全连续的存储空间。</p><p>分为：单用户连续分区存储管理、固定分区存储管理、可变分区存储管理</p><h3 id="单用户连续分区存储管理">3.2.1 单用户连续分区存储管理</h3><ol type="1"><li>主存区域划分为系统区和用户区</li><li>设置一个栅栏寄存器界分两个区域，硬件用其在执行时进行存储保护</li><li>一般使用静态重定位进行地址转换</li></ol><p>硬件实现代价低，适用于单用户单任务操作系统，如DOS。</p><h4 id="静态重定位">静态重定位</h4><p>装入作业时，把该作业中程序的指令地址和数据地址全部转换为绝对地址。</p><h3 id="固定分区存储管理">3.2.2 固定分区存储管理</h3><p>硬件实现代价低，早期操作系统采用</p><p>基本思想：支持多个数量、大小固定的分区</p><p>使用主存分配表(分区号，起始地址，长度，占用标志)，执行主存分配/去配。</p><p>固定分区会产生内存内零头，即内存分区中空闲的部分。</p><h3 id="三可变分区存储管理">三、可变分区存储管理</h3><p>创建进程时，根据进程所需主存查看主存中是否有足够空闲空间，有则分配，无则等待。由于分区大小为实际分配，其个数是随机变化的。</p><h4 id="主存分配表">主存分配表</h4><p>分为已分配区表和未分配区表，采用链表。</p><h4 id="内存分配">内存分配</h4><ul><li>最先适应分配算法</li><li>邻近适应分配算法</li><li>最优适应分配算法</li><li>最坏适应分配算法</li></ul><p>可变分区会随着进程的内存分配产生不可用的小内存分区，称为内存外零头。</p><p>任何算法难免产生外零头，最优适配算法最容易产生外零头。</p><h4 id="移动技术程序浮动技术">移动技术（程序浮动技术）</h4><p>移动分区以解决内存外零头，需要动态重定位支撑</p><h2 id="页式存储管理">3.3 页式存储管理</h2><h3 id="页式存储管理的基本原理">3.3.1 页式存储管理的基本原理</h3><ol type="1"><li>分页存储器将主存划分为多个大小相等的页架</li><li>逻辑地址被页架分成页</li><li>不同的页可以放在不同页架中，不需要连续</li><li>页表用于维系进程的主存完整性</li></ol><h4 id="地址">地址</h4><ol type="1"><li>逻辑地址由页号和单元号组成</li><li>物理地址由页架号和单元号组成</li><li>地址转换可以通过查页表完成</li></ol><h4 id="内存分配去配">内存分配/去配</h4><ol type="1"><li>可用位示图记录主存分配情况</li><li>建立进程页表维护主存逻辑完整性</li></ol><p>位示图：使用0和1表示磁盘中块的使用情况。</p><h4 id="页的共享">页的共享</h4><ol type="1"><li>数据共享：不同进程可以使用不同页号共享数据页</li><li>程序共享：不同进程必须使用相同页号共享代码页</li></ol><p>原因：共享代码页中的JMP <页内地址>使用不同页号是做不到的。</p><h3 id="页式存储管理的地址转换">3.3.2 页式存储管理的地址转换</h3><h4 id="页式存储管理的代价">页式存储管理的代价</h4><p>页表放在主存，每次地址转换需访问两次主存</p><ol type="1"><li>按页号读出页表中相应页架号</li><li>按计算出来的绝对地址进行读写</li></ol><p>这降低了存取速度—&gt;使用Cache存放部分页表，即快表。</p><h4 id="快表">快表</h4><p>存放在高速缓冲存储器中的页表部分</p><p>快表的表项：页号和页架号</p><p>这种高速存储器是联想存储器，即按照内容寻址，而非按照地址寻址。</p><p>基于快表的地址转换流程：</p><ol type="1"><li>按逻辑地址中的页号查快表</li><li>若在快表中，则由页架号和单元号生成绝对地址</li><li>不在快表中，再查主存页表形成绝对地址，同时登记该页到快表中</li><li>快表填满后，按一定策略淘汰一个旧登记项，登记新页</li></ol><h4 id="多道程序环境下的进程表">多道程序环境下的进程表</h4><p>进程表中登记了每个进程的页表，进程占有处理器运行时，其页表起始地址和长度送入页表控制寄存器。</p><p>多道程序环境下的地址转换：</p><figure><img src="/image/计算机操作系统/多道程序环境下的地址转换.png"alt="多道程序环境下的地址转换" /><figcaption aria-hidden="true">多道程序环境下的地址转换</figcaption></figure><h3 id="页式虚拟存储管理">3.3.3 页式虚拟存储管理</h3><p>基本思想：</p><p>把进程全部页面装入虚拟存储器，执行时先把部分页面装入实际内存，然后根据执行行为动态调入不在主存的页，并进行必要的页面调出。</p><ul><li>这是现代操作系统主流存储管理技术。</li></ul><p>首次只把进程第一页信息装入主存，称为请求页式存储管理。</p><h4 id="页式虚拟存储管理的页表">页式虚拟存储管理的页表</h4><p>扩充页表项，指出：</p><ul><li><p>每页的虚拟地址、实际地址</p></li><li><p>主存驻留标志、写回标志、保护标志、引用标志、可移动标志，等等</p></li></ul><p>实现</p><ul><li>中央处理器处理地址<ul><li>若页驻留，则获得块号形成绝对地址</li><li>若页不在内存，则中央处理器发出缺页中断</li></ul></li><li>操作系统处理缺页中断<ul><li>若有空闲页架，则根据辅存地址调入页，更新页表和快表等</li><li>若无空闲页架，则决定淘汰页，调出已修改页，调入页，更新页表与快表</li></ul></li></ul><figure><img src="/image/计算机操作系统/页式虚拟存储管理.png"alt="页式虚拟存储管理" /><figcaption aria-hidden="true">页式虚拟存储管理</figcaption></figure><figure><img src="/image/计算机操作系统/页式虚拟存储管理2.png"alt="页式虚拟存储管理2" /><figcaption aria-hidden="true">页式虚拟存储管理2</figcaption></figure><h3 id="页式存储管理的页面调度">3.3.4 页式存储管理的页面调度</h3><p>当主存空间已满又需要装入新页时，页式虚拟存储管理必须按一定的算法把已在主存的一些页调出去。选择淘汰页的工作即为页面调度。</p><p>若页面调度算法设计不当，会导致页面被反复淘汰、调入，这称为页面抖动。</p><h4 id="缺页中断率">缺页中断率</h4><p>衡量存储管理性能和用户编程水平的重要依据</p><p>假定进程P共n页，系统分配页架数m个，P运行中成功访问次数S，不成功访问次数F，总访问次数A=S+F，缺页中断率为：f=F/A。</p><p>影响缺页中断率的因素：</p><ul><li>分配给进程的页架数：可用页架数越多，缺页中断率越低</li><li>页面大小：页面尺寸越大，缺页中断率越低</li><li>用户编程方法：大数据条件下，对缺页中断率影响也很大</li></ul><h4 id="页面调度算法">页面调度算法</h4><ul><li><p>OPT页面调度算法</p><ul><li><p>由Belady提出，又称Belady算法。</p></li><li><p>只可模拟，不可实现。</p></li></ul><p>当要调入新页面时，先淘汰以后不再访问的页，后选择距现在最长时间后再访问的页。</p></li><li><p>先进先出算法(FIFO)：总是淘汰最先调入主存的页</p></li><li><p>最近最少用算法(LRU)：淘汰最近一段时间较久未被访问的页</p><ul><li>严格实现的代价大：维持特殊队列</li></ul></li><li><p>最不常用算法(LFU)：淘汰最近一段时间内访问次数较少的页</p></li><li><p>时钟调度算法：用循环队列构造页面队列，队列指针指向可能要淘汰的页</p></li></ul><p>LFU模拟OPT比LRU更接近。</p><p>时钟调度算法使用页引用标志位，工作流程：</p><ol type="1"><li><p>页面调入主存时，引用标志位被置为1</p></li><li><p>访问主存页面时，引用标志位被置为1</p></li><li><p>淘汰页面时，从指针当前指向的页面开始扫描循环队列</p><ul><li>将所遇到的引用标志位是1的页面的引用标志位清0，跳过</li><li>将所遇到的引用标志位是0的页面淘汰，指针推进</li></ul></li></ol><h3 id="反置页表">3.3.5 反置页表</h3><h4 id="反置页表的提出">反置页表的提出</h4><ul><li><p>页表及相关硬件机制在地址转换、存储保护、地址虚拟中发挥了关键作用</p><ul><li>为页式存储管理设置专门硬件机构</li></ul></li><li><p>内存管理单元（MMU）：中央处理器管理虚拟/物理存储器的控制线路，把虚拟地址映射成物理地址，提供存储保护，必要时确定淘汰页面</p></li><li><p>反置页表（IPT）：MMU的数据结构</p></li></ul><h4 id="反置页表的基本设计思想">反置页表的基本设计思想</h4><ol type="1"><li>对内存中每个页架建立一个页表，按照块号排序</li><li>用以完成内存页架到访问进程页号的对应，即物理到逻辑地址的转换</li></ol><h4 id="反置页表的页表项">反置页表的页表项</h4><ol type="1"><li>页号：虚拟地址页号</li><li>进程标识符：使用该页的进程号</li><li>标志位：有效、引用、修改、保护和锁定等标志信息</li><li>链指针：哈希链</li></ol><h4 id="基于反置页表的地址转换过程">基于反置页表的地址转换过程</h4><ol type="1"><li>MMU通过哈希表把进程标识和虚页号转换成一个哈希值，指向反置页表的一个表目</li><li>MMU遍历哈希链找到所需进程的虚页号，该项的索引就是页架号，通过拼接移位即可生成物理地址</li><li>若遍历反置页表未能找到匹配页表项，则产生缺页中断</li><li>选择淘汰页面也由MMU完成</li></ol><h2 id="段式存储管理">3.4 段式存储管理</h2><h3 id="段式程序设计-1">3.4.1 段式程序设计</h3><p>每个程序可由若干段组成，每一段都可以从0开始编址，段内的地址是连续的。</p><ul><li>分段存储器的逻辑地址由两部分组成<ul><li>段号：单元号</li></ul></li></ul><h4 id="基本思想">基本思想</h4><ul><li>段式存储管理基于可变分区存储管理实现，一个进程要占用多个分区。</li><li>硬件需要增加一组用户可见的段地址寄存器（代码段、数据段、堆栈段、附加段），供地址转换使用</li><li>存储管理需要增加设置一个段表，每个段占用一个段表项，包括：<ul><li>段始址、段限长、存储保护、可移动、可扩充等标志位</li></ul></li></ul><h4 id="地址转换流程">地址转换流程</h4><ol type="1"><li>从段表控制寄存器中得到当前段表</li><li>按逻辑地址中段号查段表</li><li>得到段始址和段限长</li><li>比较逻辑地址中的单元号和段限长<ul><li>若单元号&gt;段限长则发生越界中断</li><li>否则，绝对地址=段始址+单元号</li></ul></li></ol><h4 id="段的共享">段的共享</h4><ul><li>通过不同进程段表中的项指向同一个段基址来实现</li><li>对共享段的信息必须进行保护，如规定只能读不能写。不满足条件则产生保护中断</li></ul><h3 id="段式虚拟存储管理">3.4.2 段式虚拟存储管理</h3><h4 id="基本思想-1">基本思想</h4><p>把进程的所有分段都存放在辅存中，进程运行时先把当前需要的一段或几段装入主存，在执行过程中访问到不在主存的段时再把它们动态装入。</p><ul><li>段式虚拟存储管理中段的调入和调出由操作系统自动实现，对用户透明</li><li>与段覆盖技术不同，它是用户控制的主存扩充技术，操作系统不感知</li></ul><h4 id="段表扩充">段表扩充</h4><ul><li>特征位<ul><li>00：不在主存</li><li>01：在主存</li><li>11：共享段</li></ul></li><li>存取权限<ul><li>00：可执行</li><li>01：可读</li><li>11：可写</li></ul></li><li>扩充位<ul><li>0：固定长</li><li>1：可扩充</li></ul></li><li>标志位<ul><li>00：未修改</li><li>01：已修改</li></ul></li></ul><h4 id="地址转换流程-1">地址转换流程</h4><figure><img src="/image/计算机操作系统/段式虚拟存储管理的地址转换.png"alt="段式虚拟存储管理的地址转换" /><figcaption aria-hidden="true">段式虚拟存储管理的地址转换</figcaption></figure><h3 id="段页式存储管理">3.4.3 段页式存储管理</h3><h4 id="基本思想-2">基本思想</h4><p>段式存储管理可以基于页式存储管理实现，每一段不必占据连续的存储空间，可以存放在不连续的主存页架中。</p><ul><li>可以扩充出段页式虚拟存储管理：装入部分段，或者装入段中部分页面</li></ul><p>段表项为标志、页表始址和页表长，页表项为标志和块号。</p><h4 id="段页式存储管理的地址转换">段页式存储管理的地址转换</h4><figure><img src="/image/计算机操作系统/段页式存储管理的地址转换.png"alt="段页式存储管理的地址转换" /><figcaption aria-hidden="true">段页式存储管理的地址转换</figcaption></figure><h4 id="段页式虚拟存储管理的地址转换">段页式虚拟存储管理的地址转换</h4><figure><img src="/image/计算机操作系统/段页式虚拟存储管理的地址转换.png"alt="段页式虚拟存储管理的地址转换" /><figcaption aria-hidden="true">段页式虚拟存储管理的地址转换</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第二章_处理器管理文件</title>
    <link href="/2023/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6/"/>
    <url>/2023/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第二章-处理器管理文件">第二章 处理器管理文件</h1><h2 id="处理器">2.1 处理器</h2><h3 id="处理器与寄存器">2.1.1 处理器与寄存器</h3><h4 id="处理器部件的简单示意">处理器部件的简单示意</h4><figure><img src="/image/计算机操作系统/处理器部件简单示意.png"alt="处理器部件简单示意" /><figcaption aria-hidden="true">处理器部件简单示意</figcaption></figure><h4 id="用户程序可见寄存器">用户程序可见寄存器</h4><ul><li><p>可以让程序员减少访问主存储器次数，提高指令执行的效率</p></li><li><p>所有程序可使用，包括应用程序和系统程序</p></li></ul><ol type="1"><li>数据寄存器，又称通用寄存器</li><li>地址寄存器：索引、栈指针、段地址等寄存器</li></ol><h4 id="控制与状态寄存器">控制与状态寄存器</h4><p>用于控制处理器的操作，主要被具有特权的操作系统程序使用</p><ol type="1"><li>程序计数器：存储将取指令的地址</li><li>指令寄存器：存储最近使用的指令</li><li>条件码：中央处理器为指令操作结果设置的位，标志正/负/零、溢出等结果</li><li>标志位：中断位、中断允许位、中断屏蔽位、处理器模式位、内存保护位等</li></ol><h4 id="程序状态字psw">程序状态字（PSW）</h4><p>记录当前程序运行的动态信息。</p><p>通常包含：</p><ul><li>程序计数器、指令寄存器、条件码</li><li>中断字、中断允许/禁止、中断屏蔽、处理器模式、内存保护、调试控制</li></ul><p>程序状态字也是计算机系统的寄存器。</p><ul><li>通常设置一组控制与状态寄存器，也可以专设一个程序状态字寄存器</li></ul><h3 id="指令与处理器模式">2.1.2 指令与处理器模式</h3><h4 id="机器指令">机器指令</h4><p>计算机系统执行的基本命令，中央处理器执行的基本单位</p><ul><li><p>指令由一个或多个字节组成，包括操作码、操作数地址、状态字以及特征码。</p></li><li><p>指令完成各种算术逻辑运算、数据传输、控制流跳转。</p></li></ul><p>指令执行过程</p><ol type="1"><li>取指：根据程序计数器从存储器或高速缓冲存储器中取指令到指令寄存器</li><li>译码：解译指令寄存器中的指令</li><li>执行：连接中央处理器，执行运算</li></ol><h4 id="特权指令与处理器模式">特权指令与处理器模式</h4><p>与计算机核心资源相关的特殊指令会被保护，只能被操作系统程序使用。</p><p>特权指令：只能被操作系统内核使用的指令。</p><p>处理器模式：管理特权指令</p><p>设置0、1、2、3等运行模式，执行规定的指令子集。</p><p>0：操作系统内核</p><p>1：系统调用</p><p>2：共享库程序</p><p>3：用户程序</p><p>0模式可执行全部指令，3模式只能执行非特权指令。</p><p>一般而言，现代操作系统只使用0和3两种模式，即内核模式与用户模式。</p><p>处理器模式切换：中断、异常或系统异常等事件导致用户程序向OS内核切换。</p><h2 id="中断">2.2 中断</h2><h3 id="中断的概念">2.2.1 中断的概念</h3><p>在程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转而执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程，称为中断。</p><ul><li>操作系统是中断驱动的，换言之，中断是激活操作系统的唯一方式。</li></ul><p>由硬件产生的中断称为硬中断，可分为外中断和内中断</p><ol type="1"><li>外中断，也称中断（狭义）、异步中断，是来自处理器外的中断，如设备中断</li><li>内中断，也称异常，是来自处理器内部的中断，通常是程序执行过程中发生的与当前指令关联的不正常的事件，如访管、硬件故障、程序性异常</li></ol><p>外中断会根据中断优先级处理，内中断一旦出现则立即由异常处理程序处理。</p><h3 id="中断的响应和处理">2.2.2 中断的响应和处理</h3><p>在指令执行周期最后增加一个检查中断的微操作以响应中断。</p><p>中断系统是响应和处理中断的系统，包括硬件(响应)和软件(处理)子系统两部分</p><p>中断装置是计算机系统中发现并响应中断/异常的硬件装置。</p><ul><li><p>外中断；中断控制器发现和响应</p></li><li><p>异常：由指令的控制逻辑和实现线路发现和响应，Trap机制</p></li></ul><h4 id="中断控制器">中断控制器</h4><p>CPU的一个控制部件，包括中断控制逻辑线路、中断寄存器</p><ol type="1"><li>外部设备向其发出中断请求，在中断寄存器中设置已发生的中断</li><li>指令处理结束前，检查中断寄存器，若有不被屏蔽的中断产生，则改变处理器内操作顺序，引出操作系统中的中断处理程序</li></ol><h4 id="中断响应的一般过程">中断响应的一般过程</h4><ol type="1"><li>发现中断源：发现中断寄存器中中断，根据优先级决定是否响应</li><li>保护现场：将当前程序的PSW/PC保存至核心栈</li><li>处理中断</li><li>恢复现场</li></ol><h4 id="不同中断源的处理原则">不同中断源的处理原则</h4><ol type="1"><li>硬件故障中断：由处理器、内存储器、总线等硬件故障引起。</li></ol><p>保护现场，停止设备，停止中央处理器，报告操作员，等待人工干预。</p><ol start="2" type="1"><li>程序性中断：处理器执行机器指令引起。</li></ol><p>算术异常—简单处理，报告用户；也可由用户编写中断续元程序处理。</p><p>非法指令、用户态使用特权指令、地址越界、非法存取等指令异常：终止进程。</p><p>虚拟地址异常：调整内存后重新执行指令。</p><ol start="3" type="1"><li>访管/自愿性中断：由系统调用引起。</li></ol><p>保护现场，跳转具体处理程序。</p><ol start="4" type="1"><li>输入/输出中断：外围设备报告输入/输出状态。<ul><li>输入/输出完成：调整进程状态，释放等待进程</li><li>出错：等待人工干预</li></ul></li><li>外部中断：外围设备发出的信号引起。<ul><li>时钟中断、间隔时钟中断：记时和时间片处理</li><li>设备报到与结束中断：调整设备表</li><li>键盘/鼠标信号中断：根据信号相应反应</li><li>关机/重启中断：写回文件，停止设备和中央处理器</li></ul></li></ol><h3 id="多中断的响应和处理">2.2.3 多中断的响应和处理</h3><p>中断优先级：中断装置预设的对不同中断的响应顺序</p><p>中断屏蔽：高级中断事件屏蔽低级中断源（中断屏蔽位）</p><p>中断嵌套：高级中断嵌套在低级中断中，嵌套层数不宜太多。</p><h2 id="进程">2.3 进程</h2><h3 id="进程-1">2.3.1 进程</h3><p>进程是操作系统进行资源分配和调度的基本单位。</p><p>进程的概念：具有一定独立功能的程序关于某个数据集合的一次运行活动。</p><p>包括五个实体部分：</p><ol type="1"><li>操作系统管理运行程序的数据结构P</li><li>程序的内存代码C</li><li>程序的内存数据D</li><li>程序的通用寄存器信息R</li><li>操作系统控制程序执行的程序状态字PSW</li></ol><h4 id="三态模型">三态模型</h4><ul><li>就绪态：进程具有运行条件等待处理器运行</li><li>等待态：进程由于等待资源、输入输出、信号等而不具备运行条件</li><li>运行态：进程占有处理器运行</li></ul><ol type="1"><li>就绪态—&gt;运行态：处理器空闲时选择、优先进程抢占</li><li>运行态—&gt;等待态：等待资源、输入输出、信号</li><li>等待态—&gt;就绪态：资源满足、输入输出结束、信号完成</li><li>运行态—&gt;就绪态：运行时间片到、优先进程抢占</li></ol><p>此外，也有短暂的新建态和结束态，但并不属于三态模型的循环中。</p><h4 id="进程挂起">进程挂起</h4><ol type="1"><li>操作系统无法预期进程的数目和资源需求，系统运行过程中可能资源不足</li><li>运行资源不足将导致低性能与死锁</li><li>解决办法：剥夺某些进程的内存及其他资源，调入操作系统管理对换区，不参加进程调度，等合适时机调入内存、恢复资源、参与运行<ul><li>等待态占有已申请的资源，而挂起态不具有任何资源。</li></ul></li></ol><p>进程挂起和恢复的过程：</p><ol type="1"><li>一般使等待态进程进入挂起等待态，也可使就绪态进程进入挂起就绪态</li><li>运行态进程可以挂起自己进入挂起就绪态</li><li>等待事件结束后，挂起等待态进入挂起就绪态</li><li>一般恢复挂起就绪态进程为就绪态进程，也可恢复挂起等待态为等待态</li></ol><h3 id="进程的数据描述">2.3.2 进程的数据描述</h3><h4 id="进程映像">进程映像</h4><p>某时刻进程的内容及其状态集合，包括</p><ol type="1"><li>进程控制块 (Process Control Block，PCB)</li><li>进程程序块：被进程执行的程序，规定进程运行所应完成的功能</li><li>进程数据块：进程的私有地址空间，存放各种私有数据，用户栈也在数据块中，用于在函数调用时存放栈帧、局部变量和返回地址等</li><li>进程核心栈：进程在内核态工作时使用，用于保存中断现场，以及函数调用参数、局部变量和返回地址等</li></ol><h4 id="进程上下文">进程上下文</h4><p>进程物理实体和支持进程运行的环境，由三部分组成</p><ol type="1"><li>用户级上下文：程序块、数据块、共享内存区、用户栈</li><li>寄存器上下文：处理器状态寄存器、程序计数器、栈指针、通用寄存器</li><li>系统级上下文：进程控制块、内存管理信息、核心栈等操作系统管理进程所需信息</li></ol><p>当系统调度新进程占有处理器，新老进程随之发生上下文切换。</p><h4 id="进程控制块">进程控制块</h4><p>进程创建时建立进程控制块，进程销毁时回收进程控制块，与进程一一对应。</p><p>操作系统根据进程控制块对进程进行控制和管理。</p><p>进程控制块是操作系统记录和刻画进程状态及环境信息的数据结构，包含：</p><ol type="1"><li><p>标识信息：唯一地标识一个进程</p></li><li><p>现场信息：通用、控制寄存器内容、核心与用户栈指针、程序状态字等</p></li><li><p>控制信息：用于管理和调度进程</p></li><li><p>进程调度相关信息：进程状态、等待事件及原因、优先级、队列指针等</p></li><li><p>进程组成信息：代码、数据地址，进程映像在外存的地址</p></li><li><p>进程队列指引元：进程队列指针、父子进程指针</p></li><li><p>进程通信相关信息：消息队列、信号量、锁</p></li><li><p>进程处理器使用信息：占用的处理器、时间片、处理器使用时间</p></li><li><p>进程特权信息：内存访问权限、处理器特权</p></li><li><p>进程资源清单：正占有的资源、已使用的资源</p></li></ol><h3 id="进程管理">2.3.3 进程管理</h3><p>关键进程管理软件包括：</p><ol type="1"><li>系统调用/中断/异常处理</li><li>队列管理</li><li>进程控制</li><li>进程调度</li><li>进程通信</li><li>终端登录与作业控制、性能监控、审计程序等外围程序</li></ol><h4 id="进程队列">进程队列</h4><p>将处于同一状态的所有进程的PCB链接在一起的数据结构。</p><p>不同状态的进程可以排列成运行、就绪或等待队列，组织方式有：</p><ol type="1"><li>链接方式</li></ol><p>通过PCB的链接指针将同一状态进程的PCB链接，可采用单/双链表</p><ol start="2" type="1"><li>索引方式</li></ol><p>建立索引表，存放PCB地址或在PCB表中的编号</p><p>队列管理模块是操作系统实现进程管理的核心模块，进程与资源调度围绕进程队列展开。</p><h4 id="进程管理原语">进程管理原语</h4><p>操作系统通过原语来完成进程管理。常见的进程管理原语有：</p><ol type="1"><li>进程创建：在进程列表添加新进程，申请PCB并完成初始化</li><li>进程撤销：从队列中移除，归还资源，回收PCB，移除进程表项</li><li>进程阻塞：保存现场信息，修改PCB，移入等待队列，调度其他进程执行</li><li>进程唤醒：修改PCB，从等待队列移入就绪队列</li><li>进程挂起：修改状态，出入相关队列，收回资源</li><li>进程激活：修改状态，出入相关队列，分配内存</li><li>其他，如修改进程特权</li></ol><h4 id="处理器状态模式切换">处理器状态（模式）切换</h4><p>处理器状态从用户态到内核态，或从内核态到用户态。</p><p>当发生中断或系统调用，处理器状态从用户态切换到内核态。切换过程：</p><ol type="1"><li>保存被中断进程的处理器现场信息</li><li>处理器从用户态转换到内核态</li><li>处理中断或进行系统调用</li></ol><p>此时进程仍在自己的上下文中执行，仅处理器状态发生变化。</p><h4 id="进程切换">进程切换</h4><p>收回运行中进程占用的处理器，让待运行进程执行</p><p>实质上，进程切换就是进程上下文的切换：</p><ol type="1"><li>保存被中断进程的上下文</li><li>进程调度（队列管理）</li><li>恢复待运行进程的上下文</li></ol><p>进程切换的发生时机：一定发生在中断处理过程，也就是在内核态中。</p><p>P：可再入程序是能够被多个程序同时调用的程序，它是纯代码的。</p><h2 id="线程">2.4 线程</h2><h3 id="多线程环境">2.4.1 多线程环境</h3><h4id="单线程结构在并发程序设计上的问题">单线程结构在并发程序设计上的问题</h4><ul><li>进程切换、通信开销大</li><li>进程并发粒度受限，并行计算效率低</li></ul><p>解决办法：进程分配资源，线程调度执行。</p><h4 id="多线程">多线程</h4><p>在多线程环境中，进程是操作系统中进行资源分配与保护的独立单位，具有：</p><ul><li><p>容纳进程映像的虚拟地址空间</p></li><li><p>对进程、文件和设备的存取保护机制</p></li></ul><p>线程是进程的一条执行路径，是调度的基本单位。</p><p>同一个进程中所有线程共享进程获得的主存空间和资源，具有：</p><ul><li>线程唯一标识符和其状态</li><li>受保护的线程上下文</li><li>独立的程序计数器</li><li>执行堆栈</li><li>容纳局部变量的静态存储器</li></ul><p>线程的状态：运行(Active)、就绪(Runnable)和睡眠(Sleeping)</p><p>线程状态变化的相关操作：孵化、封锁、活化、剥夺、指派、结束</p><p>线程的调度：</p><p>操作系统感知线程环境：</p><ul><li><p>处理器调度线程</p></li><li><p>进程只有挂起状态</p></li></ul><p>操作系统不感知线程环境：</p><ul><li><p>处理器调度进程</p></li><li><p>用户空间中的用户调度程序调度线程</p></li></ul><h4 id="并发多线程程序设计的优点">并发多线程程序设计的优点</h4><ol type="1"><li>快速线程切换</li><li>减少系统管理开销</li><li>线程通信易于实现</li><li>并行程度提高</li><li>节省内存空间</li></ol><h3 id="多线程的实现">2.4.2 多线程的实现</h3><h4 id="内核级线程kltkernel-level-thread">内核级线程（KLT，Kernel-levelThread）</h4><ol type="1"><li>线程管理的所有工作交由操作系统内核</li><li>操作系统提供了使用KLT的程序设计接口</li><li>操作系统直接调度KLT</li></ol><p>内核级线程的特点：</p><ol type="1"><li>进程的一个线程阻塞，内核能调度同一进程的其他线程运行</li><li>多处理器环境中，内核能同时调度同一进程的多个线程并行执行</li><li>内核自身也可用多线程技术实现，提高操作系统执行速度和效率</li><li>应用程序线程在用户态而线程调度在内核态，因而线程切换需要模式切换，系统开销大</li></ol><h4 id="用户级线程ultuser-level-thread">用户级线程（ULT，User-levelThread）</h4><ol type="1"><li>用户空间运行的线程库提供多线程应用程序的开发和运行环境</li><li>任何应用程序需通过线程库进行程序设计，与线程库连接后运行</li><li>线程管理的所有工作由应用程序完成，内核不知道线程的存在</li></ol><p>用户级线程的特点</p><ol type="1"><li>线程切换不需要模式切换，系统开销小</li><li>允许进程按特定需要选择调度算法</li><li>能运行在任何操作系统上</li><li>不能利用多处理器，操作系统调度进程，只有一个ULT能执行</li><li>一个ULT的阻塞将引起整个进程的阻塞</li></ol><h4 id="jacketing技术">Jacketing技术</h4><p>将阻塞式操作系统改造为非阻塞的。</p><p>当线程陷入系统调用，执行Jacketing程序，检查资源使用，决定是否进行进程切换或线程切换。</p><h4 id="混合式线程">混合式线程</h4><p>在用户空间进行线程创建、调度与同步，单应用多个ULT可映射成一些KLT。</p><p>混合式线程的特点：</p><ol type="1"><li>组合用户级线程/内核级线程设施</li><li>程序员可针对特定应用和机器调节内核级线程数目以达更好效果</li><li>结合了纯粹用户级、内核级线程优点，减少其缺点</li></ol><figure><img src="/image/计算机操作系统/混合式线程调用.png"alt="混合式线程调用" /><figcaption aria-hidden="true">混合式线程调用</figcaption></figure><h2 id="处理器调度">2.5 处理器调度</h2><h3 id="处理器调度的层次">2.5.1 处理器调度的层次</h3><ul><li><p>高级调度，又称长程调度，作业调度，决定能否加入执行的进程池中</p><p>分时操作系统中，高级调度决定：</p><ul><li>是否接受终端用户连接</li><li>命令是否被系统接纳并构成进程</li><li>新建的进程是否加入就绪进程队列</li></ul><p>批处理操作系统中，高级调度又称为作业调度，按某种原则从后备作业队列中选取作业进入主存，并为作业做好运行前的准备和完成后的完善。</p></li><li><p>中级调度，又称平衡负载调度，决定主存中的可用进程集合</p><ul><li>提高内存利用率和作业吞吐量。</li><li>决定哪些进程被允许驻留在主存中参与竞争处理器及其他资源，起到短期调整系统负荷的作用。（将一些进程挂起）</li></ul></li><li><p>低级调度，又称短程调度，进程调度，决定哪个进程占用处理器执行</p><ul><li>按某种原则将处理器分配给就绪态进程或内核级线程。</li></ul></li></ul><p>进程调度程序，又称分派程序，是操作系统中实现处理器调度的程序。</p><figure><img src="/image/计算机操作系统/处理器调度.png" alt="处理器调度" /><figcaption aria-hidden="true">处理器调度</figcaption></figure><h3 id="处理器调度算法">2.5.2 处理器调度算法</h3><h4 id="选择处理器调度算法的原则">选择处理器调度算法的原则</h4><ol type="1"><li>资源利用率</li><li>响应时间：尽快处理实时任务</li><li>周转时间：提交给系统开始到执行完成获得结果为止的时间</li><li>吞吐量：单位时间处理的进程数</li><li>公平性：每个用户每个进程获得合理的资源份额</li></ol><h4 id="优先数调度算法">优先数调度算法</h4><p>根据分配给进程的优先数决定运行进程，分为抢占式和非抢占式</p><p>优先数的确定准则：</p><ul><li>任务的紧迫程度</li><li>交互性</li><li>使用外设的频度</li><li>进入系统时间长短</li></ul><p>一些优先数选择：</p><ul><li>计算时间短优先</li><li>剩余时间短优先</li><li>响应比（等待时间/进入时间）高优先</li><li>先来先服务FCFS：先进队先选择 (多用于高级调度)</li></ul><h4 id="时间片轮转调度算法">时间片轮转调度算法</h4><ul><li>根据各个进程进入就绪队列的顺序轮流占有CPU一个时间片</li></ul><p>时间片的确定：适中，过长则为FCFS，过短则开销大</p><p>分为单时间片、多时间片和动态时间片</p><h4 id="分级调度算法">分级调度算法</h4><ul><li>又称多队列策略，反馈循环队列</li></ul><p>基本思想：</p><ol type="1"><li>建立多个不同优先级的就绪进程队列</li><li>多个就绪进程队列间按照优先数调度</li><li>高优先级就绪进程分配的时间片短</li><li>单个就绪进程队列中进程的优先数和时间片相同</li></ol><h4 id="随机调度算法">随机调度算法</h4>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机操作系统-第一章_概述</title>
    <link href="/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>不畏浮云遮望眼，自缘身在最高层</p><span id="more"></span><h1 id="第一章-计算机操作系统概述">第一章 计算机操作系统概述</h1><h2 id="计算机系统">1.1 计算机系统</h2><h3 id="计算机系统概述">1.1.1 计算机系统概述</h3><p>电子数字计算机：能够自行按照已设定的程序进行数据处理的电子设备。</p><h4 id="计算机发展历史">计算机发展历史</h4><ul><li><p>1945～：电子真空管、机器语言，应用于科学计算</p></li><li><p>1956～：晶体管、批处理控制、Fortran/COBOL，扩展到数据处理</p></li><li><p>1959～：集成电路、多道程序、操作系统/数据库/高级语言</p></li><li><p>1976～：大规模集成电路，向快速化、小型化、系统化、网络化、智能化发展</p></li><li><p>1980～：微机出现</p></li><li><p>1990～：图形化人机交互</p></li><li><p>2003～：移动计算</p></li></ul><h4 id="计算机系统组成">计算机系统组成</h4><p>包括硬件子系统和软件子系统</p><ul><li><p>硬件：借助电、磁、光、机械等原理构成的各种物理部件的有机组合</p></li><li><p>软件：各种程序和文件，包括系统软件、支撑软件和应用软件</p><ul><li>关键系统软件：操作系统和语言处理程序</li></ul></li></ul><h4 id="计算机系统视图">计算机系统视图</h4><ul><li><p>用户视图：应用、语言处理、操作系统、计算机硬件</p></li><li><p>应用程序员视图：语言处理、操作系统、计算机硬件</p></li><li><p>语言处理程序设计者视图：操作系统、计算机硬件</p></li><li><p>操作系统设计者视图：计算机硬件</p></li></ul><h3 id="计算机硬件系统">1.1.2 计算机硬件系统</h3><h4 id="一计算机硬件系统的组成">一、计算机硬件系统的组成</h4><ol type="1"><li>中央处理器：运算单元、控制单元</li><li>主存储器</li><li>外围设备：输入/输出设备、存储设备、网络通信设备</li><li>总线</li></ol><h4 id="二冯氏计算机存储程序计算机">二、冯氏计算机：存储程序计算机</h4><p>冯·诺伊曼等人在1946年总结提出，称为冯·诺伊曼计算机模型</p><ol type="1"><li>以运算单元为中心，控制流由指令流产生</li><li>采用存储程序原理，面向主存组织数据流</li><li>主存是按地址访问、线性编址的空间</li><li>指令由操作码和地址码组成</li><li>数据以二进制编码</li></ol><h4 id="三总线">三、总线</h4><p>总线是计算机各种功能部件之间传送信息的公共通信干线，是CPU、内存、输入输出设备传递信息的公用通道。</p><p>计算机各个部件通过总线相连接，外围设备通过相应的接口电路与总线相连接，形成了计算机硬件系统。</p><p>总线的组成：一组控制线、一组数据线、一组地址线</p><p>总线的类型：</p><ol type="1"><li>内部总线：用于CPU芯片内部连接各元件</li><li>系统总线：用于连接CPU、存储器和各种输入/输出模块等主要部件</li><li>通信总线：用于计算机系统间通信</li></ol><p>片上系统 (SoC: System on a Chip)</p><p>在单个芯片上集成一个完整的系统(包括中央处理器、存储器以及外围电路等)，对所有或部分必要的电子电路进行包分组的技术。</p><p>SoC是与其他技术(如绝缘硅，提高增强时钟频率，降低功耗)并行发展的。</p><h4 id="四中央处理器">四、中央处理器</h4><p>中央处理器是计算机的运算核心和控制单元，主要包括：</p><ol type="1"><li>运算逻辑部件：一个或多个运算器</li><li>寄存器部件：包括通用寄存器、控制与状态寄存器、高速缓冲存储器</li><li>控制部件：实现各部件之间联系的数据、控制与状态内部总线；指令译码、控制指令执行、实现数据传输等功能的部件</li></ol><figure><img src="/image/计算机操作系统/中央处理器.png" alt="中央处理器" /><figcaption aria-hidden="true">中央处理器</figcaption></figure><p>存储器组织层次：越往下，容量越大、速度越慢、价格越低</p><p>L0：寄存器</p><p>L1：L1 Cache</p><p>L2：L2 Cache</p><p>L3：L3 Cache</p><p>L4：主存</p><p>L5：本地固态硬盘</p><p>L6：本地硬盘</p><p>外围设备：输入/输出设备、存储设备、通信设备</p><p>输入/输出控制方式：</p><ol type="1"><li>轮询：CPU忙式控制输入/输出，执行内存数据交换</li><li>中断：CPU启动输入/输出设备，设备中断CPU</li><li>DMA方式：CPU启动DMA，DMA独立进行输入/输出和内存数据交换，DMA中断CPU</li></ol><h3 id="计算机软件系统">1.1.3 计算机软件系统</h3><h4 id="一计算机软件系统的组成">一、计算机软件系统的组成</h4><ol type="1"><li>系统软件</li></ol><p>操作系统、实用程序、语言处理程序、数据库管理系统</p><ol start="2" type="1"><li>支撑软件</li></ol><p>接口软件、工具软件、环境数据库，也可认为是系统软件的一部分</p><ol start="3" type="1"><li>应用软件</li></ol><p>用户按其需要自行编写的专用程序</p><h4 id="二程序员的计算机系统视图">二、程序员的计算机系统视图</h4><ol type="1"><li>机器语言：计算机硬件系统</li><li>机器指令：操作系统和实用程序</li><li>数据库语言：数据库管理系统</li><li>高级语言：支撑软件</li><li>更高：支撑软件</li></ol><p>软件开发的不同层次</p><ol type="1"><li>计算机硬件系统：机器语言</li><li>操作系统资源管理：机器语言+广义指令</li><li>操作系统文件系统：机器语言+系统调用</li><li>数据库管理系统：数据库语言</li><li>语言处理程序：面向问题的语言</li></ol><h4 id="三计算机程序的执行过程">三、计算机程序的执行过程</h4><figure><img src="/image/计算机操作系统/计算机程序执行过程.png"alt="计算机程序执行过程" /><figcaption aria-hidden="true">计算机程序执行过程</figcaption></figure><h2 id="计算机操作技术">1.2 计算机操作技术</h2><h3 id="计算机操作技术的发展">1.2.1 计算机操作技术的发展</h3><h4 id="操作平台与操作系统">1. 操作平台与操作系统：</h4><p>任何一台机器都有其操作平台与操作系统，操作平台的精细化和系统化，产生了操作系统。</p><h4 id="计算机人工操作">2. 计算机人工操作</h4><p>计算机手工操作的问题：手工操作速度和电子计算速度不匹配</p><p>装入程序的引进：</p><ol type="1"><li>引入卡片和打孔纸带描述程序指令和数据</li><li>装入程序：自动化执行程序装入，必要时进行地址切换，存放在ROM中</li></ol><p>外存储设备变迁：过去的磁带与软盘，使用逐渐减少的光盘</p><p>计算机控制</p><p>汇编语言：先将汇编语言程序编译为可执行程序，再由计算机执行</p><p>高级语言：高级语言程序编译为目标代码，后编译成可执行程序，再执行</p><h4 id="简单批处理系统的操作方式">3. 简单批处理系统的操作方式</h4><p>简单批处理系统的操作控制：</p><p>引入作业控制语言，用户编写作业说明书，描述对一次计算机作业的控制。</p><p>操作员控制计算机成批输入作业，成批执行作业。</p><p>这一方式缩短了手工操作时间，提高了计算机系统的使用效率。</p><p>进展：</p><ol type="1"><li>出现了初步的资源管理程序，屏蔽了硬件处理细节</li><li>输入/输出中断出现，实现CPU与输入/输出设备并行</li><li>磁带出现，磁盘文件系统形成，但输入/输出效率还是不支持多道程序</li></ol><h4 id="操作系统与自动化操作方式">4. 操作系统与自动化操作方式</h4><p>操作系统与自动化操作控制：</p><ol type="1"><li>电子计算速度与机械输入/输出速度的矛盾</li><li>程序执行过程中输入作业，重叠时间</li></ol><p>需要多道程序同时执行，程序切换需要高速外存储设备</p><ol start="3" type="1"><li>磁盘设备出现，于是有了计算机操作系统，实现自动化控制</li></ol><h3 id="计算机操作系统">1.2.2 计算机操作系统</h3><h4 id="操作系统基本概念">1. 操作系统基本概念</h4><p>操作系统是计算机系统最基础的系统软件，管理软硬件资源、控制程序执行、改善人机界面，合理组织计算机工作流程，为用户使用计算机提供良好运行环境。</p><h4 id="操作系统组成">2. 操作系统组成</h4><ol type="1"><li>进程调度子系统</li><li>进程通信子系统</li><li>内存管理子系统</li><li>设备管理子系统</li><li>文件管理子系统</li><li>网络通信子系统</li><li>作业控制子系统</li></ol><h4 id="操作系统分类">3. 操作系统分类</h4><p>从操作方式看：</p><ol type="1"><li>多道批处理操作系统，脱机控制方式</li><li>分时操作系统，交互式操作系统</li><li>实时操作系统</li></ol><p>按应用领域分类：</p><p>服务器操作系统、并行操作系统、网络操作系统、分布式操作系统、个人机操作系统、手机操作系统、嵌入式操作系统、传感器操作系统</p><p>普适计算 Pervasive/Ubiquitous Computing</p><p>物联网 Things of Internet, CPS</p><p>移动计算 Mobile Computing (移动互联网)</p><p>嵌入式的操作系统: μC/OS-II, VxWorks, LiteOS, 翼辉SylixOS......</p><p>移动终端的操作系统： Android, iOS, 鸿蒙OS......</p><p>PC的OS: 微软的桌面系统</p><p>服务器的OS: CentOS, Ubuntu等Linux各类发行版, EulerOS, ...</p><h2 id="操作系统的不同视角">1.3 操作系统的不同视角</h2><h3 id="资源管理的视角">1.3.1 资源管理的视角</h3><h4 id="计算机系统的资源">计算机系统的资源</h4><ul><li>硬件资源：处理器、内存、外设</li><li>信息资源：数据、程序</li></ul><h4 id="软硬件资源管理">软硬件资源管理</h4><ul><li>处理器资源：占有处理器运行的程序</li><li>内存资源：程序、数据在内存中的分布</li><li>设备资源：分配、去配和使用资源</li><li>信息资源管理：访问文件信息</li><li>信号量资源：管理进程间通信</li></ul><h4 id="屏蔽资源使用的底层细节">屏蔽资源使用的底层细节</h4><p>驱动程序：最底层的、直接控制和监视各类硬件资源的地方</p><ul><li>隐藏底层硬件的具体细节，为其他部分提供抽象、具体的接口</li></ul><h4 id="资源的共享独占与并发">资源的共享：独占与并发</h4><p>资源的分配：</p><ul><li>静态分配：进程运行前一次拿到所有全部独占资源</li><li>动态分配：使用资源前临时申请</li></ul><p>可能产生竞争资源的死锁。</p><p>资源抢占方式：被抢占资源的进程需要回滚执行</p><h3 id="控制程序执行的视角">1.3.2 控制程序执行的视角</h3><p>由于中央处理器速度和输入/输出速度不匹配的矛盾，只有让多道程序同时进入内存争抢中央处理器运行，才可以使中央处理器与外围设备充分并行，提高计算机系统使用效率。</p><h4 id="多道程序设计">多道程序设计</h4><p>让多个程序同时进入计算机主存储器进行计算。</p><p>特点：</p><ol type="1"><li>中央处理器与外部设备充分并行</li><li>外部设备间充分并行</li><li>发挥中央处理器使用效率</li><li>提高单位时间算题量</li><li>单道程序的运算时间会增加</li></ol><p>多道程序系统的实现：</p><ol type="1"><li>为进入内存执行的程序建立管理实体：进程</li><li>操作系统管理和控制进程程序的执行</li><li>操作系统协调管理各类资源在进程间使用</li></ol><ul><li>处理器的管理与调度</li><li>主存储器的管理与调度</li><li>其他资源的管理与调度</li></ul><p>实现要点：</p><ol type="1"><li>如何使用资源：调用操作系统提供的服务例程</li><li>如何复用中央处理器：调度程序，让其他程序在中央处理器空闲时运行</li><li>如何使中央处理器和输入/输出设备充分并行：设备控制器和通道</li><li>如何让正在运行的程序让出中央处理器：中断</li></ol><h3 id="操作控制计算机的视角">1.3.3 操作控制计算机的视角</h3><ol type="1"><li>计算机操作控制方式</li><li>脱机作业控制方式</li><li>联机作业控制方式</li><li>命令解释程序及其处理过程</li></ol><h4 id="计算机系统操作方式">计算机系统操作方式</h4><ol type="1"><li>操作系统规定了合理操作计算机的工作流程</li><li>操作系统的操作接口：系统程序</li><li>两类作业级接口：</li></ol><p>脱机作业控制方式、联机作业控制方式</p><h4 id="脱机作业控制方式">脱机作业控制方式</h4><p>例：shell程序</p><ul><li>操作系统：提供作业说明语言</li><li>用户：编写作业说明书，确定作业加工控制步骤，并与程序数据一起提交</li><li>操作员：通过控制台输入作业</li><li>操作系统：通过作业控制程序自动控制作业的执行</li></ul><h4 id="联机作业控制方式">联机作业控制方式</h4><p>例：分时操作系统的交互控制方式</p><ul><li>计算机：提供终端 (键盘、显示器)</li><li>用户：登录系统</li><li>操作系统：提供命令解释程序</li><li>用户：联机输入操作控制命令，直接控制作业的执行</li></ul><h4 id="命令解释程序">命令解释程序</h4><p>接受和执行一条用户提出的对作业的加工处理命令</p><ul><li>会话语言：可编程的命令解释语言</li><li>图形化的命令控制方式</li><li>多通道交互的命令控制方式</li></ul><p>处理过程：</p><ol type="1"><li>操作系统启动命令解释程序，输出命令提示符，等待键盘中断、鼠标点击、多通道识别</li><li>每当用户输入命令并按回车换行，将命令暂存在命令缓冲区后，申请中断</li><li>中央处理器响应后，将控制权交给命令解释器程序，读入命令缓冲区内容，分析命令、接受参数，执行处理代码</li></ol><p>前台命令和后台命令</p><ul><li><p>前台命令执行结束后，再次输出命令提示符，等待下一条命令</p></li><li><p>后台命令处理启动后，即可接收下一条命令</p></li></ul><h3 id="人机交互的视角">1.3.4 人机交互的视角</h3><h4 id="操作系统的人机交互部分">操作系统的人机交互部分</h4><ol type="1"><li>操作系统改善人机界面，为用户使用计算机提供良好的环境</li><li>人机交互设备包括传统终端设备和新型模式识别设备</li><li>人机交互部分用于控制有关设备运行、理解执行设备传来命令</li><li>人机交互功能决定了计算机系统的友善性</li></ol><h4 id="人机交互的发展">人机交互的发展</h4><p>交互式控制方式：</p><ul><li><p>行命令控制方式：1960年代开始使用</p></li><li><p>全屏幕控制方式：1970年代开始使用</p></li></ul><p>人，而不是技术，是人机交互的中心——&gt;鼠标、菜单、窗口控制</p><h4 id="wimp界面">WIMP界面</h4><p>窗口(Window)、图标(Icon)、菜单(Menu)、指示装置(Pointing Devices)</p><ul><li><p>1990年代开始广泛使用。</p></li><li><p>不足：不能同时使用多个交互通道，产生人机交互的不平衡。</p></li></ul><h4 id="多媒体计算机">多媒体计算机</h4><p>将音频视频、图形图像和人机交互控制结合，进行综合处理</p><h4 id="虚拟现实系统">虚拟现实系统</h4><p>例：VR</p><h3 id="程序接口的视角">1.3.5 程序接口的视角</h3><h4 id="操作系统的程序接口">操作系统的程序接口</h4><p>操作系统为程序运行扩充的编程接口。</p><p>系统调用：操作系统实现的完成某种特定功能的过程</p><p>POSIX支持</p><h4 id="系统调用的实现机制">系统调用的实现机制</h4><p>中断。</p><p>系统调用的实现要点：</p><ol type="1"><li>编写系统调用处理程序</li><li>系统调用入口地址表</li><li>系统调用时，需保存当时的处理器情况</li></ol><h4 id="系统调用的实现流程">系统调用的实现流程</h4><figure><img src="/image/计算机操作系统/系统调用的实现流程.png"alt="系统调用的实现流程" /><figcaption aria-hidden="true">系统调用的实现流程</figcaption></figure><h3 id="系统结构的视角">1.3.6 系统结构的视角</h3><p>操作系统是计算机软件发展史上第一个大规模软件系统。</p><h4 id="操作系统软件的结构设计">操作系统软件的结构设计</h4><ul><li>操作系统构件：内核、进程、线程、管程等</li><li>设计概念：模块化、层次化、虚拟化</li><li>内核设计是操作系统设计中最为复杂的部分</li></ul><h4 id="操作系统内核">操作系统内核</h4><ul><li>单内核：内核中各部件杂然混居</li><li>微内核：结构性部件与功能性部件分离</li><li>混合内核：微内核和单内核的折中，较多组件在核心态中运行以更快执行</li><li>外内核：减少内核的软件抽象化和传统微内核的消息传递机制，使得开发者专注于硬件的抽象化</li></ul><h4id="操作系统实现的一种层次式结构">操作系统实现的一种层次式结构：</h4><ul><li><p>用户模式：用户与文件系统</p></li><li><p>内核模式：进程交互、输入/输出设备管理、虚拟内存、基本进程管理、硬件</p></li></ul><p>另一种层次式结构：</p><ol type="1"><li>用户：命令、进程、库、环境</li><li>文件系统调用：用户进程管理、目录管理、设备文件、文件系统、管道等高阶通信</li><li>软硬件协同内核：内存与虚拟内存管理、块设备管理与输入/输出控制、核心进程管理和控制与通信原语、中断管理</li><li>硬件电路：过程机制、指令解译、电路执行</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件工程与计算II复习</title>
    <link href="/2023/04/30/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/SEII%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/04/30/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/SEII%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="seii复习">SEII复习</h1><span id="more"></span><ul><li>软件需求工程</li><li>软件设计</li><li>软件构造</li><li>软件测试</li><li>软件交付</li><li>软件维护</li></ul><h2 id="包的原则">包的原则</h2><ul><li>重用发布等价原则（REP）</li><li>共同封闭原则（CCP）</li><li>共同重用原则（CRP）</li><li>无环依赖原则（ARP）</li><li>稳定依赖原则（SDP）</li><li>稳定抽象原则（SAP）</li></ul><h2 id="人机交互">人机交互</h2><h3 id="人机交互设计原则">人机交互设计原则</h3><ul><li><p>简洁</p></li><li><p>一致性</p></li><li><p>低出错</p></li><li><p>易记性</p></li><li><p>可视化</p></li><li><p>导航</p></li><li><p>反馈</p></li><li><p>差异性</p></li></ul><h2 id="耦合和内聚">耦合和内聚</h2><h3 id="耦合">耦合</h3><p>从高到低，越低越好，1、2、3不可接受</p><ol type="1"><li>内容耦合：一个模块直接修改另一个模块的内容</li><li>公共耦合：全局变量、文件、设备</li><li>重复耦合：重复代码</li><li>控制耦合：一个模块给其他模块传递控制信息</li><li>印记耦合：共享数据结构却只使用一部分</li><li>数据耦合：模块间传参只传需要的数据，最理想</li></ol><h3 id="内聚">内聚</h3><p>从高到低，越低越差，6、7不能接受</p><ol type="1"><li>信息内聚：模块进行许多操作，各自有各自的入又点，每个操作代码相对独立，而且所有操作都在相同的数据结构上进行</li><li>功能内聚：只执行一个操作或达到一个目的</li><li>通信内聚：对相同数据执行不同操作</li><li>过程内聚：含有不同步骤操作</li><li>时间内聚：具有时间相关性的相关操作</li><li>逻辑内聚：逻辑上相似但没有直接关联操作</li><li>偶然内聚：多个毫不相干的操作</li></ol><h2 id="设计原则">设计原则</h2><ol type="1"><li>全局变量有害</li><li>代码清晰可修改</li><li>避免重复</li><li>面向接口编程</li><li>迪米特法则：不能出现a.b.method()</li><li>接口隔离原则（接口最小化原则）</li><li>里氏替换原则：所有派生类都须可以替代其基类</li><li>组合代替继承</li><li>单一职责原则</li><li>最小化类和成员的可访问性</li><li>开放/封闭原则（OCP）：模块可扩展，不应修改（无switch、if/else）</li><li>依赖倒置原则（DIP）：高级模块不应依赖于低级，两者均应依赖抽象</li></ol><h2 id="设计模式">设计模式</h2><ul><li>策略模式</li><li>迭代器模式</li><li>抽象工厂模式</li><li>单件模式</li></ul><h2 id="代码设计">代码设计</h2><ul><li>单元测试用例的设计</li><li>契约式设计</li><li>防御式编程</li><li>表驱动</li></ul><h2 id="软件开发过程模型">软件开发过程模型</h2><ul><li>生命周期模型</li><li>构建-修复模型</li><li>瀑布模型</li><li>增量迭代模型</li><li>演化模型</li><li>原型模型</li><li>螺旋模型</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件工程与计算2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软工2-三-软件需求</title>
    <link href="/2023/04/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%B8%89-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/"/>
    <url>/2023/04/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%B8%89-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<p>单纯的软件系统是不能解决问题的，只有和现实世界之间形成有效互动才能实现问题的解决。</p><span id="more"></span><h1 id="第三部分-软件需求">第三部分 软件需求</h1><h2 id="一需求工程">一、需求工程</h2><h3 id="需求工程的概念">需求工程的概念</h3><p>所有需求处理活动的总和。它收集信息、分析问题、整合观点、记录需求并验证其正确性，最终描述出软件被应用后与其环境互动形成的期望效应。</p><p>三个主要任务：</p><ul><li><p>需求工程必须说明软件系统将被应用的应用环境及其目标，说明用来达成这些目标的软件行动（为什么、做什么）</p></li><li><p>需求工程必须将目标和功能反映到软件系统中，映射为可行的软件行为，并对软件行为进行准确的规格说明</p></li><li><p>现实世界是不断变化的世界，因此需求工程还需要妥善处理目标和功能随着时间演化的变动情况</p></li></ul><h3 id="需求工程的活动">需求工程的活动</h3><ul><li>需求开发<ul><li>需求获取</li><li>需求分析</li><li>需求规格说明</li><li>需求验证</li></ul></li><li>需求管理</li></ul><h4 id="需求获取">1. 需求获取</h4><p>从人、文档或者环境中利用各种方法和技术获取需求</p><ul><li>目标分析：根据问题确定目标、分析利害关系人确定目标</li><li>常见困难：用户与开发人员的认知差异</li><li>获取方法：面谈、问卷、文档分析、头脑风暴、专题讨论、原型</li></ul><h4 id="需求分析">2. 需求分析</h4><ol type="1"><li>通过建模整合各种信息</li><li>为问题定义出一个需求集合，该集合能界定一个问题的解决方案</li><li>检查需求中的错漏，加以修正</li></ol><h5 id="边界分析">(1) 边界分析</h5><ol type="1"><li>定义项目的范围</li><li>系统边界的定义要保证系统能和周围环境形成有效互动</li><li>系统用例图常被用于定义系统边界</li></ol><h5 id="需求建模">(2) 需求建模</h5><p>为展现和解释信息而进行的抽象描述活动</p><ul><li>常用类图、顺序图、状态图</li></ul><h4 id="需求规格说明">3. 需求规格说明</h4><p>在系统用户间交流需求信息</p><ul><li><p>要简洁、精确、一致和易于理解</p></li><li><p>需求工程师在该阶段的重要工作：定制文档模版、编写文档</p></li></ul><h4 id="需求验证">4. 需求验证</h4><p>需求规格说明文档的要求：</p><ol type="1"><li>每条需求都正确、准确地反映了用户意图</li><li>需求集在整体上具有整体性和一致性</li><li>文档的组织方式和需求的书写方式具有可读性和可修改性</li></ol><p>验证的方法：同级评审、原型、模拟</p><h3 id="需求管理">需求管理</h3><ol type="1"><li>保证需求作用的持续、稳定和有效发挥<ul><li>在需求开发活动后，设计、测试、实现等后续的软件系统开发活动都需要以围绕需求开展工作</li></ul></li><li>进行变更控制<ul><li>纳入实现合理的变更需求、拒绝不合理变更需求，控制变更成本和影响范围</li></ul></li></ol><h2 id="二需求基础">二、需求基础</h2><h3 id="需求的定义">需求的定义</h3><ul><li>用户为了解决问题或达到某种目标所需要的条件或能力</li><li>系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力</li><li>对上述中的一个条件或一种能力的一种文档化表述</li></ul><p>需求是一种解决问题后所能达到的期望。</p><p>问题域：</p><ul><li>现实世界运行规律的一种反映</li><li>需求的产生地与解决地</li><li>最终的软件产品要在现实中部署，它能够部分影响问题域，但不能任意改变现实<ul><li>软件开发必须尊重问题域，不能因为技术原因妄自修改现实情况</li></ul></li></ul><p>问题的解决：</p><ul><li>基础：模拟与共享现象</li><li>方法：直接、间接</li><li>解决方案：需求规格说明</li></ul><h3 id="需求开发的目标">需求开发的目标</h3><p>将现实世界问题域描述转化为计算世界的规格说明。</p><p>规格说明：软件产品的方案描述，以软件产品的运行机制为主要内容。</p><ul><li>关注对外交互的方式描述软件解决方案</li></ul><p>需求层次性</p><ul><li><p>业务需求：系统具备的特性</p></li><li><p>用户需求：系统能帮助用户做些什么</p></li><li><p>系统需求：用户对系统行为的期望</p></li></ul><h3 id="需求分类">需求分类</h3><h4 id="需求谱系">需求谱系</h4><ul><li>需求<ul><li>项目需求</li><li>过程需求</li><li>系统需求<ul><li>软件需求</li><li>硬件需求</li><li>其他需求</li></ul></li></ul></li><li>不切实际的期望</li></ul><h4 id="需求分类-1">需求分类</h4><ul><li>功能需求<ul><li>不考虑物理约束的情况下，用户希望系统能够执行的活动</li><li>主要表现为系统和环境之间的行为交互</li></ul></li><li>性能需求<ul><li>系统整体或系统组成部分应该拥有的性能特征</li></ul></li><li>质量属性<ul><li>系统完成工作的质量</li></ul></li><li>对外接口<ul><li>系统和环境中其他系统需要建立的接口</li></ul></li><li>约束<ul><li>进行系统构造时需要遵守的约束</li></ul></li></ul><h2 id="三需求分析">三、需求分析</h2><h3 id="需求分析的任务">需求分析的任务</h3><ul><li>建立分析模型，达成开发者和用户对需求信息的共同理解</li><li>依据共同的理解发挥创造性，创建软件系统解决方案</li></ul><h3 id="需求分析模型">需求分析模型</h3><p>模型是对事物的抽象，帮助人们在创建一个事物之前可以有更好的理解。</p><h4 id="面向对象方法模型">面向对象方法模型</h4><table><thead><tr class="header"><th>模型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>用例图</td><td>描述用户与系统的交互。从交互的角度说明了系统的边界和功能范围。</td></tr><tr class="even"><td>类图</td><td>描述应用领域中重要的概念以及概念之间的关系。它捕获了系统的静态结构。</td></tr><tr class="odd"><td>顺序图</td><td>描述系统中一次交互的行为过程，说明了在交互中的对象协作关系。</td></tr><tr class="even"><td>状态图</td><td>描述系统、用例或者对象在其整个生命期内的状态变化和行为过程。</td></tr></tbody></table><h4 id="结构化方法模型">结构化方法模型</h4><table><thead><tr class="header"><th>模型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>数据流图</td><td>从数据传递和加工的角度，描述了系统从输入到输出的功能处理过程。运用功能分解的方法，用层次结构简化处理复杂的问题。</td></tr><tr class="even"><td>实体关系图</td><td>描述系统中的数据对象及其关系，定义了系统中使用、处理和产生的所有数据。</td></tr></tbody></table><h4 id="建模">建模</h4><p>建立模型的过程被称为建模。</p><ul><li><p>建模是对系统进行思考和推理的一种方式</p></li><li><p>建模的目标是建立系统的一个表示，这个表示以精确一致的方式描述系统，使得系统的使用更加容易</p></li><li><p>建模的常用手段：抽象和分解</p></li></ul><h2 id="四面向对象分析">四、面向对象分析</h2><h3 id="简单过程">简单过程</h3><ul><li><p>系统用例图——细化系统的对外交互——&gt;用例模型/用例描述</p></li><li><p>用例模型/用例描述——明确用例中的协作对象——&gt;概念类图/领域模型</p></li><li><p>用例模型/用例描述——明确用例中的协作行为——&gt;顺序图、状态图、对象约束语言</p></li></ul><h3 id="用例图">1. 用例图</h3><h4 id="用例的定义">用例的定义</h4><p>在系统（或者子系统或者类）和外部对象的交互当中所执行的行为序列的描述，包括各种不同的序列和错误的序列，它们能够联合提供一种有价值的服务。</p><h4 id="用例图的基本元素">用例图的基本元素</h4><p>参与者、用例、关系、系统边界</p><ul><li>参与者（小人形）<ul><li>一个与正在开发的系统进行交互的用户或系统所扮演的角色</li><li>用例图中的一个参与者可以代表多个用户或系统、扮演多种角色</li></ul></li><li>用例（椭圆）</li><li>关系（不同的线和箭头及上面的补充文字）</li><li>系统边界（矩形）<ul><li>参与者总在系统边界外</li></ul></li></ul><h4 id="用例图的建立">用例图的建立</h4><ol type="1"><li>目标分析与解决方向的确定</li><li>寻找参与者</li><li>寻找用例</li><li>细化用例</li></ol><ul><li>如果用例的粒度不合适就需要进行细化和调整<ul><li>判断标准：用例描述了为应对一个业务事件，由一个用户发起，并在一个连续时间段内完成，可以增加业务价值的任务。</li></ul></li></ul><h4 id="常见错误">常见错误</h4><ul><li>不要把用例细化为单个操作<ul><li>例：不要将用户管理细化为增加、修改和删除三个更小的用例，因为它们要联合起来才能体现出业务价值。</li></ul></li><li>不要把同一个业务目标细化为不同用例<ul><li>例：特价策略制定和赠送策略制定。</li></ul></li><li>不要把没有业务价值的内容作为用例<ul><li>例：“登录”(应该描述为安全性质量需求)、“数据验证”(应该描述为数据需求)、“连接数据库”(属性软件内部实现而不是需求)等。</li></ul></li></ul><h3 id="概念类图">2. 概念类图</h3><p>概念类图又被称为领域模型。</p><p>类图是面向对象分析方法的核心，描述类和类之间的关系。</p><ul><li>和设计类图的不同：关注系统与外界的交互，而不是软件系统的内部构造机制</li><li>类型、方法、可见性等复杂的软件构造细节不会在概念类图中</li></ul><h4 id="概念类图的基本元素">概念类图的基本元素</h4><p>对象、类、链接、关联、继承</p><p>继承、组合、聚合、关联的图示：</p><pre><code class=" mermaid">classDiagram A &lt;|-- BC *-- DE o-- FG -- H</code></pre><h4 id="建立概念类图">建立概念类图</h4><p>先对每个用例文本描述，尤其是场景描述建立局部概念类图，再合并为整体概念类图。</p><ol type="1"><li>根据用例文本描述识别候选类<ul><li>软件系统与外界交互时可能设计的对象与类</li></ul></li><li>筛选候选类，确定概念类<ul><li>准则：依据系统需求；该类的对象实例的状态与行为是否完全必要</li><li>候选类向概念类的转化：<ul><li>需要维护状态、表现行为：概念类</li><li>需要维护状态，不需要表现行为：其他概念类的属性</li><li>不需要维护状态，需要表现行为：审视需求，转交行为</li><li>不需要维护状态、表现行为：剔除</li></ul></li></ul></li><li>识别关联</li><li>识别重要属性</li></ol><h3 id="顺序图">3. 顺序图</h3><p>也称交互图。</p><h4 id="消息种类">消息种类</h4><ul><li>同步消息：实线，实心三角箭头</li><li>异步消息：实线，&gt;</li><li>返回消息：虚线，&gt;</li></ul><h4 id="顺序图的建立">顺序图的建立</h4><ol type="1"><li>确定上下文环境</li><li>根据用例描述找到交互对象</li><li>按照用例描述中的流程顺序逐步添加信息</li></ol><h3 id="状态图">4. 状态图</h3><h4 id="概念">概念</h4><ul><li>状态：描述系统在特定时间行为的可视化状况的集合</li><li>状态转换：从一个状态到另一个状态</li><li>事件：导致系统表现一些可预测的行为</li><li>活动：作为状态转换的结果发生的过程</li></ul><h4 id="状态图的建立">状态图的建立</h4><ol type="1"><li>确立上下文环境</li><li>识别状态</li><li>建立状态转换</li><li>完善状态图</li></ol><h2 id="五需求文档化与验证">五、需求文档化与验证</h2><h3 id="用例文档">1. 用例文档</h3><p>在用户的角度以用例文本为主描述软件系统与外界的交互。</p><ul><li>基本职责是把问题域信息和需求传达给软件系统解决方案的设计者</li></ul><h4 id="用例文档结构示例">用例文档结构示例</h4><ul><li>文档的信息</li><li>用例图或用例列表</li><li>用例描述</li></ul><h3 id="软件需求规格说明文档">2. 软件需求规格说明文档</h3><p>在软件产品的角度以系统级需求列表的方式描述软件系统解决方案。</p><table><thead><tr class="header"><th>用例</th><th>系统规格</th></tr></thead><tbody><tr class="odd"><td>侧重于交互流程</td><td>侧重于独立需求</td></tr><tr class="even"><td>基于一次交互</td><td>基于一次交互中的软件系统处理细节</td></tr></tbody></table><h4 id="需求规格说明文档结构示例">需求规格说明文档结构示例</h4><ul><li>引言</li><li>总体描述</li><li>详细需求描述<ul><li>对外接口需求</li><li>功能需求</li><li>性能需求</li><li>约束</li><li>质量属性</li><li>其他需求</li></ul></li><li>附录</li><li>索引</li></ul><h3 id="文档化需求的注意事项">3. 文档化需求的注意事项</h3><h4 id="技术文档写作要点">技术文档写作要点</h4><ul><li>简洁</li><li>精确</li><li>易读<ul><li>有效使用引言、目录、索引等</li><li>使用系统化的方式组织内容信息<ul><li>使用相同的语句格式来组织相似、关联的信息</li><li>使用列表或表格来组织独立、并列的信息</li><li>使用编号来表达繁杂信息之间的关系，包括顺序、嵌套、层次关系</li></ul></li></ul></li><li>易修改<ul><li>独立性</li><li>ID</li><li>引用，不重复</li></ul></li></ul><h4 id="需求书写要点">需求书写要点</h4><ul><li>使用用户属于</li><li>可验证</li><li>可行性</li></ul><h4 id="需求规格说明文档书写要点">需求规格说明文档书写要点</h4><ul><li>充分利用标准文档模版，保持所有内容位置得当</li><li>保持文档内的需求集具有完备性和一致性</li><li>为需求划分优先级</li></ul><h3 id="验证需求文档">4. 验证需求文档</h3><p>方法：评审、开发系统测试用例、度量</p><h4 id="开发系统测试用例">开发系统测试用例</h4><ol type="1"><li>以需求为线索，开发测试用例套件</li><li>使用测试技术确定输入/输出数据，开发测试用例</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件工程与计算2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软工2-二-项目启动</title>
    <link href="/2023/04/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/"/>
    <url>/2023/04/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972/%E4%BA%8C-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>原神，启动！</p><span id="more"></span><h1 id="第二部分-项目启动">第二部分-项目启动</h1><h2 id="项目和项目管理">1. 项目和项目管理</h2><h3 id="项目的概念">项目的概念</h3><p>项目是具有下列特征的一系列活动和任务：</p><ul><li>具有一个明确的目标</li><li>有限定的开始和结束日期</li><li>有成本限制</li><li>消耗人力和非人力资源</li><li>多工种合作</li></ul><h3 id="项目管理的目标">项目管理的目标</h3><p>在限定时间内、一定成本内、要求的质量水平上，高效使用资源，获得用户认可。</p><h3 id="过程组与活动">过程组与活动</h3><p>过程组：</p><ol type="1"><li>项目启动</li><li>项目计划</li><li>项目执行</li><li>项目跟踪</li><li>项目收尾</li></ol><p>活动：计划制定、团队管理、成本控制、质量保障、度量、过程管理、进度跟踪与控制、风险管理、配置管理</p><h2 id="团队组织与管理">2. 团队组织与管理</h2><ul><li>一个协作良好的团队是任何项目成功的基础</li><li>软件项目尤其依赖于有效的团队组织和管理</li><li>软件开发是一个以人为主的活动，人力资源是软件项目最大的资产</li></ul><h3 id="团队的概念">团队的概念</h3><p>为了一致的目的、绩效标准、方法而共担责任并且技能互补的少数人。</p><ul><li>团队内部要有一个明确的结构</li></ul><h3 id="团队的结构">团队的结构</h3><ul><li>主程序员团队</li><li>民主团队</li><li>开放团队</li></ul><h3 id="团队建设">团队建设</h3><ol type="1"><li><p>建立团队章程</p></li><li><p>持续成功</p><p>项目阶段性成功/团队活动成功</p></li><li><p>和谐沟通</p></li><li><p>避免团队杀手</p></li></ol><ul><li>防范式管理</li><li>官僚主义</li><li>地理分散</li><li>时间分割</li><li>产品质量的降低</li><li>虚假的最后期限</li><li>小圈子控制</li></ul><h2 id="软件质量保障">3. 软件质量保障</h2><p>软件工程师需要对软件产品的质量负责。</p><p>人们通常会选用系统的某些质量要素进行量化处理，建立质量特征，这些特征被称为质量属性。</p><p>为了根据质量属性描述和评价系统的整体质量，人们从很多质量属性的定义中选择了一些能够相互配合、相互联系的特征集，它们被称为质量模型。</p><p>质量模型的因素</p><ul><li>功能性、可靠性、易用性、效率、可维护性、可移植性</li></ul><h3 id="质量保障">质量保障</h3><table><thead><tr class="header"><th>里程碑</th><th>质量保障活动</th></tr></thead><tbody><tr class="odd"><td>需求开发</td><td>需求评审、需求度量</td></tr><tr class="even"><td>体系结构</td><td>体系结构评审、集成测试</td></tr><tr class="odd"><td>详细设计</td><td>详细设计评审、设计度量、集成测试</td></tr><tr class="even"><td>实现</td><td>代码评审、代码度量、测试</td></tr><tr class="odd"><td>测试</td><td>测试、测试度量</td></tr></tbody></table><h3 id="评审">评审</h3><ol type="1"><li><p>在规划阶段(Planning)，制定审查计划，决定审查会议的次数，安排每次审查会议的时间、地点、参与人员、审查内容等等。</p></li><li><p>在总体部署阶段(Overview)，向所有参与审查会议的人员描述待审查材料的内容、审查的目标以及一些假设，并分发文档。</p></li><li><p>在准备阶段(Preparation)，审查人员各自独立执行检查任务。在检查的过程当中，他们可能会被要求使用检查清单、场景等检查方法。检查中发现的问题会被记录下来，以准备开会讨论或者提交给收集人员。</p></li><li><p>在审查会议阶段(InspectionMeeting)，通过会议讨论，识别、确认、分类发现的错误。</p></li><li><p>在返工阶段(Rework)，修改发现的缺陷。</p></li><li><p>在跟踪阶段(Follow-up)，要确认所有发现的问题都得到了解决，所有的错误都得到了修正。</p></li></ol><h3 id="质量度量">质量度量</h3><p>度量是软件产品在特点属性的量化测试程度。</p><h2 id="软件配置管理">4. 软件配置管理</h2><h3 id="配置管理的概念">配置管理的概念</h3><p>用技术的和管理的指导和监督方法，来标识和说明配置项的功能和物理特征，控制对这些特征的变更，记录和报告变更处理及其实现状态，并验证与规格需求的一致性。</p><p>配置项：</p><p>置于软件配置管理之下的软件配置的各种有关项目，包括各类文档、评审记录与文档、软件文档、源码及其可执行码、运行所需的系统软件和支持软件以及有关数据等。</p><h3 id="配置管理活动">配置管理活动</h3><ul><li>标识配置项</li><li>版本管理</li><li>变更控制</li><li>配置审计</li><li>状态报告</li><li>软件发布管理</li></ul><h3 id="分支管理常见策略">分支管理常见策略</h3><ul><li>主分支</li><li>开发分支</li><li>临时分支<ul><li>功能</li><li>预发布</li><li>修补bug</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件工程与计算2</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第十一章_并发控制</title>
    <link href="/2023/03/11/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/03/11/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第十一章-并发控制">第十一章 并发控制</h1><p>事务可以一个一个地串行执行，即每一刻都只有一个事务运行。</p><ul><li>在单处理器系统中，事务的并行执行实际上是这些并行事务的并行操作轮流交叉运行。</li><li>在多处理器系统中，可以实现真正多个事务的并行运行，称为同时并发方式。</li></ul><p>本章讨论的数据库并发控制以单处理器系统为基础。</p><h2 id="并发控制概述">11.1 并发控制概述</h2><p>事务是并发控制的基本单位。</p><p>数据库管理系统需要对并发操作进行正确调度，以保证事务的隔离性和一致性。</p><h3 id="并发操作带来的数据不一致性">并发操作带来的数据不一致性</h3><ul><li>丢失修改<ul><li>两个事务同时读入同一数据进行修改，导致其中一者的修改被丢失</li></ul></li><li>不可重复读<ul><li>一个事务读取数据后，另一个事务更新了数据，使得前一个事务再读取数据异常</li></ul></li><li>读“脏”数据（dirty read）<ul><li>一个事务修改数据，另一个事务读取了数据后，前一个事务被撤销</li></ul></li></ul><p>并发控制机制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务干扰，从而避免造成数据的不一致性。</p><p>并发控制的主要技术：</p><ul><li>封锁</li><li>时间戳</li><li>乐观控制法</li><li>多版本并发控制</li></ul><h2 id="封锁">11.2 封锁</h2><p>封锁是实现并发控制的一种非常重要的技术。封锁就是事务在操作某个数据对象前，先向系统发出请求对其加锁，避免其他事务干扰。</p><h3 id="基本的封锁类型">基本的封锁类型</h3><ul><li>排他锁（exclusive locks，又称X锁、写锁）<ul><li>事务T对数据对象A加上X锁后，只允许T读取和修改A，其他任何事务都不能对A加任何锁，直到T释放锁。</li><li>保证其他事务在T释放锁前不能再读取和修改A。</li></ul></li><li>共享锁（share locks，又称S锁、读锁）<ul><li>事务T对数据对象A加上S锁后，事务T可以读A但不能修改A，而其他事务也只能对A加S锁。</li><li>保证其他事务在T释放锁前不能修改A。</li></ul></li></ul><h3 id="封锁协议">封锁协议</h3><p>封锁协议是运用X锁和S锁的一些规则。</p><p>三级封锁协议的主要区别在于什么操作需要申请封锁，以及何时释放锁。</p><ul><li>封锁协议级别越高，一致性程度越高。</li></ul><h4 id="一级封锁协议">一级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放。</p><ul><li>不能保证可重复读和不读“脏”数据</li></ul><h4 id="二级封锁协议">二级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放；</p><p>事务T在读取数据R之前必须对其加S锁，读完即可释放S锁。</p><ul><li>不能保证可重复读</li></ul><h4 id="三级封锁协议">三级封锁协议</h4><p>事务T在修改数据R之前必须对其加X锁，直到事务结束才释放；</p><p>事务T在读取数据R之前必须对其加S锁，直到事务结束才释放。</p><h3 id="活锁和死锁">11.2.3 活锁和死锁</h3><h4 id="活锁">活锁</h4><p>事务由于一直被其他事务封锁而永远等待，这就是活锁。</p><p>避免活锁的简单办法是采用先来先服务的策略。</p><h4 id="死锁">死锁</h4><p>两个事务各自封锁了部分资源，又等待对方封锁的资源，这就形成了死锁。</p><p>解决死锁问题的方法：采取一定措施预防死锁；定期诊断系统中有无死锁，有则解除之。</p><h5 id="死锁的预防">死锁的预防</h5><ul><li>一次封锁法<ul><li>每个事务必须一次将所有要使用的数据全部加锁，否则就不能执行</li><li>可以有效防止死锁</li><li>缺点：<ul><li>一次加锁全部数据，扩大封锁范围，降低系统并发度</li><li>数据库数据不断变化，原本不要求封锁的数据可能也会变成封锁对象，很难事先确定每个事务要封锁的全部数据对象。为此只能进一步扩大封锁范围，降低并发度</li></ul></li></ul></li><li>顺序封锁法<ul><li>预先对数据对象规定一个封锁顺序</li><li>可以有效防止死锁</li><li>缺点：<ul><li>数据库系统中要封锁的数据对象太多，维护资源封锁顺序非常困难</li><li>事务的封锁请求可以随着事务的执行动态决定，很难事先确定，按顺序封锁</li></ul></li></ul></li></ul><h5 id="死锁的诊断和解除">死锁的诊断和解除</h5><p>一般使用超时法或事务等待图法。</p><ul><li>超时法<ul><li>一个事务的等待时间超过规定的时限，就认为发生了死锁</li><li>实现简单</li><li>缺点：<ul><li>容易误判死锁</li><li>时间若设置太长，死锁发生后不能及时发现</li></ul></li></ul></li><li>等待图法<ul><li>使用有向图表示的事务等待图动态地反映事务的等待情况。</li></ul></li></ul><p>解除死锁的方法：选择一个处理死锁代价最小的事务进行撤销，之后再加以恢复。</p><h2 id="并发调度的可串行性">11.3 并发调度的可串行性</h2><p>多个事务的并发调度是正确的，当且仅当其结果与按某一次序串行地执行这些事务的结果相同，这种调度策略称为可串行化调度。</p><p>可串行性是并发事务正确调度的准则。一个可串行化的并发调度才是正确的调度。</p><h3 id="可串行化调度的充分条件">可串行化调度的充分条件</h3><h4 id="冲突可串行化">冲突可串行化</h4><p>冲突操作是指不同的事务对同一个数据的读写操作和写写操作。</p><p>不同事务的冲突操作和同一事务的两个操作是不能交换的。</p><p>一个调度在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度。如果这另一个调度是串行的，则称原调度是冲突可串行化的调度。</p><ul><li><p>一个冲突可串行化的调度一定是可串行化的调度。</p><p>即，冲突可串行化是可串行化的充分条件。</p></li></ul><h4 id="两段锁协议">两段锁协议</h4><p>两段锁协议（简称2PL）是当前数据库管理系统普遍采用以实现并发调度可串行性的方法。</p><ul><li>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁，称为扩展阶段</li><li>在释放一个封锁后，事务不再申请和获得其他封锁，称为收缩阶段</li></ul><p>事务遵守两段锁协议是可串行化调度的充分条件。</p><h2 id="封锁的粒度">11.4 封锁的粒度</h2><p>封锁对象的大小称为封锁粒度（granularity）。</p><ul><li><p>封锁粒度和系统的并发度和并发控制的开销密切相关。</p></li><li><p>一个系统同时支持多种封锁粒度供不同的事务选择是比较理想的，称为多粒度封锁。</p></li></ul><h3 id="多粒度封锁">多粒度封锁</h3><p>多粒度树：根结点是整个数据库，表示最大的数据粒度，叶结点表示最小的数据粒度。</p><p><strong>多粒度封锁协议</strong>允许多粒度树中的每一个结点被独立地加锁。</p><ul><li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样的锁<ul><li>显式封锁：应事务要求直接加到数据对象上的锁</li><li>隐式封锁：未被独立加锁，因为其上级结点加锁而被加锁</li></ul></li><li>对某个对象加锁，先要检查自身是否有显式封锁与之冲突，再要检查所有上级结点是否赋于它隐式封锁，最后还要检查其下级结点是否有冲突的显式封锁，这样效率太低<ul><li>引入意向锁</li></ul></li></ul><h3 id="意向锁">意向锁</h3><p>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；即任一结点加锁时，须对它的上层结点加意向锁。</p><p>三种常见意向锁：</p><ul><li>意向共享锁（Intent Share Lock，IS锁）<ul><li>对一个结点加S锁，先对其上级结点加IS锁</li></ul></li><li>意向排他锁（Intent Exclusive Lock，IX锁）<ul><li>对一个结点加X锁，先对其上层结点加IX锁</li></ul></li><li>共享意向排他锁（Share Intent Exclusive Lock，SIX锁）<ul><li>一个数据对象先被加了S锁，后被加了IX锁</li></ul></li></ul><p>锁的强度偏序：X—SIX—S/IX—IS</p><ul><li><p>以强锁代替弱锁是安全的，反之则不然</p></li><li><p>申请时自上而下检查，释放时自下而上</p></li></ul><h2 id="其他并发控制机制">11.5 其他并发控制机制</h2><p>时间戳方法、乐观控制法和多版本并发控制等。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第十章_数据库恢复技术</title>
    <link href="/2023/03/10/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/03/10/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%8D%81%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第十章-数据库恢复技术">第十章 数据库恢复技术</h1><h2 id="事物的基本概念">10.1 事物的基本概念</h2><h3 id="事物">事物</h3><p>事物是用户定义的一个数据库操作序列，是一个不可分割的工作单位。</p><p>在SQL中，定义事务的语句一般有三条：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>事务以<code>BEGIN TRANSACTION</code>开始，以<code>COMMIT</code>或<code>ROLLBACK</code>结束。</p><ul><li><code>COMMIT</code>表示提交</li><li><code>ROLLBACK</code>表示回滚，系统将该事务已经完成的操作全部撤销</li></ul><p>事务是恢复和并发控制的基本单位。</p><h3 id="事务的acid特性">事务的ACID特性</h3><ul><li>原子性（Atomicity）<ul><li>事务是数据库的逻辑工作单位，包括的操作要么都做，要么不做</li></ul></li><li>一致性（Consistency）<ul><li>事务执行的结果必须是数据库从一个一致性状态到另一个一致性状态</li></ul></li><li>隔离性（Isolation）<ul><li>一个事务的执行不能被其他事务干扰</li></ul></li><li>持续性（Durability）<ul><li>也称永久性，一个事务一旦提交，它对数据库中数据的改变就是永久的</li></ul></li></ul><p>保证事务ACID特性是事务管理的重要任务，可能破坏ACID的因素有：</p><ul><li>多个事务并行运行时，不同事务的操作交叉执行</li><li>事务在运行过程中被强行停止</li></ul><h2 id="数据库恢复概述">10.2 数据库恢复概述</h2><p>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态的功能。</p><ul><li>恢复子系统是数据库管理系统的一个重要组成部分</li></ul><h3 id="故障的种类">10.2.1 故障的种类</h3><ul><li>事务内部的故障<ul><li>非预期的，不能由应用程序处理的故障</li><li>恢复程序需要强行回滚该事务，这类恢复操作称为事务撤销（UNDO）</li></ul></li><li>系统故障<ul><li>又称软故障，指造成系统停止运转的任何事件，使得系统要重新启动</li><li>恢复子系统除需要撤销所有未完成的事务，还需要重做（REDO）所有已提交事务</li></ul></li><li>介质故障<ul><li>又称硬故障，指外存故障，如磁盘损坏、磁头碰撞等</li></ul></li><li>计算机病毒</li></ul><p>各类故障对数据库的影响有两种可能性：数据库本身被破坏；数据可能不正确。</p><p>恢复的基本原理：冗余</p><ul><li>数据库任何一部分被破坏或不正确的数据可以根据存储在系统别处的冗余数据来重建</li></ul><h3 id="恢复的实现技术">10.2.2 恢复的实现技术</h3><p>建立冗余数据最常用的技术是数据转储和登记日志文件。通常一个数据库系统会同时使用这两种方法。</p><h4 id="数据转储">数据转储</h4><p>数据转储是数据库恢复中采用的基本技术。数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存。这些备用的数据称为<strong>后备副本</strong>或后援副本。</p><ul><li>重装后备副本只能将数据库恢复到转储时的状态，故必须重新运行转储后的所有更新</li><li>转储十分耗费时间和资源，不能频繁进行</li></ul><p>转储可分为静态转储和动态转储：</p><ul><li>静态转储是在系统中无运行事务时进行的转储操作。<ul><li>简单，保证数据库的一致性，但会降低数据库的可用性</li></ul></li><li>动态转储是指转储期间允许对数据库进行存取或修改<ul><li>必须登记转储期间各事务对数据库的修改活动，建立日志文件</li></ul></li></ul><p>转储又可分为海量转储和增量转储：</p><ul><li>海量转储，一次转储全部数据库</li><li>增量转储，每次只转储上次转储后更新过的数据</li></ul><h4 id="日志文件">日志文件</h4><p>日志文件是用来记录事务对数据库的更新操作的文件，主要有两种格式：</p><ul><li>以记录为单位的日志文件</li><li>以数据块为单位的日志文件</li></ul><p>以记录为单位的日志文件需要登记的内容：</p><ul><li>各个事务的开始、结束标记</li><li>各个事务的所有更新操作</li></ul><p>这里每个事务的开始、结束标记和每个更新操作均作为日志文件的一个日志记录，包括：</p><ul><li>事务标识（表明是哪个事务）</li><li>操作的类型（更新、插入和删除）</li><li>操作对象</li><li>更新前数据的旧值（对于插入操作为空）</li><li>更新后数据的新值（对于删除操作为空）</li></ul><p>以数据块为单位的日志文件需要登记事务标识和被更新的数据块，将更新前和更新后的整个块放入日志文件中。</p><h5 id="日志文件的作用">日志文件的作用</h5><ul><li>事务故障恢复和系统故障恢复必须用日志文件</li><li>在动态转储方式中必须建立日志文件，结合后备副本和日志文件恢复数据库</li><li>在静态转储方式中也可以建立日志文件帮助恢复，不必重新运行已完成的事务</li></ul><h5 id="登记日志文件">登记日志文件</h5><p>为保证数据库可恢复，登记日志文件必须遵循两条原则：</p><ul><li>登记的次序严格按并发事务处理的时间顺序。</li><li>必须先写日志文件，后写数据库</li></ul><h3 id="恢复策略">10.2.3 恢复策略</h3><h4 id="事务故障的恢复">1. 事务故障的恢复</h4><p>事务故障是指事务在运行至正常终点前被终止，这时恢复子系统应利用日志文件做撤销：</p><ol type="1"><li>反向扫描日志文件，查找该事务的更新操作</li><li>对该事务的更新操作进行逆操作</li><li>继续扫描处理直到该事务的开始标记</li></ol><h4 id="系统故障的恢复">2. 系统故障的恢复</h4><p>系统故障的恢复是由系统在重新启动时自动完成的。</p><ol type="1"><li>正向扫描日志文件，找出故障发生前已经提交的事务，将其事务标记记入重做队列，同时找出故障发生时尚未完成的事务，记入撤销队列</li><li>对撤销队列中的各个事务进行撤销</li><li>对重做队列中的各个事务进行重做</li></ol><h4 id="介质故障的恢复">3. 介质故障的恢复</h4><p>恢复方法时重装数据库，重做已完成的事务。</p><ol type="1"><li>装入最新的数据库后备副本</li><li>装入相应的日志文件副本，重做已完成的事务</li></ol><h3 id="具有检查点的恢复技术">10.2.4 具有检查点的恢复技术</h3><p>在日志中增加一类新的记录——检查点记录，增加一个重新开始文件，让恢复子系统在登录日志期间动态维护日志。</p><p>检查点记录的内容：</p><ul><li>建立检查点时刻所有在执行的事务清单</li><li>这些进程是最近一个日志记录的地址</li></ul><p>动态维护日志的方法是：周期性地执行建立检查点、保存数据库状态的操作</p><ol type="1"><li>将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上。</li><li>在日志文件中写入一个检查点记录。</li><li>将当前数据缓冲区的所有数据记录写入磁盘的数据库中。</li><li>把检查点记录在日志文件中的地址写入一个重新开始文件</li></ol><p>使用检查点方法可以改善恢复效率。</p><p>系统使用检查点方法进行恢复的步骤：</p><ol type="1"><li><p>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。</p></li><li><p>由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。这里建立两个事务队列:</p><ul><li>UNDO-LIST：需要执行UNDO操作的事务集合；</li><li>REDO- LIST：需要执行REDO操作的事务集合。</li></ul></li><li><p>从检查点开始正向扫描日志文件。</p><ul><li>如有新开始的事务，把事务暂时放入UNDO-LIST队列；</li><li>如有提交的事务，把事务从UNDO-LIST队列移到REDO-LIST队列；</li></ul><p>直到日志文件结束。</p></li><li><p>对UNDO-LIST中的每个事务执行UNDO操作，对REDO-LIST中的每个事务执行REDO 操作。</p></li></ol><h3 id="数据库镜像">10.2.5 数据库镜像</h3><p>数据库镜像，即数据库管理系统根据数据管理员要求，自动把整个数据库或其中关键数据复制到另一个磁盘上。每当主数据库更新，数据库管理系统自动把更新后的数据复制过去，由数据库管理系统自动保证镜像数据和主数据库的一致性。</p><p>实际应用中，用户往往只选择对关键数据和日志文件进行镜像。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第八章_数据库编程</title>
    <link href="/2023/03/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AB%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/03/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AB%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第八章-数据库编程">第八章 数据库编程</h1><p>SQL编程技术可以有效克服SQL语言实现复杂应用方面的不足，提高应用系统和数据库管理系统间的互操作性。</p><p>在应用系统中使用SQL编程来访问和管理数据库中数据的方式主要有：嵌入式SQL、过程化SQL、存储过程和自定义函数、开放数据库互连、OLEDB、JDBC（Java数据库连接）等。</p><h2 id="嵌入式sql">8.1 嵌入式SQL</h2><p>将SQL语句嵌入程序设计语言中，一般采取预编译方法实现。</p><h3 id="嵌入式sql语句和主语言之间的通信">8.1.1嵌入式SQL语句和主语言之间的通信</h3><p>数据库工作单元与源程序工作单元之间的通信主要包括</p><ul><li>向主语言传递SQL语句的执行状态信息，使主语言能够据此信息控制程序流程，主要用SQL通信区（SQLCommunication Area，SQLCA）实现</li><li>主语言向SQL语句提供参数，主要用主变量实现</li><li>将SQL语句查询数据库的结果交由主语言处理，主要用主变量和游标实现</li></ul><h4 id="sql通信区">SQL通信区</h4><p>SQL语句执行后，系统反馈给应用的信息将被送到SQL通信区中。</p><ul><li>SQL通信区中变量SQLCODE用以存储每次执行SQL后返回的代码</li><li>应用每次执行完一条SQL语句后都应该测试SQLCODE的值</li></ul><h4 id="主变量">主变量</h4><p>SQL中使用的主语言程序变量简称为<strong>主变量</strong>。</p><ul><li>分为输入主变量和输出主变量<ul><li>输入主变量由应用程序赋值，SQL语句引用</li><li>输出主变量由SQL语句赋值，返回给应用程序</li></ul></li><li>一个主变量可以附带一个任选的指示变量<ul><li>指示变量是用以指示主变量的值或条件的整型变量</li></ul></li></ul><h4 id="游标">游标</h4><p>SQL面向集合，一条SQL语句可以产生或处理多条记录；主语言面向记录，一次只能处理一条记录，因此只用主变量不能完全满足SQL和主语言的协同。</p><p>游标是系统为用户开设的一个数据缓冲区，存放SQL的执行结果，每个游标区都有其名字。</p><ul><li>用户通过游标逐一获取记录并赋给主变量，交由主语言处理</li></ul><p>不用游标的SQL语句：</p><p>说明性语句、数据定义语句、数据控制语句、查询结果为单记录的选择语句、非CURRENT形式的增删改语句</p><p>使用游标的SQL语句：</p><p>多条记录的选择语句、CURRENT形式的UPDATE和DELETE语句。</p><h3 id="动态sql">8.1.2 动态SQL</h3><p>上述的嵌入式SQL语句中使用的主变量、查询目标列、条件等都是固定的，是静态SQL语句。但有些应用可能要到执行时才能够确定要提交的SQL语句，这就需要动态SQL语句。</p><h4 id="sql语句主变量">SQL语句主变量</h4><p>程序主变量包含SQL语句的内容，这样的变量称为SQL语句主变量。</p><h4 id="动态参数">动态参数</h4><p>动态参数通过PREPARE语句准备主变量和执行语句绑定数据或主变量来完成。</p><h2 id="过程化sql">8.2 过程化SQL</h2><p>过程化SQL是对SQL的扩展，使其增加了过程化语句功能。</p><p>过程化SQL的基本结构是块。所有的过程化SQL程序都是由块组成。这些块之间可以相互嵌套，每个块完成一个逻辑操作。</p><p>基本结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">定义部分：<span class="hljs-keyword">DECLARE</span> 变量、常量、游标、异常等<br><br>执行部分：<span class="hljs-keyword">BEGIN</span> <span class="hljs-keyword">SQL</span>语句、过程化<span class="hljs-keyword">SQL</span>的流程控制语句<br><span class="hljs-keyword">EXCEPTION</span> 异常处理<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>流程控制：IF-THEN-END IF、IF-THEN-ELSE-END IF</p><p>循环控制：LOOP-END LOOP、WHILE-LOOP-END LOOP、FOR-LOOP-END LOOP</p><p>错误处理：过程化SQL提供了完善的异常处理机制</p><h4 id="存储过程与函数">存储过程与函数</h4><p>过程化SQL块主要有两种类型：命名块和匿名块，上述均为匿名块，每次执行都要编译，不能存储到数据库中，也不能在其他过程化SQL块中调用。过程和函数是命名块，被编译后保存在数据库中，称为持久性存储模块，可以被反复调用。</p><p>存储过程是由过程化SQL语句编写的过程，经编译和优化后存储在数据库服务器中。</p><p>函数，也称自定义函数，是用户自己使用过程化SQL设计定义的，和存储过程不同的是必须指定返回的类型。</p><h2 id="odbc编程">8.3 ODBC编程</h2><p>提出和产生ODBC的原因是存在不同的数据库系统。</p><p>ODBC是微软公司开放体系的一部分，建立了一组访问数据库的应用程序编程接口规范（ApplicationProgramming Interface，API）。</p><ul><li>ODBC一方面规范应用开发，另一方面规范关系数据库管理系统应用接口</li></ul><p>ODBC由四部分组成：用户应用程序、ODBC驱动程序管理器、数据库驱动程序、数据源</p><h3 id="用户应用程序">用户应用程序</h3><p>使用ODBC来开发应用系统的程序简称为ODBC应用程序，包括内容：</p><ol type="1"><li>请求连接数据库</li><li>向数据源发送SQL语句</li><li>为SQL语句执行分配空间，定义所读取的数据格式</li><li>获取数据库操作结果或处理错误</li><li>进行数据处理并向用户提交处理结果</li><li>请求事务的提交和回滚操作</li><li>断开与数据源的连接</li></ol><h3 id="odbc驱动程序管理器">ODBC驱动程序管理器</h3><p>驱动程序管理器用来管理各种驱动程序。</p><p>ODBC驱动程序管理器管理应用程序和驱动程序之间的通信，主要功能包括：</p><ul><li><p>装载ODBC驱动程序</p></li><li><p>选择和连接正确的驱动程序</p></li><li><p>管理数据源（建立、配置和删除）</p></li><li><p>检查ODBC调用参数的合法性</p></li><li><p>记录ODBC函数的调用</p></li><li><p>当应用层需要时，返回驱动程序的有关信息</p></li></ul><h3 id="数据库驱动程序">数据库驱动程序</h3><p>ODBC通过数据库驱动程序来提供应用系统和数据库平台的独立性。</p><p>ODBC应用程序的操作通过驱动程序管理器提交给某个驱动程序，调用驱动程序支持的函数来存取数据库。</p><p>单束与多束：</p><ul><li>单束：数据源和应用程序在同一台机器上，驱动程序直接完成对数据文件的输入/输出操作，驱动程序相当于数据管理器</li><li>多束：支持网络环境下数据访问，驱动程序完成数据库访问请求的提交和结果集接受</li></ul><h3 id="odbc数据源管理">ODBC数据源管理</h3><p>数据源时最终用户需要访问的数据，包含了数据库位置和数据库类型等信息，是一种数据连接的抽象。</p><p>ODBC给每个被访问的数据源指定唯一的数据源名，映射到所有必要的、用来存取数据的低层软件。</p><p>在连接中，用数据源名来代表用户名、服务器名、所连接的数据库名等。最终用户无须知道数据库管理系统或其他数据管理软件、网络以及有关ODBC驱动程序的细节，数据源对最终用户是透明的。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第七章_数据库设计</title>
    <link href="/2023/03/07/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/03/07/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第七章-数据库设计">第七章 数据库设计</h1><h2 id="概述">7.1 概述</h2><p>数据库设计是指对于一个给定的应用环境，构造(设计)优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</p><ul><li><p>信息管理要求：在数据库中应该存储和管理哪些数据对象。</p></li><li><p>数据操作要求：对数据对象需要进行哪些操作，如查询、增、删、改、统计等操作。</p></li></ul><p>数据库设计的目标是为用户和各种应用系统提供一个信息基础设施和高效率的运行环境。</p><p>高效率的运行环境：</p><ul><li>数据库数据的存取效率高</li><li>数据库存储空间的利用率高</li><li>数据库系统运行管理的效率高</li></ul><h3 id="数据库设计的特点">7.1.1 数据库设计的特点</h3><h4 id="数据库建设的基本规律">数据库建设的基本规律</h4><p>三分技术、七分管理、十二分基础数据</p><ul><li><p>管理：数据库建设项目管理、企业业务管理</p></li><li><p>基础数据：数据的收集、整理、组织和不断更新</p></li></ul><p>结构（数据）设计和行为（处理）设计相结合</p><ul><li>将数据库结构设计和数据处理设计密切结合</li><li>结构和行为分离的设计：<ul><li>传统软件工程：重行为设计</li><li>早期数据库设计：重结构设计</li></ul></li></ul><h3 id="数据库设计方法">7.1.2 数据库设计方法</h3><p>大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。</p><p>它要求多方面的知识和技术。主要包括：</p><ul><li><p>计算机的基础知识</p></li><li><p>软件工程的原理和方法</p></li><li><p>程序设计的方法和技巧</p></li><li><p>数据库的基本知识</p></li><li><p>数据库设计技术</p></li><li><p>应用领域的知识</p></li></ul><p>数据库设计方法：</p><ul><li>手工试凑法</li><li>规范设计法<ul><li>新奥尔良方法</li><li>基于E-R模型的数据库设计方法</li><li>3NF的设计方法</li><li>面向对象的数据库设计方法</li><li>统一建模语言（UML）方法</li></ul></li></ul><h3 id="数据库设计的基本步骤">7.1.3 数据库设计的基本步骤</h3><p>数据库设计的6个阶段：</p><ul><li>需求分析</li><li>概念结构设计：概念模型</li><li>逻辑结构设计：数据模型</li><li>物理结构设计</li><li>数据库实施</li><li>数据库运行和维护</li></ul><p>需求分析和概念设计独立于任何数据库管理系统；</p><p>逻辑设计和物理设计与选用的数据库管理系统密切相关。</p><p>参加数据库设计的人员</p><ul><li>系统分析人员和数据库设计人员<ul><li>自始至终参与数据库设计，其水平决定了数据库系统的 质量</li></ul></li><li>数据库管理员和用户代表<ul><li>主要参加需求分析与数据库的运行和维护</li></ul></li><li>应用开发人员<ul><li>包括程序员和操作员</li><li>在实施阶段参与进来，分别负责编制程序和准备软硬件 环境</li></ul></li></ul><h3 id="数据库设计过程中的各级模式">7.1.4数据库设计过程中的各级模式</h3><ul><li>需求分析阶段：综合分析应用要求</li><li>概念结构设计阶段：概念模式</li><li>逻辑结构设计阶段：逻辑模式与面向应用的外模式</li><li>物理结构设计阶段：内模式</li></ul><h2 id="需求分析">7.2 需求分析</h2><h4 id="数据字典">数据字典</h4><p>数据字典是关于数据库中数据的描述，即元数据，而非数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善的。它在数据库设计中占有重要地位。</p><p>数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容。</p><ul><li>数据项：不可再分的数据单位</li><li>数据结构：由若干数据项组成，反映了数据之间的组合关系</li><li>数据流：数据结构在系统内传输的路径</li><li>数据存储：数据结构停留或保存的地方</li><li>处理过程：一般用判定表或判定树来描述</li></ul><p>需求分析阶段收集到的基础数据是下一步进行概念设计的基础。</p><h2 id="概念设计">7.3 概念设计</h2><p>将需求分析得到的用户需求抽象为信息结构的过程就是概念结构设计。</p><h3 id="概念结构设计">概念结构设计</h3><h4 id="实体与属性的划分">实体与属性的划分</h4><p>现实世界事物能作为属性的尽量作为属性对待以简化E-R图。</p><ul><li>作为属性，不能再具有需要描述的物质</li><li>属性不能与其他实体具有联系</li></ul><p>方法：自顶向下地进行需求分析，自底向上地设计概念结构</p><ul><li>首先设计各子系统E-R图，再进行集成、重构</li><li>各子系统E-R图的冲突：<ul><li>属性冲突：属性域、取值单位冲突</li><li>命名冲突：同名异义，异名同义</li><li>结构冲突</li></ul></li></ul><h3 id="e-r模型">E-R模型</h3><p>用实体-联系（E-R）图来描述现实世界的概念模型。</p><p>E-R图提供了表示实体型、属性和联系的方法。</p><ul><li>实体型用矩形表示，矩形内写明实体名</li><li>属性用椭圆形表示，用无向边将其与相应的实体型连接</li><li>联系用菱形表示，菱形内写明联系名，用无向边分别与有关实体型连接，同时在边旁标上联系的类型（1:1、1:n或m:n）</li></ul><p>E-R图的绘制：</p><p>先绘制实体属性图、实体联系图，再进行综合。</p><h4 id="e-r扩展">E-R扩展</h4><h5 id="isa联系">ISA联系</h5><p>某些实体型是某个实体型的子类型，这种父类-子类联系称为ISA联系。</p><p>ISA联系描述了实体型中实体的一种分类方法：</p><ul><li>分类属性<ul><li>使用分类属性的值把父实体型中的实体分派到子实体型中</li></ul></li><li>不相交约束和可重叠约束<ul><li>父类中的一个实体是否能同时属于多个子类中的实体集</li></ul></li><li>完备性约束<ul><li>父类中的一个实体是否必须是某一个子类中的实体<ul><li>是，称为完全特化，双线连接，否则为部分特化，单线连接</li></ul></li></ul></li></ul><h5 id="基数约束">基数约束</h5><p>基数约束是对实体之间一对一、一对多和多对多的细化。</p><p>约束使用一个数对min..max表示</p><ul><li>min = 1的约束为强制参与约束；min = 0的约束为非强制参与约束。</li></ul><h5 id="part-of联系">Part-of联系</h5><p>部分联系，表明某个实体型是另外一个实体型的一部分。</p><ul><li>非独占联系：整体被破坏，部分实体可以存在，用非强制参与联系表示<ul><li>称该部分实体为强实体型</li></ul></li><li>独占联系：整体被破坏，部分实体不能存在<ul><li>称该部分实体为弱实体型，用双矩形表示，用双菱形表示识别联系</li></ul></li></ul><h3 id="uml">UML</h3><p>暂略</p><h2 id="逻辑结构设计">7.4 逻辑结构设计</h2><p>逻辑结构设计的任务就是把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。</p><h3 id="e-r图向关系模型的转换">7.4.1 E-R图向关系模型的转换</h3><p>一般原则：</p><ul><li><p>一个实体型转换为一个关系模式，关系的属性和码就是实体的属性和码。</p></li><li><p>对于实体间的联系：</p><ul><li>1:1联系可以转换为一个独立的关系模式，也可以和任一端的关系模式合并</li><li>1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并</li><li>m:n联系可以转换为一个关系模式，与该联系相连的各实体的码以及联系本身的属性均转换成关系的属性，各实体的码组成关系的码或其一部分</li><li>3个及以上实体间的一个多元联系可以转换为一个关系模式</li><li>具有相同码的关系模式可以合并</li></ul></li></ul><h3 id="数据模型的优化">7.4.2 数据模型的优化</h3><p>数据库逻辑设计的结果不是唯一的。</p><p>规范化理论指导的优化方法：</p><ol type="1"><li>确定数据依赖</li><li>对各个关系模式之间的数据依赖进行极小化处理，消除冗余联系</li><li>按照数据依赖的理论对关系模式逐一进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式</li><li>根据需求分析阶段得到的处理要求分析对于这样的应用环境这些模式是否合适，是否要对某些模式进行合并或分解<ul><li>并不是规范化程度越高的关系就越优</li></ul></li><li>对关系模式进行必要分解<ul><li>水平分解：把关系的元组分为若干子集合，定义每个子集合为一个子关系</li><li>垂直分解：把关系模式的属性分解为若干子集合，形成若干子关系模式</li></ul></li></ol><h3 id="设计用户子模式">7.4.3 设计用户子模式</h3><ul><li>使用更符合用户习惯的别名</li><li>可以对不同级别的用户定义不同的视图</li><li>简化用户对系统的使用</li></ul><h2 id="物理结构设计">7.5 物理结构设计</h2><p>数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。</p><p>为一个给定的逻辑模型选取最适合应用要求物理结构的过程，就是数据库的物理设计。其内容主要包括为关系模式选择存取方法，以及设计关系、索引等数据库文件的物理存储结构。</p><p>物理设计一般分为两步：</p><ol type="1"><li>确定数据库物理结构，在关系数据库中主要指存取方法和存储结构</li><li>对物理结构进行评价，评价的重点是时间和空间效率</li></ol><h3 id="关系模式存取方法">7.5.1 关系模式存取方法</h3><p>常用的存取方法为索引方法和聚簇方法。</p><ul><li>B+树索引存取方法</li><li>hash索引存取方法</li><li>聚簇存取方法<ul><li>为了提高某个或某些属性的查询速度，把这个或这些属性上具有相同值的元组集中存放在连续的物理块中称为聚簇，该属性或属性组称为聚簇码</li></ul></li></ul><h3 id="确定数据库的存储结构">7.5.2 确定数据库的存储结构</h3><p>确定数据库物理结构主要指确定数据的存放位置和存储结构，需要综合考虑存取时间、存取空间利用率和维护代价三方面因素。</p><h2 id="数据库的实施和维护">7.6 数据库的实施和维护</h2><h3 id="数据的载入和应用程序的调试">7.6.1数据的载入和应用程序的调试</h3><p>数据库实施阶段包括两项重要工作：数据的载入、应用程序的编码与调试</p><ul><li>组织数据入库是数据库实施阶段最主要的工作。<ul><li>数据装载办法：人工、计算机辅助数据入库</li></ul></li><li>数据库应用程序的设计应该与数据库设计同时进行</li></ul><h3 id="数据库的试运行">7.6.2 数据库的试运行</h3><ul><li>先输入小批量数据调试，合格后再输入大批量数据，逐步完成运行评价</li><li>做好数据库转储和恢复工作</li></ul><h3 id="数据库的运行和维护">7.6.3 数据库的运行和维护</h3><ul><li>数据库的转储和恢复</li><li>数据库的安全性、完整性控制</li><li>数据库性能的监督、分析和改造</li><li>数据库的重组织和重构造</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第六章_关系数据理论</title>
    <link href="/2023/03/06/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
    <url>/2023/03/06/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第六章-关系数据理论">第六章 关系数据理论</h1><h2 id="关系模式与范式">6.1 关系模式与范式</h2><h3 id="数据依赖">数据依赖</h3><p>数据依赖是一个关系内部属性和属性之间的一种约束关系，这种约束关系是通过属性间值的相等与否体现出来的数据间相关联系，是数据内在的性质，语义的体现。</p><p>最重要的数据依赖：</p><ul><li>函数依赖（Functional Dependency，FD）</li><li>多值依赖（Multi-Valued Dependency，MVD）</li></ul><h3 id="关系模式">关系模式</h3><p>在第2章中的五元组关系模式：R(U,D,DOM,F)</p><ul><li>R为符号化的元组语义</li><li>U为一组属性</li><li>D为属性组U的属性所来自的域</li><li>DOM为属性到域的映射</li><li>F为U上的一组数据依赖</li></ul><p>由于D、DOM与模式设计关系不大，本章中把关系模式看作三元组R&lt;U,F&gt;，当且仅当U上的一个关系r满足F时，r称为关系模式R&lt;U,F&gt;的一个关系。</p><h4 id="第一范式1nf">第一范式（1NF）</h4><p>每一个分量都是不可分的数据项的关系模式。</p><p>1NF的问题：</p><p>例：U={Sno,Sdept,Mname,Cno,Grade} //学号、系、系主任名、课程号、成绩</p><ul><li><p>数据冗余</p><p>每个系的系主任名重复出现</p></li><li><p>更新异常</p><p>数据冗余使得更新数据库的代价较大</p></li><li><p>插入异常</p><p>无学生的系无法存入系和系主任的信息</p></li><li><p>删除异常</p><p>学生全部毕业，则系和系主任信息也被删除</p></li></ul><p>改进：分成三个关系模式：</p><ul><li><p>S(Sno,Sdept,Sno-&gt;Sdept)</p></li><li><p>SC(Sno,Cno,Grade,(Sno,Cno)-&gt;Grade)</p></li><li><p>DEPT(Sdept,Mname,Sdept-&gt;Mname)</p></li></ul><h2 id="规范化">6.2 规范化</h2><h3 id="函数依赖">6.2.1 函数依赖</h3><p>定义较为抽象，总结为：</p><ul><li>关系R中两个属性组X和Y，对于Y的任一取值有唯一X确定它，则Y函数依赖于X<ul><li>记为X-&gt;Y</li><li>Y包含于X，此时为平凡的函数依赖</li></ul></li><li>不存在X的真子集能函数确定Y，则Y完全函数依赖于X，否则为部分函数依赖<ul><li>完全函数依赖在箭头上写F，部分写P</li></ul></li><li>Z平凡函数依赖于Y，Y平凡函数依赖于X，则Z传递函数依赖于X</li></ul><p>以下为定义：</p><p>设R(U)是属性集U上的关系模式，X和Y是U的子集，若对R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则X函数确定Y或Y函数依赖于X，记作X-&gt;Y。</p><p>函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。</p><ul><li>X-&gt;Y，Y不包含于X，则称X-&gt;Y为非平凡的函数依赖，一般都讨论这样的函数依赖</li><li>X-&gt;Y，Y包含于X，则称X-&gt;Y为平凡的函数依赖，它对任意关系模式都必然成立</li><li>X-&gt;Y，X称为这个函数依赖的决定属性组，称为决定因素</li><li>X-&gt;Y，Y-&gt;X，记作X&lt;--&gt;Y</li></ul><p>在R(U)中，如果X-&gt;Y，并且对于X的任意真子集X'，都有X'不函数确定Y，则称Y对X完全函数依赖，记作X-&gt;^FY，</p><p>若X-&gt;Y，但Y不对X完全函数依赖，则称Y对X部分函数依赖，记作X-&gt;^PY</p><p>在R(U)中，如果X-&gt;Y不平凡，Y-&gt;Z不平凡，则称Z对X传递函数依赖，记为X-&gt;^{传递}Z</p><ul><li>如果X-&gt;Y平凡，此处为直接函数依赖</li></ul><h3 id="码">6.2.2 码</h3><p>设K是R&lt;U,F&gt;中的属性或属性组合，若U完全函数依赖于K，则K为R的候选码。</p><ul><li>若U部分函数依赖于K，则K称为超码。候选码是最小的超码。</li></ul><p>若候选码多于一个，则选定其中的一个为主码。</p><ul><li><p>包含在任何一个候选码中的属性称为主属性，反之为非主属性或非码属性。</p></li><li><p>整个属性组是码，称为全码</p></li></ul><p>关系模式R中属性或属性组X并非R的码，但是另一个关系模式的码，称X为R的外码。</p><h3 id="范式">6.2.3 范式</h3><p>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</p><p>高级范式真包含于低级范式，从高到低有5NF、4NF、BCNF、3NF、2NF、1NF。</p><p>一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程称为规范化。</p><p>定义抽象，小结：</p><ul><li>1NF：候选码能函数确定每个非主属性</li><li>2NF：候选码能完全函数确定每个非主属性</li><li>3NF：存在码能直接（而非传递）完全函数确定每个非主属性</li><li>BCNF：每个码都能函数确定任意非主属性</li></ul><h4 id="nf">2NF</h4><p>若R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R属于2NF。</p><h4 id="nf-1">3NF</h4><p>若R属于1NF，且每一个非主属性既不传递依赖于码，也不部分依赖于码，则R属于3NF。</p><h4 id="bcnf">BCNF</h4><p>关系模式R中，若每一个决定因素都包含码，则R属于BCNF。</p><ul><li>所有非主属性对每一个码都是完全函数依赖</li><li>所有主属性对每一个不包含它的码也是完全函数依赖</li><li>没有任何属性完全依赖于非码的任何一组属性</li></ul><h4 id="多值依赖">多值依赖</h4><p>设R(U)是属性集U上的一个关系模式，X，Y，Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X-&gt;-&gt;Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。</p><p>性质：</p><ul><li>对称性：X-&gt;-&gt;Y， 则X-&gt;-&gt;Z，其中Z=U-X-Y。</li><li>传递性：X-&gt;-&gt;Y，Y-&gt;-&gt;Z，则X-&gt;-&gt;Z-Y</li><li>函数依赖是多值依赖的特殊情况</li><li>若X-&gt;-&gt;Y，X-&gt;-&gt;Z，则X-&gt;-&gt;YZ，X-&gt;-&gt;Y交Z，X-&gt;-&gt;Y-Z，X-&gt;-&gt;Z-Y</li></ul><p>特点：</p><ul><li><p>多值依赖的有效性与属性集的范围有关</p></li><li><p>若函数依赖X-&gt;-&gt;Y在R(U)上成立，则对于任何Y‘包含于Y，均有X-&gt;-&gt;Y'成立。而多值依赖X-&gt;-&gt;Y若在R(U)上成立，却不能断言对于任何Y'包含于Y有X-&gt;-&gt;Y'成立。</p></li></ul><h4 id="nf-2">4NF</h4><p>限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</p><h3 id="规范化小结">6.2.4 规范化小结</h3><p>规范化的基本思想是逐步消除数据依赖的不合适部分，实质上是概念的单一化。</p><p>关系模式的规范化过程是通过对关系模式的分解来实现的。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第五章_数据库完整性</title>
    <link href="/2023/03/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    <url>/2023/03/05/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第五章-数据库完整性">第五章 数据库完整性</h1><p>数据库的完整性是指数据的正确性和相容性。</p><ul><li>数据的正确性是指数据是复合现实世界语义，反映当前实际情况的</li><li>数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的</li></ul><p>数据库管理系统为维护数据库完整性而实现的功能：</p><ul><li>提供定义完整性约束条件的机制</li><li>提供完整性检查的方法</li><li>进行违约处理</li></ul><p>关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能够为所有用户和应用提供一致的数据库完整性。</p><h2 id="实体完整性">5.1 实体完整性</h2><p>关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。</p><ul><li>对单属性构成的码，可以在列级定义，也可以在表级定义<ul><li>Sno CHAR(9) PRIMARY KEY</li><li>PRIMARY KEY (Sno)</li></ul></li><li>对多属性构成的码，只能在表级定义<ul><li>PRIMARY KEY(Sno, Cno)</li></ul></li></ul><p>实体完整性检查和违约处理</p><ul><li>检查主码的各个属性是否为空，有一个为空就拒绝插入或修改</li><li>检查主码值是否唯一，如果不唯一就拒绝插入或修改<ul><li>方法：全表扫描、B+树索引</li></ul></li></ul><h2 id="参照完整性">5.2 参照完整性</h2><p>关系模型的参照完整性在CREATE TABLE中用FOREIGNKEY来定义哪些列尾外码，用REFERENCES短语指明这些外码参照哪些表的主码。</p><p>参照完整性检查和违约处理</p><table><thead><tr class="header"><th>被参照表</th><th>参照表</th><th>违约处理</th></tr></thead><tbody><tr class="odd"><td>可能破坏参照完整性</td><td>插入元组</td><td>拒绝</td></tr><tr class="even"><td>可能破坏参照完整性</td><td>修改外码值</td><td>拒绝</td></tr><tr class="odd"><td>删除元组</td><td>可能破坏参照完整性</td><td>拒绝/级联删除/设置为空值</td></tr><tr class="even"><td>修改主码值</td><td>可能破坏参照完整性</td><td>拒绝/级联删除/设置为空值</td></tr></tbody></table><ul><li>拒绝（NO ACTION），一般为默认策略</li></ul><h2 id="用户定义的完整性">5.3 用户定义的完整性</h2><p>用户定义的完整性就是针对某一具体应用的数据必须满足的语义条件。</p><ul><li><p>属性上的约束条件</p><ul><li><p>非空（NOT NULL）</p></li><li><p>唯一（UNIQUE）</p></li><li><p>用CHECK语句指定列值条件</p><p><code>Sex CHAR(2) CHECK (Sex IN('男','女'))</code></p></li><li><p>修改或插入时检查；违约处理：拒绝执行</p></li></ul></li><li><p>元组上的约束条件</p><ul><li>用CHECK指定元组约束条件</li><li>修改或插入时检查；违约处理：拒绝执行</li></ul></li></ul><h2 id="完整性约束命名子句">5.4 完整性约束命名子句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-operator">&lt;</span>完整性约束条件名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>完整性约束条件<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Student <br>(Sno <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">6</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C1 <span class="hljs-keyword">CHECK</span> (Sno <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">90000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">99999</span>), <br> Sname <span class="hljs-type">CHAR</span>(<span class="hljs-number">20</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C2 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br> Sage <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>), <br> Ssex <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">CONSTRAINT</span> C4 <span class="hljs-keyword">CHECK</span>(SSex <span class="hljs-keyword">IN</span>(<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>)), <br><span class="hljs-keyword">CONSTRAINT</span> StudentKey <span class="hljs-keyword">PRIMARY</span> KEY(Sno)<br>;)<br></code></pre></td></tr></table></figure><p>修改例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> C3;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> Student<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> C3 <span class="hljs-keyword">CHECK</span> (Sage <span class="hljs-operator">&lt;</span> <span class="hljs-number">40</span>);<br></code></pre></td></tr></table></figure><h2 id="域中的完整性限制">5.5 域中的完整性限制</h2><p>域是一组具有相同数据类型的值的集合。</p><p>SQL中，可以用CREATEDOMAIN来创建一个域以及其应该满足的完整性约束条件以定义属性。</p><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DOMAIN GenderDomain <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">CONSTRAINT</span> GD <span class="hljs-keyword">CHECK</span>(<span class="hljs-keyword">VALUE</span> <span class="hljs-keyword">IN</span>(<span class="hljs-string">&#x27;男&#x27;</span>，<span class="hljs-string">&#x27;女&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="断言">5.6 断言</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ASSERTION <span class="hljs-operator">&lt;</span>断言名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">CHECK</span>子句<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h2 id="触发器">5.7 触发器</h2><p>触发器（trigger）是用户定义在关系表上的一类由事件驱动的特殊过程。</p><ul><li>触发器又叫事件-条件-动作规则。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span><br>&#123;BEFORE<span class="hljs-operator">|</span>AFTER&#125; <span class="hljs-operator">&lt;</span>触发事件<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <span class="hljs-comment">/* 指明触发器激活时间在事件前后 */</span><br><span class="hljs-keyword">REFERENCING</span> <span class="hljs-keyword">NEW</span><span class="hljs-operator">|</span><span class="hljs-keyword">OLD</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>变量<span class="hljs-operator">&gt;</span>  <span class="hljs-comment">/* 指明引用的变量 */</span><br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> &#123;<span class="hljs-type">ROW</span><span class="hljs-operator">|</span>STATEMENT&#125;<br>[<span class="hljs-keyword">WHEN</span> <span class="hljs-operator">&lt;</span>触发条件<span class="hljs-operator">&gt;</span>] <span class="hljs-operator">&lt;</span>触发动作体<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><ul><li>只有表的拥有者才能在表上创建触发器，且触发器数量有限</li><li>同一模式下，触发器名必须是唯一的，且触发器名和表名必须在同一模式下</li><li>触发器只能定义在基本表上，不能定义在视图上</li><li>触发事件可以是INSERT、DELETE或UPDATE，也可以是其组合</li><li>行级触发器每行都执行，语句级触发器只触发一次</li></ul><p>删除触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-operator">&lt;</span>触发器名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第四章_数据库安全性</title>
    <link href="/2023/03/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <url>/2023/03/04/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第四章-数据库安全性">第四章 数据库安全性</h1><h2 id="数据库安全性概述">4.1 数据库安全性概述</h2><p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</p><p>系统安全保护措施是否有效是数据库系统的主要技术指标之一。</p><h3 id="数据库的不安全因素">数据库的不安全因素</h3><ul><li>非授权用户对数据库的恶意存取和破坏</li><li>数据库中重要或敏感的数据被泄露</li><li>安全环境的脆弱性</li></ul><h3 id="安全标准简介">安全标准简介</h3><p>TCSEC/TDI</p><table><thead><tr class="header"><th>安全级别</th><th>定义</th></tr></thead><tbody><tr class="odd"><td>A1</td><td>验证设计</td></tr><tr class="even"><td>B3</td><td>安全域</td></tr><tr class="odd"><td>B2</td><td>结构化保护</td></tr><tr class="even"><td>B1</td><td>标记安全保护</td></tr><tr class="odd"><td>C2</td><td>受控的存取保护</td></tr><tr class="even"><td>C1</td><td>自主安全保护</td></tr><tr class="odd"><td>D</td><td>最小保护</td></tr></tbody></table><ul><li><p>D级，最低级别，一切不符合更高标准的系统均归于D组</p></li><li><p>C1：能够实现对用户和数据的分离，进行自主存取控制(DAC)</p></li><li><p>B1：对系统数据加以标记，并对被标记的主客体实施强制存取控制(MAC)以及审计</p></li><li><p>B1以上为安全产品</p></li></ul><p>CC（Common Criteria）：安全功能要求和安全保证要求</p><h2 id="数据库安全性控制">4.2 数据库安全性控制</h2><p>主要内容：</p><ul><li>用户身份鉴别</li><li>多层存取控制</li><li>审计</li><li>视图</li><li>数据加密</li></ul><h3 id="用户身份鉴别">4.2.1 用户身份鉴别</h3><p>常见方法：</p><ul><li>静态口令鉴别</li><li>动态口令鉴别</li><li>生物特征鉴别</li><li>智能卡鉴别</li></ul><h3 id="存取控制">4.2.2 存取控制</h3><p>存取控制机制的组成：</p><ul><li>定义用户权限<ul><li>提供适当语言以定义用户权限，编译后存储在数据字典中，称为安全规则</li></ul></li><li>合法权限检查<ul><li>根据安全规则进行合法权限检查</li></ul></li><li>定义用户权限和合法权限检查机制一起组成了数据库管理系统的存取控制子系统。</li></ul><p>C2级的数据库管理系统支持自主存取控制（Discretionary AccessControl，DAC）；</p><p>B1级的数据库管理系统支持强制存取控制（Mandatory AccessControl，MAC）。</p><ul><li>在自主存取控制中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，用户可将其拥有的存取权限转授给其他用户</li><li>在强制存取控制中，每个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取</li></ul><h4 id="自主存取控制">自主存取控制</h4><p>用户权限的两个要素：数据库对象和操作类型</p><ul><li>在数据库系统中，定义存取权限称为授权</li></ul><p>关系数据库系统中，存取控制的对象不仅有数据本身，还有数据库模式</p><table><thead><tr class="header"><th>对象类型</th><th>对象</th></tr></thead><tbody><tr class="odd"><td>数据</td><td>基本表和视图、属性列</td></tr><tr class="even"><td>数据库模式</td><td>模式、基本表、视图、索引</td></tr></tbody></table><p>SQL使用GRANT语句向用户授予权限，REVOKE语句收回已经授予用户的权限。</p><h5 id="grant">GRANT</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION]<br></code></pre></td></tr></table></figure><ul><li>如果制定了WITH GRANTOPTION子句，则授权的用户可以把这种权限转授。</li><li>GRANT ALL PRIVILEGES可以将全部操作权限授予用户</li><li>授予全部用户：TO PUBLIC</li><li>对属性列授权时必须明确指出相应的属性列名</li></ul><h5 id="revoke">REVOKE</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-operator">&gt;</span>]...[CASCADE<span class="hljs-operator">|</span>RESTRICT];<br></code></pre></td></tr></table></figure><ul><li>一般默认CASCADE，将收回全部直接或间接从该用户获得的对应权限，而RESTRICT只收回指定用户的权限</li></ul><h5 id="创建数据库模式的权限">创建数据库模式的权限</h5><p>创建数据库模式一类的数据库对象的授权由数据库管理员在创建用户时完成。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">WITH</span>] [DBA<span class="hljs-operator">|</span>RESOURCE<span class="hljs-operator">|</span><span class="hljs-keyword">CONNECT</span>];<br></code></pre></td></tr></table></figure><ul><li>只有系统的超级用户才有权创建一个新的数据库用户</li><li>新创建的数据库用户有三种权限：CONNECT、RESOURCE、DBA，默认CONNECT<ul><li>CONNECT权限用户不能创建新用户、模式、基本表</li><li>RESOURCE权限用户可以创建基本表，不能创建新用户和模式</li><li>DBA权限用户是系统的超级用户，可以创建新用户、模式和基本表，拥有所有数据库对象的存取权限</li></ul></li></ul><h5 id="数据库角色-role">数据库角色 ROLE</h5><p>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。</p><ul><li>为一组具有相同权限的用户创建一个角色，简化授权的过程</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ROLE <span class="hljs-operator">&lt;</span>角色名<span class="hljs-operator">&gt;</span>;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-number">3</span><span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>用户<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span>]...<br>[<span class="hljs-keyword">WITH</span> ADMIN OPTION]<br><br><span class="hljs-keyword">REVOKE</span> <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>对象类型<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">TO</span> <span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>角色<span class="hljs-operator">&gt;</span>]...;<br></code></pre></td></tr></table></figure><ul><li>如果指定了WITH ADMIN OPTION，那么获得权限的用户可以转授该权限。</li></ul><h4 id="强制存取控制">强制存取控制</h4><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类。</p><ul><li><p>主体是系统中的活动实体，既包括数据管理系统所管理的实际用户，也包括代表用户的各进程</p></li><li><p>客体是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引等。</p></li><li><p>对于主体和客体，数据库管理系统为它们每个实例指派一个敏感度标记（label）</p><p>敏感度标记被分为若干级别，如绝密（TopSecret，TS），机密（Secret，S），可信（Confidential，C），公开（Public，P），TS&gt;=S&gt;=C&gt;=P</p><p>主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级</p><ul><li>仅当主体的许可证级别大于等于客体的密级时，该主体才能读取该客体</li><li>仅当主体的许可证级别小于等于客体的密级时，该主体才能写该客体</li><li>即用户只能读低于或等于自己许可的数据，创建高于或等于自己许可的数据，以防止高级用户将数据泄露给低级用户</li></ul></li><li><p>强制存取控制对数据本身加以的密级标识和数据时一个整体</p></li></ul><h5id="自主存取控制强制存取控制dacmac">自主存取控制+强制存取控制（DAC+MAC）</h5><p>先进行自主存取控制审查，在进行强制存取控制检查</p><h2 id="一些安全性保护办法">4.3 一些安全性保护办法</h2><h3 id="视图机制">4.3.1 视图机制</h3><p>把要保密的数据对无权存取的用户隐藏起来，为数据提供一定程度的安全保护。</p><h3 id="审计audit">4.3.2 审计（audit）</h3><p>审计功能把用户对数据库的所有操作自动记录下来放入审计日志（auditlog）。</p><ul><li>审计通常是很费时间和空间的，所以数据库系统往往都将审计设置成可选的</li><li>审计设置以及审计日志一般存储在数据字典中，必须开启审计开关（设置audit_trail为true），才能在系统表SYS_AUDITTRAIL中看到审计信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">AUDIT <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>;<br><br>NOAUDIT <span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>权限<span class="hljs-operator">&gt;</span>]...<br><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>对象名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>审计一般可以分为用户级审计和系统级审计。</p><p>数据库安全审计系统提供了一种事后检查的安全机制。安全审计机制将特定用户或者特定对象相关的操作记录到系统审计日志中，作为后续对操作的查询分析和追踪的依据。通过审计机制，可以约束用户可能的恶意操作。</p><h3 id="数据加密">4.3.3 数据加密</h3><p>加密的基本思想是依据一定的算法将原始数据——明文（plaintext）变换为不可直接识别的格式——密文（cipher text）。</p><p>数据加密主要包括存储加密和传输加密。</p><ul><li>存储加密<ul><li>透明存储加密：内核级加密保护，对用户完全透明</li><li>非透明存储加密：通过多个加密函数实现</li></ul></li><li>传输加密<ul><li>链路加密：对传输数据在链路层进行加密，加密报文和报头</li><li>端到端加密：在发送端加密，接收端解密，加密报文</li></ul></li></ul><h3 id="其他安全性保护">4.3.4 其他安全性保护</h3><ul><li><p>推理控制：避免由低级数据推导出高级数据</p></li><li><p>隐蔽信道：间接信息传递</p></li><li><p>数据隐私：控制不愿他人知道或他人不便知道的个人数据的能力</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第三章_SQL</title>
    <link href="/2023/03/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%89%E7%AB%A0_SQL/"/>
    <url>/2023/03/03/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%89%E7%AB%A0_SQL/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第三章-sql">第三章 SQL</h1><p>结构化查询语言（Structured QueryLanguage，SQL）是关系数据库标准语言，功能包括</p><ul><li>数据库的查询</li><li>数据库模式创建</li><li>数据库数据的插入与修改</li><li>数据库安全性完整性定义与控制</li><li>……</li></ul><h2 id="sql概述">3.1 SQL概述</h2><h3 id="sql的特点">3.1.1 SQL的特点</h3><ul><li>综合统一<ul><li>集数据定义语言、数据操纵语言、数据控制语言于一体</li></ul></li><li>高度非过程化<ul><li>存取路径的选择以及SQL的操作过程由系统自动完成</li></ul></li><li>面向集合的操作方式<ul><li>操作对象、查找结果都可以是元组的集合</li></ul></li><li>以同一种语法结构提供多种使用方式<ul><li>能嵌入到C++、Java中</li></ul></li><li>语言简洁，易学易用<ul><li>数据查询：SELECT</li><li>数据定义：CREATE、DROP、ALTER</li><li>数据操纵：INSERT、UPDATE、DELETE</li><li>数据控制：GRANT、REVOKE</li></ul></li></ul><h3 id="sql的基本概念">3.1.2 SQL的基本概念</h3><h4 id="sql与三级模式">SQL与三级模式</h4><ul><li>内模式：存储文件</li><li>模式：基本表</li><li>外模式：视图</li></ul><p>用户可以用SQL对基本表和视图进行查询或其他操作。基本表和视图都是关系。</p><p>基本表是本事独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表，一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。</p><p>存储文件的逻辑结构组成了关系数据库的内模式，其逻辑结构对用户是隐蔽的。</p><p>视图是一个或几个基本表导出的表，它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据。这些数据仍存放在导出视图的基本表中，因而视图仅仅是一个虚表。用户可以在视图上再定义视图。</p><h2 id="数据定义">3.2 数据定义</h2><p>层次化的数据库对象命名机制：</p><p>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</p><p>SQL的数据定义：模式定义、表定义、视图定义和索引定义</p><table><thead><tr class="header"><th>操作对象</th><th>创建</th><th>删除</th><th>修改</th></tr></thead><tbody><tr class="odd"><td>模式</td><td>CREATE SCHEMA</td><td>DROP SCHEMA</td><td></td></tr><tr class="even"><td>表</td><td>CREATE TABLE</td><td>DROP TABLE</td><td>ALTER TABLE</td></tr><tr class="odd"><td>视图</td><td>CREATE VIEW</td><td>DROP VIEW</td><td></td></tr><tr class="even"><td>索引</td><td>CREATE INDEX</td><td>DROP INDEX</td><td>ALTER INDEX</td></tr></tbody></table><h3 id="模式">模式</h3><p>定义模式即定义了一个命名空间，在此空间中可以定义该模式包含的数据库对象，例如基本表、视图、索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span><br><span class="hljs-keyword">AUTHORIZATION</span> <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-operator">&lt;</span>表定义子句<span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>视图定义子句<span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>授权定义子句<span class="hljs-operator">&gt;</span>];<br></code></pre></td></tr></table></figure><p>不指定模式名时，模式名将隐含为用户名。</p><p>删除模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> SCHEMA <span class="hljs-operator">&lt;</span>模式名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>CASCADE<span class="hljs-operator">|</span>RESTRICT<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><ol type="1"><li>CASCADE：删除模式的同时删除该模式中所有数据库对象</li><li>RESTRICT：如果该模式中定义了下属的数据库对象，则拒绝执行删除</li></ol><h3 id="基本表">基本表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]<br>[，<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>列级完整性约束条件<span class="hljs-operator">&gt;</span>]]<br>…<br>[，<span class="hljs-operator">&lt;</span>表级完整性约束条件<span class="hljs-operator">&gt;</span>]);<br></code></pre></td></tr></table></figure><p>列级完整性：PRIMARY KEY、UNIQUE、NOT NULL等</p><p>表级完整性：PRIMARY KEY(Sno, Cno)；FOREIGN KEY(Cno) REFERENCESCourse(Cno)</p><table><thead><tr class="header"><th>数据类型</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>CHAR(n),CHARACTER(n)</td><td>长度为n的定长字符串</td></tr><tr class="even"><td>VARCHAR(n)</td><td>最大长度为n的变长字符串</td></tr><tr class="odd"><td>CLOB</td><td>字符串大对象</td></tr><tr class="even"><td>BLOB</td><td>二进制大对象</td></tr><tr class="odd"><td>INT，INTEGER</td><td>长整数(4字节)</td></tr><tr class="even"><td>SMALLINT</td><td>短整数(2字节)</td></tr><tr class="odd"><td>BIGINT</td><td>大整数(8字节)</td></tr><tr class="even"><td>NUMERIC(p，d)</td><td>定点数，由p位数字(不包括符号、小数点)组成，小数后面有d位数字</td></tr><tr class="odd"><td>DECIMAL(p, d), DEC(p, d)</td><td>同NUMERIC</td></tr><tr class="even"><td>REAL</td><td>取决于机器精度的单精度浮点数</td></tr><tr class="odd"><td>DOUBLE PRECISION</td><td>取决于机器精度的双精度浮点数</td></tr><tr class="even"><td>FLOAT(n)</td><td>可选精度的浮点数，精度至少为n位数字</td></tr><tr class="odd"><td>BOOLEAN</td><td>逻辑布尔量</td></tr><tr class="even"><td>DATE</td><td>日期，包含年、月、日，格式为YYYY-MM-DD</td></tr><tr class="odd"><td>TIME</td><td>时间，包含一日的时、分、秒，格式为HH:MM:SS</td></tr><tr class="even"><td>TIMESTAMP</td><td>时间戳类型</td></tr><tr class="odd"><td>INTERVAL</td><td>时间间隔类型</td></tr></tbody></table><p>修改基本表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> <br>[<span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>新列名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span> [完整性约束]]<br>[<span class="hljs-keyword">ADD</span> <span class="hljs-operator">&lt;</span>表级完整性约束<span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">DROP</span> [<span class="hljs-keyword">COLUMN</span>] <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [CASCADE<span class="hljs-operator">|</span> RESTRICT]]<br>[<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span><span class="hljs-operator">&lt;</span>完整性约束名<span class="hljs-operator">&gt;</span>[RESTRICT <span class="hljs-operator">|</span> CASCADE]]<br>[<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span><span class="hljs-operator">&lt;</span>数据类型<span class="hljs-operator">&gt;</span>]；<br></code></pre></td></tr></table></figure><ul><li><p>ADD用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件</p></li><li><p>DROP COLUMN用于删除表中列</p></li><li><p>DROP CONSTRAINT用于删除指定的完整性约束条件</p></li><li><p>ALTER COLUMN用于修改原有列定义，包括列名和数据类型</p></li></ul><h3 id="索引">索引</h3><p>作用：加快查询速度</p><p>建立索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> [<span class="hljs-operator">&lt;</span>顺序<span class="hljs-operator">&gt;</span>]…);<br></code></pre></td></tr></table></figure><ul><li><p>顺序：</p><ul><li>升序：ASC</li><li>降序：DESC</li><li>缺省值：ASC</li></ul></li><li><p>UNIQUE：每个索引值只对应唯一的数据记录</p></li><li><p>CLUSTER：表示要建立的索引是聚簇索引</p></li></ul><p>修改索引：<code>ALTER INDEX &lt;旧名称&gt; RENAME TO &lt;新名称&gt;</code>;</p><p>删除索引：<code>DROP INDEX &lt;名称&gt;;</code></p><h2 id="数据查询">3.3 数据查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span><span class="hljs-operator">|</span><span class="hljs-keyword">DISTINCT</span>] <span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>目标列表达式<span class="hljs-operator">&gt;</span>]…<br><span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表<span class="hljs-operator">/</span>视图名<span class="hljs-operator">&gt;</span> [,<span class="hljs-operator">&lt;</span>表<span class="hljs-operator">/</span>视图名<span class="hljs-operator">&gt;</span>]… <span class="hljs-operator">|</span> (<span class="hljs-keyword">SELECT</span>语句) [<span class="hljs-keyword">AS</span>] <span class="hljs-operator">&lt;</span>别名<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WHERE</span> <span class="hljs-operator">&lt;</span>条件表达式<span class="hljs-operator">&gt;</span>]<br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">1</span><span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">HAVING</span> <span class="hljs-operator">&lt;</span>条件表达式<span class="hljs-operator">&gt;</span>]]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>]<br></code></pre></td></tr></table></figure><ul><li>DISTINCT：去除重复行，缺省为ALL</li><li>WHERE表示指定条件，作用于表<ul><li>BETWEEN AND（范围）、IN（集合）、LIKE（匹配字符）、ISNULL（空值）、AND OR（多重条件查询）、ORDER BY（升降排列）</li></ul></li><li>聚集函数只用于SELECT和GROUP BY中的HAVING子句<ul><li>COUNT、SUM、AVG、MAX、MIN（需要指定DISTINCT或ALL）</li></ul></li><li>GROUP BY按照某一列或多列的值分组<ul><li>指定属性值相同的元组为一组，然后对每一组作用聚集函数进行计算</li></ul></li></ul><table><thead><tr class="header"><th>查询条件</th><th>谓词</th></tr></thead><tbody><tr class="odd"><td>比较</td><td>=, &gt;, &lt;, &gt;=, &lt;=, !=, &lt;&gt;, !&gt;, !&lt;;NOT+上述比较运算符</td></tr><tr class="even"><td>确定范围</td><td>BETWEEN AND, NOT BETWEEN AND</td></tr><tr class="odd"><td>确定集合</td><td>IN, NOT IN</td></tr><tr class="even"><td>字符匹配</td><td>LIKE, NOT LIKE</td></tr><tr class="odd"><td>空值</td><td>IS NULL, IS NOT NULL</td></tr><tr class="even"><td>多重条件(逻辑运算)</td><td>AND, OR, NOT</td></tr></tbody></table><h4 id="字符匹配">字符匹配</h4><p>匹配串可以是一个完整的字符串，也可以含有通配符%(任意长度字符串)和_(任意单个字符)</p><p>用。</p><h4 id="空值">空值</h4><ul><li>产生：没赋值/修改/外连接/关系运算</li><li>判断：IS NULL / IS NOT NULL (注意IS一直有)</li><li>约束条件：NOT NULL / UNIQUE / PRIMARY KEY不能取空值</li><li>逻辑运算：TRUE FALSE UNKNOWN</li></ul><h4 id="聚集函数">聚集函数</h4><p>统计元组个数：COUNT(*)</p><p>统计一列中值的个数：COUNT([DISTINCT | ALL] <列名>)</p><p>计算一列值的总和(必须为数值型)：SUM([DISTINCT | ALL] <列名>)</p><p>计算一列值的平均值(必须为数值型)：AVG([DISTINCT | ALL] <列名>)</p><p>求最大最小值：MAX / MIN([DISTINCT | ALL] 列名)</p><h4 id="连接查询">连接查询</h4><p>连接查询即同时涉及两个以上表的查询，连接条件或连接谓词是连接两表的条件</p><p><列1> <比较运算符> <列2></p><p><列1> BETWEEN <列2> AND <列3></p><p>连接字段：连接谓词中的列名称。</p><ul><li><p>等值/自然连接：连接运算符为=。</p></li><li><p>自身连接：表与自己进行连接：需要给表起别名，并使用别名前缀以示区别。</p></li><li><p>多表连接</p></li></ul><p>连接操作的执行过程</p><ol type="1"><li>嵌套循环</li></ol><p>逐个对表1中每个元组执行遍历表2的连接操作。</p><ol start="2" type="1"><li>排序合并</li></ol><p>首先按连接属性对两表排序，然后查找表1中元组在表2中的连接，查找到大于表1字段值的元组后，查询不再继续。</p><ol start="3" type="1"><li>索引连接</li></ol><p>对表2按连接字段建立索引，依次查询表1中各元组的连接。</p><p>外连接：以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</p><p>SELECT <字段名> FROM <表名> LEFT JOIN <表名> ON <连接条件></p><h4 id="嵌套查询">嵌套查询</h4><p><字段名> IN/比较运算符 (ANY/ALL) <查询语句> (NOT) EXISTS<查询语句></p><h4 id="集合操作">集合操作</h4><ul><li>并 UNION、交 INTERSECT、差 EXCEPT</li></ul><p>参与集合操作的各查询结果的列数和各数据类型必须相同。</p><p>UNION：合并多个查询结果，去掉重复元组</p><p>UNION ALL：合并多个查询结果，保留重复元组</p><h4 id="派生表查询">派生表查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> (查询语句);<br></code></pre></td></tr></table></figure><p>若子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT语句子句后列名为其缺省属性。</p><h2 id="数据更新">3.4 数据更新</h2><ul><li><p>插入：INSERT INTO <表名> [<属性列>,…] VALUES (<常量>,…)</p><ul><li>指定要插入数据的表名及属性列，插入的元组在其余属性列取空值。</li><li>未指定属性列：插入完整元组，且属性列属性的顺序和表一致。</li><li>VALUES提供的值的个数与类型必须与INTO子句匹配。</li></ul></li><li><p>修改：UPDATE <表名> SET <列名>=<表达式>,… [WHERE 条件]</p></li><li><p>删除：DELETE FROM <表名> [WHERE 条件]</p></li></ul><h2 id="视图">3.5 视图</h2><p>视图是虚表，从一个或几个基本表导出，只存放定义而无数据，基表中数据变化，视图中数据也随之改变。</p><p>视图的更新是同步于基本表的，一般来说，行列子集视图可以更新，其他（如AVG）不可。</p><p>视图的作用：</p><ul><li>简化用户的操作</li><li>使用户能以多种角度看待同一数据</li><li>视图对重构数据库提供了一定程度的逻辑独立性<ul><li>外模式不变，即使模式变更也不影响</li></ul></li><li>对机密数据提供安全保护<ul><li>每个用户看到的视图不同</li></ul></li><li>可以更清晰地表达查询</li></ul><p>视图做不到的：</p><ul><li>部分特殊视图不允许更新</li><li>视图消解有局限性，有时不能正确地查询</li></ul><h3 id="建立视图">建立视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [(<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>,…)]<br><span class="hljs-keyword">AS</span> <span class="hljs-operator">&lt;</span>子查询<span class="hljs-operator">&gt;</span><br>[<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure><ul><li><p>WITH CHECKOPTION：对视图进行UPDATE、INSERT和DELETE时要保证更新的行满足视图定义中的谓词条件(即子查询中的条件表达式)。</p><ul><li>子查询可以是任意的select语句。</li></ul></li><li><p>行列子集视图：从单个表导出某些列，保留主码</p></li><li><p>组成视图的属性列名：全部省略或全部指定</p></li><li><p>实现增删改视图--&gt;增删改基本表：不写聚集函数</p></li></ul><p>关系数据库管理系统在执行CREATEVIEW的时候只是将视图定义存入数据字典，并不执行SELECT。查询时，按定义将其查出。</p><h3 id="删除视图">删除视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> <span class="hljs-operator">&lt;</span>视图名<span class="hljs-operator">&gt;</span> [CASCADE];<br></code></pre></td></tr></table></figure><p>CASCADE：级联地删除视图及其导出的视图。</p><h3 id="查询视图">查询视图</h3><p>用户查询视图与查询基本表一致。</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第二章_关系数据库</title>
    <link href="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/03/02/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第二章-关系数据库">第二章 关系数据库</h1><h2 id="关系数据结构及其形式化定义">2.1 关系数据结构及其形式化定义</h2><h3 id="关系">2.1.1 关系</h3><h4 id="关系数据结构的形式化定义">关系数据结构的形式化定义</h4><ol type="1"><li>域（domain）</li></ol><p>域是一组具有相同数据类型的值的集合</p><ol start="2" type="1"><li>笛卡尔积（cartesian product）</li></ol><p>笛卡尔积是域上的一种集合运算。</p><p>给定一组域<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>，允许其中某些域是相同的，<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>的笛卡尔积为</p><p><span class="math inline">\(D_1\times D_2\times ...\timesD_n=\{(d_1,d_2,...,d_n)|d_i\in D_i,i=1,2,...,n\}\)</span></p><p>其中，每个元素<spanclass="math inline">\((d_1,d_2,...,d_n)\)</span>称作一个n元组（n-tuple），或简称元组。元组中的每一个值<spanclass="math inline">\(d_i\)</span>称为一个分量。</p><p>一个域允许的不同取值个数称为这个域的基数（cardinal number）。</p><p>若<span class="math inline">\(D_i\)</span>为有限集，其基数为<spanclass="math inline">\(m_i(i=1,2,...,n)\)</span>，则<spanclass="math inline">\(D_1\times D_2\times ...\timesD_n\)</span>的基数M为</p><p><span class="math inline">\(M=\prod_{i=1}^n m_i\)</span></p><ol start="3" type="1"><li>关系</li></ol><p><span class="math inline">\(D_1\times D_2\times ...\timesD_n\)</span>的子集称为在域<spanclass="math inline">\(D_1,D_2,...,D_n\)</span>上的关系，表示为<spanclass="math inline">\(R(D_1,D_2,...,D_n)\)</span>。</p><p>这里R表示关系的名字，n是关系的目或度（degree），关系中的每个元素是关系中的元组，通常用t表示。</p><ul><li>当<spanclass="math inline">\(n=1\)</span>时，称该关系为一元关系（unaryrelation）</li><li>当<spanclass="math inline">\(n=2\)</span>时，称该关系为二元关系（binaryrelation）</li></ul><p>关系是笛卡尔积的有限子集，故关系是一张每行对应一个元组的二维表，表的每列对应一个域。每列的名字为属性，n目关系必有n个属性。</p><p>若关系中的某一属性组能唯一地标识一个元组而其子集不能，则称该属性组为候选码（candidatekey）。</p><p>若一个关系有多个候选码，则选定其中一个为主码（primary key）。</p><p>候选码地各个属性为主属性（primeattribute）。不包含在任何候选码中的属性称为非主属性或非码属性。</p><p>在最简单地情况下，候选码只包含一个属性，在最极端地情况下，关系模式地所有属性是这个关系模式地候选码，称为全码（all-key）。</p><h5 id="关系的三种类型">关系的三种类型</h5><p>基本表、查询表和视图表，其中基本表为实际存在的表，查询表是查询结果对应的表，视图表是由基本表或其他视图表导出的表，是虚表。</p><h5 id="基本关系的性质">基本关系的性质</h5><ol type="1"><li>列是同质的，每一列中的分量是同一类型的数据，来自同一个域</li><li>不同的列可来自同一个域，但有不同的属性名</li><li>列和行都是无序的</li><li>任意两个元组的候选码不能取相同值</li><li>每个分量都是不可分的数据项</li></ol><p>关系模型要求关系必须是规范化的，满足一定的规范条件。规范化的关系称为范式（NormalForm，NF）。</p><h3 id="关系模式与关系数据库">2.1.2 关系模式与关系数据库</h3><p>关系的描述称为关系模式，可以形式化地表示为<spanclass="math inline">\(R(U,D,DOM,F)\)</span>。</p><p>其中R是关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间关系的依赖关系集合。</p><p>其中，<span class="math inline">\(DOM(属性名)=域名\)</span>。</p><p>关系模式可以简记为<spanclass="math inline">\(R(U)或R(A_1,A_2,...,A_n)\)</span>。其中<spanclass="math inline">\(A_1,A_2,...,A_n\)</span>为属性名。</p><p>关系数据库的型称为关系数据库模式，包括若干域的定义和在这些域上定义的若干关系模式，是对关系数据库的描述。</p><p>关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</p><h2 id="关系操作">2.2 关系操作</h2><h3 id="基本关系操作">2.2.1 基本关系操作</h3><p>关系操作的对象和结果都是集合，这种方式也称为一次一集合方式，相应地，非关系数据模型的数据操作方式则为一次一记录的方式。</p><p>关系模型中常用的关系操作包括查询(query)操作和插入(insert)、删除(delete)、修改(update)操作两部分。</p><p>查询操作是关系操作中最主要的部分，包括：</p><p>选择(select)、投影(project)、连接(join)、除(divide)、并(union)、差(except)、交(intersection)、笛卡尔积等。</p><p>查询操作中，选择、投影、并、差、笛卡尔积是5种基本操作，其他操作可用基本操作来定义和导出。</p><h3 id="关系数据语言的分类">2.2.2 关系数据语言的分类</h3><p>早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数（relationalgebra）和关系演算（relation calculus）。</p><ul><li>关系代数用对关系的运算来表达查询要求</li><li>关系演算则用谓词来表达查询要求<ul><li>关系演算按谓词变元的基本对象是元组还是域变量分为元组关系演算和域关系演算</li></ul></li></ul><p>一个关系数据语言能够表示关系代数可以表示的查询，称为具有完备的表达能力，简称关系完备性。已经证明关系代数、元组关系演算和域关系演算在表达能力上是等价的。</p><p>结构化查询语言（Structured QueryLanguage，SQL）介于关系代数和关系演算之间。</p><p>SQL兼具查询、数据定义、数据控制功能，是集查询、数据定义语言、数据操纵语言和数据控制语言为一体的关系数据语言。</p><ul><li>SQL是一种高度非过程化的语言。</li></ul><h2 id="关系的完整性">2.3 关系的完整性</h2><p>关系模型中有三类完整性约束：实体完整性（entityintegrity）、参照完整性（referentialintegrity）和用户定义的完整性（user-defined integrity）</p><h3 id="实体完整性">实体完整性</h3><p>实体完整性规则：若属性A（一个或一组属性）是基本关系R的主属性，则A不能取空值</p><h3 id="参照完整性">参照完整性</h3><p>设F是基本关系R的一个或一组属性，但不是关系R的码，<spanclass="math inline">\(K_S\)</span>是基本关系S的主码。如果F与<spanclass="math inline">\(K_s\)</span>对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。</p><p>参照完整性规则：若属性F是基本关系R的外码，它与基本关系S的主码<spanclass="math inline">\(K_s\)</span>相对应，则对于R中每个原则在F上的值必须或者取空值，或者等于S中某个元组的主码值。</p><h3 id="用户定义的完整性">用户定义的完整性</h3><p>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</p><h2 id="关系代数">2.4 关系代数</h2><p>关系代数用对关系的运算来表达查询。</p><ul><li>关系代数的运算又分为传统的集合运算和专门的关系运算两类<ul><li>集合运算符：并<span class="math inline">\(\cup\)</span>、差<spanclass="math inline">\(-\)</span>、交<spanclass="math inline">\(\cap\)</span>、笛卡尔积<spanclass="math inline">\(\times\)</span></li><li>专门关系运算符：选择<spanclass="math inline">\(\sigma\)</span>、投影<spanclass="math inline">\(\prod\)</span>、连接<spanclass="math inline">\(\Join\)</span>、除<spanclass="math inline">\(\div\)</span></li></ul></li></ul><h3 id="传统的集合运算">2.4.1 传统的集合运算</h3><p>传统的集合运算是二目运算，包括并、差、交、笛卡尔积4种运算</p><p>（1）并（union）：<span class="math inline">\(R\cup S=\{t|t\in R \veet\in S\}\)</span></p><p>（2）差（except）：<span class="math inline">\(R-S=\{t|t\in R\wedget\notin S\}\)</span></p><p>（3）交（intersection）：<span class="math inline">\(R\cap S=\{t|t\inR\wedge t\in S\}\)</span></p><p>（4）笛卡尔积（cartesian product）：<spanclass="math inline">\(R\times S=\{t_rt_s|t_r\in R\wedge t_s\inS\}\)</span></p><h3 id="专门的关系运算">2.4.2 专门的关系运算</h3><p>专门的关系运算包括选择、投影、连接、除运算等。</p><p>引入几个记号：</p><ul><li><p>设关系模式为 <spanclass="math inline">\(R(A_1,A_2,...,A_n)\)</span>，它的一个关系设为<spanclass="math inline">\(R\)</span>。<span class="math inline">\(t\inR\)</span> 表示 <span class="math inline">\(t\)</span> 是 <spanclass="math inline">\(R\)</span> 的一个元组。<spanclass="math inline">\(t[A_i]\)</span> 则表示元组 <spanclass="math inline">\(t\)</span> 中相应于属性 <spanclass="math inline">\(A_i\)</span> 的一个分量。</p></li><li><p>若 <spanclass="math inline">\(A=\{A_{i1},A_{i2},...,A_{ik}\}\)</span>，其中<span class="math inline">\(A_{i1},A_{i2},...,A_{ik}\)</span> 是 <spanclass="math inline">\(A_1,A_2,...,A_n\)</span> 中的一部分，称<spanclass="math inline">\(A\)</span>为属性列或属性组。<spanclass="math inline">\(t[A]=(t[A_{i1}],t[A_{i2}],...,t[A_{in}])\)</span>为元组<spanclass="math inline">\(t\)</span>在属性列<spanclass="math inline">\(A\)</span>上诸分量的集合，<spanclass="math inline">\(\overline{A}\)</span>则表示<spanclass="math inline">\(\{A_1,A_2,...,A_n\}\)</span>中去掉<spanclass="math inline">\(\{A_{i1},A_{i2},...,A_{in}\}\)</span>后剩余的属性组。</p></li><li><p><span class="math inline">\(R\)</span>为<spanclass="math inline">\(n\)</span>目关系，<spanclass="math inline">\(S\)</span>为m目关系。<spanclass="math inline">\(t_r\in R\)</span>，<spanclass="math inline">\(t_s\in S\)</span>，<spanclass="math inline">\(t_rt_s\)</span>称为元组的连接或串接。它是一个<spanclass="math inline">\(n+m\)</span>列的新元组，前<spanclass="math inline">\(n\)</span>个分量为<spanclass="math inline">\(R\)</span>中的一个<spanclass="math inline">\(n\)</span>元组，后<spanclass="math inline">\(m\)</span>个分量为<spanclass="math inline">\(S\)</span>中的一个<spanclass="math inline">\(m\)</span>元组。</p></li><li><p>给定一个关系<span class="math inline">\(R(X,Y)\)</span>，<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Z\)</span>为属性组。当<spanclass="math inline">\(t[X]=x\)</span>时，<spanclass="math inline">\(x\)</span>在<spanclass="math inline">\(R\)</span>中的象集定义为</p><p><span class="math inline">\(Z_=\{t[Z]|t\in R,t[X]=x\}\)</span></p><p>它表示<span class="math inline">\(R\)</span>在属性组<spanclass="math inline">\(X\)</span>上值为<spanclass="math inline">\(x\)</span>的诸元组在<spanclass="math inline">\(Z\)</span>上分量的集合。</p></li></ul><h4 id="专门关系运算的定义">专门关系运算的定义</h4><h5 id="选择selection">选择（selection）</h5><p>选择又称为限制（restriction），是在关系<spanclass="math inline">\(R\)</span>中选择满足给定条件的诸元组，记作<spanclass="math inline">\(\sigma _F(R)=\{t|t\in R\wedgeF(t)=true\}\)</span></p><p>其中<spanclass="math inline">\(F\)</span>表示选择条件，它是一个逻辑表达式，取逻辑值真或假。</p><h5 id="投影projection">投影（projection）</h5><p>关系 <span class="math inline">\(R\)</span> 上的投影是从 <spanclass="math inline">\(R\)</span>中选择出若干属性列组成新的关系，记作</p><p><span class="math inline">\(\prod _{A}(R)=\{t[A]|t\inR\}\)</span></p><p>其中 <span class="math inline">\(A\)</span> 为 <spanclass="math inline">\(R\)</span> 的属性列。</p><h5 id="连接join">连接（join）</h5><p>连接也称为<spanclass="math inline">\(\theta\)</span>连接。它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作</p><p><span class="math inline">\(R\Join _{A\theta B}S=\{t_rt_s|t_r\in R\ort_s\in S\or t_r[A]\theta t_s[B] \}\)</span></p><p>其中，<span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 分别为 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 上列数相等且可比的属性组，<spanclass="math inline">\(\theta\)</span>是比较运算符。连接运算从 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 的笛卡尔积 <spanclass="math inline">\(R\times S\)</span> 中选取 <spanclass="math inline">\(R\)</span> 关系在 <spanclass="math inline">\(A\)</span> 属性组上的值与 <spanclass="math inline">\(S\)</span> 关系在 <spanclass="math inline">\(B\)</span> 属性组上的值满足比较关系 <spanclass="math inline">\(\theta\)</span>的元组。</p><ul><li><p><span class="math inline">\(\theta\)</span> 为 =的连接运算称为等值连接，它是从关系 <spanclass="math inline">\(R\)</span> 和 <spanclass="math inline">\(S\)</span> 的笛卡尔积中选取 <spanclass="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span>属性值相等的那些元组。</p></li><li><p>自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中去除重复属性列</p><ul><li>一般的连接操作是从行的角度进行运算，自然连接还需要去除重复列，因而是同时从行和列的角度进行运算</li><li>自然连接中被舍弃的元组称为悬浮元组（danglingtuple），把悬浮元组也保存在结果关系中，而在其他属性值上写<spanclass="math inline">\(null\)</span>，这种连接称为外连接；只保留左关系的悬浮元组称为左外连接，反之为右外连接</li></ul></li></ul><h5 id="除运算division">除运算（division）</h5><p>//以下定义过于抽象，其实就是选择R(X,Y)中Y与S(Y,Z)中的Y具有相同值的所有对应X。</p><p>设关系 <span class="math inline">\(R\)</span> 除以关系 <spanclass="math inline">\(S\)</span> 的结果为关系 <spanclass="math inline">\(T\)</span>，则 <spanclass="math inline">\(T\)</span> 包含所有在 <spanclass="math inline">\(R\)</span> 但不在 <spanclass="math inline">\(S\)</span> 中的属性及其值，且 <spanclass="math inline">\(T\)</span> 的元组与 <spanclass="math inline">\(S\)</span> 的元组的所有组合都在 <spanclass="math inline">\(R\)</span> 中。</p><p>除法的象集定义：</p><p>给定关系 <span class="math inline">\(R(X,Y)\)</span> 和 <spanclass="math inline">\(S(Y,Z)\)</span>，其中<spanclass="math inline">\(X\)</span>、<spanclass="math inline">\(Y\)</span>、<spanclass="math inline">\(Z\)</span>为属性组。<spanclass="math inline">\(R\)</span> 中的 <spanclass="math inline">\(Y\)</span> 与 <spanclass="math inline">\(S\)</span> 中的 <spanclass="math inline">\(Y\)</span>可以有不同的属性名，但必须出自相同的域集。</p><p><span class="math inline">\(R\)</span> 与 <spanclass="math inline">\(S\)</span> 的除运算得到一个新的关系 <spanclass="math inline">\(P(X)\)</span>，<spanclass="math inline">\(P\)</span> 是 <spanclass="math inline">\(R\)</span> 中满足下列条件的元组在 <spanclass="math inline">\(X\)</span> 属性列上的投影：元组在 <spanclass="math inline">\(X\)</span> 上分量值 <spanclass="math inline">\(x\)</span> 的象集 <spanclass="math inline">\(Y_x\)</span> 包含 <spanclass="math inline">\(S\)</span> 在 <spanclass="math inline">\(Y\)</span> 上投影的集合。记作</p><p><span class="math inline">\(R\div S=\{t_r[X] |t_r\in R \and \prod_Y(S)\subseteq Y_X \}\)</span></p><p>除操作也是同时从行和列的角度进行运算。</p><p>关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。</p><h2 id="关系演算">2.5 关系演算</h2><p>不考，暂略</p>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-第一章_绪论</title>
    <link href="/2023/03/01/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/03/01/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80/%E7%AC%AC%E4%B8%80%E7%AB%A0_%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>我自横刀向天笑，去留肝胆两昆仑。</p><span id="more"></span><h1 id="第一章-绪论">第一章 绪论</h1><h2 id="数据库系统概述">1.1 数据库系统概述</h2><h3 id="数据库的4个基本概念">1.1.1 数据库的4个基本概念</h3><p>数据、数据库、数据库管理系统、数据库系统</p><h4 id="数据data">数据（Data）</h4><p>数据是数据库中存储的基本对象，是描述事物的符号记录。</p><p>数据有多种表现形式，可以经过数字化后存入计算机。</p><p>数据的含义称为数据的语义，数据与其语义是不可分的。</p><h4 id="数据库databasedb">数据库（Database，DB）</h4><p>数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，可为各种用户共享。</p><p>数据库数据具有永久存储、有组织和可共享三个基本特点。</p><h4id="数据库管理系统database-management-systemdbms">数据库管理系统（DatabaseManagement System，DBMS）</h4><p>数据库管理系统是计算机的基础软件，主要功能包含以下几个方面：</p><h5 id="数据定义">(1) 数据定义</h5><p>提供数据定义语言（Data DefinitionLanguage，DDL），用以对数据库中的数据对象的组成与结构进行定义</p><h5 id="数据组织存储和管理">(2) 数据组织、存储和管理</h5><h5 id="数据操纵">(3) 数据操纵</h5><p>提供数据操纵语言（Data ManipulationLanguage，DML），用以操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。</p><h5 id="数据库的事务管理和运行管理">(4) 数据库的事务管理和运行管理</h5><h5 id="数据库的建立和维护">(5) 数据库的建立和维护</h5><h5 id="其他功能">(6) 其他功能</h5><p>包括数据库管理系统与网络中其他软件系统的通信功能，异构数据库之间的互访和互操作功能等。</p><h4 id="数据库系统database-systemdbs">数据库系统（DatabaseSystem，DBS）</h4><p>数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DatabaseAdministrator，DBA）组成的存储、管理、处理和维护数据的系统。</p><h3 id="数据库系统的特点">1.1.2 数据库系统的特点</h3><ul><li>文件系统管理数据的缺点：整体无结构，共享性低，冗余度高，独立性差</li></ul><h4 id="数据结构化">数据结构化</h4><p>数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。</p><p>整体结构化是指数据库中的数据不再仅仅针对一个应用，而是面向整个组织或企业；不仅数据内部是结构化的，而且整体是结构化的，数据之间是具有联系的。</p><h4id="数据的共享性高冗余度低且易扩充">数据的共享性高、冗余度低且易扩充</h4><p>数据共享可以大大减少数据冗余，节约存储空间，数据共享还能避免数据之间的不相容性与不一致性。</p><h4 id="数据独立性高">数据独立性高</h4><p>数据库的数据独立性包括数据的物理独立性和逻辑独立性。</p><ul><li><p>物理独立性是指用户的应用程序与数据库中数据的物理存储是相互独立的。</p></li><li><p>逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</p></li></ul><h4id="数据由数据库管理系统统一管理和控制">数据由数据库管理系统统一管理和控制</h4><p>为了保证数据库的并发共享与数据库中数据的正确与一致，数据库管理系统提供以下的数据控制功能：</p><h5 id="数据的安全性保护">(1) 数据的安全性保护</h5><p>保护数据以防止不合法使用造成的数据泄密和破坏。</p><h5 id="数据的完整性检查">(2) 数据的完整性检查</h5><p>数据的完整性指数据的正确性、有效性和相容性。</p><h5 id="并发控制">(3) 并发控制</h5><h5 id="数据库恢复">(4) 数据库恢复</h5><p>数据库管理系统必须具有将数据库从错误状态恢复到某一已知的正确状态的功能。</p><p>数据库是长期存储在计算机内有组织、大量、共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。</p><p>数据库系统的出现使信息系统从以加工数据的程序为中心转为围绕共享的数据库为中心的新阶段。</p><h2 id="数据模型">1.2 数据模型</h2><p>数据模型是对现实世界数据特征的抽象，是数据库系统的核心和基础。</p><p>数据模型分为两类，第一类为概念模型，第二类是逻辑模型和物理模型。</p><ul><li><p>概念模型也称信息模型，它按用户的观点来对数据和信息建模，主要用于数据库设计。</p></li><li><p>逻辑模型主要包括层次模型、网状模型、关系模型、面向对象数据模型和对象关系数据模型、半结构化数据模型等，它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。</p></li><li><p>物理模型是对数据最底层的抽象，描述数据在系统内部的表示和存取方式。物理模型的具体实现是数据库管理系统的任务，数据库设计人员要了解和选择物理模型，最终用户则不需考虑物理级细节。</p></li></ul><p>先将现实世界抽象为信息世界（概念模型），再将信息世界转换为机器世界。</p><h3 id="概念模型">1.2.1 概念模型</h3><p>概念模型是对现实世界的抽象，用于信息世界的建模。</p><h4 id="信息世界的基本概念">信息世界的基本概念</h4><ol type="1"><li>实体（entity）</li></ol><p>客观存在并可相互区别的事物称为实体。</p><ol start="2" type="1"><li>属性（attribute）</li></ol><p>实体所具有的某一特性。</p><ol start="3" type="1"><li>码（key）</li></ol><p>唯一标识实体的属性集称为码</p><ol start="4" type="1"><li>实体型（entity type）</li></ol><p>用实体及其属性名集合来抽象和刻画同类实体，称为实体型。</p><ol start="5" type="1"><li>实体集（entity set）</li></ol><p>同一类型实体的集合称为实体集。</p><ol start="6" type="1"><li>联系（relationship）</li></ol><p>实体内部的联系通常指组成实体的各属性之间的联系，实体之间的联系通常指不同实体集之间的联系。</p><p>实体之间的联系有一对一、一对多、多对多等多种类型。</p><h4id="概念模型的一种表示方法实体-联系方法entity-relationship-approach">概念模型的一种表示方法：实体-联系方法（Entity-Relationshipapproach）</h4><p>该方法用实体-联系图（E-Rdiagram）来描述现实世界的概念模型，E-R方法也称E-R模型。</p><h3 id="数据模型的组成要素">1.2.2 数据模型的组成要素</h3><p>数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成。</p><ol type="1"><li>数据结构</li></ol><p>数据结构描述数据库的组成对象以及对象之间的联系。</p><ol start="2" type="1"><li>数据操作</li></ol><p>数据操作是指对数据库中各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则。</p><ol start="3" type="1"><li>数据的完整性约束条件</li></ol><p>数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。</p><h3 id="常用的数据模型">1.2.3 常用的数据模型</h3><ul><li>层次模型（hierarchical model）</li><li>网状模型（network model）</li><li>关系模型（relational model）</li><li>面向对象数据模型（object oriented data model）</li><li>对象关系数据模型（object relational data model）</li><li>半结构化数据模型（semistructure data model）</li></ul><p>其中层次模型和网状模型称为格式化模型。</p><h4 id="层次模型">层次模型</h4><ol type="1"><li>有且只有一个结点没有双亲结点，该结点为根结点；</li><li>根以外的其他结点有且只有一个双亲结点。</li></ol><p>优点：结构简单清晰、查询效率高、完整性支持好</p><p>缺点：现实世界很多联系是非层次性的</p><h4 id="网状模型">网状模型</h4><ol type="1"><li>允许一个以上的结点没有双亲；</li><li>一个结点可以有一个以上的双亲。</li></ol><p>优点：直观地描述现实世界、存取效率高</p><p>缺点：结构复杂，因而DDL与DML也十分复杂</p><h2 id="数据库系统的结构">1.3 数据库系统的结构</h2><h3 id="数据库系统模式的概念">1.3.1 数据库系统模式的概念</h3><p>数据模型中，型（type）是对某一类数据的结构和属性的说明，值（value）是型的一个具体赋值。</p><p>模式（schema）是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体值。模式的一个具体值称为模式的一个实例。</p><p>模式是相对稳定的，实例时相对变动的。</p><h3 id="数据库系统的三级模式结构">1.3.2 数据库系统的三级模式结构</h3><p>数据库系统由外模式、模式和内模式三级构成。</p><ol type="1"><li>模式</li></ol><p>模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p><ol start="2" type="1"><li>外模式</li></ol><p>外模式也称子模式（subschema）或用户模式，是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用相关的数据的逻辑表示。</p><p>外模式通常是模式的子集。</p><ol start="3" type="1"><li>内模式</li></ol><p>内模式也称存储模式（storageschema），是数据物理结构和存储方式的描述，是数据库内部数据的组织方式。</p><p>一个数据库只有一个内模式</p><h3 id="数据库的二级映像功能与数据独立性">1.3.3数据库的二级映像功能与数据独立性</h3><ol type="1"><li>外模式/模式映像</li></ol><p>模式改变时，数据库管理员对各个外模式/模式映像作相应改变，使外模式保持不变，保证数据逻辑独立性。</p><ol start="2" type="1"><li>模式/内模式映像</li></ol><p>数据库存储结构改变时，数据库管理员对模式/内模式映像作相应改变，使模式保持不变，保证数据物理独立性。</p><p>数据与程序之间的独立性使得数据的定义和描述从应用程序中分离。数据的存取由数据库管理系统管理，简化了应用程序的编制，减少了应用程序的维护与修改。</p><ul><li>文件系统数据独立性是文件间相互独立，而数据库系统数据独立性是逻辑、物理独立性</li></ul><h2 id="数据库系统的组成">1.4 数据库系统的组成</h2><ol type="1"><li><p>硬件平台及数据库</p><ul><li>足够大的内存存放操作系统、数据库管理系统的核心模块、数据缓冲区和应用程序</li><li>足够大的磁盘存放数据库，足够大的磁带作数据备份</li><li>系统有较高的通道能力以提高数据传送率</li></ul></li><li><p>软件</p><ul><li>数据库管理系统</li><li>支持数据库管理系统运行的操作系统</li><li>具有与数据库接口的高级语言及其编译系统，便于开发应用程序</li><li>以数据库管理系统为核心的应用开发工具</li></ul></li><li><p>人员</p><ul><li><p>数据库管理员</p></li><li><p>系统分析员与数据库设计人员</p></li><li><p>应用程序员</p></li><li><p>用户</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据管理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-4.0_树</title>
    <link href="/2022/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter4.0_Tree/"/>
    <url>/2022/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter4.0_Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter4.0tree-树">Chapter4.0：Tree 树</h1><span id="more"></span><h4 id="两类数据结构">两类数据结构</h4><ul><li>线性：列表、栈、队列、字符串</li><li>非线性：树、图</li></ul><h2 id="一树">一、树</h2><h3 id="定义">定义</h3><p>一棵树是一些结点的集合。<br />集合可以为空，否则，这棵树具有一个特殊的称为根的结点，以及零棵或更多非空子树。</p><h3 id="术语">术语</h3><p>结点的度数为其所具有的后代数。<br />树的度数是其结点度数的最大值。<br />度数为0的结点称为叶，度数非0的结点称为枝。<br />层级：根的层级为0(1)，其余结点的层级为其父结点加1。<br />树高：结点的最高层级。</p><h2 id="二二叉树">二、二叉树</h2><h3 id="定义-1">定义</h3><p>一棵二叉树是一些有限个结点的(可以为空)集合。</p><p>当二叉树非空： * 它有一个根结点。 *其余的结点被分为两个二叉树，称为根的左子树和右子树。</p><p>二叉树与树的区别 1.二叉树的每个结点都有且仅有两个子树(可以为空)，而树的每个结点可以有任意个子树。2. 二叉树的结点的左右子树是有顺序区别的，而树的结点的子树是无序的。</p><h3 id="二叉树的性质">二叉树的性质</h3><ol type="1"><li>有n个结点的二叉树有n-1条边。</li><li>在第i层的结点树最多为2^i。</li><li>高度为h的二叉树最少有h+1个结点，最多有2^(h+1)-1个结点</li><li>如果叶的数量为x，度数为2的结点树为y，那么x=y+1</li><li>包含n个结点的二叉树的树高最多为n-1，虽少为[log(n+1)]-1。(底为2)</li></ol><h4 id="满二叉树">满二叉树</h4><p>树高h，包含2^(h+1)-1个结点的二叉树为满二叉树。</p><h4 id="完全二叉树">完全二叉树</h4><p>一棵树高为k的有n个结点的二叉树，如果对树中的结点按从上到下、从左到右的顺序进行编号，编号为i的结点与满二叉树中编号为i的结点位置相同，则这棵二叉树为完全二叉树。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-3.1_栈与队列</title>
    <link href="/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter3.1_Stack&amp;Queue/"/>
    <url>/2022/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter3.1_Stack&amp;Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter3.1stack-queue-栈与队列">Chapter3.1：Stack Queue栈与队列</h1><span id="more"></span><h2 id="一栈">一、栈</h2><p>栈是插入与删除发生在同一端的列表，该端称为顶部，另一端称为底部。栈也被称为LIFO(Last In First Out)列表</p><h3 id="栈的模型">栈的模型</h3><p>Abstract Data Type: Stack：<br />instances: list of elements<br />operations:<br />Create(): Create an empty stack<br />IsEmpty()<br />IsFull()<br />Top(): Return top element of the stack<br />Add(x): add element x to the stack<br />Delete(x) :Delete top element from stack and put it in x</p><h3 id="栈的链表实现">栈的链表实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span>&#123;topOfStack = <span class="hljs-literal">null</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> topOfStack == <span class="hljs-literal">null</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">()</span>&#123;topOfStack = <span class="hljs-literal">null</span>;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(object x)</span>&#123;<br>    topOfStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(x, topOfStack);<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">top</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> topOFStack.element;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Underflow&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty())<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Underflow</span>();<br>    topOfStack = topOfStack.next;<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">topAndPop</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty())<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">topItem</span> <span class="hljs-operator">=</span> topOfStack.element;<br>    topOfStack = topOfStack.next;<br>    <span class="hljs-keyword">return</span> topItem;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> ListNode topOfStack;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈的数组实现">栈的数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">()</span>&#123;<span class="hljs-built_in">this</span>(DEFAULT_CAPACITY);&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>    array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">object</span>[capacity];<br>    topOfStack = -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> topOfStack==-<span class="hljs-number">1</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> topOfStack==theArray.length–<span class="hljs-number">1</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeEmpty</span><span class="hljs-params">()</span>&#123;topOfStack=-<span class="hljs-number">1</span>;&#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(object x)</span> <span class="hljs-keyword">throws</span> overflow&#123;<br>    <span class="hljs-keyword">if</span>(isFull()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Overflow</span>();<br>    array[++topOfStack] = x;<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">top</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> array[topOfStack];<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Underflow&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Underflow</span>();<br>    array[topOfStack--] = <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> object <span class="hljs-title function_">topAndPop</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">topItem</span> <span class="hljs-operator">=</span> top();<br>    array[topOfStack--] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> topItem;<br>  &#125;<br>  <span class="hljs-keyword">private</span> object[] array;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> topOfStack;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>多个栈的存在会导致空间的浪费，当只有两个栈时，我们可以将两个栈在同一个线性表的两端进行存储，两者向中间延伸。</p><h3 id="栈的应用">栈的应用</h3><ul><li>括号匹配</li></ul><h2 id="二队列">二、队列</h2><p>队列是插入和删除发送在两端的线性表，新元素插入的地方称为尾部，旧元素删除的地方称为首部。队列也被称为FIFO(First In First Out)列表。</p><h3 id="队列的模型">队列的模型</h3><p>Abstract Data Type: Queue: instances: ordered list of elementsoperations: Create(): Create an empty queue IsEmpty() IsFull() First():return first element of the queue Last(): return last element of thequeue Add(x): add element x to the queue Delete(x): delete front elementfrom the queue and put it in x</p><h3 id="队列的数组实现">队列的数组实现</h3><p>元素的增加：++back; array[back]=x;<br />元素的删除：两种办法<br />1. ++front; O(1)<br />2. 将整个队列左移 O(n)<br />可以使用循环数组来表示队列，方法有二<br />1. 分类讨论头和尾抵达了数组边界的情况 2. back = (back+1)%array.length;front = (front+1)%array.length</p><h3 id="队列的链表实现">队列的链表实现</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-2.0_算法分析</title>
    <link href="/2022/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter2.0_AlgorithmAnalysis/"/>
    <url>/2022/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter2.0_AlgorithmAnalysis/</url>
    
    <content type="html"><![CDATA[<h2 id="chapter2.0算法分析">Chapter2.0：算法分析</h2><span id="more"></span><p>算法是为解决问题而定义的一系列方法。算法分析主要在于算法占用的时间与空间。算法分析的两个方法：性能分析和性能度量</p><h3 id="空间复杂度">1. 空间复杂度</h3><p>运行完成程序需要的内存空间 组成：指令、数据、环境栈空间此处讨论的存储器主要指内存。 #### (1) 指令空间程序编译成的二进制码的空间大小 又称代码空间本课程中，我们默认忽略指令空间原因：操作系统对代码所占的内存具有一些管理机制，代码所占内存有限 ####(2) 数据空间 定长部分：包含指令、简单变量、定长度的成员变量、常量的内存变长部分：随数据变化而变化的部分，如递归栈、动态分配区域一般而言，变长部分更为重要。 #### (3) 环境栈空间</p><h3 id="时间复杂度">2. 时间复杂度</h3><p>运行完成程序需要的时间长度<br />编译时间不被计算进时间复杂度。<br />计算程序的时间复杂度，关键操作个数是核心，循环中操作个数格外重要。</p><h4 id="最好最差和平均的复杂度分析">最好、最差和平均的复杂度分析</h4><p>平均复杂度往往难以定义。<br />使用算术平均值作为平均复杂度(假设所有情况等概率)是简化的运算，不能完全代表平均情况。</p><p>步骤数计算：count++；</p><h4 id="算法的渐进分析">算法的渐进分析</h4><p>记号：O、𝛺、o、𝜃</p><h5 id="o表示法">O表示法</h5><p>表示算法复杂度的上限<br />定义：f(n)=O(g(n))，即当n尽量大时，存在c，f(n)&lt;=cg(n)。</p><h5 id="o表示法-1">o表示法</h5><p>定义：f(n)=o(g(n))，即当n尽量大时，存在c，f(n)&lt;cg(n)。当前算法复杂度小于该量级。</p><h5 id="𝛺表示法">𝛺表示法</h5><p>表示算法复杂度的下界<br />定义：f(n)=𝛺(g(n))，即当n尽量大时，存在c，f(n)&gt;=cg(n)。</p><h5 id="𝜃表示法">𝜃表示法</h5><p>表示和算法复杂度同等的两级<br />f(n)=𝜃(g(n))，即当n尽量大，存在，，使g(n)&lt;=f(n)&lt;=g(n)。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-1.0_绪论</title>
    <link href="/2022/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter1.0_Intro/"/>
    <url>/2022/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Chapter1.0_Intro/</url>
    
    <content type="html"><![CDATA[<h2 id="chapter1.0绪论">Chapter1.0：绪论</h2><span id="more"></span><p>课程主要是学习数据结构而不倾于算法结构</p><ol type="1"><li><p>关心数据类型和数据处理步骤</p></li><li><p>处理更加复杂、难以计算的部分</p></li><li><p>不依赖于特定编程语言</p></li><li><p>介绍常用算法和数据结构</p></li><li><p>后置课程 ·编译原理 ·操作系统 ·数据库</p></li></ol><h3 id="什么是数据结构">什么是数据结构</h3><ol type="1"><li>数据 数据是信息的载体，是数字、字符和其他符号组成的集合。数据可用于描述客观世界。表示数据的符号可以输入计算机，被计算机识别和处理。 数据分类：</li></ol><ol type="1"><li>数值型(numerical)：int, float, complex</li><li>非数值型(non-numerical)：character, string, graph, voice</li></ol><ol start="2" type="1"><li>数据结构 数据结构是数据对象以及对象各成员间关系的统称。数据结构分类：线性结构(linear structure)与非线性(non-linear)结构</li></ol><p>数据结构是分层的 数据结构涉及三个方面：数据的逻辑结构——从用户视图看，是面向问题的。数据的物理结构——从具体实现视图看，是面向计算机的。相关的操作及其实现。</p><p>Example：学生表 逻辑结构——线性表 物理结构——数组、链表操作——插入、删除、查找</p><p>数据类型：具有操作该类值的操作集的值的集合 大多编程语言具有Atom DataTypes和Structure Data Types两类预定义的数据结构。</p><ol start="3" type="1"><li>ADT和OO ADT：Abstract Data Types 抽象数据类型是将类型和与这个类型有关的操作集合封装在一起的数据模型。OO：Object-oriented 三个方面（考试）：封装、继承、多态 类与继承</li></ol><h3 id="算法">算法</h3><p>算法定义：为了解决某个问题的一系列操作 特点： 1. 明确输入 2. 明确输出3. 确定性 4. 可行性 5. 有穷性</p><p>Deterministic算法：当给固定输入，会有固定输出程序：用编程语言编写，可以在机器上运行，不满足有穷性。</p><h3 id="数学复习">数学复习</h3><p>log底数默认为2。<br />同余：A≡B(mod N)<br />数学归纳法：<br />1. Basis 2. Inductive hypothesis 3. Inductive proof 反证法</p><p>算法思想：递归、分治、贪心、线性规划</p><p>递归：Base cases + Making progress<br />* 直接递归：函数自己调用自己<br />* 间接递归：多个函数相互调用形成环状调用的递归</p><p>泛型 Generic<br />将类型设置为变量。<br />应当尽量避免代码克隆。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Geternitier的博客</title>
    <link href="/2022/06/30/%E5%A4%A9%E9%A9%AC%E6%AD%8C/"/>
    <url>/2022/06/30/%E5%A4%A9%E9%A9%AC%E6%AD%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="天马歌">天马歌</h3><span id="more"></span><p>唐·李白</p><p>天马来出月支窟，背为虎文龙翼骨。<br />嘶青云，振绿发， 兰筋权奇走灭没。<br />腾昆仑，历西极，四足无一蹶。<br />鸡鸣刷燕晡秣越，神行电迈蹑慌惚。<br />天马呼，飞龙趋， 目明长庚臆双凫。<br />尾如流星首渴乌，口喷红光汗沟朱。 曾陪时龙蹑天衢，羁金络月照皇都。<br />逸气棱棱凌九区，白璧如山谁敢沽。<br />回头笑紫燕，但觉尔辈愚。<br />天马奔， 恋君轩，駷跃惊矫浮云翻。<br />万里足踯躅，遥瞻阊阖门。<br />不逢寒风子，谁采逸景孙。<br />白云在青天，丘陵远崔嵬。 盐车上峻坂，倒行逆施畏日晚。<br />伯乐翦拂中道遗，少尽其力老弃之。<br />愿逢田子方，恻然为我悲。<br />虽有玉山禾，不能疗苦饥。<br />严霜五月凋桂枝，伏枥衔冤摧两眉。<br />请君赎献穆天子，犹堪弄影舞瑶池。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_8_信息熵</title>
    <link href="/2022/03/08/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_8%20%E4%BF%A1%E6%81%AF%E7%86%B5/"/>
    <url>/2022/03/08/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_8%20%E4%BF%A1%E6%81%AF%E7%86%B5/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_8-信息熵">DataScience_8 信息熵</h1><h2 id="信息熵">8.1 信息熵</h2><p>信息度量的三个性质：单调性、非负性、可加性</p><ol type="1"><li>单调性：确定性越高的事件的信息量越低</li><li>非负性：非负性是从随机性引入信息度量的必然</li><li>可加性：事件总不确定性可表示为各事件不确定性和</li></ol><h3 id="信息熵-1">信息熵</h3><p><span class="math inline">\(H(X)=-\Sigma_{x\in\mathcalX}p(x)logp(x)\)</span></p><ul><li>非负性</li><li>期望性：<spanclass="math inline">\(H(X)=E(log(1/p(X)))\)</span></li><li>对数底可换：<spanclass="math inline">\(H_b(X)=log_baH_a(X)\)</span></li></ul><h3 id="联合熵">联合熵</h3><p>两个离散随机变量<spanclass="math inline">\(X,Y\)</span>，其联合熵<spanclass="math inline">\(H(X,Y)=-\Sigma_x\Sigma_yp(x,y)log[p(x,y)]\)</span></p><ul><li>联合熵不小于每个独立的熵。</li><li>联合熵不大于每个独立熵的和。</li></ul><h3 id="条件熵">条件熵</h3><p>在已知随机变量<spanclass="math inline">\(X\)</span>的条件下，描述随机变量<spanclass="math inline">\(Y\)</span>所需的信息量。</p><p><spanclass="math inline">\(H(Y|X)=\Sigma_xp(x)H(Y|X=x)=-\Sigma_{x,y}p(x,y)logp(y|x)\)</span>。</p><ul><li>当Y的值完全取决于X的值，条件熵为0。</li><li>独立的随机变量的条件熵等于自身的熵。<spanclass="math inline">\(H(Y|X)=H(X)\)</span>。</li><li>链式法则：<spanclass="math inline">\(H(X,Y)=H(X)+H(Y|X)\)</span>。</li><li>贝叶斯公式：<spanclass="math inline">\(H(Y|X)=H(X|Y)-H(X)+H(Y)\)</span>。</li></ul><h3 id="相对熵">相对熵</h3><p>又称KL散度，两个概率分布P和Q差别的非对称性的度量。P为真实分布，Q为假设分布。</p><p><span class="math inline">\(D_{KL}(P||Q)=-\SigmaP(x)log\frac{Q(x)}{P(x)}\)</span></p><ul><li>非负性：<spanclass="math inline">\(D_{KL}(P||Q)\ge0,D_{KL}(P||Q)=0\)</span>当且仅当<spanclass="math inline">\(P=Q\)</span></li><li>不对称性：<span class="math inline">\(D_{KL}(P||Q)\neD_{KL}(Q||P)\)</span></li></ul><h3 id="交叉熵">交叉熵</h3><p>基于相同事件测度的两个概率分布<spanclass="math inline">\(p\)</span>和<spanclass="math inline">\(q\)</span>的交叉熵是指当基于一个非真实的概率分布<spanclass="math inline">\(q\)</span>进行编码时，在事件集合中唯一标识一个事件所需要的信息量。</p><p><span class="math inline">\(H(p,q)=-\Sigma p(x)logq(x)\)</span></p><ul><li>交叉熵和相对熵：<spanclass="math inline">\(H(p,q)=H(p)+D_{KL}(P||Q)\)</span></li></ul><h2 id="信息变化">8.2 信息变化</h2><h3 id="互信息">互信息</h3><p>两个随机变量的互信息是变量间相互依赖性的量度。</p><p><span class="math inline">\(I(X;Y)=\Sigma_{y\in Y}\Sigma_{x\inX}p(x,y)log(\frac{p(x,y)}{p(x)p(y)})\)</span></p><p>其中<span class="math inline">\(p(x,y)\)</span>是<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>的联合概率分布函数，而<spanclass="math inline">\(p(x),p(y)\)</span>分别是<spanclass="math inline">\(X,Y\)</span>的边缘概率分布函数。</p><h3 id="信息增益">信息增益</h3><p>即相对熵。</p><p>对于离散型随机变量：<span class="math inline">\(Gain(P,Q)=-\SigmaP(x)ln\frac{Q(x)}{P(x)}\)</span></p><p>对于连续型随机变量：<spanclass="math inline">\(Gain(P,Q)=\int_{-\infin}^{\infin}p(x)ln\frac{p(x)}{q(x)}dx\)</span></p><h4 id="信息增益率">信息增益率</h4><p>属性的信息增益和该属性熵的比值：对于数据集合<spanclass="math inline">\(T\)</span>中的属性<spanclass="math inline">\(P\)</span>，</p><p><spanclass="math inline">\(GainRatio(T,P)=\frac{Gain(T,P)}{Entropy(T,P)}\)</span>。</p><p>当<span class="math inline">\(Entropy(T,P)=0\)</span>，<spanclass="math inline">\(P\)</span>的信息增益率无意义。</p><ul><li>属性值为连续数值型，可以用信息增益率来代替信息增益。</li></ul><h3 id="基尼系数">基尼系数</h3><p><spanclass="math inline">\(Gini(D)=1-\Sigma_{i=1}^mp_i^2\)</span></p><p>其中m表示数据集D中类别C的个数，<spanclass="math inline">\(p_i\)</span>表示<spanclass="math inline">\(D\)</span>中一个记录属于<spanclass="math inline">\(C\)</span>的概率。</p><h2 id="最大熵">8.3 最大熵</h2><h3 id="最大熵原理">最大熵原理</h3><p>一个正确的概率分布应该满足下述条件：</p><ol type="1"><li>服从样本数据中的已知的统计证据</li><li>使熵最大化</li></ol><h3 id="最大熵模型">最大熵模型</h3><p>设满足所有约束条件的模型集合为<spanclass="math inline">\(E_{\overlineP}(f_i)=EP(f_i),i=1,2,...,M\)</span></p><p>定义在条件概率分布<spanclass="math inline">\(P(Y|X)\)</span>上的条件熵为<spanclass="math inline">\(H(P)=-\Sigma_{x,y}\overlineP(x)P(y|x)logP(y|x)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_7_线性模型</title>
    <link href="/2022/03/07/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_7%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/03/07/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_7%20%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_7-线性模型">DataScience_7 线性模型</h1><h2 id="回归分析">7.1 回归分析</h2><p>回归分析的主要内容和步骤：</p><ol type="1"><li>将变量分为自变量和因变量</li><li>找出回归模型描述变量间关系</li><li>对回归模型进行统计检验</li><li>通过检验后，使用回归模型，根据自变量预测因变量</li></ol><p>只有一个自变量的称为一元回归，两个及以上自变量的称为多元回归。</p><p>按照回归曲线的形态，回归也可分为线性和非线性回归。</p><h3 id="一元线性回归">7.1.1 一元线性回归</h3><p>若散点呈直线趋势，则认为<spanclass="math inline">\(x,y\)</span>的关系可以用一元线性回归模型描述，将数据描述成下述方程：</p><p><span class="math inline">\(y=a+bx+e\)</span>。</p><p>称上式为总体一元线性回归方程。<spanclass="math inline">\(a+bx\)</span>表示<spanclass="math inline">\(y\)</span>随<spanclass="math inline">\(x\)</span>的变化而线性变化的部分，<spanclass="math inline">\(e\)</span>是一切随机因素影响的总和，称为随机误差。对于<spanclass="math inline">\(x\)</span>某一确定的值，对应<spanclass="math inline">\(y\)</span>值虽然有波动，但<spanclass="math inline">\(e\)</span>的期望值为0。</p><ul><li>通常假设<span class="math inline">\(e\simN(0,\sigma^2)\)</span>。</li></ul><h4 id="最小二乘估计">最小二乘估计</h4><p>计算参数<span class="math inline">\(a,b\)</span>，使得<spanclass="math inline">\(Q(a,b)=\Sigma_{i=1}^ne_i^2=\Sigma_{i=1}^n(y_i-a-bx_i)^2\)</span>最小。</p><h4 id="回归显著性检验">回归显著性检验</h4><p>检验<span class="math inline">\(y\)</span>和<spanclass="math inline">\(x\)</span>是否存在线性关系。</p><p>分解偏差平方和并进行比较。</p><ul><li><p>总偏差平方和：<spanclass="math inline">\(S_T=\Sigma_{i=1}^n(y_i-\overliney)^2\)</span></p></li><li><p>回归偏差平方和：<spanclass="math inline">\(S_R=\Sigma_{i=1}^n(\hat{y_i}-\overliney)^2\)</span></p></li><li><p>随机误差：<spanclass="math inline">\(S_e=\Sigma_{i=1}^n(\hat{y_i}-y_i)^2\)</span></p></li><li><p><span class="math inline">\(S_T=S_R+S_e\)</span></p></li></ul><p><span class="math inline">\(S_R\)</span>应该尽量大，<spanclass="math inline">\(S_e\)</span>应该尽量小。</p><p>且有<span class="math inline">\(\frac{S_e}{\sigma^2}\sim\mathcalX^2(n-2)\)</span>，<spanclass="math inline">\(\frac{S_R}{\sigma^2}\sim\mathcalX^2(1)\)</span>。</p><p>构造统计量<span class="math inline">\(F=\frac{S_R}{\frac{S_e}{(n-2)}}\sim F(1,n-2)\)</span>，给定显著性水平<spanclass="math inline">\(\alpha\)</span>，当<spanclass="math inline">\(F\geF_\alpha(1,n-2)\)</span>，认为样本数据具有显著的相关性。</p><h3 id="广义线性回归">7.1.2 广义线性回归</h3><p>转化为线性化问题。</p><ol type="1"><li>双曲线：<span class="math inline">\(\frac1y=a+\fracbx,y&#39;=\frac1y,x&#39;=\frac bx,y&#39;=a+x&#39;\)</span></li><li>指数：<spanclass="math inline">\(y=ae^{bx},y&#39;=lny,a&#39;=lna,y&#39;=a&#39;+bx\)</span></li><li>对数：<spanclass="math inline">\(y=a+blnx,x&#39;=lnx,y=a+bx&#39;\)</span></li><li>幂函数：<spanclass="math inline">\(y=ax^b,y&#39;=lny,x&#39;=lnx,a&#39;=lna,y&#39;=a&#39;+bx&#39;\)</span></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_6_高维数据</title>
    <link href="/2022/03/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_6%20%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/03/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_6%20%E9%AB%98%E7%BB%B4%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_6-高维数据">DataScience_6 高维数据</h1><h2 id="数据几何学">6.1 数据几何学</h2><h3 id="线性空间">6.1.1 线性空间</h3><h4 id="线性空间-1">线性空间</h4><p>非空集合V称为数域的一个线性空间，当V满足数域上下述八条运算法则：</p><ol type="1"><li><span class="math inline">\(\forall \mathbf u,\mathbf v,\mathbfw\in\mathbf V:(\mathbf u+\mathbf v)+\mathbf w=\mathbf u+(\mathbfv+\mathbf w)\)</span></li><li><span class="math inline">\(\forall \mathbf u,\mathbf v\in\mathbfV:\mathbf u+\mathbf v=\mathbf v+\mathbf u\)</span></li><li>存在元素<span class="math inline">\(\mathbf 0\)</span>：<spanclass="math inline">\(\forall \mathbf u \in\mathbf V:\mathbf u+\mathbf0=\mathbf u\)</span></li><li>对任意的<span class="math inline">\(\mathbfu\)</span>存在负元素<span class="math inline">\(-\mathbfu\)</span>，使得<span class="math inline">\(\mathbf u+(-\mathbfu)=0\)</span></li><li>对于数域中的<span class="math inline">\(1\)</span>，有<spanclass="math inline">\(1\mathbf u=\mathbf u\)</span></li><li><span class="math inline">\(\forall k,l\in \mathbb R,\forall \mathbfu\in\mathbf V,(kl)\mathbf u=k(l\mathbf u)\)</span></li><li><span class="math inline">\(\forall k,l\in \mathbb R,\forall \mathbfu\in\mathbf V,(k+l)\mathbf u=k\mathbf u+l\mathbf u\)</span></li><li><span class="math inline">\(\forall k\in \mathbb R,\forall \mathbfu,\mathbf v\in\mathbf V,k(\mathbf u+\mathbf v)=k\mathbf u+k\mathbfv\)</span></li></ol><h4 id="线性表示">线性表示</h4><p>对于<span class="math inline">\(\mathbf V\)</span>中的一组向量<spanclass="math inline">\(\mathbf u_1,...,\mathbf u_n\)</span>，对于<spanclass="math inline">\(\mathbf v\)</span>，如果存在<spanclass="math inline">\(k_1,...,k_n\)</span>使得<spanclass="math inline">\(\mathbf v=k_1\mathbf u_1+...+k_n\mathbfu_n\)</span>，则称<span class="math inline">\(\mathbfv\)</span>可以被向量组<span class="math inline">\(\mathbfu_1,...,\mathbf u_n\)</span>线性表示。</p><ul><li>如果<span class="math inline">\(\mathbf v\)</span>可以被向量组<spanclass="math inline">\(\mathbf u_1,...,\mathbfu_n\)</span>线性表示，那么系数<spanclass="math inline">\(k_1,...,k_n\)</span>唯一。</li></ul><h4 id="基">基</h4><p>若存在<span class="math inline">\(n\)</span>个线性无关的向量<spanclass="math inline">\(\mathbf u_1,...,\mathbfu_n\)</span>，使得线性空间<span class="math inline">\(\mathbfV\)</span>中任一向量都能被其线性表示，则称<spanclass="math inline">\(\mathbf u_1,...,\mathbf u_n\)</span>为<spanclass="math inline">\(\mathbf V\)</span>的一组基，<spanclass="math inline">\(\mathbf V\)</span>为<spanclass="math inline">\(n\)</span>维线性空间。</p><h4 id="线性映射与线性变换">线性映射与线性变换</h4><p><span class="math inline">\(f\)</span>是线性空间<spanclass="math inline">\(U\)</span>到<spanclass="math inline">\(V\)</span>的映射，若它是线性映射，则满足：</p><ol type="1"><li><span class="math inline">\(\forall \mathbf u,\mathbf u&#39;\inU,f(\mathbf u+\mathbf u&#39;)=f(\mathbf u)+f(\mathbfu&#39;)\)</span></li><li><span class="math inline">\(\forall k\in\mathbb R,\forall \mathbfu\in U,f(k\mathbf u)=kf(\mathbf u)\)</span></li></ol><p>线性变换是线性空间到自身空间的线性映射。</p><ul><li><span class="math inline">\(\mathbf u_1,...,\mathbfu_n\)</span>为<span class="math inline">\(\mathbfV\)</span>的一组基，<spanclass="math inline">\(v_1,...,v_n\)</span>是<spanclass="math inline">\(\mathbf V\)</span>任意<spanclass="math inline">\(n\)</span>个变量，存在唯一的线性变换矩阵<spanclass="math inline">\(A\)</span>使得<spanclass="math inline">\(A[\mathbf u_1,...,\mathbf u_n]^T=[\mathbfv_1,...,\mathbf v_n]^T\)</span>。</li></ul><h4 id="特征值与特征向量">特征值与特征向量</h4><p>看线代去罢。</p><h3 id="维度灾难">6.1.2 维度灾难</h3><p>当空间维度增加时，分析和组织高维空间时，因体积指数增加而遇到各种问题的场景。</p><ul><li>特征维度增加，更易找到分类的超平面</li><li>给定训练样本，维度增加容易带来过拟合</li><li>维度增加，需要的样本数量呈指数增长。</li></ul><h4 id="j-l引理">J-L引理</h4><p>对给定的<spanclass="math inline">\(\varepsilon\in(0,1)\)</span>以及N维欧氏空间中的<spanclass="math inline">\(m\)</span>个点<spanclass="math inline">\(\{x_1,……,x_m\}\)</span>，对于任意满足条件的<spanclass="math inline">\(n&gt;\frac{logm}{\frac{\varepsilon^2}2-\frac{\varepsilon^3}3}\)</span>的正整数<spanclass="math inline">\(n\)</span>，存在一个线性映射<spanclass="math inline">\(f:R^N\rightarrow R^n\)</span>，将这<spanclass="math inline">\(m\)</span>个点，从高维空间<spanclass="math inline">\(R^N\)</span>中映射到低维空间<spanclass="math inline">\(R^n\)</span>中，同时基本上保持了点集成员两两之间的距离，即对于任意两个点<spanclass="math inline">\(x_i,x_j：1\le i\lt j\le m\)</span>，都有<spanclass="math inline">\((1-𝜀)|x_i-x_j|^2\le|f(x_i)-f(x_j)|^2\le(1+𝜀)|x_i-x_j|^2\)</span>。更进一步的，这个线性映射<spanclass="math inline">\(f\)</span>还可以在随机多项式时间内求出。</p><ul><li>直观含义：一个高维空间中的点集，可以被线性嵌入地位空间，同时其空间结构只遭受较小形变，所用算法只需要随机多项式时间。</li></ul><h2 id="数据降维">6.2 数据降维</h2><h3 id="常用降维方法">6.2.1 常用降维方法</h3><p>线性判别分析（LDA）、判别分析（DA）、局部线性嵌入（LLE）</p><h3 id="主成分分析">6.2.2 主成分分析</h3><p>原始数据：<span class="math inline">\(m\)</span>条<spanclass="math inline">\(n\)</span>维数据，组成<spanclass="math inline">\(n\times m\)</span>矩阵<spanclass="math inline">\(X\)</span>。</p><p>计算步骤</p><ol type="1"><li>对<spanclass="math inline">\(X\)</span>的每一行进行0均值化，即减去该行的均值。</li><li>求出<span class="math inline">\(X\)</span>的协方差矩阵<spanclass="math inline">\(C=\frac1mXX^T\)</span>，该矩阵为<spanclass="math inline">\(n\times n\)</span>的。</li><li>计算<span class="math inline">\(C\)</span>的特征值和特征向量<spanclass="math inline">\(C\beta_i=\lambda_i\beta_i,i=1,...,n,\lambda_1\ge...\ge\lambda_n\)</span>。</li><li>特征向量单位化：<spanclass="math inline">\(p_i=\frac{\beta_i}{|\beta_i|},i=1,...,n\)</span>，<spanclass="math inline">\(P^T=(p_1,...p_n)\)</span>。</li><li>取前<spanclass="math inline">\(k\)</span>大的特征值及其对应的单位特征向量，<spanclass="math inline">\(Q^T=(p_1,...,p_k)\)</span>。</li><li>降维：<span class="math inline">\(Y=QX\)</span>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_5_多维分布</title>
    <link href="/2022/03/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_5%20%E5%A4%9A%E7%BB%B4%E5%88%86%E5%B8%83/"/>
    <url>/2022/03/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_5%20%E5%A4%9A%E7%BB%B4%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_5-多维分布">DataScience_5 多维分布</h1><h2 id="多维概率分布">5.1 多维概率分布</h2><h3 id="二维随机变量联合分布">5.1.1 二维随机变量联合分布</h3><h4 id="二维随机变量">二维随机变量</h4><p>设样本空间<span class="math inline">\(\Omega=e,X=X(e)\)</span>和<spanclass="math inline">\(Y=Y(e)\)</span>是定义在<spanclass="math inline">\(\Omega\)</span>上的随机变量，它们构成的一个变量<spanclass="math inline">\((X,Y)\)</span>称为二维随机变量或二维随机向量。</p><h4 id="联合分布">联合分布</h4><p>设<span class="math inline">\((X,Y)\)</span>为二维随机变量，<spanclass="math inline">\(x,y\)</span>是任意实数，称二元函数<spanclass="math inline">\(F(x,y)=P(X\le x\cap Y\le y)=P(X\le x,Y\ley)\)</span>为二维随机变量<spanclass="math inline">\((X,Y)\)</span>的联合分布函数。</p><h4 id="概率分布律">概率分布律</h4><p>设二维离散随机变量<spanclass="math inline">\((X,Y)\)</span>所有可能取值为<spanclass="math inline">\((x_i,y_j)(i,j=1,2,...)\)</span>，则称<spanclass="math inline">\(P(X=x_i,Y=y_j)=p_{ij}\)</span>为设二维离散随机变量<spanclass="math inline">\((X,Y)\)</span>的概率分布律，简称分布律。</p><h4 id="概率密度函数">概率密度函数</h4><p>设二维随机变量<spanclass="math inline">\((X,Y)\)</span>的分布函数为<spanclass="math inline">\(F(x,y)\)</span>，如果存在非负函数<spanclass="math inline">\(f(x,y)\)</span>，使得对于<spanclass="math inline">\(\forall x,y\in \mathbb R\)</span>，都有<spanclass="math inline">\(F(x,y)=\int_{-\infin}^x\int_{-\infin}^yf(s,t)dsdt\)</span>。则称<spanclass="math inline">\((X,Y)\)</span>为二维连续随机变量，并称非负函数<spanclass="math inline">\(f(x,y)\)</span>为<spanclass="math inline">\((X,Y)\)</span>的概率密度函数，或称<spanclass="math inline">\(f(x,y)\)</span>为<spanclass="math inline">\(X,Y\)</span>的联合概率密度。</p><h3 id="二维随机变量边缘分布">5.1.2 二维随机变量边缘分布</h3><h4 id="边缘分布">边缘分布</h4><p>设<spanclass="math inline">\((X,Y)\)</span>为二维随机变量，称一维随机变量<spanclass="math inline">\(X,Y\)</span>的概率分布为二维随机变量<spanclass="math inline">\((X,Y)\)</span>关于<spanclass="math inline">\(X,Y\)</span>对应的边缘分布，分别记作<spanclass="math inline">\(F_X(x),F_Y(y)\)</span>。</p><h4 id="边缘分布律">边缘分布律</h4><p>设二维随机变量<spanclass="math inline">\((X,Y)\)</span>的分布律为<spanclass="math inline">\(p_{ij}\)</span>，那么对于随机变量<spanclass="math inline">\(X,Y\)</span>，其各自的分布律对于固定的<spanclass="math inline">\(i,j=1,2,...\)</span>满足<spanclass="math inline">\(P(X=x_i)=\Sigma_jp_{ij}=p_{i·}\)</span>，则称<spanclass="math inline">\(p+{i·}\)</span>为随机变量<spanclass="math inline">\((X,Y)\)</span>的边缘分布律。</p><h4 id="边缘密度">边缘密度</h4><p>设二维随机变量<spanclass="math inline">\((X,Y)\)</span>的概率密度为<spanclass="math inline">\(f(x,y)\)</span>，边缘概率密度<spanclass="math inline">\(f_X(x),f_Y(y)\)</span>定义为：</p><p><spanclass="math inline">\(f_X(x)=\int_{-\infin}^{+\infin}f(x,y)dy,f_Y(y)=\int_{-\infin}^{+\infin}f(x,y)dx\)</span>。</p><h3 id="条件分布">5.1.3 条件分布</h3><h4 id="条件概率">条件概率</h4><p>离散：</p><p>设<spanclass="math inline">\((X,Y)\)</span>为二维离散型随机变量，其分布律为<spanclass="math inline">\(p_{ij}\)</span>，其边缘概率分别为<spanclass="math inline">\(p_{i·},p_{·j}\)</span>，则其条件概率为：</p><p><spanclass="math inline">\(P(X=x_i|Y=y_j)=\frac{P(X=x_i,Y=y_j)}{P(Y=y_j)}=\frac{p_{ij}}{p_{·j}}\)</span>，</p><p><spanclass="math inline">\(P(Y=y_j|X=x_i)=\frac{P(X=x_i,Y=y_j)}{P(X=x_i)}=\frac{p_{ij}}{p_{i·}}\)</span>。</p><p>连续：</p><p>设<spanclass="math inline">\((X,Y)\)</span>为二维连续型随机变量，其概率密度为<spanclass="math inline">\(f(x,y)\)</span>，其边缘概率分别为<spanclass="math inline">\(f_X(x),f_Y(y)\)</span>。则条件概率密度定义为：<spanclass="math inline">\(f_{X|Y}(x|y)=\frac{f(x,y)}{f_Y(y)},f_{Y|X}(y|x)=\frac{f(x,y)}{f_X(x)}\)</span>。</p><h4 id="独立性">独立性</h4><p>离散：</p><p>设<spanclass="math inline">\((X,Y)\)</span>为二维离散型随机变量，其分布律为<spanclass="math inline">\(p_{ij}\)</span>，其边缘概率分别为<spanclass="math inline">\(p_{i·},p_{·j}\)</span>，且对任意<spanclass="math inline">\(i,j\)</span>有<spanclass="math inline">\(p_{ij}=p_{i·}p_{·j}\)</span>，则称随机变量<spanclass="math inline">\(X,Y\)</span>相互独立。</p><p>连续：</p><p>设<spanclass="math inline">\((X,Y)\)</span>为二维连续型随机变量，其概率密度为<spanclass="math inline">\(f(x,y)\)</span>，其边缘概率分别为<spanclass="math inline">\(f_X(x),f_Y(y)\)</span>，且对任意<spanclass="math inline">\(x,y\)</span>有<spanclass="math inline">\(f(x,y)=f_X(x)f_Y(y)\)</span>，则称随机变量<spanclass="math inline">\(X,Y\)</span>相互独立。</p><h3 id="多维分布的矩">5.1.4 多维分布的矩</h3><p>回顾：随机变量<spanclass="math inline">\(X,Y\)</span>相互独立，则<spanclass="math inline">\(E(XY)=E(X)E(Y),D(X+Y)=D(X)+D(Y)\)</span>。</p><h4 id="混合矩">混合矩</h4><p>设一批数据为<spanclass="math inline">\((X_1,Y_1),...,(X_n,Y_n)\)</span>, 则其<spanclass="math inline">\(k+l\)</span>的混合矩为<spanclass="math inline">\(\frac{\Sigma_{i=1}^nX_i^kY_j^l}{n}\)</span></p><p><spanclass="math inline">\(X,Y\)</span>为随机变量，则其混合矩为：<spanclass="math inline">\(E(X^kY^l)\)</span></p><h4 id="混合中心距">混合中心距</h4><p>设一批数据为<spanclass="math inline">\((X_1,Y_1),...,(X_n,Y_n)\)</span>, 则其<spanclass="math inline">\(k+l\)</span>的混合中心矩为<spanclass="math inline">\(\frac{\Sigma_{i=1}^n(X_i-\overlineX)^k(Y_j-\overline Y)^l}{n}\)</span></p><p><spanclass="math inline">\(X,Y\)</span>为随机变量，则其混合矩为：<spanclass="math inline">\(E((X-EX)^k(Y-EY)^l)\)</span></p><h4 id="协方差">协方差</h4><p>随机变量<span class="math inline">\(X,Y\)</span>的协方差<spanclass="math inline">\(Cov(X,Y)=E((X-EX)(Y-EY))=E(XY)-E(X)E(Y)\)</span>。</p><ul><li><spanclass="math inline">\(Cov(X+Y,Z)=Cov(X,Z)+Cov(Y,Z)\)</span></li><li><span class="math inline">\(D(X+Y)=D(X)+D(Y)+2Cov(X,Y)\)</span></li><li><span class="math inline">\(D(X-Y)=D(X)+D(Y)-2Cov(X,Y)\)</span></li></ul><p>显然，当随机变量<spanclass="math inline">\(X,Y\)</span>相互独立，<spanclass="math inline">\(Cov(X,Y)=0\)</span>。</p><p>协方差的数值会受到<spanclass="math inline">\(X,Y\)</span>的单位的影响<spanclass="math inline">\(\rightarrow\)</span>相关系数。</p><h4 id="相关系数">相关系数</h4><p>设随机变量<spanclass="math inline">\(X,Y\)</span>的数学期望和方差都存在，称<spanclass="math inline">\(\rho_{XY}=\frac{Cov(X,Y)}{\sqrt{D(X)D(Y)}}\)</span>为随机变量<spanclass="math inline">\(X,Y\)</span>的相关系数，也记作<spanclass="math inline">\(corr(X,Y)\)</span>。</p><ul><li><p>Schwarz不等式：<spanclass="math inline">\(Cov(X,Y)^2\le\sigma_X^2\sigma_Y^2\)</span></p></li><li><p>归一性：<spanclass="math inline">\(|\rho_{XY}|\le1\)</span></p></li><li><p>线性相关定理：<spanclass="math inline">\(|\rho_{XY}|=1\)</span>的充要条件是<spanclass="math inline">\(X,Y\)</span>几乎处处线性相关。</p><ul><li>即存在常数<span class="math inline">\(a\ne0,b\)</span>，使得<spanclass="math inline">\(Y=aX+b\)</span>几乎处处成立。</li></ul></li></ul><h3 id="常用二维分布">5.1.5 常用二维分布</h3><h4 id="二维均匀分布">二维均匀分布</h4><p>设G为平面上的有界区域，面积为<spanclass="math inline">\(A\)</span>，若二维随机变量<spanclass="math inline">\((X,Y)\)</span>具有概率密度<spanclass="math inline">\(f(x,y)=\frac1A,(x,y)\in G\)</span>，其他<spanclass="math inline">\(f(x,y)=0\)</span>，称<spanclass="math inline">\((X,Y)\)</span>在G上二维均匀分布。</p><h4 id="二维正态分布">二维正态分布</h4><p>服从参数为<spanclass="math inline">\(\mu_1,\mu_2,\sigma_1,\sigma_2,\rho\)</span>的二维正态分布的随机变量<spanclass="math inline">\(X,Y\)</span>的概率密度为：</p><p><spanclass="math inline">\(f(x,y)=\frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}e^{-\frac1{2(1-\rho^2)}(\frac{(x-\mu_1)^2}{\sigma_1^2}-2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}+\frac{(y-\mu_2)^2}{\sigma_2^2})},-\infin&lt;x,y&lt;+\infin\)</span>。</p><p>显然，边缘密度函数为<spanclass="math inline">\(f_X(x)=\frac1{\sqrt{2\pi\sigma_1}}e^{-\frac{(x-\mu_1)^2}{2\sigma_1^2}},f_Y(y)=\frac1{\sqrt{2\pi\sigma_2}}e^{-\frac{(y-\mu_2)^2}{2\sigma_2^2}}\)</span>，</p><p>即<span class="math inline">\(X\sim N(\mu_1,\sigma_1^2),Y\simN(\mu_2,\sigma_2^2)\)</span>且与<spanclass="math inline">\(\rho\)</span>无关。</p><h2 id="函数的概率分布">5.2 函数的概率分布</h2><p>基本解法：随机变量<span class="math inline">\(Y\)</span></p><ul><li><span class="math inline">\(Y\)</span>离散，写出<spanclass="math inline">\(Y\)</span>的可能取值，找出<spanclass="math inline">\(Y=y_i\)</span>的等价事件<spanclass="math inline">\(X\in D\)</span>，<spanclass="math inline">\(P(Y=y_i)=P(X\in D)\)</span>。</li><li><span class="math inline">\(Y\)</span>连续，写出<spanclass="math inline">\(Y\)</span>的分布函数<spanclass="math inline">\(F_Y(y)=P_Y(Y\le y)\)</span>，找出<spanclass="math inline">\(Y\le y\)</span>的等价事件<spanclass="math inline">\(X\in D\)</span>，求得<spanclass="math inline">\(F_Y(y)=P(X\in D)\)</span>，再求概率密度函数<spanclass="math inline">\(f_Y(y)\)</span>。</li></ul><p>定理：</p><p><span class="math inline">\(X\)</span>的密度函数为<spanclass="math inline">\(f_X(x)\)</span>，<spanclass="math inline">\(-\infin\lt x\lt\infin\)</span>，<spanclass="math inline">\(Y=g(X)\)</span>，<spanclass="math inline">\(g(x)\)</span>严格单调，则<spanclass="math inline">\(Y\)</span>的概率密度为<spanclass="math inline">\(f_Y(y)=f_x(h(y))|h&#39;(y)|,a\lt t\ltb\)</span>。</p><p>其中<spanclass="math inline">\(a=min(g(-\infin),g(\infin)),b=max(g(-\infin),g(\infin))\)</span>，<spanclass="math inline">\(h(x)\)</span>为<spanclass="math inline">\(g(x)\)</span>的反函数。</p><p>定理：</p><p><span class="math inline">\(Y=g(X)\)</span>为随机变量<spanclass="math inline">\(X\)</span>的函数，<spanclass="math inline">\(g\)</span>为连续函数，则</p><ol type="1"><li><span class="math inline">\(X\)</span>离散，分布律为<spanclass="math inline">\(p_k,k=1,2,...\)</span>，如果级数<spanclass="math inline">\(\Sigma_{k=1}^\infing(x_k)p_k\)</span>绝对收敛，则<spanclass="math inline">\(E(Y)=E(g(X))=\Sigma_{k=1}^\infing(x_k)p_k\)</span>。</li><li><span class="math inline">\(X\)</span>连续，密度函数<spanclass="math inline">\(f(x)\)</span>，<spanclass="math inline">\(\int_{-\infin}^{+\infin}g(x)f(x)dx\)</span>绝对收敛，则<spanclass="math inline">\(E(Y)=E(g(X))=\int_{-\infin}^{+\infin}g(x)f(x)dx\)</span>。</li></ol><h2 id="相关性分析和独立性检验">5.3 相关性分析和独立性检验</h2><h3 id="pearson相关系数">5.3.1 Pearson相关系数</h3><p>两个样本<span class="math inline">\(X,Y\)</span>的Pearsonr相关系数通常使用<spanclass="math inline">\(X,Y\)</span>的相关系数除以两者的标准差来计算。</p><p>Pearson r的性质：</p><ol type="1"><li><p><span class="math inline">\(r\in[-1,1]\)</span>，当<spanclass="math inline">\(r\gt0\)</span>，<spanclass="math inline">\(Y\)</span>与<spanclass="math inline">\(X\)</span>正相关，<spanclass="math inline">\(r\)</span>越大表示线性关系越强；</p><p><span class="math inline">\(r=1\)</span>，<spanclass="math inline">\(X,Y\)</span>存在严格线性相关关系；</p><p><span class="math inline">\(r&lt;0\)</span>，<spanclass="math inline">\(Y\)</span>与<spanclass="math inline">\(X\)</span>负相关，<spanclass="math inline">\(r\)</span>越小，线性关系越强；</p><p><span class="math inline">\(r=-1\)</span>，<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>存在严格线性相关关系。</p></li><li><p><span class="math inline">\(r\)</span>具有对称性，<spanclass="math inline">\(r_{XY}=r_{YX}\)</span>。</p></li><li><p><span class="math inline">\(r\)</span>与<spanclass="math inline">\(X,Y\)</span>的尺度、和原点无关，即将原有样本数据经线性变换后不改变<spanclass="math inline">\(r\)</span>值。</p></li><li><p><span class="math inline">\(r\)</span>只描述<spanclass="math inline">\(X,Y\)</span>之间的线性关系，即使存在某种完全的非线性关系也可能<spanclass="math inline">\(r=0\)</span>.</p></li><li><p><spanclass="math inline">\(r\)</span>只描述线性关系，不描述因果关系。</p></li></ol><p>Pearson r计算公式：</p><p><spanclass="math inline">\(r_{XY}=\frac{n\Sigma_iX_iY_i-\Sigma_iX_i\Sigma_iY_i}{\sqrt{n\Sigma_iX_i^2-(\Sigma_iX_i)^2}\sqrt{n\Sigma_iY_i^2-(\Sigma_iY_i)^2}}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_4_推断统计</title>
    <link href="/2022/03/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_4%20%E6%8E%A8%E6%96%AD%E7%BB%9F%E8%AE%A1/"/>
    <url>/2022/03/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_4%20%E6%8E%A8%E6%96%AD%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_4-推断统计">DataScience_4 推断统计</h1><p>参数估计与假设检验</p><h2 id="参数估计">4.1 参数估计</h2><p>参数估计是在抽样分布的基础上，从总体中抽取样本，根据样本统计量来估计和推断所关心的未知参数的方法。</p><ul><li>两种基本形式：点估计、区间估计</li></ul><p>估计量：用于估计总体参数的随机变量。</p><p>估计值：估计参数时计算出的统计量的具体值。</p><h3 id="点估计">4.1.1 点估计</h3><p>依据样本<spanclass="math inline">\(X=(X_1,...,X_n)\)</span>估计总体分布所含的未知参数<spanclass="math inline">\(\theta\)</span>或<spanclass="math inline">\(\theta\)</span>的函数<spanclass="math inline">\(h(\theta)\)</span>。</p><p>一般<span class="math inline">\(\theta\)</span>或<spanclass="math inline">\(\theta\)</span>的函数<spanclass="math inline">\(h(\theta)\)</span>是总体的某个数字特征，如数学期望、方差、相关系数等。</p><h4 id="矩估计">矩估计</h4><p>用样本原点矩的值估计总体矩。</p><p>随机变量X服从某总体分布，其中包含k个未知参数<spanclass="math inline">\(\theta_1,...,\theta_k\)</span>，<spanclass="math inline">\(\mu_l=E(X^l)\)</span>为总体的l阶矩。<spanclass="math inline">\(X_1,...,X_n\)</span>为来自X的样本，<spanclass="math inline">\(A_l\)</span>为样本的l阶矩，求解方程组<spanclass="math inline">\(A_i=\mu_i,i=1,...,k\)</span>得到估计值<spanclass="math inline">\(\theta_1,...,\theta_k\)</span>。</p><p>矩估计定理：</p><p>设随机变量X的数学期望<spanclass="math inline">\(\mu\)</span>和方差<spanclass="math inline">\(\sigma^2\)</span>都存在，且<spanclass="math inline">\(\sigma^2\gt0\)</span>。<spanclass="math inline">\(\mu,\sigma^2\)</span>均未知。<spanclass="math inline">\(X_1,...,X_n\)</span>为来自X的样本，则<spanclass="math inline">\(\mu,\sigma^2\)</span>的估计量<spanclass="math inline">\(\hat\mu=\overline X,\hat{\sigma^2}=\frac 1n\Sigma_{i=1}^n(X_i-\overline X)^2\)</span></p><p>优先采取阶数更低的估计值。</p><h4 id="极大似然估计">极大似然估计</h4><p>x为样本值，<spanclass="math inline">\(\theta\)</span>是需要估计的总体参数，<spanclass="math inline">\(L(\theta)\)</span>为似然函数，则<spanclass="math inline">\(\hat\theta=arg_\theta maxL(\theta)\)</span>。</p><ol type="1"><li>X为离散随机变量，<spanclass="math inline">\(P(X=x)={(x;\theta)}\)</span>，则<spanclass="math inline">\(L(\theta)=\prod_{i=1}^nP(x;\theta)\)</span>。</li><li>X为连续随机变量，概率密度为<spanclass="math inline">\(f(x;\theta)\)</span>，则<spanclass="math inline">\(L(\theta)=\prod_{i=1}^nf(x;\theta)\)</span>。</li></ol><p>泊松分布极大似然估计定理：<spanclass="math inline">\(\hat\lambda=\overline x\)</span></p><p>指数分布极大似然估计定理：<spanclass="math inline">\(\hat\lambda=\frac 1 {\overline{X}}\)</span></p><p>正态分布极大似然估计定理：<spanclass="math inline">\(\hat\mu=\overline X,\hat{\sigma^2}=\frac 1n\Sigma_{i=1}^n(X_i-\overline X)^2\)</span></p><p>均匀分布极大似然估计定理：<span class="math inline">\(X\sim \mathbbU(a,b)\)</span>，<spanclass="math inline">\(a=min(X_i),b=max(X_i)\)</span>。</p><h3 id="评估分析">4.1.2 评估分析</h3><p>参数估计量和估计方法的评价标准：</p><ul><li>无偏性</li><li>有效性</li><li>一致性</li></ul><h4 id="无偏性">无偏性</h4><p>无偏估计：估计量抽样分布的数学期望等于被估总体参数。</p><p>示例：</p><p>设总体的均值为<span class="math inline">\(\mu\)</span>，方差为<spanclass="math inline">\(\sigma^2\)</span>，<spanclass="math inline">\(X_1,...,X_n\)</span>为总体一样本，</p><p>样本均值为<span class="math inline">\(\overline X=\frac 1 n\Sigma_{i=1}^nX_i\)</span>，样本方差为<spanclass="math inline">\(S^2=\frac 1 {n-1}\Sigma_{i=1}^n(X_i-\overlineX)\)</span>，则</p><p><span class="math inline">\(E(\overline X)=\mu,Var(\overline X)=\frac{\sigma^2} n,E(S^2)=\sigma^2\)</span>。</p><p>所以<span class="math inline">\(\overline X,S^2\)</span>为<spanclass="math inline">\(\mu\)</span>和<spanclass="math inline">\(\sigma^2\)</span>的无偏估计。</p><p>设总体X的k阶矩<spanclass="math inline">\(\mu_k=E(X^k)\)</span>，<spanclass="math inline">\(k\ge1\)</span>，无论总体服从什么分布，k阶样本矩<spanclass="math inline">\(A_k=\frac 1n\Sigma_{i=1}^nX_i^k\)</span>都是k阶总体矩<spanclass="math inline">\(\mu_k\)</span>的无偏估计量。</p><p>一个参数可以有多个无偏估计。</p><h4 id="有效性">有效性</h4><p>对于某总体未知参数的两个无偏估计量，相应抽样分布的方差越小则越有效。</p><h4 id="一致性">一致性</h4><p>随着样本容量增大，估计量越来越接近总体参数。</p><h3 id="区间估计">4.1.3 区间估计</h3><p>设总体X的分布<spanclass="math inline">\(F(x;\theta)\)</span>中含有未知参数<spanclass="math inline">\(\theta\)</span>，若存在参数的两个估计量<spanclass="math inline">\(\underline\theta(X_1,...,X_n),\overline\theta(X_1,...,X_n)\)</span>，对于给定的<spanclass="math inline">\(\alpha\in(0,1)\)</span>，有<spanclass="math inline">\(P\{\underline\theta\lt\theta\lt\overline\theta\}=1-\alpha\)</span>。</p><p>则<spanclass="math inline">\((\underline\theta,\overline\theta)\)</span>为总体参数<spanclass="math inline">\(\theta\)</span>的置信水平为<spanclass="math inline">\(1-\alpha\)</span>的置信区间，<spanclass="math inline">\(\underline\theta,\overline\theta\)</span>分别称为置信下限和置信上限。</p><h4 id="单总体均值区间估计">单总体均值区间估计</h4><p><spanclass="math inline">\(X_1,...,X_n\)</span>为来自总体的一个样本，计算总体均值<spanclass="math inline">\(\mu\)</span>的置信水平为<spanclass="math inline">\(1-\alpha\)</span>的置信区间。</p><ol type="1"><li>总体近似服从正态分布，<spanclass="math inline">\(\sigma^2\)</span>已知：</li></ol><p><span class="math inline">\(\frac{\overline X-\mu}{\sigma/\sqrtn}\sim N(0,1)\)</span>，置信区间为<span class="math inline">\((\overlineX-\frac\sigma{\sqrt n}z_{\frac\alpha 2},\overline X+\frac\sigma{\sqrtn}z_{\frac\alpha 2})\)</span>。</p><ol start="2" type="1"><li>总体近似服从正态分布，<spanclass="math inline">\(\sigma^2\)</span>未知：</li></ol><p><span class="math inline">\(\frac{\overline X-\mu}{S/\sqrt n}\simt(n-1)\)</span>，置信区间为<span class="math inline">\((\overlineX-\frac S{\sqrt n}t_{\frac\alpha 2}(n-1),\overline X+\frac S{\sqrtn}t_{\frac\alpha 2}(n-1))\)</span>。</p><ol start="3" type="1"><li>总体不服从正态分布，但样本容量较大：</li></ol><p><span class="math inline">\(\frac{\overline X-\mu}{S/\sqrt n}\simN(0,1)\)</span>，置信区间为<span class="math inline">\((\overlineX-\frac S{\sqrt n}z_{\frac\alpha 2},\overline X+\frac S{\sqrtn}z_{\frac\alpha 2})\)</span>。</p><h4 id="单总体方差区间估计">单总体方差区间估计</h4><p><spanclass="math inline">\(X_1,...,X_n\)</span>为来自总体的一个样本，计算总体方差<spanclass="math inline">\(\sigma^2\)</span>的置信水平为<spanclass="math inline">\(1-\alpha\)</span>的置信区间，<spanclass="math inline">\(\mu\)</span>未知。</p><p><span class="math inline">\(\frac{(n-1)S^2}{\sigma^2}\sim\mathcalX^2(n-1)\)</span>，有<span class="math inline">\(P\{\mathcalX^2_{1-\frac\alpha2}(n-1)\}\lt\frac{(n-1)S^2}{\sigma^2}\lt P\{\mathcalX^2_{\frac\alpha2}(n-1)\}\)</span></p><p>则置信区间为<span class="math inline">\((\frac{(n-1)S^2}{\mathcalX^2_{\frac\alpha2}(n-1)},\frac{(n-1)S^2}{\mathcalX^2_{1-\frac\alpha2}(n-1)})\)</span>。</p><h4 id="双总体均值差区间估计">双总体均值差区间估计</h4><p><span class="math inline">\(X_1,...,X_{n_1}\)</span>和<spanclass="math inline">\(Y_1,...,Y_{n_2}\)</span>是来自某两个总体的样本，且两样本独立。对于给定的置信水平<spanclass="math inline">\(\alpha\)</span>，计算关于两总体均值差<spanclass="math inline">\(\mu_1-\mu_2\)</span>的置信水平为<spanclass="math inline">\(1-\alpha\)</span>的置信区间。</p><ol type="1"><li>两总体近似服从正态分布<spanclass="math inline">\(N(\mu_1,\sigma_1^2)\)</span>和<spanclass="math inline">\(N(\mu_2,\sigma_2^2)\)</span>，<spanclass="math inline">\(\mu_1,\mu_2\)</span>未知，<spanclass="math inline">\(\sigma_1^2,\sigma_2^2\)</span>已知。</li></ol><p><span class="math inline">\(\overline X-\overline Y\simN(\mu_1-\mu_2,\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2})\)</span></p><ol start="2" type="1"><li>两总体近似服从正态分布<spanclass="math inline">\(N(\mu_1,\sigma_1^2)\)</span>和<spanclass="math inline">\(N(\mu_2,\sigma_2^2)\)</span>，<spanclass="math inline">\(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2\)</span>未知，但<spanclass="math inline">\(\sigma_1^2=\sigma_2^2\)</span>。</li></ol><p><span class="math inline">\(\frac{(\overline X-\overlineY)-(\mu_1-\mu_2)}{S_w\sqrt{1/n_1+2/n_2}}\sim t(n_1+n_2-2)\)</span></p><ol start="3" type="1"><li>两总体不服从正态分布，但样本量较大。</li></ol><p><span class="math inline">\(\overline X-\overline Y\simN(\mu_1-\mu_2,\frac{S_1^2}{n_1}+\frac{S_2^2}{n_2})\)</span></p><h4 id="双总体方差比区间估计">双总体方差比区间估计</h4><p><span class="math inline">\(X_1,...,X_{n_1}\)</span>和<spanclass="math inline">\(Y_1,...,Y_{n_2}\)</span>是来自某两个总体的样本，且两样本独立。对于给定的置信水平<spanclass="math inline">\(\alpha\)</span>，计算关于两总体方差比<spanclass="math inline">\(\frac{\sigma_1^2}{\sigma_2^2}\)</span>的置信水平为<spanclass="math inline">\(1-\alpha\)</span>的置信区间。</p><p>估计条件：两总体近似服从正态分布<spanclass="math inline">\(N(\mu_1,\sigma_1^2)\)</span>和<spanclass="math inline">\(N(\mu_2,\sigma_2^2)\)</span>，<spanclass="math inline">\(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2\)</span>未知。</p><p><spanclass="math inline">\(\frac{S_1^2/S_2^2}{\sigma_1^2/\sigma_2^2}\simF(n_1-1,n_2-1)\)</span></p><h2 id="假设检验">4.2 假设检验</h2><p>在样本的基础上对总体的某种结论作出判断。</p><h3 id="参数假设检验">4.2.1 参数假设检验</h3><p>参数假设检验是对总体分布中未知参数的假设检验。</p><p>检验方法参考区间估计。</p><h3 id="非参数假设检验">4.2.2 非参数假设检验</h3><p>对未知分布函数类型或其某些特征提出的假设进行检验。</p><h4 id="符号检验">符号检验</h4><p>两个总体，从总体分布<spanclass="math inline">\(F(x),G(x)\)</span>中分别取容量为<spanclass="math inline">\(n\)</span>的样本<spanclass="math inline">\(X_1,...,X_n\)</span>和<spanclass="math inline">\(Y_1,...,Y_n\)</span>，检验<spanclass="math inline">\(H_0:F(x)=G(x),H_1:F(x)\ne G(x)\)</span>。</p><p>首先将样本数据配对排列，当<span class="math inline">\(x_i\gty_i,n_+\)</span>加一，<span class="math inline">\(x_i\lty_i,n_-\)</span>加一。</p><p>计算临界值<span class="math inline">\(c_1,c_2\)</span>，如果<spanclass="math inline">\(c_1\le n_+\le c_2\)</span>，不拒绝原假设：</p><p><span class="math inline">\(P(n_+\lec_1)=\Sigma_{i=0}^{c_1}C_n^i(0.5)^n\le\frac\alpha2\)</span></p><p><span class="math inline">\(P(n_+\gec_2)=\Sigma_{i=c_2}^{n}C_n^i(0.5)^n\le\frac\alpha2\)</span></p><h4 id="秩和检验">秩和检验</h4><p>双总体非参数假设检验。</p><p>两总体中分别取容量为<spanclass="math inline">\(n_1,n_2\)</span>的样本，检验假设：</p><p><span class="math inline">\(H_0:F(x)=G(x),H_1:F(x)\neG(x)\)</span></p><p>若原假设<spanclass="math inline">\(H_0\)</span>成立，将两总体的观察值放在一起并排序，两样本的数据应该均匀分散在队列中。</p><p>样本数据的秩是该数据在混合排序后的序号，若几个样本数据相同，则每个数据的秩取为这几个数据的序号的平均数。求出每个观察值的秩，将属于<spanclass="math inline">\(X\)</span>的样本数据的秩求和为<spanclass="math inline">\(R_1\)</span>，总体<spanclass="math inline">\(Y\)</span>的秩和为<spanclass="math inline">\(R_2\)</span>。</p><p>假设<span class="math inline">\(R_1\le R_2\)</span>，取<spanclass="math inline">\(T=R_1\)</span>作为统计量，根据给定<spanclass="math inline">\(\alpha\)</span>查表得临界值<spanclass="math inline">\(T_1,T_2\)</span>，若<spanclass="math inline">\(T\)</span>在两者之间，则不能拒绝原假设<spanclass="math inline">\(H_0\)</span>，两样本间总体差异不显著。</p><p>大样本逼近：样本容量较大时，<spanclass="math inline">\(T\)</span>近似服从<spanclass="math inline">\(N(\mu,\sigma^2)\)</span>，其中</p><p><spanclass="math inline">\(\mu=\frac{n_1(n_1+n_2+1)}{2},\sigma^2=\frac{n_1n_2(n_1+n_2+1)}{12}\)</span>。则<spanclass="math inline">\(U=\frac{T-\mu}{\sigma}\sim N(0,1)\)</span>。</p><p>秩和检验的拒绝域为<span class="math inline">\(|U|\gtz_{\frac\alpha2}\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_3_抽样分布</title>
    <link href="/2022/03/03/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_3%20%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"/>
    <url>/2022/03/03/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_3%20%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_3-抽样分布">DataScience_3 抽样分布</h1><h2 id="数据抽样">3.1 数据抽样</h2><h3 id="抽样方法">3.1.1 抽样方法</h3><ul><li><p>简单随机抽样：每个样本点被抽样的概率相等</p></li><li><p>系统抽样：排列所有单位，随机抽取一个单位为初始单位，再按一定规则抽取其他单位</p><ul><li>如<span class="math inline">\(r+nk\)</span></li></ul></li><li><p>整群抽样：抽取群而不是个体</p></li><li><p>分层抽样：样本分层，每层抽样</p></li></ul><h3 id="矩与抽样">3.1.2 矩与抽样</h3><p>抽样分布：统计量的分布</p><h4 id="统计量抽样收敛定理">统计量抽样收敛定理</h4><p>设<span class="math inline">\(\mu\)</span>和<spanclass="math inline">\(\sigma^2\)</span>分别为总体的均值和方差，<spanclass="math inline">\(X_1,...,X_n\)</span>为总体一样本，样本均值为<spanclass="math inline">\(\overline X=\frac 1 n\Sigma_{i=1}^nX_i\)</span>，样本方差为<spanclass="math inline">\(S^2=\frac 1 {n-1}\Sigma_{i=1}^n(X_i-\overlineX)^2\)</span>，则有：</p><ol type="1"><li><span class="math inline">\(E(\overline X)=\mu\)</span></li><li><span class="math inline">\(D(\overline X)=\frac {\sigma^2}n\)</span></li><li><span class="math inline">\(E(S^2)=\sigma^2\)</span></li></ol><h2 id="极限定理">3.2 极限定理</h2><h3 id="矩的不等式">3.2.1 矩的不等式</h3><h4 id="马尔科夫不等式">马尔科夫不等式</h4><p>设随机变量X非负且具有数学期望<spanclass="math inline">\(E(X)\)</span>，<span class="math inline">\(\forall\varepsilon\gt0\)</span>，有<spanclass="math inline">\(P(X\ge\varepsilon)\le\frac{E(X)}\varepsilon\)</span>。</p><ul><li><span class="math inline">\(E(X)\ge\varepsilonP(X\ge\varepsilon)\)</span></li></ul><h4 id="切比雪夫不等式">切比雪夫不等式</h4><p>设随机变量X具有数学期望<spanclass="math inline">\(E(X)=\mu\)</span>，方差<spanclass="math inline">\(D(X)=\sigma^2\)</span>，则<spanclass="math inline">\(\forall \varepsilon\gt0\)</span>，有</p><p><spanclass="math inline">\(P(|X-\mu|\ge\varepsilon)\le\frac{\sigma^2}{\varepsilon^2}\)</span>或等价于<spanclass="math inline">\(P(|X-\mu|\lt\varepsilon)\ge1-\frac{\sigma^2}{\varepsilon^2}\)</span></p><p>方差为0的充要条件：<spanclass="math inline">\(P(X=E(X))=1\)</span>。</p><h3 id="大数定律">3.2.2 大数定律</h3><h4 id="伯努利大数定律">伯努利大数定律</h4><p><span class="math inline">\(X_n\sim\mathbb B(n,p)\)</span>，<spanclass="math inline">\(\forall\varepsilon\gt0\)</span>，有<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(|\frac{x_n}{n}-p|\lt\varepsilon)=1\)</span>。</p><h4 id="切比雪夫大数定律">切比雪夫大数定律</h4><p>设<spanclass="math inline">\(X_1,...,X_n\)</span>为独立（可以非同分布）随机变量，有相同的数学期望<spanclass="math inline">\(\mu\)</span>和有限的方差<spanclass="math inline">\(\sigma_i^2\)</span>，</p><p><span class="math inline">\(\forall \varepsilon\gt0\)</span>，有<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(|\frac1n\Sigma_{i=1}^nX_i-\frac1n\Sigma_{i=1}^nEX_i|\lt\varepsilon)=1\)</span>。</p><h4 id="辛钦大数定律">辛钦大数定律</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>为<spanclass="math inline">\(X\)</span>的独立同分布随机变量，<spanclass="math inline">\(E(X)=\mu\)</span>存在，</p><p><span class="math inline">\(\forall\varepsilon\gt0\)</span>，有<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(|\frac1n\Sigma_{i=1}^nX_i-\mu|&lt;\varepsilon)=1\)</span>。</p><h4 id="弱大数定律">弱大数定律</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>为<spanclass="math inline">\(X\)</span>的独立同分布随机变量，<spanclass="math inline">\(E(X)\)</span>存在，则<spanclass="math inline">\(\overline X_n\)</span>依概率收敛于<spanclass="math inline">\(EX\)</span>，</p><p><span class="math inline">\(\forall\varepsilon\gt0\)</span>，有<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(|\frac1n\Sigma_{i=1}^nX_i-EX|&lt;\varepsilon)=1\)</span>。</p><p>大数定律告诉我们可以用频率近似替代概率，用样本均值近似替代总体均值。</p><h3 id="中心极限定理">3.2.3 中心极限定理</h3><h4 id="德莫弗-拉普拉斯中心极限定理">德莫弗-拉普拉斯中心极限定理</h4><p><span class="math inline">\(X_n\sim\mathbb B(n,p)\)</span>，则<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(\frac{X_n-np}{\sqrt{np(1-p)}}\lex)=\frac1{\sqrt{2\pi}}\int_{-\infin}^xe^{-\frac{t^2}2}dt\)</span></p><h4 id="独立同分布中心极限定理">独立同分布中心极限定理</h4><p>设<spanclass="math inline">\(X_1,...,X_n\)</span>为独立（可以非同分布）随机变量，有相同的数学期望<spanclass="math inline">\(\mu\)</span>和方差<spanclass="math inline">\(\sigma^2\)</span>，随机变量之和<spanclass="math inline">\(Y_n=\frac{\Sigma_{i=1}^nX_i-n\mu}{\sqrtn\sigma}\)</span>，则有<spanclass="math inline">\(\lim_{n\rightarrow\infin}P(Y_n\lex)=\int_{-\infin}^x\frac1{\sqrt{2\pi}}e^{-\frac{t^2}2}dt\)</span>。</p><h4 id="均值抽样分布定理">均值抽样分布定理</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>是总体<spanclass="math inline">\(\mathbb N(\mu,\sigma^2)\)</span>的样本，<spanclass="math inline">\(\overline X\)</span>是样本均值，则有<spanclass="math inline">\(\overline X\sim\mathbbN(\mu,\frac{\sigma^2}n)\)</span>。</p><h2 id="常用抽样分布">3.3 常用抽样分布</h2><h3 id="伽马函数">3.3.0 伽马函数</h3><p><spanclass="math inline">\(\Gamma(x)=\int_0^{+\infin}t^{x-1}e^{-t}dt(x\gt0)\)</span>，其中负整数和0是它的一阶极点。</p><ul><li><p><span class="math inline">\(\Gamma(n)=(n-1)!\)</span>，<spanclass="math inline">\(n\in\mathbb N^*\)</span></p></li><li><p>对<span class="math inline">\(x\in(0,1)\)</span>，有<spanclass="math inline">\(\Gamma(x)\Gamma(1-x)=\frac\pi{sin\pix}\)</span>，可得<spanclass="math inline">\(\Gamma(\frac12)=\sqrt\pi\)</span></p></li></ul><h4 id="伽马分布">伽马分布</h4><p><spanclass="math inline">\(f(x)=\frac{\beta^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\betax},x\gt0\)</span></p><ul><li>数学期望：<span class="math inline">\(\frac\alpha\beta\)</span></li><li>方差：<span class="math inline">\(\frac\alpha{\beta^2}\)</span></li></ul><p>x越大，伽马函数越趋近于Stirling公式，当x够大，可以用Stirling公式计算伽马函数值：</p><p><spanclass="math inline">\(\Gamma(x)\sim\sqrt{2\pi}e^{-x}x^{x-\frac12}\)</span></p><h3 id="卡方分布">3.3.1 卡方分布</h3><p>设<span class="math inline">\(X_1,...,X_n\)</span>是<spanclass="math inline">\(\mathbbN(0,1)\)</span>的独立同分布随机变量，则称随机变量<spanclass="math inline">\(\mathcalX^2=\Sigma_{i=1}^nX_i^2\)</span>服从自由度为n的<spanclass="math inline">\(\mathcal X^2\)</span>分布，记为<spanclass="math inline">\(\mathcal X^2(n)\)</span>。</p><ul><li>概率密度：<span class="math inline">\(f(x)=\frac1{2^{\fracn2}\Gamma(\frac n2)}x^{\frac n2-1}e^{-\frac x2},x\gt0\)</span>。</li><li>卡方分布是<span class="math inline">\(\alpha=\fracn2,\beta=\frac12\)</span>的伽马分布特例。</li><li>数学期望：n</li><li>方差：2n</li></ul><p>可加性：</p><p>设<span class="math inline">\(X_1\sim\mathcalX^2(n_1),X_2\sim\mathcal X^2(n_2)\)</span>，且<spanclass="math inline">\(X_1,X_2\)</span>相互独立，则<spanclass="math inline">\(X_1+X_2\sim\mathcal X^2(n_1+n_2)\)</span>。</p><h4 id="方差抽样分布定理">方差抽样分布定理</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>是总体<spanclass="math inline">\(\mathbbN(\mu,\sigma^2)\)</span>的样本，样本方差为<spanclass="math inline">\(S^2\)</span>，则有<spanclass="math inline">\(\frac{(n-1)S^2}{\sigma^2}\sim\mathcalX^2(n-1)\)</span>。</p><h3 id="t分布">3.3.2 t分布</h3><p>设<span class="math inline">\(X\sim\mathbb N(0,1),Y\sim\mathcalX^2(n)\)</span>，且<spanclass="math inline">\(X,Y\)</span>相互独立，称随机变量<spanclass="math inline">\(t=\frac X{\sqrt{\fracYn}}\)</span>服从自由度为n的t分布。</p><ul><li><p>概率密度函数：<spanclass="math inline">\(f(x)=\frac{\Gamma(\frac{n+1}2)}{\sqrt{n\pi}\Gamma(\frac2n)}(1+\frac{x^2}n)^{-\frac{n+1}2}\)</span></p></li><li><p>数字特征：<span class="math inline">\(T=\fracXY\)</span>，有<span class="math inline">\(E(T)=0,D(T)=\fracn{n-2}\)</span></p></li><li><p>上<span class="math inline">\(\alpha\)</span>分位点：</p><p>对于给定的<spanclass="math inline">\(\alpha\in(0,1)\)</span>，称满足<spanclass="math inline">\(P(t\gt t_\alpha(n))=\alpha\)</span>的<spanclass="math inline">\(t_\alpha(n)\)</span>为<spanclass="math inline">\(t(n)\)</span>分布的上<spanclass="math inline">\(\alpha\)</span>分位点。</p></li><li><p><span class="math inline">\(t\)</span>分布关于<spanclass="math inline">\(x=0\)</span>对称，故<spanclass="math inline">\(t_\alpha(n)=-t_{1-\alpha}(n)\)</span>。</p></li></ul><p><span class="math inline">\(t\)</span>分布的正态收敛性：<spanclass="math inline">\(t(n)\)</span>分布的概率密度<spanclass="math inline">\(f(x)\)</span>趋于标准正态分布的概率密度：</p><p><spanclass="math inline">\(\lim_{n\rightarrow\infin}f(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}2}\)</span>。</p><h4 id="均值抽样分布定理t分布">均值抽样分布定理（t分布）</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>是总体<spanclass="math inline">\(\mathbbN(\mu,\sigma^2)\)</span>的样本，总体方差未知，<spanclass="math inline">\(\overline X\)</span>是样本均值，<spanclass="math inline">\(S^2\)</span>为样本方差，则有<spanclass="math inline">\(\frac{\overline X-\mu}{S/\sqrt{n}}\simt(n-1)\)</span>。</p><h3 id="f分布">3.3.3 F分布</h3><p>设<span class="math inline">\(X\sim\mathcal X^2(n_1),Y\sim\mathcalX^2(n_2)\)</span>，且<spanclass="math inline">\(X,Y\)</span>相互独立，则随机变量<spanclass="math inline">\(F=\frac{\frac X{n_1}}{\fracY{n_2}}=\frac{n_2X}{n_1Y}\)</span>服从自由度为<spanclass="math inline">\(n_1,n_2\)</span>的F分布，记为<spanclass="math inline">\(F(n_1,n_2)\)</span>，其中<spanclass="math inline">\(n_1\)</span>为第一自由度，<spanclass="math inline">\(n_2\)</span>为第二自由度。</p><ul><li><p>数学期望：<spanclass="math inline">\(\frac{n_2}{n_2-2}\)</span>。</p></li><li><p>倒数对称性：<spanclass="math inline">\(F_{1-\alpha}(n_1,n_2)=\frac1{F_\alpha(n_2,n_1)}\)</span>。</p></li></ul><h4 id="正态分布逼近定理">正态分布逼近定理</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>与<spanclass="math inline">\(Y_1,...,Y_n\)</span>分别来自正态总体<spanclass="math inline">\(\mathbb N(\mu_1,\sigma_1^2)\)</span>和<spanclass="math inline">\(\mathbb N(\mu_2,\sigma_2^2)\)</span>，则</p><p><span class="math inline">\(\frac{\overline X-\overlineY-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}\simN(0,1)\)</span>。</p><h4 id="方差抽样分布定理f分布">方差抽样分布定理（F分布）</h4><p>设<span class="math inline">\(X_1,...,X_n\)</span>与<spanclass="math inline">\(Y_1,...,Y_n\)</span>分别来自正态总体<spanclass="math inline">\(\mathbb N(\mu_1,\sigma_1^2)\)</span>和<spanclass="math inline">\(\mathbbN(\mu_2,\sigma_2^2)\)</span>，样本方差为<spanclass="math inline">\(S_1^2\)</span>和<spanclass="math inline">\(S_2^2\)</span>，则有<spanclass="math inline">\(\frac{(S_1^2)/(S_2^2)}{(\sigma_1^2)/(\sigma_2^2)}\simF(n_1-1,n_2-1)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_2_数据抽象</title>
    <link href="/2022/03/02/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_2%20%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"/>
    <url>/2022/03/02/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_2%20%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_2-数据抽象">DataScience_2 数据抽象</h1><h2 id="概率">2.1 概率</h2><h3 id="随机试验">2.1.1 随机试验</h3><p>如果一个试验满足以下3个条件：</p><ol type="1"><li>试验可以在相同的条件下重复进行</li><li>试验的所有可能结果明确可知，且不止一个</li><li>每一次试验会出现哪一个结果，事先并不能确定</li></ol><p>则称此试验为随机试验，简称试验。</p><p>大量重复试验中具有某种规律性的事件称为<strong>随机事件</strong>，简称事件。</p><h3 id="样本空间">2.1.2 样本空间</h3><p>随机试验中的每一个可能出现的试验结果称为该试验的一个样本点，全体样本点组成的集合称为该试验的样本空间。</p><ul><li><p>样本空间的任意一个子集是一个随机事件。</p></li><li><p>样本空间<spanclass="math inline">\(\Omega\)</span>包含所有样本点，称为必然事件，<spanclass="math inline">\(\varnothing\)</span>为不可能事件。</p></li><li><p>包含一个样本点的随机事件成为基本事件，包含多个样本点的随机事件称为复合事件。</p></li></ul><p>事件的关系和计算</p><ol type="1"><li><span class="math inline">\(A\subseteqB\)</span>，事件B包含事件A，即事件A发生必然导致事件B发生。</li><li><span class="math inline">\(A=B\)</span>，事件A与B相等。</li><li><span class="math inline">\(A\cap B\)</span>或<spanclass="math inline">\(AB\)</span>，事件A和B同时发生，称为A与B的交/积事件。<ul><li><spanclass="math inline">\(AB\neq\varnothing\)</span>，称A和B相容</li><li><span class="math inline">\(AB=\varnothing\)</span>，称A和B互斥</li></ul></li><li><span class="math inline">\(A\cupB\)</span>，事件A和B至少有一个发生，称为A与B的交/积事件。</li><li><spanclass="math inline">\(A-B\)</span>，事件A发生而B不发生，称为A与B的差事件。</li><li><span class="math inline">\(\overlineA\)</span>，事件A不发生，称为事件A的逆事件或对立事件。</li><li>如果<spanclass="math inline">\(\bigcup_{i=1}^nA_i=\Omega\)</span>，称这有限个事件<spanclass="math inline">\(A_i\)</span>构成一个完备事件组。</li></ol><h3 id="概率-1">2.1.3 概率</h3><p>公理化定义：</p><p>设随机试验的样本空间为<spanclass="math inline">\(\Omega\)</span>，如果对每一个事件A都有一个确定的实数<spanclass="math inline">\(P(A)\)</span>，且满足：</p><ol type="1"><li><p>非负性：<span class="math inline">\(P(A)\ge 0\)</span></p></li><li><p>规范性：<span class="math inline">\(P(\Omega) =1\)</span></p></li><li><p>可列可加性：<span class="math inline">\(P(\bigcup_{i=1}^\infinA_i)=\Sigma_{i=1}^\infin P(A_i)\)</span></p></li></ol><p>则称<span class="math inline">\(P(A)\)</span>为事件A的概率。</p><h4 id="古典概型">古典概型</h4><p>样本空间有穷且每个样本点等可能，这种概率模型称为古典概型。</p><h4 id="几何概型">几何概型</h4><p>样本空间是个可度量的有界区域，每个样本点等可能，这种概率模型称为几何概型。</p><h4 id="概率的性质">概率的性质</h4><ol type="1"><li><p>有界性：任意事件A，<span class="math inline">\(0\leP(A)\le1\)</span>，<span class="math inline">\(P(\varnothing) =0\)</span>，<span class="math inline">\(P(\Omega)=1\)</span>。</p></li><li><p>单调性：<span class="math inline">\(A\subseteqB\)</span>，则<spanclass="math inline">\(P(B-A)=P(B)-P(A)\)</span>，<spanclass="math inline">\(P(B)\ge P(A)\)</span>。</p></li></ol><h4 id="概率公式">概率公式</h4><ol type="1"><li><p><span class="math inline">\(P(\overlineA)=1-P(A)\)</span></p></li><li><p>加法公式：<span class="math inline">\(P(A\cupB)=P(A)+P(B)-P(AB)\)</span></p></li><li><p>减法公式：<spanclass="math inline">\(P(A-B)=P(A)-P(AB)=P(A\overlineB)\)</span></p></li><li><p>条件概率公式：<spanclass="math inline">\(P(B|A)=\frac{P(AB)}{P(A)}\)</span></p><p>若<spanclass="math inline">\(P(A)\gt0\)</span>，称已知A发生的条件下，B发生的概率为条件概率，记为<spanclass="math inline">\(P(B|A)\)</span>。</p></li><li><p>乘法公式：如果<spanclass="math inline">\(P(A)\gt0\)</span>，<spanclass="math inline">\(P(AB)=P(A)P(B|A)\)</span></p></li><li><p>全概率公式：若<span class="math inline">\(\bigcup_{i=1}^nA_i=\Omega\)</span>且<spanclass="math inline">\(A_iA_j=\varnothing\)</span>，<spanclass="math inline">\(P(A_i)\gt0\)</span>，则对任意事件B，</p><p><spanclass="math inline">\(B=\bigcup_{i=1}^nA_iB,P(B)=\Sigma_{i=1}^nP(A_i)P(B|A_i)\)</span></p></li><li><p>贝叶斯公式：若<span class="math inline">\(\bigcup_{i=1}^nA_i=\Omega\)</span>且<spanclass="math inline">\(A_iA_j=\varnothing\)</span>，<spanclass="math inline">\(P(A_i)\gt0\)</span>，则对任意事件B，只要<spanclass="math inline">\(P(B)\gt0\)</span>，就有<spanclass="math inline">\(P(A_j|B)=\frac{P(A_j)P(B|A_j)}{\Sigma_{i=1}^nP(A_i)P(B|A_i)}\)</span></p></li></ol><h3 id="独立性">2.1.4 独立性</h3><p>事件是否发生对另一个事件的概率没有影响，这样的两个事件为相互独立事件。</p><p>事件A和事件B相互独立时，<spanclass="math inline">\(P(AB)=P(A)P(B)\)</span>。</p><ul><li>事件A和事件B相互独立时，<span class="math inline">\(\overlineA\)</span>与<span class="math inline">\(B\)</span>、<spanclass="math inline">\(A\)</span>与<span class="math inline">\(\overlineB\)</span>、<span class="math inline">\(\overline A\)</span>与<spanclass="math inline">\(\overline B\)</span>也相互独立。</li><li>事件A和事件B相互独立时，<spanclass="math inline">\(P(A)\gt0\)</span>，则有<spanclass="math inline">\(P(B|A)=P(B)\)</span>。</li></ul><h2 id="随机变量">2.2 随机变量</h2><p>给定样本空间，若对于每一个样本点都有唯一确定的实数X与之对应，则称X是一个随机变量。</p><p>随机变量X的概率分布函数：<span class="math inline">\(F(x)=P(X\lex)\)</span></p><ul><li>分布函数性质：非负性；单调不减；右连续；左极限为0，右极限为1</li></ul><h3 id="离散随机变量">离散随机变量</h3><p>随机变量的取值为可列个，则称其为离散随机变量。</p><h3 id="连续随机变量">连续随机变量</h3><p>对于随机变量<span class="math inline">\(X\)</span>及其分布函数<spanclass="math inline">\(F(x)\)</span>，如果存在非负可积函数<spanclass="math inline">\(f(x)\)</span>满足<spanclass="math inline">\(\forall x:F(x)=\int_{-\infin}^xf(t)dt\)</span>，则称<spanclass="math inline">\(X\)</span>为连续随机变量，<spanclass="math inline">\(f(x)\)</span>为<spanclass="math inline">\(X\)</span>的概率密度函数。</p><p>连续随机变量的性质：</p><ol type="1"><li>如果<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x\)</span>处连续，那么<spanclass="math inline">\(F&#39;(x)=f(x)\)</span>。</li><li>连续随机变量<spanclass="math inline">\(X\)</span>的任意一点概率为0，即<spanclass="math inline">\(P(X=x)=0\)</span>。</li></ol><h2 id="数据动力学">2.3 数据动力学</h2><p>数据科学借鉴了物理学的矩的概念，用数据分布代替物理量分布，用概率密度代替物理密度函数。矩是对变量分布和形态特点的一组度量。</p><p>原点矩：给定一批数据<spanclass="math inline">\(x_1,x_2,...,x_n\)</span>，其<spanclass="math inline">\(k\)</span>阶原点矩<spanclass="math inline">\(A_k=\frac{1}{n}\Sigma_{i=1}^nx_i^k\)</span>。</p><ul><li>我们称1阶原点矩为算术平均值，2阶原点矩为数据集的转动惯量。</li></ul><h3 id="数学期望">数学期望</h3><p>离散随机变量的数学期望：<spanclass="math inline">\(E(X)=\Sigma_{i=1}^\infin x_ip_i\)</span>。</p><p>连续随机变量的数学期望：<spanclass="math inline">\(E(X)=\int_{-\infin}^{+\infin}xf(x)dx\)</span></p><ul><li>要求<span class="math inline">\(\Sigma_{i=1}^\infinx_ip_i\)</span>和<spanclass="math inline">\(\int_{-\infin}^{+\infin}xf(x)dx\)</span>绝对收敛。</li></ul><p>数学期望的性质：</p><ol type="1"><li>常数<span class="math inline">\(C\)</span>，<spanclass="math inline">\(E(C)=C\)</span></li><li>常数<span class="math inline">\(C\)</span>及随机变量<spanclass="math inline">\(X\)</span>，<spanclass="math inline">\(E(CX)=CE(X)\)</span></li><li>设随机变量<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>，<spanclass="math inline">\(E(X+Y)=E(X)+E(Y)\)</span></li><li>设随机变量<span class="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>独立，<spanclass="math inline">\(E(XY)=E(X)E(Y)\)</span></li></ol><p>中心矩：</p><p>给定随机变量X，若<spanclass="math inline">\(E((X-EX)^k)\)</span>存在，则其k阶中心矩的定义为<spanclass="math inline">\(E((X-EX)^k)\)</span>。</p><ul><li>2阶中心矩即方差，记为<spanclass="math inline">\(\sigma^2(X)\)</span>或<spanclass="math inline">\(D(X)\)</span>或<spanclass="math inline">\(Var(X)\)</span>。</li><li><spanclass="math inline">\((\sigma^2(X))^{\frac{1}{2}}\)</span>即标准差，记为<spanclass="math inline">\(\sigma(X)\)</span>。</li><li><span class="math inline">\(D(X)=E(X^2)-E(X)^2\)</span></li></ul><p>方差的性质：</p><ol type="1"><li><span class="math inline">\(C\)</span>为常数，<spanclass="math inline">\(D(C)=0\)</span>。</li><li>设<span class="math inline">\(X\)</span>为随机变量，<spanclass="math inline">\(C\)</span>为常数，则<spanclass="math inline">\(D(C+X)=D(X),D(CX)=C^2D(X)\)</span>。</li><li>随机变量<span class="math inline">\(X\)</span>与<spanclass="math inline">\(Y\)</span>相互独立，<spanclass="math inline">\(D(X+Y)=D(X)+D(Y),D(X-Y)=D(X)-D(Y)\)</span>。</li></ol><h2 id="概率分布">2.4 概率分布</h2><h3 id="数学工具">2.4.0 数学工具</h3><p>#### 泰勒展开</p><p>若<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=a\)</span>处无穷可微，则当<spanclass="math inline">\(x\rightarrow a\)</span>时，有<spanclass="math inline">\(f(x)=\Sigma_{n=0}^\infin\frac{f^{(n)}(a)}{n!}(x-a)^n\)</span>。</p><p><span class="math inline">\(\Sigma_{n=0}^\infin\frac{f^{(n)}(a)}{n!}(x-a)^n\)</span>称为<spanclass="math inline">\(f(x)\)</span>的泰勒级数。若<spanclass="math inline">\(a=0\)</span>则称为麦克劳林级数。</p><h4 id="矩生成函数">矩生成函数</h4><p>随机变量X的矩生成函数<spanclass="math inline">\(M_X(s)\)</span>定义为：<spanclass="math inline">\(M_X(s)=E[e^{sX}]\)</span>。</p><p>如果存在常数<span class="math inline">\(\delta\)</span>使得<spanclass="math inline">\(M_X(s)\)</span>对于任意<spanclass="math inline">\(s\in[-\delta,\delta]\)</span>有穷，则称<spanclass="math inline">\(M_X(s)\)</span>存在。</p><p>矩生成定理：</p><p>假设随机变量X的矩生成函数<spanclass="math inline">\(M_X(s)\)</span>存在，则<spanclass="math inline">\(E[X^k]=\frac{d^k}{ds^k}M_X(s)|_{s=0}\)</span>。</p><p>矩生成函数的唯一性定理：</p><p>对于两个随机变量X和Y，假设存在常数<spanclass="math inline">\(\delta\)</span>使得<spanclass="math inline">\(M_X(s)\)</span>和<spanclass="math inline">\(M_Y(s)\)</span>对于任意<spanclass="math inline">\(s\in[-\delta,\delta]\)</span>存在且相等，则X和Y的分布函数相等。</p><p>矩生成函数可加性定理：</p><p><spanclass="math inline">\(X_1,X_2,...,X_n\)</span>为独立随机变量，则<spanclass="math inline">\(M_{X_1+X_2+...+X_n}(s)=M_{X_1}(s)M_{X_2}(s)...M_{X_n}(s)\)</span>。</p><h3 id="离散概率分布">2.4.1 离散概率分布</h3><h4 id="伯努利分布">伯努利分布</h4><p>随机变量<span class="math inline">\(X\)</span>，<spanclass="math inline">\(P(X=k)=p^kq^{1-k}\)</span>，且满足<spanclass="math inline">\(k=0,1,p\in(0,1),q=1-p\)</span>，</p><p>则称<span class="math inline">\(X\)</span>服从参数为<spanclass="math inline">\(p\)</span>的伯努利分布，记为<spanclass="math inline">\(X\sim Bern(p)\)</span>。</p><p>数学期望：<span class="math inline">\(p\)</span></p><p>方差：<span class="math inline">\(p(1-p)\)</span></p><p>矩生成函数：<span class="math inline">\(M_X(s)=q+pe^s\)</span></p><h4 id="二项分布">二项分布</h4><p>随机变量<span class="math inline">\(X\)</span>，<spanclass="math inline">\(P(X=k)=(_k^n)p^k(1-p)^{n-k},k=0,1,...,n\)</span>，</p><p>称<span class="math inline">\(X\)</span>服从参数<spanclass="math inline">\(n\)</span>，<spanclass="math inline">\(p\)</span>的二项分布，记为<spanclass="math inline">\(X\sim \mathbb B(n,p)\)</span>。</p><p>数学期望：<span class="math inline">\(np\)</span></p><p>方差：<span class="math inline">\(np(1-p)\)</span></p><p>矩生成函数：<spanclass="math inline">\(M_X(s)=(q+pe^s)^n\)</span></p><p>二项分布可加性：</p><p>二项分布随机变量<span class="math inline">\(X\sim \mathbbB(m,p)\)</span>和<span class="math inline">\(Y\sim \mathbbB(n,p)\)</span>相互独立，则有<span class="math inline">\(X+Y\sim\mathbbB(m+n,p)\)</span>。</p><h4 id="泊松分布">泊松分布</h4><p>随机变量<span class="math inline">\(X\)</span>，<spanclass="math inline">\(P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda},k=0,1,...,n,\lambda\gt0\)</span>，</p><p>称<span class="math inline">\(X\)</span>服从参数为<spanclass="math inline">\(\lambda\)</span>的泊松分布，记作<spanclass="math inline">\(X\sim\pi(\lambda)\)</span>。</p><p>数学期望：<span class="math inline">\(\lambda\)</span></p><p>方差：<span class="math inline">\(\lambda\)</span></p><p>矩生成函数：<spanclass="math inline">\(M_X(s)=e^{\lambda(e^s-1)}\)</span></p><p>泊松逼近定理：</p><p>设<span class="math inline">\(\lambda\gt 0\)</span>是一个常数，<spanclass="math inline">\(n\)</span>为正整数，若<spanclass="math inline">\(np\)</span>近似<spanclass="math inline">\(\lambda\)</span>，则对于任一固定的非负整数k，有</p><p><spanclass="math inline">\(\lim_{n\rightarrow\infin}(_k^n)p_n^k(1-p_n)^{n-k}=\frac{\lambda^k}{k!}e^{-\lambda}\)</span>。</p><h4 id="几何分布">几何分布</h4><p>随机变量X，<spanclass="math inline">\(P(X=k)=q^{k-1}p,k=1,2,...,q=1-p\)</span>，</p><p>称X服从参数为p的几何分布，记作<spanclass="math inline">\(X\sim\mathbb G(p)\)</span>。</p><ul><li>几何分布的无记忆性：<span class="math inline">\(P(X\gt m+n|X\gtm)=P(X\gt n)\)</span></li></ul><p>数学期望：<span class="math inline">\(\frac 1 p\)</span></p><p>方差：<span class="math inline">\(\frac{1-p}{p^2}\)</span></p><p>矩生成函数：<spanclass="math inline">\(M_X(s)=\frac{pe^s}{1-(1-p)e^s}\)</span></p><h4 id="超几何分布">超几何分布</h4><p>随机变量<span class="math inline">\(X\)</span>，<spanclass="math inline">\(P(X=k)=\frac{C_M^kC_{N-M}^{n-k}}{C_N^n},k=1,2,...,n,N,M,n\in\mathbb Z,M\ge N,n\ge N\)</span>，</p><p>称<span class="math inline">\(X\)</span>服从参数为<spanclass="math inline">\(N,M,n\)</span>的超几何分布，记为<spanclass="math inline">\(X\sim\mathbb H(N,M,n)\)</span>。</p><ul><li>形象描述：<span class="math inline">\(N\)</span>件产品中有<spanclass="math inline">\(M\)</span>件次品，随机抽取<spanclass="math inline">\(n\)</span>件产品，恰有<spanclass="math inline">\(k\)</span>件次品的概率。</li></ul><p>数学期望：<span class="math inline">\(n\frac M N\)</span></p><p>方差：<span class="math inline">\(n\frac M N\frac {N-M} N\frac{N-n}{N-1}\)</span></p><h3 id="连续概率分布">2.4.2 连续概率分布</h3><h4 id="均匀分布">均匀分布</h4><p><span class="math inline">\(X\sim\mathbbU(a,b)\)</span>，概率密度函数<span class="math inline">\(f(x)=\frac1{b-a},a\lt x\lt b\)</span>。</p><p>数学期望：<span class="math inline">\(\frac {a+b} 2\)</span></p><p>方差：<span class="math inline">\(\frac {(b-a)^2} {12}\)</span></p><h4 id="指数分布">指数分布</h4><p><span class="math inline">\(X\sim\mathbbE(\lambda)\)</span>，概率密度函数<spanclass="math inline">\(f(x)=\lambda e^{-\lambda x},x\gt 0,\lambda\gt0\)</span>。</p><ul><li>指数分布的无记忆性：<span class="math inline">\(P(X\gt s+t|X\gts)=P(X\gt t),\forall s,t\gt 0\)</span></li></ul><p>数学期望：<span class="math inline">\(\frac 1 {\lambda}\)</span></p><p>方差：<span class="math inline">\(\frac 1 {\lambda^2}\)</span></p><h4 id="正态分布">正态分布</h4><p><span class="math inline">\(X\sim\mathbbN(\mu,\sigma^2)\)</span>，概率密度函数<spanclass="math inline">\(f(x)=\frac{1}{\sqrt{2\pi\sigma}}e^{-\frac{(x-\mu)^2}{2\sigma^2}},-\infin\ltx\lt+\infin,\sigma\gt 0\)</span>。</p><p>数学期望：<span class="math inline">\(\mu\)</span></p><p>方差：<span class="math inline">\(\sigma^2\)</span></p><ul><li>正态分布的对称性</li><li>正态分布的标准化：<span class="math inline">\(Z=\frac{X-\mu}\sigma\)</span>，则<span class="math inline">\(Z\sim\mathbbN(0,1)\)</span>。</li></ul><p>二项分布正态逼近定理：<spanclass="math inline">\(\lim_{n\rightarrow\infin}\mathbb B(n,p)=\mathbbN(\mu,\sigma^2)\)</span></p><p>泊松分布正态逼近定理：<spanclass="math inline">\(\lim_{n\rightarrow\infin}\pi(\lambda)=\mathbbN(\mu,\sigma^2)\)</span></p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础_1_基础知识</title>
    <link href="/2022/03/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/03/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80/DataScience_1%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>八月秋高风怒号，卷我屋上三重茅。</p><span id="more"></span><h1 id="datascience_1-基础知识">DataScience_1 基础知识</h1><h2 id="dikw模型">1.1 DIKW模型</h2><p>原始观察获得数据，分析数据获得信息，实践应用产生知识，智慧则凭借已有知识预测未来。</p><ol type="1"><li>数据：自然世界抽象为集合元素的表示。</li></ol><p>在实际应用中，采用某种数学元素作为数据的抽象表示<spanclass="math inline">\(d\)</span>，数据集为相应的集合<spanclass="math inline">\(\mathcal{D}\)</span>。</p><ol start="2" type="1"><li>信息：数据赋予某种结构获得信息<spanclass="math inline">\(\mathcal{I}=\mathcal{S}(\mathcalD)\)</span>。</li></ol><p>信息通常能被人类所理解，被用来消除不确定性。</p><p>常见的数学结构包括序结构、代数结构、拓扑结构等等。</p><ol start="3" type="1"><li>知识：信息和规则的二元组<span class="math inline">\(\mathcalK=&lt;\mathcal I,\mathcal R&gt;\)</span>。</li></ol><p>信息和规则结合获得知识，并且能够推理出更多知识。</p><p>知识推理从方式上可分为演绎推理和归纳推理；从单调性上可分为单调与非单调推理；从方法上可分为基于规则、模型、事例推理。</p><ul><li>非单调推理：新知识的加入可能使原先的知识变为假。</li></ul><ol start="4" type="1"><li>智慧：收集、加工、应用、传播知识的能力。</li></ol><h2 id="数据类型">1.2 数据类型</h2><h3 id="表示数据类型">1.2.1 表示数据类型</h3><p>从数据表示的视角，数据可分为结构化与非结构化数据。</p><p>结构化数据指高度组织化，可通过关系数据库输入、检索和操作的数据，往往是定量数据。</p><p>非结构化数据没有预定义的数据模型，通常存储于非关系数据库中，常常是定性数据。</p><p>半结构化数据介于两者之间，使用元数据（标签和语义标记）来识别特定的数据特征并将数据缩放为记录和预设字段。</p><h3 id="计算数据类型">1.2.2 计算数据类型</h3><p>统计数据是采用某种计量尺度对事物进行计量的结果，采用不同计量尺度会得到不同类型的统计数据。从计量的角度来看，统计数据可分为定类、定序、定距、定比数据。</p><p>前两类数据不能用数值表示，称为定性数据，后两类能用数值表示，称为定量数据。</p><ol type="1"><li><p>定类数据：事物的分类结果。</p></li><li><p>定序数据：反映对象顺序，表现为类别，可以进行偏序。</p></li><li><p>定距数据：具有顺序和距离属性，可以进行加减。</p></li></ol><p>定距数据中没有固定的0位。</p><ol start="4" type="1"><li>定比数据：具有顺序、距离、比例属性，可以进行加减乘除，没有负数。</li></ol><p>这四类数据级别从低到高，高级别数据可以用低级类型的数据分析方法来分析，反之则不行。</p><p>定类数据：饼图、柱状图</p><p>定序数据：柱状图</p><p>数字数据：直方图、折线图</p><h2 id="数据汇总">1.3 数据汇总</h2><h3 id="集中趋势度量">1.3.1 集中趋势度量</h3><p>反映数据的平均水平或数据的中心值。</p><p>对于平均的不同理解，往往会导致不同的计算结果。</p><ol type="1"><li>众数：一批数据中出现次数最多的数值。</li></ol><p>众数不受极值的影响，通常用来描述离散型变量，尤其是分类型变量。</p><p>众数通常用于定类变量的统计中，对于定序变量、定距变量和定比变量，通常使用中位数和算术平均数表示集中趋势。</p><ol start="2" type="1"><li>中位数：将数据从小到大排序后，处在数据序列中间的数值。</li></ol><p>n个排序后的数据，若n为奇数，则取第(n + 1) /2个数为中位数，n为偶数，则取第n / 2个和n / 2 +1个数的算术平均为中位数。</p><p>由中位数可扩展出四分位数。记为<spanclass="math inline">\(Q_i\)</span>。进一步可扩展至N分位数。</p><ol start="3" type="1"><li>算术平均数：一组数据的算术平均值，容易受极值的影响。</li></ol><p>求和稳定性（归零性）：每个数据减去算术平均数的结果求和为0。</p><p>算术平均值的偏差平方和极小性：每个数据减去算术平均数的结果的平方最小。</p><p>加权平均数：权重可反映数据的重要程度、频繁度等。</p><p>几何平均数：数据相乘开n次方，通常用于分析数据的平均增长率，通常要求每个数据非负。</p><p>均值不等式：<spanclass="math inline">\(调和平均\leq几何平均\leq算术平均\leq平方平均\)</span>。</p><p>集中趋势度量通常是产品设计的目标，但我们还需要考虑系统能承受的波动，即数据的离散程度。</p><h3 id="离散趋势度量">1.3.2 离散趋势度量</h3><p>全距/极差：样本最大值和最小值的差，当不考虑数据分布且数据中存在极值时适合使用。</p><p>内距/内四分位距：<span class="math inline">\(Q_3-Q_1\)</span>。</p><p>两者均不能提供精确的数据分布信息，不能用来进行精确的统计推算。</p><p>偏差平方和：每个数据与平均数偏差平方的和。</p><p>方差：偏差平方和的平均数</p><p>标准差：方差的平方根</p><p>修正方差：将方差定义式中分母的n改为n-1，具有无偏估计的性质。</p><p>变异系数：样本标准差除以均值。</p><h4 id="矩">矩</h4><p>设一批数据为<spanclass="math inline">\(X_1,X_2,...,X_n\)</span>。</p><p>其k阶原点矩定义为<spanclass="math inline">\(A_k=\frac{1}{n}\Sigma_i^nX_i^k\)</span>，k阶中心矩定义为<spanclass="math inline">\(B_k=\frac{1}{n}\Sigma_i^n(X_i-\overlineX)^k\)</span>。</p><p>中心矩都可用原点矩表示：<spanclass="math inline">\(B_k=\Sigma_{i=0}^kC_k^i(-A_i)^iA_{k-i}\)</span></p><h3 id="形态趋势度量">1.3.3 形态趋势度量</h3><p>偏度：<spanclass="math inline">\(S^3=\frac{B_3}{(B_2)^{1.5}}\)</span></p><p>偏度为0则数据对称，平均值与中位数相等。</p><p>偏度大于0，则称数据为正偏的，平均值大于中位数。</p><p>峰度：<spanclass="math inline">\(S^4=\frac{B_4}{(B_2)^2}\)</span></p><p>标准正态分布的峰度为3，因此大于3的为尖顶峰度，小于3的为平顶峰度。</p><p>峰度在1.8左右，数据分布接近矩形，小于1.8数据分布开始呈U形。</p>]]></content>
    
    
    <categories>
      
      <category>数据科学基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
