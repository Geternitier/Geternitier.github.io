<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java网络编程</title>
    <link href="/2022/10/25/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/10/25/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>网络编程是指编写运行在多个通过网络连接的主机的程序。</p><span id="more"></span><blockquote><p>java.net包提供了两种网络协议的支持：TCP和UDP  </p><ul><li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP层是位于IP层之上，应用层之下的中间层。TCP 保障了两个应用程序之间的可靠通信。通常用于互联网协议，称为TCP/IP。  </li><li>UDP（User Datagram Protocol，用户数据报协议）位于 OSI 模型的传输层，是一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。</li></ul></blockquote><h2 id="一、Java-Socket编程"><a href="#一、Java-Socket编程" class="headerlink" title="一、Java Socket编程"></a>一、Java Socket编程</h2><p>在网络编程中，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。<br>Socket套接字是支持TCP/IP协议的网络通信的基本操作单元，它包含了进行网络通信必须的五种信息：</p><ul><li>连接使用的协议  </li><li>本地主机的IP地址  </li><li>本地进程的协议端口  </li><li>远程主机的IP地址  </li><li>远程进程的协议端口  </li></ul><h3 id="1、套接字的连接过程"><a href="#1、套接字的连接过程" class="headerlink" title="1、套接字的连接过程"></a>1、套接字的连接过程</h3><p>服务器监听、客户端请求、连接确认</p><ol><li>服务器套接字处于等待连接的状态，实时监控网络状态</li><li>客户端的套接字提出连接请求以连接服务端套接字。为此，客户端套接字需要服务器套接字的地址和端口号</li><li>服务器套接字监听到并响应客户端套接字，建立一个新的线程，将服务端套接字的描述发给客户端。</li></ol><h3 id="2、Socket的基本工作过程："><a href="#2、Socket的基本工作过程：" class="headerlink" title="2、Socket的基本工作过程："></a>2、Socket的基本工作过程：</h3><ol><li>创建Socket</li><li>创建连接Socket的IO流</li><li>按一定协议对Socket进行读写操作</li><li>关闭Socket</li></ol><h3 id="3、Java-Socket：简单的服务端与客户端程序"><a href="#3、Java-Socket：简单的服务端与客户端程序" class="headerlink" title="3、Java Socket：简单的服务端与客户端程序"></a>3、Java Socket：简单的服务端与客户端程序</h3><h4 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">sock</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(sock.getInputStream());<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);<br>            String message;<br>            message = bufferedReader.readLine();<br>            System.out.println(message);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Server</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();<br>        server.execute();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(socket.getOutputStream());<br>            <span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream());<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);<br>            System.out.println(<span class="hljs-string">&quot;Connection succeeded.&quot;</span>);<br>            writer.println(<span class="hljs-string">&quot;Happy Birthday!&quot;</span>);<br>            writer.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>();<br>        client.execute();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、IO-模型"><a href="#二、IO-模型" class="headerlink" title="二、IO 模型"></a>二、IO 模型</h2><h3 id="1、同步和异步"><a href="#1、同步和异步" class="headerlink" title="1、同步和异步"></a>1、同步和异步</h3><ul><li>同步：同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回</li><li>异步：异步就是发起一个调用后，立即得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他请求。  </li></ul><p>被调用者通常依靠事件、回调等机制来通知调用者其返回结果。<br>两者的最大区别在于，异步的情况下，调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。</p><h3 id="2、阻塞和非阻塞"><a href="#2、阻塞和非阻塞" class="headerlink" title="2、阻塞和非阻塞"></a>2、阻塞和非阻塞</h3><ul><li>阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li><li>非阻塞：非阻塞就是发起一个请求，调用者不用已知等着结果返回，可以从事其他任务。</li></ul><p>Java Socket在调用accept、read等方法时，会发生阻塞</p><h3 id="3、Java支持的三种IO模型"><a href="#3、Java支持的三种IO模型" class="headerlink" title="3、Java支持的三种IO模型"></a>3、Java支持的三种IO模型</h3><ul><li>BIO（Blocking IO，同步阻塞IO）：一个线程处理一个连接</li><li>NIO（Non-blocking IO，同步非阻塞IO）：一个线程处理多个连接</li><li>AIO（Asynchronous IO，异步非阻塞IO）：通道异步</li></ul><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>在Server中建立ServerSocket对象，绑定端口，等待连接，若连接成功就新建一个进程去处理连接。</p><p>BIO的缺点：资源的浪费，每个客户端的连接都需要占用一个进程。</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>相关类处于java.nio包中。<br><img src="/img/networkProject/NIO%E5%9B%BE%E8%A7%A3.jpeg" alt="NIO 图解" title="NIO 图解"><br>NIO的三大核心部分：Selector(选择器)、Channel(通道)、Buffer(缓冲区)    </p><ul><li><p>Buffer：数据从Channel读入Buffer，又从Buffer写入Channel<br>在Java中，Buffer是一个抽象类，具有ByteBuffer、CharBuffer等子类，采用相似方法管理不同数据类型。<br>具有的基本属性：  </p><ul><li>容量：Buffer作为一个内存块所具有的一定大小，不能为负且创建后不可更改。</li><li>限制：Buffer中可以操作数据的大小，不能为负且小于等于其容量。写入模式下，限制等于buffer的容量，读取模式下，限制等于写入的数据量。</li><li>位置：下一个要读取或写入的数据的索引，不能为负且不能大于限制。</li><li>标记：通过mark方法指定Buffer中一个特定的位置，之后可以调用reset方法恢复到这个位置。</li></ul><p>Java Buffer存取数据的两个基本办法：</p><ul><li>put() 在Buffer的当前位置写入内容</li><li>get() 获取Buffer数据</li></ul></li><li><p>Channel：IO源与目标打开的连接，不能直接访问数据，只能与Buffer进行交互。<br>在Java中，Channel是一个接口，具有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel等实现</p><p>Java Channel读写数据的基本办法：</p><ul><li>read()</li><li>write()</li></ul></li><li><p>Selector<br>Selector会不断轮询注册在上的所有channel，并发现处于就绪状态的channel。<br>使用步骤：</p></li></ul><ol><li>使用静态工厂办法open()获取选择器：<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span> = <span class="hljs-keyword">Selector</span>.open()<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li><li>获取可选择通道。该通道必须实现SelectableChannel接口并为非阻塞模式。</li><li>将通道注册到选择器，并告知监控的事件：<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">SelectableChannel.register(<span class="hljs-keyword">Selector</span> <span class="hljs-keyword">selector</span>, int ops)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li><li>调用Selector.select()，该方法将就绪事件放在SelectedKey集合中，并返回就绪事件数，这是个阻塞方法，直到至少有一个就绪事件，或其它县城调用当前Selector对象的wakeup()方法，或当前线程中断时返回。<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-keyword">while</span>(selector.<span class="hljs-built_in">select</span>() &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">Set</span>&lt;SelectionKey&gt; <span class="hljs-built_in">keys</span> = selector.selectedKeys();<br>&#125;<br></code></pre></td></tr></table></figure>给select()赋予一个long类型的参数可以限制其阻塞时间；selectNode()不阻塞，无就绪事件则返回0。  </li><li>处理就绪事件</li></ol><p>Channel和Buffer的基本操作</p><ol><li>分别建立连接文件和Socket的Channel</li><li>建立所需类型（Byte，等等）的Buffer，分配内存</li><li>从Channel中将数据读入Buffer/使用Channel从Buffer中读取数据</li><li>关闭Channel</li></ol><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4>]]></content>
    
    
    <categories>
      
      <category>networkProject</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Geternitier的博客</title>
    <link href="/2022/10/20/%E5%A4%A9%E9%A9%AC%E6%AD%8C/"/>
    <url>/2022/10/20/%E5%A4%A9%E9%A9%AC%E6%AD%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="天马歌"><a href="#天马歌" class="headerlink" title="天马歌"></a>天马歌</h3><span id="more"></span><p>唐·李白</p><p>天马来出月支窟，背为虎文龙翼骨。<br>嘶青云，振绿发， 兰筋权奇走灭没。<br>腾昆仑，历西极，四足无一蹶。<br>鸡鸣刷燕晡秣越，神行电迈蹑慌惚。<br>天马呼，飞龙趋， 目明长庚臆双凫。<br>尾如流星首渴乌，口喷红光汗沟朱。<br>曾陪时龙蹑天衢，羁金络月照皇都。<br>逸气棱棱凌九区，白璧如山谁敢沽。<br>回头笑紫燕，但觉尔辈愚。<br>天马奔， 恋君轩，駷跃惊矫浮云翻。<br>万里足踯躅，遥瞻阊阖门。<br>不逢寒风子，谁采逸景孙。<br>白云在青天，丘陵远崔嵬。<br>盐车上峻坂，倒行逆施畏日晚。<br>伯乐翦拂中道遗，少尽其力老弃之。<br>愿逢田子方，恻然为我悲。<br>虽有玉山禾，不能疗苦饥。<br>严霜五月凋桂枝，伏枥衔冤摧两眉。<br>请君赎献穆天子，犹堪弄影舞瑶池。  </p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
